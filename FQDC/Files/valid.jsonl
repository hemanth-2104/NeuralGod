{"project": "qemu", "commit_id": "089da572b956ef0f8f5b8d5917358e07892a77c2", "target": 1, "func": "void fw_cfg_add_callback(FWCfgState *s, uint16_t key, FWCfgCallback callback,\n\n                         void *callback_opaque, uint8_t *data, size_t len)\n\n{\n\n    int arch = !!(key & FW_CFG_ARCH_LOCAL);\n\n\n\n    assert(key & FW_CFG_WRITE_CHANNEL);\n\n\n\n    key &= FW_CFG_ENTRY_MASK;\n\n\n\n    assert(key < FW_CFG_MAX_ENTRY && len <= 65535);\n\n\n\n    s->entries[arch][key].data = data;\n\n    s->entries[arch][key].len = len;\n\n    s->entries[arch][key].callback_opaque = callback_opaque;\n\n    s->entries[arch][key].callback = callback;\n\n}\n", "idx": 15}
{"project": "qemu", "commit_id": "98f343395e937fa1db3a28dfb4f303f97cfddd6c", "target": 1, "func": "static void emulated_push_error(EmulatedState *card, uint64_t code)\n\n{\n\n    EmulEvent *event = (EmulEvent *)g_malloc(sizeof(EmulEvent));\n\n\n\n    assert(event);\n\n    event->p.error.type = EMUL_ERROR;\n\n    event->p.error.code = code;\n\n    emulated_push_event(card, event);\n\n}\n", "idx": 22}
{"project": "qemu", "commit_id": "d4a63ac8b19eb208465f27fde63f3cff7018fdfd", "target": 0, "func": "static void rtas_ibm_change_msi(PowerPCCPU *cpu, sPAPRMachineState *spapr,\n\n                                uint32_t token, uint32_t nargs,\n\n                                target_ulong args, uint32_t nret,\n\n                                target_ulong rets)\n\n{\n\n    uint32_t config_addr = rtas_ld(args, 0);\n\n    uint64_t buid = rtas_ldq(args, 1);\n\n    unsigned int func = rtas_ld(args, 3);\n\n    unsigned int req_num = rtas_ld(args, 4); /* 0 == remove all */\n\n    unsigned int seq_num = rtas_ld(args, 5);\n\n    unsigned int ret_intr_type;\n\n    unsigned int irq, max_irqs = 0, num = 0;\n\n    sPAPRPHBState *phb = NULL;\n\n    PCIDevice *pdev = NULL;\n\n    spapr_pci_msi *msi;\n\n    int *config_addr_key;\n\n\n\n    switch (func) {\n\n    case RTAS_CHANGE_MSI_FN:\n\n    case RTAS_CHANGE_FN:\n\n        ret_intr_type = RTAS_TYPE_MSI;\n\n        break;\n\n    case RTAS_CHANGE_MSIX_FN:\n\n        ret_intr_type = RTAS_TYPE_MSIX;\n\n        break;\n\n    default:\n\n        error_report(\"rtas_ibm_change_msi(%u) is not implemented\", func);\n\n        rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n        return;\n\n    }\n\n\n\n    /* Fins sPAPRPHBState */\n\n    phb = spapr_pci_find_phb(spapr, buid);\n\n    if (phb) {\n\n        pdev = spapr_pci_find_dev(spapr, buid, config_addr);\n\n    }\n\n    if (!phb || !pdev) {\n\n        rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n        return;\n\n    }\n\n\n\n    /* Releasing MSIs */\n\n    if (!req_num) {\n\n        msi = (spapr_pci_msi *) g_hash_table_lookup(phb->msi, &config_addr);\n\n        if (!msi) {\n\n            trace_spapr_pci_msi(\"Releasing wrong config\", config_addr);\n\n            rtas_st(rets, 0, RTAS_OUT_HW_ERROR);\n\n            return;\n\n        }\n\n\n\n        xics_free(spapr->icp, msi->first_irq, msi->num);\n\n        if (msi_present(pdev)) {\n\n            spapr_msi_setmsg(pdev, 0, false, 0, num);\n\n        }\n\n        if (msix_present(pdev)) {\n\n            spapr_msi_setmsg(pdev, 0, true, 0, num);\n\n        }\n\n        g_hash_table_remove(phb->msi, &config_addr);\n\n\n\n        trace_spapr_pci_msi(\"Released MSIs\", config_addr);\n\n        rtas_st(rets, 0, RTAS_OUT_SUCCESS);\n\n        rtas_st(rets, 1, 0);\n\n        return;\n\n    }\n\n\n\n    /* Enabling MSI */\n\n\n\n    /* Check if the device supports as many IRQs as requested */\n\n    if (ret_intr_type == RTAS_TYPE_MSI) {\n\n        max_irqs = msi_nr_vectors_allocated(pdev);\n\n    } else if (ret_intr_type == RTAS_TYPE_MSIX) {\n\n        max_irqs = pdev->msix_entries_nr;\n\n    }\n\n    if (!max_irqs) {\n\n        error_report(\"Requested interrupt type %d is not enabled for device %x\",\n\n                     ret_intr_type, config_addr);\n\n        rtas_st(rets, 0, -1); /* Hardware error */\n\n        return;\n\n    }\n\n    /* Correct the number if the guest asked for too many */\n\n    if (req_num > max_irqs) {\n\n        trace_spapr_pci_msi_retry(config_addr, req_num, max_irqs);\n\n        req_num = max_irqs;\n\n        irq = 0; /* to avoid misleading trace */\n\n        goto out;\n\n    }\n\n\n\n    /* Allocate MSIs */\n\n    irq = xics_alloc_block(spapr->icp, 0, req_num, false,\n\n                           ret_intr_type == RTAS_TYPE_MSI);\n\n    if (!irq) {\n\n        error_report(\"Cannot allocate MSIs for device %x\", config_addr);\n\n        rtas_st(rets, 0, RTAS_OUT_HW_ERROR);\n\n        return;\n\n    }\n\n\n\n    /* Setup MSI/MSIX vectors in the device (via cfgspace or MSIX BAR) */\n\n    spapr_msi_setmsg(pdev, SPAPR_PCI_MSI_WINDOW, ret_intr_type == RTAS_TYPE_MSIX,\n\n                     irq, req_num);\n\n\n\n    /* Add MSI device to cache */\n\n    msi = g_new(spapr_pci_msi, 1);\n\n    msi->first_irq = irq;\n\n    msi->num = req_num;\n\n    config_addr_key = g_new(int, 1);\n\n    *config_addr_key = config_addr;\n\n    g_hash_table_insert(phb->msi, config_addr_key, msi);\n\n\n\nout:\n\n    rtas_st(rets, 0, RTAS_OUT_SUCCESS);\n\n    rtas_st(rets, 1, req_num);\n\n    rtas_st(rets, 2, ++seq_num);\n\n    if (nret > 3) {\n\n        rtas_st(rets, 3, ret_intr_type);\n\n    }\n\n\n\n    trace_spapr_pci_rtas_ibm_change_msi(config_addr, func, req_num, irq);\n\n}\n", "idx": 62}
{"project": "qemu", "commit_id": "2662a059aa2affddfbe42e78b11c802cf30a970f", "target": 0, "func": "static int create_ppc_opcodes (CPUPPCState *env, ppc_def_t *def)\n\n{\n\n    opcode_t *opc, *start, *end;\n\n\n\n    fill_new_table(env->opcodes, 0x40);\n\n#if defined(PPC_DUMP_CPU)\n\n    printf(\"* PowerPC instructions for PVR %08x: %s flags %016\" PRIx64\n\n           \" %08x\\n\",\n\n           def->pvr, def->name, def->insns_flags, def->flags);\n\n#endif\n\n    if (&opc_start < &opc_end) {\n\n        start = &opc_start;\n\n        end = &opc_end;\n\n    } else {\n\n        start = &opc_end;\n\n        end = &opc_start;\n\n    }\n\n    for (opc = start + 1; opc != end; opc++) {\n\n        if ((opc->handler.type & def->insns_flags) != 0) {\n\n            if (register_insn(env->opcodes, opc) < 0) {\n\n                printf(\"*** ERROR initializing PowerPC instruction \"\n\n                       \"0x%02x 0x%02x 0x%02x\\n\", opc->opc1, opc->opc2,\n\n                       opc->opc3);\n\n                return -1;\n\n            }\n\n#if defined(PPC_DUMP_CPU)\n\n            if (opc1 != 0x00) {\n\n                if (opc->opc3 == 0xFF) {\n\n                    if (opc->opc2 == 0xFF) {\n\n                        printf(\" %02x -- -- (%2d ----) : %s\\n\",\n\n                               opc->opc1, opc->opc1, opc->oname);\n\n                    } else {\n\n                        printf(\" %02x %02x -- (%2d %4d) : %s\\n\",\n\n                               opc->opc1, opc->opc2, opc->opc1, opc->opc2,\n\n                               opc->oname);\n\n                    }\n\n                } else {\n\n                    printf(\" %02x %02x %02x (%2d %4d) : %s\\n\",\n\n                           opc->opc1, opc->opc2, opc->opc3,\n\n                           opc->opc1, (opc->opc3 << 5) | opc->opc2,\n\n                           opc->oname);\n\n                }\n\n            }\n\n#endif\n\n        }\n\n    }\n\n    fix_opcode_tables(env->opcodes);\n\n    fflush(stdout);\n\n    fflush(stderr);\n\n\n\n    return 0;\n\n}\n", "idx": 166}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "func": "static inline void mix_2f_1r_to_dolby(AC3DecodeContext *ctx)\n\n{\n\n    int i;\n\n    float (*output)[256] = ctx->audio_block.block_output;\n\n\n\n    for (i = 0; i < 256; i++) {\n\n        output[1][i] -= output[3][i];\n\n        output[2][i] += output[3][i];\n\n    }\n\n    memset(output[3], 0, sizeof(output[3]));\n\n}\n", "idx": 183}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static void timerlist_rearm(QEMUTimerList *timer_list)\n\n{\n\n    /* Interrupt execution to force deadline recalculation.  */\n\n    if (timer_list->clock->type == QEMU_CLOCK_VIRTUAL) {\n\n        qemu_start_warp_timer();\n\n    }\n\n    timerlist_notify(timer_list);\n\n}\n", "idx": 298}
{"project": "qemu", "commit_id": "c19f47bf5e8fe3dbd10206a52d0e6e348f803933", "target": 0, "func": "static void tcg_liveness_analysis(TCGContext *s)\n\n{\n\n    uint8_t *dead_temps, *mem_temps;\n\n    int oi, oi_prev, nb_ops;\n\n\n\n    nb_ops = s->gen_next_op_idx;\n\n    s->op_dead_args = tcg_malloc(nb_ops * sizeof(uint16_t));\n\n    s->op_sync_args = tcg_malloc(nb_ops * sizeof(uint8_t));\n\n    \n\n    dead_temps = tcg_malloc(s->nb_temps);\n\n    mem_temps = tcg_malloc(s->nb_temps);\n\n    tcg_la_func_end(s, dead_temps, mem_temps);\n\n\n\n    for (oi = s->gen_last_op_idx; oi >= 0; oi = oi_prev) {\n\n        int i, nb_iargs, nb_oargs;\n\n        TCGOpcode opc_new, opc_new2;\n\n        bool have_opc_new2;\n\n        uint16_t dead_args;\n\n        uint8_t sync_args;\n\n        TCGArg arg;\n\n\n\n        TCGOp * const op = &s->gen_op_buf[oi];\n\n        TCGArg * const args = &s->gen_opparam_buf[op->args];\n\n        TCGOpcode opc = op->opc;\n\n        const TCGOpDef *def = &tcg_op_defs[opc];\n\n\n\n        oi_prev = op->prev;\n\n\n\n        switch (opc) {\n\n        case INDEX_op_call:\n\n            {\n\n                int call_flags;\n\n\n\n                nb_oargs = op->callo;\n\n                nb_iargs = op->calli;\n\n                call_flags = args[nb_oargs + nb_iargs + 1];\n\n\n\n                /* pure functions can be removed if their result is unused */\n\n                if (call_flags & TCG_CALL_NO_SIDE_EFFECTS) {\n\n                    for (i = 0; i < nb_oargs; i++) {\n\n                        arg = args[i];\n\n                        if (!dead_temps[arg] || mem_temps[arg]) {\n\n                            goto do_not_remove_call;\n\n                        }\n\n                    }\n\n                    goto do_remove;\n\n                } else {\n\n                do_not_remove_call:\n\n\n\n                    /* output args are dead */\n\n                    dead_args = 0;\n\n                    sync_args = 0;\n\n                    for (i = 0; i < nb_oargs; i++) {\n\n                        arg = args[i];\n\n                        if (dead_temps[arg]) {\n\n                            dead_args |= (1 << i);\n\n                        }\n\n                        if (mem_temps[arg]) {\n\n                            sync_args |= (1 << i);\n\n                        }\n\n                        dead_temps[arg] = 1;\n\n                        mem_temps[arg] = 0;\n\n                    }\n\n\n\n                    if (!(call_flags & TCG_CALL_NO_READ_GLOBALS)) {\n\n                        /* globals should be synced to memory */\n\n                        memset(mem_temps, 1, s->nb_globals);\n\n                    }\n\n                    if (!(call_flags & (TCG_CALL_NO_WRITE_GLOBALS |\n\n                                        TCG_CALL_NO_READ_GLOBALS))) {\n\n                        /* globals should go back to memory */\n\n                        memset(dead_temps, 1, s->nb_globals);\n\n                    }\n\n\n\n                    /* input args are live */\n\n                    for (i = nb_oargs; i < nb_iargs + nb_oargs; i++) {\n\n                        arg = args[i];\n\n                        if (arg != TCG_CALL_DUMMY_ARG) {\n\n                            if (dead_temps[arg]) {\n\n                                dead_args |= (1 << i);\n\n                            }\n\n                            dead_temps[arg] = 0;\n\n                        }\n\n                    }\n\n                    s->op_dead_args[oi] = dead_args;\n\n                    s->op_sync_args[oi] = sync_args;\n\n                }\n\n            }\n\n            break;\n\n        case INDEX_op_debug_insn_start:\n\n            break;\n\n        case INDEX_op_discard:\n\n            /* mark the temporary as dead */\n\n            dead_temps[args[0]] = 1;\n\n            mem_temps[args[0]] = 0;\n\n            break;\n\n\n\n        case INDEX_op_add2_i32:\n\n            opc_new = INDEX_op_add_i32;\n\n            goto do_addsub2;\n\n        case INDEX_op_sub2_i32:\n\n            opc_new = INDEX_op_sub_i32;\n\n            goto do_addsub2;\n\n        case INDEX_op_add2_i64:\n\n            opc_new = INDEX_op_add_i64;\n\n            goto do_addsub2;\n\n        case INDEX_op_sub2_i64:\n\n            opc_new = INDEX_op_sub_i64;\n\n        do_addsub2:\n\n            nb_iargs = 4;\n\n            nb_oargs = 2;\n\n            /* Test if the high part of the operation is dead, but not\n\n               the low part.  The result can be optimized to a simple\n\n               add or sub.  This happens often for x86_64 guest when the\n\n               cpu mode is set to 32 bit.  */\n\n            if (dead_temps[args[1]] && !mem_temps[args[1]]) {\n\n                if (dead_temps[args[0]] && !mem_temps[args[0]]) {\n\n                    goto do_remove;\n\n                }\n\n                /* Replace the opcode and adjust the args in place,\n\n                   leaving 3 unused args at the end.  */\n\n                op->opc = opc = opc_new;\n\n                args[1] = args[2];\n\n                args[2] = args[4];\n\n                /* Fall through and mark the single-word operation live.  */\n\n                nb_iargs = 2;\n\n                nb_oargs = 1;\n\n            }\n\n            goto do_not_remove;\n\n\n\n        case INDEX_op_mulu2_i32:\n\n            opc_new = INDEX_op_mul_i32;\n\n            opc_new2 = INDEX_op_muluh_i32;\n\n            have_opc_new2 = TCG_TARGET_HAS_muluh_i32;\n\n            goto do_mul2;\n\n        case INDEX_op_muls2_i32:\n\n            opc_new = INDEX_op_mul_i32;\n\n            opc_new2 = INDEX_op_mulsh_i32;\n\n            have_opc_new2 = TCG_TARGET_HAS_mulsh_i32;\n\n            goto do_mul2;\n\n        case INDEX_op_mulu2_i64:\n\n            opc_new = INDEX_op_mul_i64;\n\n            opc_new2 = INDEX_op_muluh_i64;\n\n            have_opc_new2 = TCG_TARGET_HAS_muluh_i64;\n\n            goto do_mul2;\n\n        case INDEX_op_muls2_i64:\n\n            opc_new = INDEX_op_mul_i64;\n\n            opc_new2 = INDEX_op_mulsh_i64;\n\n            have_opc_new2 = TCG_TARGET_HAS_mulsh_i64;\n\n            goto do_mul2;\n\n        do_mul2:\n\n            nb_iargs = 2;\n\n            nb_oargs = 2;\n\n            if (dead_temps[args[1]] && !mem_temps[args[1]]) {\n\n                if (dead_temps[args[0]] && !mem_temps[args[0]]) {\n\n                    /* Both parts of the operation are dead.  */\n\n                    goto do_remove;\n\n                }\n\n                /* The high part of the operation is dead; generate the low. */\n\n                op->opc = opc = opc_new;\n\n                args[1] = args[2];\n\n                args[2] = args[3];\n\n            } else if (have_opc_new2 && dead_temps[args[0]]\n\n                       && !mem_temps[args[0]]) {\n\n                /* The low part of the operation is dead; generate the high. */\n\n                op->opc = opc = opc_new2;\n\n                args[0] = args[1];\n\n                args[1] = args[2];\n\n                args[2] = args[3];\n\n            } else {\n\n                goto do_not_remove;\n\n            }\n\n            /* Mark the single-word operation live.  */\n\n            nb_oargs = 1;\n\n            goto do_not_remove;\n\n\n\n        default:\n\n            /* XXX: optimize by hardcoding common cases (e.g. triadic ops) */\n\n            nb_iargs = def->nb_iargs;\n\n            nb_oargs = def->nb_oargs;\n\n\n\n            /* Test if the operation can be removed because all\n\n               its outputs are dead. We assume that nb_oargs == 0\n\n               implies side effects */\n\n            if (!(def->flags & TCG_OPF_SIDE_EFFECTS) && nb_oargs != 0) {\n\n                for (i = 0; i < nb_oargs; i++) {\n\n                    arg = args[i];\n\n                    if (!dead_temps[arg] || mem_temps[arg]) {\n\n                        goto do_not_remove;\n\n                    }\n\n                }\n\n            do_remove:\n\n                tcg_op_remove(s, op);\n\n            } else {\n\n            do_not_remove:\n\n                /* output args are dead */\n\n                dead_args = 0;\n\n                sync_args = 0;\n\n                for (i = 0; i < nb_oargs; i++) {\n\n                    arg = args[i];\n\n                    if (dead_temps[arg]) {\n\n                        dead_args |= (1 << i);\n\n                    }\n\n                    if (mem_temps[arg]) {\n\n                        sync_args |= (1 << i);\n\n                    }\n\n                    dead_temps[arg] = 1;\n\n                    mem_temps[arg] = 0;\n\n                }\n\n\n\n                /* if end of basic block, update */\n\n                if (def->flags & TCG_OPF_BB_END) {\n\n                    tcg_la_bb_end(s, dead_temps, mem_temps);\n\n                } else if (def->flags & TCG_OPF_SIDE_EFFECTS) {\n\n                    /* globals should be synced to memory */\n\n                    memset(mem_temps, 1, s->nb_globals);\n\n                }\n\n\n\n                /* input args are live */\n\n                for (i = nb_oargs; i < nb_oargs + nb_iargs; i++) {\n\n                    arg = args[i];\n\n                    if (dead_temps[arg]) {\n\n                        dead_args |= (1 << i);\n\n                    }\n\n                    dead_temps[arg] = 0;\n\n                }\n\n                s->op_dead_args[oi] = dead_args;\n\n                s->op_sync_args[oi] = sync_args;\n\n            }\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 301}
{"project": "FFmpeg", "commit_id": "bbe26eff2235dc2d1c79a5a1e25b46d8d7f0fe08", "target": 1, "func": "static int decode_slice(struct AVCodecContext *avctx, void *arg)\n\n{\n\n    H264Context *h = *(void **)arg;\n\n    int lf_x_start = h->mb_x;\n\n\n\n    h->mb_skip_run = -1;\n\n\n\n    av_assert0(h->block_offset[15] == (4 * ((scan8[15] - scan8[0]) & 7) << h->pixel_shift) + 4 * h->linesize * ((scan8[15] - scan8[0]) >> 3));\n\n\n\n    h->is_complex = FRAME_MBAFF(h) || h->picture_structure != PICT_FRAME ||\n\n                    avctx->codec_id != AV_CODEC_ID_H264 ||\n\n                    (CONFIG_GRAY && (h->flags & CODEC_FLAG_GRAY));\n\n\n\n    if (!(h->avctx->active_thread_type & FF_THREAD_SLICE) && h->picture_structure == PICT_FRAME) {\n\n        const int start_i  = av_clip(h->resync_mb_x + h->resync_mb_y * h->mb_width, 0, h->mb_num - 1);\n\n        if (start_i) {\n\n            int prev_status = h->er.error_status_table[h->er.mb_index2xy[start_i - 1]];\n\n            prev_status &= ~ VP_START;\n\n            if (prev_status != (ER_MV_END | ER_DC_END | ER_AC_END))\n\n                h->er.error_occurred = 1;\n\n        }\n\n    }\n\n\n\n    if (h->pps.cabac) {\n\n        /* realign */\n\n        align_get_bits(&h->gb);\n\n\n\n        /* init cabac */\n\n        ff_init_cabac_decoder(&h->cabac,\n\n                              h->gb.buffer + get_bits_count(&h->gb) / 8,\n\n                              (get_bits_left(&h->gb) + 7) / 8);\n\n\n\n        ff_h264_init_cabac_states(h);\n\n\n\n        for (;;) {\n\n            // START_TIMER\n\n            int ret = ff_h264_decode_mb_cabac(h);\n\n            int eos;\n\n            // STOP_TIMER(\"decode_mb_cabac\")\n\n\n\n            if (ret >= 0)\n\n                ff_h264_hl_decode_mb(h);\n\n\n\n            // FIXME optimal? or let mb_decode decode 16x32 ?\n\n            if (ret >= 0 && FRAME_MBAFF(h)) {\n\n                h->mb_y++;\n\n\n\n                ret = ff_h264_decode_mb_cabac(h);\n\n\n\n                if (ret >= 0)\n\n                    ff_h264_hl_decode_mb(h);\n\n                h->mb_y--;\n\n            }\n\n            eos = get_cabac_terminate(&h->cabac);\n\n\n\n            if ((h->workaround_bugs & FF_BUG_TRUNCATED) &&\n\n                h->cabac.bytestream > h->cabac.bytestream_end + 2) {\n\n                er_add_slice(h, h->resync_mb_x, h->resync_mb_y, h->mb_x - 1,\n\n                                h->mb_y, ER_MB_END);\n\n                if (h->mb_x >= lf_x_start)\n\n                    loop_filter(h, lf_x_start, h->mb_x + 1);\n\n                return 0;\n\n            }\n\n            if (h->cabac.bytestream > h->cabac.bytestream_end + 2 )\n\n                av_log(h->avctx, AV_LOG_DEBUG, \"bytestream overread %td\\n\", h->cabac.bytestream_end - h->cabac.bytestream);\n\n            if (ret < 0 || h->cabac.bytestream > h->cabac.bytestream_end + 4) {\n\n                av_log(h->avctx, AV_LOG_ERROR,\n\n                       \"error while decoding MB %d %d, bytestream (%td)\\n\",\n\n                       h->mb_x, h->mb_y,\n\n                       h->cabac.bytestream_end - h->cabac.bytestream);\n\n                er_add_slice(h, h->resync_mb_x, h->resync_mb_y, h->mb_x,\n\n                                h->mb_y, ER_MB_ERROR);\n\n                return -1;\n\n            }\n\n\n\n            if (++h->mb_x >= h->mb_width) {\n\n                loop_filter(h, lf_x_start, h->mb_x);\n\n                h->mb_x = lf_x_start = 0;\n\n                decode_finish_row(h);\n\n                ++h->mb_y;\n\n                if (FIELD_OR_MBAFF_PICTURE(h)) {\n\n                    ++h->mb_y;\n\n                    if (FRAME_MBAFF(h) && h->mb_y < h->mb_height)\n\n                        predict_field_decoding_flag(h);\n\n                }\n\n            }\n\n\n\n            if (eos || h->mb_y >= h->mb_height) {\n\n                tprintf(h->avctx, \"slice end %d %d\\n\",\n\n                        get_bits_count(&h->gb), h->gb.size_in_bits);\n\n                er_add_slice(h, h->resync_mb_x, h->resync_mb_y, h->mb_x - 1,\n\n                                h->mb_y, ER_MB_END);\n\n                if (h->mb_x > lf_x_start)\n\n                    loop_filter(h, lf_x_start, h->mb_x);\n\n                return 0;\n\n            }\n\n        }\n\n    } else {\n\n        for (;;) {\n\n            int ret = ff_h264_decode_mb_cavlc(h);\n\n\n\n            if (ret >= 0)\n\n                ff_h264_hl_decode_mb(h);\n\n\n\n            // FIXME optimal? or let mb_decode decode 16x32 ?\n\n            if (ret >= 0 && FRAME_MBAFF(h)) {\n\n                h->mb_y++;\n\n                ret = ff_h264_decode_mb_cavlc(h);\n\n\n\n                if (ret >= 0)\n\n                    ff_h264_hl_decode_mb(h);\n\n                h->mb_y--;\n\n            }\n\n\n\n            if (ret < 0) {\n\n                av_log(h->avctx, AV_LOG_ERROR,\n\n                       \"error while decoding MB %d %d\\n\", h->mb_x, h->mb_y);\n\n                er_add_slice(h, h->resync_mb_x, h->resync_mb_y, h->mb_x,\n\n                                h->mb_y, ER_MB_ERROR);\n\n                return -1;\n\n            }\n\n\n\n            if (++h->mb_x >= h->mb_width) {\n\n                loop_filter(h, lf_x_start, h->mb_x);\n\n                h->mb_x = lf_x_start = 0;\n\n                decode_finish_row(h);\n\n                ++h->mb_y;\n\n                if (FIELD_OR_MBAFF_PICTURE(h)) {\n\n                    ++h->mb_y;\n\n                    if (FRAME_MBAFF(h) && h->mb_y < h->mb_height)\n\n                        predict_field_decoding_flag(h);\n\n                }\n\n                if (h->mb_y >= h->mb_height) {\n\n                    tprintf(h->avctx, \"slice end %d %d\\n\",\n\n                            get_bits_count(&h->gb), h->gb.size_in_bits);\n\n\n\n                    if (   get_bits_left(&h->gb) == 0\n\n                        || get_bits_left(&h->gb) > 0 && !(h->avctx->err_recognition & AV_EF_AGGRESSIVE)) {\n\n                        er_add_slice(h, h->resync_mb_x, h->resync_mb_y,\n\n                                        h->mb_x - 1, h->mb_y,\n\n                                        ER_MB_END);\n\n\n\n                        return 0;\n\n                    } else {\n\n                        er_add_slice(h, h->resync_mb_x, h->resync_mb_y,\n\n                                        h->mb_x, h->mb_y,\n\n                                        ER_MB_END);\n\n\n\n                        return -1;\n\n                    }\n\n                }\n\n            }\n\n\n\n            if (get_bits_left(&h->gb) <= 0 && h->mb_skip_run <= 0) {\n\n                tprintf(h->avctx, \"slice end %d %d\\n\",\n\n                        get_bits_count(&h->gb), h->gb.size_in_bits);\n\n                if (get_bits_left(&h->gb) == 0) {\n\n                    er_add_slice(h, h->resync_mb_x, h->resync_mb_y,\n\n                                    h->mb_x - 1, h->mb_y,\n\n                                    ER_MB_END);\n\n                    if (h->mb_x > lf_x_start)\n\n                        loop_filter(h, lf_x_start, h->mb_x);\n\n\n\n                    return 0;\n\n                } else {\n\n                    er_add_slice(h, h->resync_mb_x, h->resync_mb_y, h->mb_x,\n\n                                    h->mb_y, ER_MB_ERROR);\n\n\n\n                    return -1;\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 443}
{"project": "FFmpeg", "commit_id": "5b0ad91b996506632708dcefc22d2835d04a4dba", "target": 1, "func": "static int img_read_packet(AVFormatContext *s1, AVPacket *pkt)\n\n{\n\n    VideoData *s = s1->priv_data;\n\n    char filename[1024];\n\n    int ret;\n\n    ByteIOContext f1, *f;\n\n\n\n    if (get_frame_filename(filename, sizeof(filename),\n\n                           s->path, s->img_number) < 0)\n\n        return -EIO;\n\n    \n\n    if (!s->is_pipe) {\n\n        f = &f1;\n\n        if (url_fopen(f, filename, URL_RDONLY) < 0)\n\n            return -EIO;\n\n    } else {\n\n        f = &s1->pb;\n\n        if (url_feof(f))\n\n            return -EIO;\n\n    }\n\n\n\n    av_new_packet(pkt, s->img_size);\n\n    pkt->stream_index = 0;\n\n\n\n    switch(s->img_fmt) {\n\n    case IMGFMT_PGMYUV:\n\n        ret = pgm_read(s, f, pkt->data, pkt->size, 1);\n\n        break;\n\n    case IMGFMT_PGM:\n\n        ret = pgm_read(s, f, pkt->data, pkt->size, 0);\n\n        break;\n\n    case IMGFMT_YUV:\n\n        ret = yuv_read(s, filename, pkt->data, pkt->size);\n\n        break;\n\n    case IMGFMT_PPM:\n\n        ret = ppm_read(s, f, pkt->data, pkt->size);\n\n        break;\n\n    default:\n\n        return -EIO;\n\n    }\n\n    \n\n    if (!s->is_pipe) {\n\n        url_fclose(f);\n\n    }\n\n\n\n    if (ret < 0) {\n\n        av_free_packet(pkt);\n\n        return -EIO; /* signal EOF */\n\n    } else {\n\n        s->img_number++;\n\n        return 0;\n\n    }\n\n}\n", "idx": 446}
{"project": "qemu", "commit_id": "b5eff355460643d09e533024360fe0522f368c07", "target": 1, "func": "static int bdrv_rd_badreq_sectors(BlockDriverState *bs,\n\n                                  int64_t sector_num, int nb_sectors)\n\n{\n\n    return\n\n        nb_sectors < 0 ||\n\n        sector_num < 0 ||\n\n        nb_sectors > bs->total_sectors ||\n\n        sector_num > bs->total_sectors - nb_sectors;\n\n}\n", "idx": 521}
{"project": "qemu", "commit_id": "c9f4b77ad5783bd84bca4ab99d4b3d6ee61de01c", "target": 1, "func": "static void pc_dimm_check_memdev_is_busy(Object *obj, const char *name,\n\n                                      Object *val, Error **errp)\n\n{\n\n    MemoryRegion *mr;\n\n\n\n    mr = host_memory_backend_get_memory(MEMORY_BACKEND(val), errp);\n\n    if (memory_region_is_mapped(mr)) {\n\n        char *path = object_get_canonical_path_component(val);\n\n        error_setg(errp, \"can't use already busy memdev: %s\", path);\n\n        g_free(path);\n\n    } else {\n\n        qdev_prop_allow_set_link_before_realize(obj, name, val, errp);\n\n    }\n\n}\n", "idx": 670}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_rfci(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    /* Restore CPU state */\n\n    gen_helper_rfci(cpu_env);\n\n    gen_sync_exception(ctx);\n\n#endif\n\n}\n", "idx": 712}
{"project": "FFmpeg", "commit_id": "28f9ab7029bd1a02f659995919f899f84ee7361b", "target": 0, "func": "void ff_vp3_v_loop_filter_c(uint8_t *first_pixel, int stride, int *bounding_values)\n\n{\n\n    unsigned char *end;\n\n    int filter_value;\n\n    const int nstride= -stride;\n\n\n\n    for (end= first_pixel + 8; first_pixel < end; first_pixel++) {\n\n        filter_value =\n\n            (first_pixel[2 * nstride] - first_pixel[ stride])\n\n         +3*(first_pixel[0          ] - first_pixel[nstride]);\n\n        filter_value = bounding_values[(filter_value + 4) >> 3];\n\n        first_pixel[nstride] = av_clip_uint8(first_pixel[nstride] + filter_value);\n\n        first_pixel[0] = av_clip_uint8(first_pixel[0] - filter_value);\n\n    }\n\n}\n", "idx": 734}
{"project": "FFmpeg", "commit_id": "da55ee6ccc05efdd9006bb8c31db9012a3326857", "target": 1, "func": "void avcodec_align_dimensions2(AVCodecContext *s, int *width, int *height, int linesize_align[4]){\n\n    int w_align= 1;\n\n    int h_align= 1;\n\n\n\n    switch(s->pix_fmt){\n\n    case PIX_FMT_YUV420P:\n\n    case PIX_FMT_YUYV422:\n\n    case PIX_FMT_UYVY422:\n\n    case PIX_FMT_YUV422P:\n\n    case PIX_FMT_YUV440P:\n\n    case PIX_FMT_YUV444P:\n\n    case PIX_FMT_GRAY8:\n\n    case PIX_FMT_GRAY16BE:\n\n    case PIX_FMT_GRAY16LE:\n\n    case PIX_FMT_YUVJ420P:\n\n    case PIX_FMT_YUVJ422P:\n\n    case PIX_FMT_YUVJ440P:\n\n    case PIX_FMT_YUVJ444P:\n\n    case PIX_FMT_YUVA420P:\n\n    case PIX_FMT_YUV420P9LE:\n\n    case PIX_FMT_YUV420P9BE:\n\n    case PIX_FMT_YUV420P10LE:\n\n    case PIX_FMT_YUV420P10BE:\n\n    case PIX_FMT_YUV422P10LE:\n\n    case PIX_FMT_YUV422P10BE:\n\n\n\n\n\n        w_align= 16; //FIXME check for non mpeg style codecs and use less alignment\n\n        h_align= 16;\n\n        if(s->codec_id == CODEC_ID_MPEG2VIDEO || s->codec_id == CODEC_ID_MJPEG || s->codec_id == CODEC_ID_AMV || s->codec_id == CODEC_ID_THP || s->codec_id == CODEC_ID_H264)\n\n            h_align= 32; // interlaced is rounded up to 2 MBs\n\n        break;\n\n    case PIX_FMT_YUV411P:\n\n    case PIX_FMT_UYYVYY411:\n\n        w_align=32;\n\n        h_align=8;\n\n        break;\n\n    case PIX_FMT_YUV410P:\n\n        if(s->codec_id == CODEC_ID_SVQ1){\n\n            w_align=64;\n\n            h_align=64;\n\n        }\n\n    case PIX_FMT_RGB555:\n\n        if(s->codec_id == CODEC_ID_RPZA){\n\n            w_align=4;\n\n            h_align=4;\n\n        }\n\n    case PIX_FMT_PAL8:\n\n    case PIX_FMT_BGR8:\n\n    case PIX_FMT_RGB8:\n\n        if(s->codec_id == CODEC_ID_SMC){\n\n            w_align=4;\n\n            h_align=4;\n\n        }\n\n        break;\n\n    case PIX_FMT_BGR24:\n\n        if((s->codec_id == CODEC_ID_MSZH) || (s->codec_id == CODEC_ID_ZLIB)){\n\n            w_align=4;\n\n            h_align=4;\n\n        }\n\n        break;\n\n    default:\n\n        w_align= 1;\n\n        h_align= 1;\n\n        break;\n\n    }\n\n\n\n    *width = FFALIGN(*width , w_align);\n\n    *height= FFALIGN(*height, h_align);\n\n    if(s->codec_id == CODEC_ID_H264 || s->lowres)\n\n        *height+=2; // some of the optimized chroma MC reads one line too much\n\n                    // which is also done in mpeg decoders with lowres > 0\n\n\n\n    linesize_align[0] =\n\n    linesize_align[1] =\n\n    linesize_align[2] =\n\n    linesize_align[3] = STRIDE_ALIGN;\n\n//STRIDE_ALIGN is 8 for SSE* but this does not work for SVQ1 chroma planes\n\n//we could change STRIDE_ALIGN to 16 for x86/sse but it would increase the\n\n//picture size unneccessarily in some cases. The solution here is not\n\n//pretty and better ideas are welcome!\n\n#if HAVE_MMX\n\n    if(s->codec_id == CODEC_ID_SVQ1 || s->codec_id == CODEC_ID_VP5 ||\n\n       s->codec_id == CODEC_ID_VP6 || s->codec_id == CODEC_ID_VP6F ||\n\n       s->codec_id == CODEC_ID_VP6A) {\n\n        linesize_align[0] =\n\n        linesize_align[1] =\n\n        linesize_align[2] = 16;\n\n    }\n\n#endif\n\n}", "idx": 747}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "static void test_io_channel_setup_sync(SocketAddressLegacy *listen_addr,\n\n                                       SocketAddressLegacy *connect_addr,\n\n                                       QIOChannel **src,\n\n                                       QIOChannel **dst)\n\n{\n\n    QIOChannelSocket *lioc;\n\n\n\n    lioc = qio_channel_socket_new();\n\n    qio_channel_socket_listen_sync(lioc, listen_addr, &error_abort);\n\n\n\n    if (listen_addr->type == SOCKET_ADDRESS_LEGACY_KIND_INET) {\n\n        SocketAddressLegacy *laddr = qio_channel_socket_get_local_address(\n\n            lioc, &error_abort);\n\n\n\n        g_free(connect_addr->u.inet.data->port);\n\n        connect_addr->u.inet.data->port = g_strdup(laddr->u.inet.data->port);\n\n\n\n        qapi_free_SocketAddressLegacy(laddr);\n\n    }\n\n\n\n    *src = QIO_CHANNEL(qio_channel_socket_new());\n\n    qio_channel_socket_connect_sync(\n\n        QIO_CHANNEL_SOCKET(*src), connect_addr, &error_abort);\n\n    qio_channel_set_delay(*src, false);\n\n\n\n    qio_channel_wait(QIO_CHANNEL(lioc), G_IO_IN);\n\n    *dst = QIO_CHANNEL(qio_channel_socket_accept(lioc, &error_abort));\n\n    g_assert(*dst);\n\n\n\n    test_io_channel_set_socket_bufs(*src, *dst);\n\n\n\n    object_unref(OBJECT(lioc));\n\n}\n", "idx": 814}
{"project": "FFmpeg", "commit_id": "cfec0d64752509f8ac798acca6225df630fa5284", "target": 1, "func": "static int cllc_decode_frame(AVCodecContext *avctx, void *data,\n                             int *got_picture_ptr, AVPacket *avpkt)\n{\n    CLLCContext *ctx = avctx->priv_data;\n    AVFrame *pic = data;\n    ThreadFrame frame = { .f = data };\n    uint8_t *src = avpkt->data;\n    uint32_t info_tag, info_offset;\n    int data_size;\n    GetBitContext gb;\n    int coding_type, ret;\n    if (avpkt->size < 4 + 4) {\n        av_log(avctx, AV_LOG_ERROR, \"Frame is too small %d.\\n\", avpkt->size);\n    }\n    info_offset = 0;\n    info_tag    = AV_RL32(src);\n    if (info_tag == MKTAG('I', 'N', 'F', 'O')) {\n        info_offset = AV_RL32(src + 4);\n        if (info_offset > UINT32_MAX - 8 || info_offset + 8 > avpkt->size) {\n            av_log(avctx, AV_LOG_ERROR,\n                   \"Invalid INFO header offset: 0x%08\"PRIX32\" is too large.\\n\",\n                   info_offset);\n        }\n        ff_canopus_parse_info_tag(avctx, src + 8, info_offset);\n        info_offset += 8;\n        src         += info_offset;\n    }\n    data_size = (avpkt->size - info_offset) & ~1;\n    /* Make sure our bswap16'd buffer is big enough */\n    av_fast_padded_malloc(&ctx->swapped_buf,\n                          &ctx->swapped_buf_size, data_size);\n    if (!ctx->swapped_buf) {\n        av_log(avctx, AV_LOG_ERROR, \"Could not allocate swapped buffer.\\n\");\n        return AVERROR(ENOMEM);\n    }\n    /* bswap16 the buffer since CLLC's bitreader works in 16-bit words */\n    ctx->bdsp.bswap16_buf((uint16_t *) ctx->swapped_buf, (uint16_t *) src,\n                          data_size / 2);\n    if ((ret = init_get_bits8(&gb, ctx->swapped_buf, data_size)) < 0)\n        return ret;\n    /*\n     * Read in coding type. The types are as follows:\n     *\n     * 0 - YUY2\n     * 1 - BGR24 (Triples)\n     * 2 - BGR24 (Quads)\n     * 3 - BGRA\n     */\n    coding_type = (AV_RL32(src) >> 8) & 0xFF;\n    av_log(avctx, AV_LOG_DEBUG, \"Frame coding type: %d\\n\", coding_type);\n    switch (coding_type) {\n    case 0:\n        avctx->pix_fmt             = AV_PIX_FMT_YUV422P;\n        avctx->bits_per_raw_sample = 8;\n        if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0)\n            return ret;\n        ret = decode_yuv_frame(ctx, &gb, pic);\n        if (ret < 0)\n            return ret;\n        break;\n    case 1:\n    case 2:\n        avctx->pix_fmt             = AV_PIX_FMT_RGB24;\n        avctx->bits_per_raw_sample = 8;\n        if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0)\n            return ret;\n        ret = decode_rgb24_frame(ctx, &gb, pic);\n        if (ret < 0)\n            return ret;\n        break;\n    case 3:\n        avctx->pix_fmt             = AV_PIX_FMT_ARGB;\n        avctx->bits_per_raw_sample = 8;\n        if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0)\n            return ret;\n        ret = decode_argb_frame(ctx, &gb, pic);\n        if (ret < 0)\n            return ret;\n        break;\n    default:\n        av_log(avctx, AV_LOG_ERROR, \"Unknown coding type: %d.\\n\", coding_type);\n    }\n    pic->key_frame = 1;\n    pic->pict_type = AV_PICTURE_TYPE_I;\n    *got_picture_ptr = 1;\n    return avpkt->size;\n}", "idx": 838}
{"project": "FFmpeg", "commit_id": "c8cfbc6629c1fe5755b59a3bcfd95ad08b843a07", "target": 1, "func": "static int hevc_decode_frame(AVCodecContext *avctx, void *data, int *got_output,\n\n                             AVPacket *avpkt)\n\n{\n\n    int ret;\n\n    int new_extradata_size;\n\n    uint8_t *new_extradata;\n\n    HEVCContext *s = avctx->priv_data;\n\n\n\n    if (!avpkt->size) {\n\n        ret = ff_hevc_output_frame(s, data, 1);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        *got_output = ret;\n\n        return 0;\n\n    }\n\n\n\n    new_extradata = av_packet_get_side_data(avpkt, AV_PKT_DATA_NEW_EXTRADATA,\n\n                                            &new_extradata_size);\n\n    if (new_extradata && new_extradata_size > 0) {\n\n        ret = hevc_decode_extradata(s, new_extradata, new_extradata_size);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n\n\n    s->ref = NULL;\n\n    ret    = decode_nal_units(s, avpkt->data, avpkt->size);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (avctx->hwaccel) {\n\n        if (s->ref && (ret = avctx->hwaccel->end_frame(avctx)) < 0) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"hardware accelerator failed to decode picture\\n\");\n\n            ff_hevc_unref_frame(s, s->ref, ~0);\n\n            return ret;\n\n        }\n\n    } else {\n\n        /* verify the SEI checksum */\n\n        if (avctx->err_recognition & AV_EF_CRCCHECK && s->is_decoded &&\n\n            s->sei.picture_hash.is_md5) {\n\n            ret = verify_md5(s, s->ref->frame);\n\n            if (ret < 0 && avctx->err_recognition & AV_EF_EXPLODE) {\n\n                ff_hevc_unref_frame(s, s->ref, ~0);\n\n                return ret;\n\n            }\n\n        }\n\n    }\n\n    s->sei.picture_hash.is_md5 = 0;\n\n\n\n    if (s->is_decoded) {\n\n        av_log(avctx, AV_LOG_DEBUG, \"Decoded frame with POC %d.\\n\", s->poc);\n\n        s->is_decoded = 0;\n\n    }\n\n\n\n    if (s->output_frame->buf[0]) {\n\n        av_frame_move_ref(data, s->output_frame);\n\n        *got_output = 1;\n\n    }\n\n\n\n    return avpkt->size;\n\n}\n", "idx": 1018}
{"project": "qemu", "commit_id": "271a916e8a4188b0ec94bafff18aa93de0047820", "target": 1, "func": "static always_inline void gen_rldimi (DisasContext *ctx, int mbn, int shn)\n\n{\n\n    uint64_t mask;\n\n    uint32_t sh, mb;\n\n\n\n    sh = SH(ctx->opcode) | (shn << 5);\n\n    mb = MB(ctx->opcode) | (mbn << 5);\n\n    if (likely(sh == 0)) {\n\n        if (likely(mb == 0)) {\n\n            gen_op_load_gpr_T0(rS(ctx->opcode));\n\n            goto do_store;\n\n        } else if (likely(mb == 63)) {\n\n            gen_op_load_gpr_T0(rA(ctx->opcode));\n\n            goto do_store;\n\n        }\n\n        gen_op_load_gpr_T0(rS(ctx->opcode));\n\n        gen_op_load_gpr_T1(rA(ctx->opcode));\n\n        goto do_mask;\n\n    }\n\n    gen_op_load_gpr_T0(rS(ctx->opcode));\n\n    gen_op_load_gpr_T1(rA(ctx->opcode));\n\n    gen_op_rotli64_T0(sh);\n\n do_mask:\n\n    mask = MASK(mb, 63 - sh);\n\n    gen_andi_T0_64(ctx, mask);\n\n    gen_andi_T1_64(ctx, ~mask);\n\n    gen_op_or();\n\n do_store:\n\n    gen_op_store_T0_gpr(rA(ctx->opcode));\n\n    if (unlikely(Rc(ctx->opcode) != 0))\n\n        gen_set_Rc0(ctx);\n\n}\n", "idx": 1033}
{"project": "FFmpeg", "commit_id": "91abb473fb8432226918da4fe03365ebaf688978", "target": 0, "func": "static void put_no_rnd_pixels_y2_mmx( UINT8  *block, const UINT8 *pixels, int line_size, int h)\n\n{\n\n  UINT8  *p;\n\n  const UINT8 *pix;\n\n  p = block;\n\n  pix = pixels;\n\n  MOVQ_ZERO(mm7);\n\n  JUMPALIGN();\n\n  do {\n\n    __asm __volatile(\n\n\t\"movq\t%1, %%mm0\\n\\t\"\n\n\t\"movq\t%2, %%mm1\\n\\t\"\n\n\t\"movq\t%%mm0, %%mm2\\n\\t\"\n\n\t\"movq\t%%mm1, %%mm3\\n\\t\"\n\n\t\"punpcklbw %%mm7, %%mm0\\n\\t\"\n\n\t\"punpcklbw %%mm7, %%mm1\\n\\t\"\n\n\t\"punpckhbw %%mm7, %%mm2\\n\\t\"\n\n\t\"punpckhbw %%mm7, %%mm3\\n\\t\"\n\n\t\"paddusw %%mm1, %%mm0\\n\\t\"\n\n\t\"paddusw %%mm3, %%mm2\\n\\t\"\n\n\t\"psrlw\t$1, %%mm0\\n\\t\"\n\n\t\"psrlw\t$1, %%mm2\\n\\t\"\n\n\t\"packuswb  %%mm2, %%mm0\\n\\t\"\n\n\t\"movq\t%%mm0, %0\\n\\t\"\n\n\t:\"=m\"(*p)\n\n\t:\"m\"(*pix),\n\n\t \"m\"(*(pix+line_size))\n\n\t:\"memory\");\n\n   pix += line_size;\n\n   p +=   line_size;\n\n  } while(--h);\n\n}\n", "idx": 1065}
{"project": "qemu", "commit_id": "46181129eac9a56d9a948667282dd03d5015f096", "target": 0, "func": "int bdrv_child_check_perm(BdrvChild *c, uint64_t perm, uint64_t shared,\n\n                          Error **errp)\n\n{\n\n    return bdrv_check_update_perm(c->bs, perm, shared, c, errp);\n\n}\n", "idx": 1219}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void ide_flush_cb(void *opaque, int ret)\n\n{\n\n    IDEState *s = opaque;\n\n\n\n    s->pio_aiocb = NULL;\n\n\n\n    if (ret == -ECANCELED) {\n\n        return;\n\n    }\n\n    if (ret < 0) {\n\n        /* XXX: What sector number to set here? */\n\n        if (ide_handle_rw_error(s, -ret, IDE_RETRY_FLUSH)) {\n\n            return;\n\n        }\n\n    }\n\n\n\n    if (s->bs) {\n\n        block_acct_done(bdrv_get_stats(s->bs), &s->acct);\n\n    }\n\n    s->status = READY_STAT | SEEK_STAT;\n\n    ide_cmd_done(s);\n\n    ide_set_irq(s->bus);\n\n}\n", "idx": 1249}
{"project": "FFmpeg", "commit_id": "57d77b3963ce1023eaf5ada8cba58b9379405cc8", "target": 0, "func": "int av_opencl_register_kernel_code(const char *kernel_code)\n\n{\n\n    int i, ret = 0;\n\n    LOCK_OPENCL;\n\n    if (gpu_env.kernel_code_count >= MAX_KERNEL_CODE_NUM) {\n\n        av_log(&openclutils, AV_LOG_ERROR,\n\n         \"Could not register kernel code, maximum number of registered kernel code %d already reached\\n\",\n\n         MAX_KERNEL_CODE_NUM);\n\n        ret = AVERROR(EINVAL);\n\n        goto end;\n\n    }\n\n    for (i = 0; i < gpu_env.kernel_code_count; i++) {\n\n        if (gpu_env.kernel_code[i].kernel_string == kernel_code) {\n\n            av_log(&openclutils, AV_LOG_WARNING, \"Same kernel code has been registered\\n\");\n\n            goto end;\n\n        }\n\n    }\n\n    gpu_env.kernel_code[gpu_env.kernel_code_count].kernel_string = kernel_code;\n\n    gpu_env.kernel_code[gpu_env.kernel_code_count].is_compiled = 0;\n\n    gpu_env.kernel_code_count++;\n\nend:\n\n    UNLOCK_OPENCL;\n\n    return ret;\n\n}\n", "idx": 1274}
{"project": "FFmpeg", "commit_id": "25e3e53d4092e7b69a4d681824fa0f7b2731bb1e", "target": 1, "func": "static void compute_stats(HTTPContext *c)\n\n{\n\n    HTTPContext *c1;\n\n    FFStream *stream;\n\n    char *p;\n\n    time_t ti;\n\n    int i, len;\n\n    ByteIOContext pb1, *pb = &pb1;\n\n\n\n    if (url_open_dyn_buf(pb) < 0) {\n\n        /* XXX: return an error ? */\n\n        c->buffer_ptr = c->buffer;\n\n        c->buffer_end = c->buffer;\n\n        return;\n\n    }\n\n\n\n    url_fprintf(pb, \"HTTP/1.0 200 OK\\r\\n\");\n\n    url_fprintf(pb, \"Content-type: %s\\r\\n\", \"text/html\");\n\n    url_fprintf(pb, \"Pragma: no-cache\\r\\n\");\n\n    url_fprintf(pb, \"\\r\\n\");\n\n\n\n    url_fprintf(pb, \"<HEAD><TITLE>FFServer Status</TITLE>\\n\");\n\n    if (c->stream->feed_filename)\n\n        url_fprintf(pb, \"<link rel=\\\"shortcut icon\\\" href=\\\"%s\\\">\\n\", c->stream->feed_filename);\n\n    url_fprintf(pb, \"</HEAD>\\n<BODY>\");\n\n    url_fprintf(pb, \"<H1>FFServer Status</H1>\\n\");\n\n    /* format status */\n\n    url_fprintf(pb, \"<H2>Available Streams</H2>\\n\");\n\n    url_fprintf(pb, \"<TABLE cellspacing=0 cellpadding=4>\\n\");\n\n    url_fprintf(pb, \"<TR><Th valign=top>Path<th align=left>Served<br>Conns<Th><br>bytes<Th valign=top>Format<Th>Bit rate<br>kbits/s<Th align=left>Video<br>kbits/s<th><br>Codec<Th align=left>Audio<br>kbits/s<th><br>Codec<Th align=left valign=top>Feed\\n\");\n\n    stream = first_stream;\n\n    while (stream != NULL) {\n\n        char sfilename[1024];\n\n        char *eosf;\n\n\n\n        if (stream->feed != stream) {\n\n            av_strlcpy(sfilename, stream->filename, sizeof(sfilename) - 10);\n\n            eosf = sfilename + strlen(sfilename);\n\n            if (eosf - sfilename >= 4) {\n\n                if (strcmp(eosf - 4, \".asf\") == 0)\n\n                    strcpy(eosf - 4, \".asx\");\n\n                else if (strcmp(eosf - 3, \".rm\") == 0)\n\n                    strcpy(eosf - 3, \".ram\");\n\n                else if (!strcmp(stream->fmt->name, \"rtp\")) {\n\n                    /* generate a sample RTSP director if\n\n                       unicast. Generate an SDP redirector if\n\n                       multicast */\n\n                    eosf = strrchr(sfilename, '.');\n\n                    if (!eosf)\n\n                        eosf = sfilename + strlen(sfilename);\n\n                    if (stream->is_multicast)\n\n                        strcpy(eosf, \".sdp\");\n\n                    else\n\n                        strcpy(eosf, \".rtsp\");\n\n                }\n\n            }\n\n\n\n            url_fprintf(pb, \"<TR><TD><A HREF=\\\"/%s\\\">%s</A> \",\n\n                         sfilename, stream->filename);\n\n            url_fprintf(pb, \"<td align=right> %d <td align=right> \",\n\n                        stream->conns_served);\n\n            fmt_bytecount(pb, stream->bytes_served);\n\n            switch(stream->stream_type) {\n\n            case STREAM_TYPE_LIVE:\n\n                {\n\n                    int audio_bit_rate = 0;\n\n                    int video_bit_rate = 0;\n\n                    const char *audio_codec_name = \"\";\n\n                    const char *video_codec_name = \"\";\n\n                    const char *audio_codec_name_extra = \"\";\n\n                    const char *video_codec_name_extra = \"\";\n\n\n\n                    for(i=0;i<stream->nb_streams;i++) {\n\n                        AVStream *st = stream->streams[i];\n\n                        AVCodec *codec = avcodec_find_encoder(st->codec->codec_id);\n\n                        switch(st->codec->codec_type) {\n\n                        case CODEC_TYPE_AUDIO:\n\n                            audio_bit_rate += st->codec->bit_rate;\n\n                            if (codec) {\n\n                                if (*audio_codec_name)\n\n                                    audio_codec_name_extra = \"...\";\n\n                                audio_codec_name = codec->name;\n\n                            }\n\n                            break;\n\n                        case CODEC_TYPE_VIDEO:\n\n                            video_bit_rate += st->codec->bit_rate;\n\n                            if (codec) {\n\n                                if (*video_codec_name)\n\n                                    video_codec_name_extra = \"...\";\n\n                                video_codec_name = codec->name;\n\n                            }\n\n                            break;\n\n                        case CODEC_TYPE_DATA:\n\n                            video_bit_rate += st->codec->bit_rate;\n\n                            break;\n\n                        default:\n\n                            abort();\n\n                        }\n\n                    }\n\n                    url_fprintf(pb, \"<TD align=center> %s <TD align=right> %d <TD align=right> %d <TD> %s %s <TD align=right> %d <TD> %s %s\",\n\n                                 stream->fmt->name,\n\n                                 stream->bandwidth,\n\n                                 video_bit_rate / 1000, video_codec_name, video_codec_name_extra,\n\n                                 audio_bit_rate / 1000, audio_codec_name, audio_codec_name_extra);\n\n                    if (stream->feed)\n\n                        url_fprintf(pb, \"<TD>%s\", stream->feed->filename);\n\n                    else\n\n                        url_fprintf(pb, \"<TD>%s\", stream->feed_filename);\n\n                    url_fprintf(pb, \"\\n\");\n\n                }\n\n                break;\n\n            default:\n\n                url_fprintf(pb, \"<TD align=center> - <TD align=right> - <TD align=right> - <td><td align=right> - <TD>\\n\");\n\n                break;\n\n            }\n\n        }\n\n        stream = stream->next;\n\n    }\n\n    url_fprintf(pb, \"</TABLE>\\n\");\n\n\n\n    stream = first_stream;\n\n    while (stream != NULL) {\n\n        if (stream->feed == stream) {\n\n            url_fprintf(pb, \"<h2>Feed %s</h2>\", stream->filename);\n\n            if (stream->pid) {\n\n                url_fprintf(pb, \"Running as pid %d.\\n\", stream->pid);\n\n\n\n#if defined(linux) && !defined(CONFIG_NOCUTILS)\n\n                {\n\n                    FILE *pid_stat;\n\n                    char ps_cmd[64];\n\n\n\n                    /* This is somewhat linux specific I guess */\n\n                    snprintf(ps_cmd, sizeof(ps_cmd),\n\n                             \"ps -o \\\"%%cpu,cputime\\\" --no-headers %d\",\n\n                             stream->pid);\n\n\n\n                    pid_stat = popen(ps_cmd, \"r\");\n\n                    if (pid_stat) {\n\n                        char cpuperc[10];\n\n                        char cpuused[64];\n\n\n\n                        if (fscanf(pid_stat, \"%10s %64s\", cpuperc,\n\n                                   cpuused) == 2) {\n\n                            url_fprintf(pb, \"Currently using %s%% of the cpu. Total time used %s.\\n\",\n\n                                         cpuperc, cpuused);\n\n                        }\n\n                        fclose(pid_stat);\n\n                    }\n\n                }\n\n#endif\n\n\n\n                url_fprintf(pb, \"<p>\");\n\n            }\n\n            url_fprintf(pb, \"<table cellspacing=0 cellpadding=4><tr><th>Stream<th>type<th>kbits/s<th align=left>codec<th align=left>Parameters\\n\");\n\n\n\n            for (i = 0; i < stream->nb_streams; i++) {\n\n                AVStream *st = stream->streams[i];\n\n                AVCodec *codec = avcodec_find_encoder(st->codec->codec_id);\n\n                const char *type = \"unknown\";\n\n                char parameters[64];\n\n\n\n                parameters[0] = 0;\n\n\n\n                switch(st->codec->codec_type) {\n\n                case CODEC_TYPE_AUDIO:\n\n                    type = \"audio\";\n\n                    snprintf(parameters, sizeof(parameters), \"%d channel(s), %d Hz\", st->codec->channels, st->codec->sample_rate);\n\n                    break;\n\n                case CODEC_TYPE_VIDEO:\n\n                    type = \"video\";\n\n                    snprintf(parameters, sizeof(parameters), \"%dx%d, q=%d-%d, fps=%d\", st->codec->width, st->codec->height,\n\n                                st->codec->qmin, st->codec->qmax, st->codec->time_base.den / st->codec->time_base.num);\n\n                    break;\n\n                default:\n\n                    abort();\n\n                }\n\n                url_fprintf(pb, \"<tr><td align=right>%d<td>%s<td align=right>%d<td>%s<td>%s\\n\",\n\n                        i, type, st->codec->bit_rate/1000, codec ? codec->name : \"\", parameters);\n\n            }\n\n            url_fprintf(pb, \"</table>\\n\");\n\n\n\n        }\n\n        stream = stream->next;\n\n    }\n\n\n\n#if 0\n\n    {\n\n        float avg;\n\n        AVCodecContext *enc;\n\n        char buf[1024];\n\n\n\n        /* feed status */\n\n        stream = first_feed;\n\n        while (stream != NULL) {\n\n            url_fprintf(pb, \"<H1>Feed '%s'</H1>\\n\", stream->filename);\n\n            url_fprintf(pb, \"<TABLE>\\n\");\n\n            url_fprintf(pb, \"<TR><TD>Parameters<TD>Frame count<TD>Size<TD>Avg bitrate (kbits/s)\\n\");\n\n            for(i=0;i<stream->nb_streams;i++) {\n\n                AVStream *st = stream->streams[i];\n\n                FeedData *fdata = st->priv_data;\n\n                enc = st->codec;\n\n\n\n                avcodec_string(buf, sizeof(buf), enc);\n\n                avg = fdata->avg_frame_size * (float)enc->rate * 8.0;\n\n                if (enc->codec->type == CODEC_TYPE_AUDIO && enc->frame_size > 0)\n\n                    avg /= enc->frame_size;\n\n                url_fprintf(pb, \"<TR><TD>%s <TD> %d <TD> %\"PRId64\" <TD> %0.1f\\n\",\n\n                             buf, enc->frame_number, fdata->data_count, avg / 1000.0);\n\n            }\n\n            url_fprintf(pb, \"</TABLE>\\n\");\n\n            stream = stream->next_feed;\n\n        }\n\n    }\n\n#endif\n\n\n\n    /* connection status */\n\n    url_fprintf(pb, \"<H2>Connection Status</H2>\\n\");\n\n\n\n    url_fprintf(pb, \"Number of connections: %d / %d<BR>\\n\",\n\n                 nb_connections, nb_max_connections);\n\n\n\n    url_fprintf(pb, \"Bandwidth in use: %dk / %dk<BR>\\n\",\n\n                 current_bandwidth, max_bandwidth);\n\n\n\n    url_fprintf(pb, \"<TABLE>\\n\");\n\n    url_fprintf(pb, \"<TR><th>#<th>File<th>IP<th>Proto<th>State<th>Target bits/sec<th>Actual bits/sec<th>Bytes transferred\\n\");\n\n    c1 = first_http_ctx;\n\n    i = 0;\n\n    while (c1 != NULL) {\n\n        int bitrate;\n\n        int j;\n\n\n\n        bitrate = 0;\n\n        if (c1->stream) {\n\n            for (j = 0; j < c1->stream->nb_streams; j++) {\n\n                if (!c1->stream->feed)\n\n                    bitrate += c1->stream->streams[j]->codec->bit_rate;\n\n                else if (c1->feed_streams[j] >= 0)\n\n                    bitrate += c1->stream->feed->streams[c1->feed_streams[j]]->codec->bit_rate;\n\n            }\n\n        }\n\n\n\n        i++;\n\n        p = inet_ntoa(c1->from_addr.sin_addr);\n\n        url_fprintf(pb, \"<TR><TD><B>%d</B><TD>%s%s<TD>%s<TD>%s<TD>%s<td align=right>\",\n\n                    i,\n\n                    c1->stream ? c1->stream->filename : \"\",\n\n                    c1->state == HTTPSTATE_RECEIVE_DATA ? \"(input)\" : \"\",\n\n                    p,\n\n                    c1->protocol,\n\n                    http_state[c1->state]);\n\n        fmt_bytecount(pb, bitrate);\n\n        url_fprintf(pb, \"<td align=right>\");\n\n        fmt_bytecount(pb, compute_datarate(&c1->datarate, c1->data_count) * 8);\n\n        url_fprintf(pb, \"<td align=right>\");\n\n        fmt_bytecount(pb, c1->data_count);\n\n        url_fprintf(pb, \"\\n\");\n\n        c1 = c1->next;\n\n    }\n\n    url_fprintf(pb, \"</TABLE>\\n\");\n\n\n\n    /* date */\n\n    ti = time(NULL);\n\n    p = ctime(&ti);\n\n    url_fprintf(pb, \"<HR size=1 noshade>Generated at %s\", p);\n\n    url_fprintf(pb, \"</BODY>\\n</HTML>\\n\");\n\n\n\n    len = url_close_dyn_buf(pb, &c->pb_buffer);\n\n    c->buffer_ptr = c->pb_buffer;\n\n    c->buffer_end = c->pb_buffer + len;\n\n}\n", "idx": 1275}
{"project": "FFmpeg", "commit_id": "9f06c1c61e876e930753da200bfe835817e30a53", "target": 1, "func": "static inline int decode_residual_inter(AVSContext *h) {\n\n    int block;\n\n\n\n    /* get coded block pattern */\n\n    int cbp= get_ue_golomb(&h->s.gb);\n\n    if(cbp > 63){\n\n        av_log(h->s.avctx, AV_LOG_ERROR, \"illegal inter cbp\\n\");\n\n        return -1;\n\n    }\n\n    h->cbp = cbp_tab[cbp][1];\n\n\n\n    /* get quantizer */\n\n    if(h->cbp && !h->qp_fixed)\n\n        h->qp = (h->qp + get_se_golomb(&h->s.gb)) & 63;\n\n    for(block=0;block<4;block++)\n\n        if(h->cbp & (1<<block))\n\n            decode_residual_block(h,&h->s.gb,ff_cavs_inter_dec,0,h->qp,\n\n                                  h->cy + h->luma_scan[block], h->l_stride);\n\n    decode_residual_chroma(h);\n\n\n\n    return 0;\n\n}\n", "idx": 1388}
{"project": "FFmpeg", "commit_id": "80ca19f766aea8f4724aac1b3faa772d25163c8a", "target": 0, "func": "static int ipvideo_decode_block_opcode_0xA(IpvideoContext *s)\n\n{\n\n    int x, y;\n\n    unsigned char P[4];\n\n    int flags = 0;\n\n\n\n    /* 4-color encoding for each 4x4 quadrant, or 4-color encoding on\n\n     * either top and bottom or left and right halves */\n\n    CHECK_STREAM_PTR(24);\n\n\n\n    if (s->stream_ptr[0] <= s->stream_ptr[1]) {\n\n\n\n        /* 4-color encoding for each quadrant; need 32 bytes */\n\n        CHECK_STREAM_PTR(32);\n\n\n\n        for (y = 0; y < 16; y++) {\n\n            // new values for each 4x4 block\n\n            if (!(y & 3)) {\n\n                memcpy(P, s->stream_ptr, 4);\n\n                s->stream_ptr += 4;\n\n                flags = bytestream_get_le32(&s->stream_ptr);\n\n            }\n\n\n\n            for (x = 0; x < 4; x++, flags >>= 2)\n\n                *s->pixel_ptr++ = P[flags & 0x03];\n\n\n\n            s->pixel_ptr += s->stride - 4;\n\n            // switch to right half\n\n            if (y == 7) s->pixel_ptr -= 8 * s->stride - 4;\n\n        }\n\n\n\n    } else {\n\n        // vertical split?\n\n        int vert = s->stream_ptr[12] <= s->stream_ptr[13];\n\n        uint64_t flags = 0;\n\n\n\n        /* 4-color encoding for either left and right or top and bottom\n\n         * halves */\n\n\n\n        for (y = 0; y < 16; y++) {\n\n            // load values for each half\n\n            if (!(y & 7)) {\n\n                memcpy(P, s->stream_ptr, 4);\n\n                s->stream_ptr += 4;\n\n                flags = bytestream_get_le64(&s->stream_ptr);\n\n            }\n\n\n\n            for (x = 0; x < 4; x++, flags >>= 2)\n\n                *s->pixel_ptr++ = P[flags & 0x03];\n\n\n\n            if (vert) {\n\n                s->pixel_ptr += s->stride - 4;\n\n                // switch to right half\n\n                if (y == 7) s->pixel_ptr -= 8 * s->stride - 4;\n\n            } else if (y & 1) s->pixel_ptr += s->line_inc;\n\n        }\n\n    }\n\n\n\n    /* report success */\n\n    return 0;\n\n}\n", "idx": 1441}
{"project": "FFmpeg", "commit_id": "6a276c46b119d47e1d473e0813893820a9393562", "target": 0, "func": "static inline void dv_decode_video_segment(DVVideoContext *s,\n\n                                           const uint8_t *buf_ptr1,\n\n                                           const uint16_t *mb_pos_ptr)\n\n{\n\n    int quant, dc, dct_mode, class1, j;\n\n    int mb_index, mb_x, mb_y, v, last_index;\n\n    int y_stride, i;\n\n    DCTELEM *block, *block1;\n\n    int c_offset;\n\n    uint8_t *y_ptr;\n\n    const uint8_t *buf_ptr;\n\n    PutBitContext pb, vs_pb;\n\n    GetBitContext gb;\n\n    BlockInfo mb_data[5 * DV_MAX_BPM], *mb, *mb1;\n\n    DECLARE_ALIGNED_16(DCTELEM, sblock[5*DV_MAX_BPM][64]);\n\n    DECLARE_ALIGNED_8(uint8_t, mb_bit_buffer[80 + 4]); /* allow some slack */\n\n    DECLARE_ALIGNED_8(uint8_t, vs_bit_buffer[5 * 80 + 4]); /* allow some slack */\n\n    const int log2_blocksize= 3-s->avctx->lowres;\n\n    int is_field_mode[5];\n\n\n\n    assert((((int)mb_bit_buffer)&7)==0);\n\n    assert((((int)vs_bit_buffer)&7)==0);\n\n\n\n    memset(sblock, 0, sizeof(sblock));\n\n\n\n    /* pass 1 : read DC and AC coefficients in blocks */\n\n    buf_ptr = buf_ptr1;\n\n    block1 = &sblock[0][0];\n\n    mb1 = mb_data;\n\n    init_put_bits(&vs_pb, vs_bit_buffer, 5 * 80);\n\n    for(mb_index = 0; mb_index < 5; mb_index++, mb1 += s->sys->bpm, block1 += s->sys->bpm * 64) {\n\n        /* skip header */\n\n        quant = buf_ptr[3] & 0x0f;\n\n        buf_ptr += 4;\n\n        init_put_bits(&pb, mb_bit_buffer, 80);\n\n        mb = mb1;\n\n        block = block1;\n\n        is_field_mode[mb_index] = 0;\n\n        for(j = 0;j < s->sys->bpm; j++) {\n\n            last_index = s->sys->block_sizes[j];\n\n            init_get_bits(&gb, buf_ptr, last_index);\n\n\n\n            /* get the dc */\n\n            dc = get_sbits(&gb, 9);\n\n            dct_mode = get_bits1(&gb);\n\n            class1 = get_bits(&gb, 2);\n\n            if (DV_PROFILE_IS_HD(s->sys)) {\n\n                mb->idct_put = s->idct_put[0];\n\n                mb->scan_table = s->dv_zigzag[0];\n\n                mb->factor_table = s->dv100_idct_factor[((s->sys->height == 720)<<1)|(j >= 4)][class1][quant];\n\n                is_field_mode[mb_index] |= !j && dct_mode;\n\n            } else {\n\n                mb->idct_put = s->idct_put[dct_mode && log2_blocksize==3];\n\n                mb->scan_table = s->dv_zigzag[dct_mode];\n\n                mb->factor_table = s->dv_idct_factor[class1 == 3][dct_mode]\n\n                    [quant + dv_quant_offset[class1]];\n\n            }\n\n            dc = dc << 2;\n\n            /* convert to unsigned because 128 is not added in the\n\n               standard IDCT */\n\n            dc += 1024;\n\n            block[0] = dc;\n\n            buf_ptr += last_index >> 3;\n\n            mb->pos = 0;\n\n            mb->partial_bit_count = 0;\n\n\n\n#ifdef VLC_DEBUG\n\n            printf(\"MB block: %d, %d \", mb_index, j);\n\n#endif\n\n            dv_decode_ac(&gb, mb, block);\n\n\n\n            /* write the remaining bits  in a new buffer only if the\n\n               block is finished */\n\n            if (mb->pos >= 64)\n\n                bit_copy(&pb, &gb);\n\n\n\n            block += 64;\n\n            mb++;\n\n        }\n\n\n\n        /* pass 2 : we can do it just after */\n\n#ifdef VLC_DEBUG\n\n        printf(\"***pass 2 size=%d MB#=%d\\n\", put_bits_count(&pb), mb_index);\n\n#endif\n\n        block = block1;\n\n        mb = mb1;\n\n        init_get_bits(&gb, mb_bit_buffer, put_bits_count(&pb));\n\n        flush_put_bits(&pb);\n\n        for(j = 0;j < s->sys->bpm; j++, block += 64, mb++) {\n\n            if (mb->pos < 64 && get_bits_left(&gb) > 0) {\n\n                dv_decode_ac(&gb, mb, block);\n\n                /* if still not finished, no need to parse other blocks */\n\n                if (mb->pos < 64)\n\n                    break;\n\n            }\n\n        }\n\n        /* all blocks are finished, so the extra bytes can be used at\n\n           the video segment level */\n\n        if (j >= s->sys->bpm)\n\n            bit_copy(&vs_pb, &gb);\n\n    }\n\n\n\n    /* we need a pass other the whole video segment */\n\n#ifdef VLC_DEBUG\n\n    printf(\"***pass 3 size=%d\\n\", put_bits_count(&vs_pb));\n\n#endif\n\n    block = &sblock[0][0];\n\n    mb = mb_data;\n\n    init_get_bits(&gb, vs_bit_buffer, put_bits_count(&vs_pb));\n\n    flush_put_bits(&vs_pb);\n\n    for(mb_index = 0; mb_index < 5; mb_index++) {\n\n        for(j = 0;j < s->sys->bpm; j++) {\n\n            if (mb->pos < 64) {\n\n#ifdef VLC_DEBUG\n\n                printf(\"start %d:%d\\n\", mb_index, j);\n\n#endif\n\n                dv_decode_ac(&gb, mb, block);\n\n            }\n\n            if (mb->pos >= 64 && mb->pos < 127)\n\n                av_log(NULL, AV_LOG_ERROR, \"AC EOB marker is absent pos=%d\\n\", mb->pos);\n\n            block += 64;\n\n            mb++;\n\n        }\n\n    }\n\n\n\n    /* compute idct and place blocks */\n\n    block = &sblock[0][0];\n\n    mb = mb_data;\n\n    for(mb_index = 0; mb_index < 5; mb_index++) {\n\n        v = *mb_pos_ptr++;\n\n        mb_x = v & 0xff;\n\n        mb_y = v >> 8;\n\n        /* We work with 720p frames split in half. The odd half-frame (chan==2,3) is displaced :-( */\n\n        if (s->sys->height == 720 && !(s->buf[1]&0x0C)) {\n\n               mb_y -= (mb_y>17)?18:-72; /* shifting the Y coordinate down by 72/2 macroblocks */\n\n        }\n\n\n\n        /* idct_put'ting luminance */\n\n        if ((s->sys->pix_fmt == PIX_FMT_YUV420P) ||\n\n            (s->sys->pix_fmt == PIX_FMT_YUV411P && mb_x >= (704 / 8)) ||\n\n            (s->sys->height >= 720 && mb_y != 134)) {\n\n            y_stride = (s->picture.linesize[0]<<((!is_field_mode[mb_index])*log2_blocksize)) - (2<<log2_blocksize);\n\n        } else {\n\n            y_stride = 0;\n\n        }\n\n        y_ptr = s->picture.data[0] + ((mb_y * s->picture.linesize[0] + mb_x)<<log2_blocksize);\n\n        for(j = 0; j < 2; j++, y_ptr += y_stride) {\n\n            for (i=0; i<2; i++, block += 64, mb++, y_ptr += (1<<log2_blocksize))\n\n                 if (s->sys->pix_fmt == PIX_FMT_YUV422P && s->sys->width == 720 && i)\n\n                     y_ptr -= (1<<log2_blocksize);\n\n                 else\n\n                     mb->idct_put(y_ptr, s->picture.linesize[0]<<is_field_mode[mb_index], block);\n\n        }\n\n\n\n        /* idct_put'ting chrominance */\n\n        c_offset = (((mb_y>>(s->sys->pix_fmt == PIX_FMT_YUV420P)) * s->picture.linesize[1] +\n\n                     (mb_x>>((s->sys->pix_fmt == PIX_FMT_YUV411P)?2:1)))<<log2_blocksize);\n\n        for(j=2; j; j--) {\n\n            uint8_t *c_ptr = s->picture.data[j] + c_offset;\n\n            if (s->sys->pix_fmt == PIX_FMT_YUV411P && mb_x >= (704 / 8)) {\n\n                  uint64_t aligned_pixels[64/8];\n\n                  uint8_t *pixels = (uint8_t*)aligned_pixels;\n\n                  uint8_t *c_ptr1, *ptr1;\n\n                  int x, y;\n\n                  mb->idct_put(pixels, 8, block);\n\n                  for(y = 0; y < (1<<log2_blocksize); y++, c_ptr += s->picture.linesize[j], pixels += 8) {\n\n                      ptr1= pixels + (1<<(log2_blocksize-1));\n\n                      c_ptr1 = c_ptr + (s->picture.linesize[j]<<log2_blocksize);\n\n                      for(x=0; x < (1<<(log2_blocksize-1)); x++) {\n\n                          c_ptr[x]= pixels[x];\n\n                          c_ptr1[x]= ptr1[x];\n\n                      }\n\n                  }\n\n                  block += 64; mb++;\n\n            } else {\n\n                  y_stride = (mb_y == 134) ? (1<<log2_blocksize) :\n\n                                             s->picture.linesize[j]<<((!is_field_mode[mb_index])*log2_blocksize);\n\n                  for (i=0; i<(1<<(s->sys->bpm==8)); i++, block += 64, mb++, c_ptr += y_stride)\n\n                       mb->idct_put(c_ptr, s->picture.linesize[j]<<is_field_mode[mb_index], block);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 1447}
{"project": "qemu", "commit_id": "0ce470cd4ca88e84e547a3b95159d23ce6be419e", "target": 0, "func": "int kvmppc_fixup_cpu(PowerPCCPU *cpu)\n\n{\n\n    CPUState *cs = CPU(cpu);\n\n    int smt;\n\n\n\n    /* Adjust cpu index for SMT */\n\n    smt = kvmppc_smt_threads();\n\n    cs->cpu_index = (cs->cpu_index / smp_threads) * smt\n\n        + (cs->cpu_index % smp_threads);\n\n\n\n    return 0;\n\n}\n", "idx": 1572}
{"project": "qemu", "commit_id": "2c9ee0291f8ca7e18f8e96a34e8f4be7867219d2", "target": 1, "func": "static void *spapr_create_fdt_skel(const char *cpu_model,\n\n                                   hwaddr initrd_base,\n\n                                   hwaddr initrd_size,\n\n                                   hwaddr kernel_size,\n\n                                   const char *boot_device,\n\n                                   const char *kernel_cmdline,\n\n                                   uint32_t epow_irq)\n\n{\n\n    void *fdt;\n\n    CPUPPCState *env;\n\n    uint32_t start_prop = cpu_to_be32(initrd_base);\n\n    uint32_t end_prop = cpu_to_be32(initrd_base + initrd_size);\n\n    char hypertas_prop[] = \"hcall-pft\\0hcall-term\\0hcall-dabr\\0hcall-interrupt\"\n\n        \"\\0hcall-tce\\0hcall-vio\\0hcall-splpar\\0hcall-bulk\";\n\n    char qemu_hypertas_prop[] = \"hcall-memop1\";\n\n    uint32_t refpoints[] = {cpu_to_be32(0x4), cpu_to_be32(0x4)};\n\n    uint32_t interrupt_server_ranges_prop[] = {0, cpu_to_be32(smp_cpus)};\n\n    char *modelname;\n\n    int i, smt = kvmppc_smt_threads();\n\n    unsigned char vec5[] = {0x0, 0x0, 0x0, 0x0, 0x0, 0x80};\n\n\n\n    fdt = g_malloc0(FDT_MAX_SIZE);\n\n    _FDT((fdt_create(fdt, FDT_MAX_SIZE)));\n\n\n\n    if (kernel_size) {\n\n        _FDT((fdt_add_reservemap_entry(fdt, KERNEL_LOAD_ADDR, kernel_size)));\n\n    }\n\n    if (initrd_size) {\n\n        _FDT((fdt_add_reservemap_entry(fdt, initrd_base, initrd_size)));\n\n    }\n\n    _FDT((fdt_finish_reservemap(fdt)));\n\n\n\n    /* Root node */\n\n    _FDT((fdt_begin_node(fdt, \"\")));\n\n    _FDT((fdt_property_string(fdt, \"device_type\", \"chrp\")));\n\n    _FDT((fdt_property_string(fdt, \"model\", \"IBM pSeries (emulated by qemu)\")));\n\n\n\n    _FDT((fdt_property_cell(fdt, \"#address-cells\", 0x2)));\n\n    _FDT((fdt_property_cell(fdt, \"#size-cells\", 0x2)));\n\n\n\n    /* /chosen */\n\n    _FDT((fdt_begin_node(fdt, \"chosen\")));\n\n\n\n    /* Set Form1_affinity */\n\n    _FDT((fdt_property(fdt, \"ibm,architecture-vec-5\", vec5, sizeof(vec5))));\n\n\n\n    _FDT((fdt_property_string(fdt, \"bootargs\", kernel_cmdline)));\n\n    _FDT((fdt_property(fdt, \"linux,initrd-start\",\n\n                       &start_prop, sizeof(start_prop))));\n\n    _FDT((fdt_property(fdt, \"linux,initrd-end\",\n\n                       &end_prop, sizeof(end_prop))));\n\n    if (kernel_size) {\n\n        uint64_t kprop[2] = { cpu_to_be64(KERNEL_LOAD_ADDR),\n\n                              cpu_to_be64(kernel_size) };\n\n\n\n        _FDT((fdt_property(fdt, \"qemu,boot-kernel\", &kprop, sizeof(kprop))));\n\n    }\n\n    _FDT((fdt_property_string(fdt, \"qemu,boot-device\", boot_device)));\n\n    _FDT((fdt_property_cell(fdt, \"qemu,graphic-width\", graphic_width)));\n\n    _FDT((fdt_property_cell(fdt, \"qemu,graphic-height\", graphic_height)));\n\n    _FDT((fdt_property_cell(fdt, \"qemu,graphic-depth\", graphic_depth)));\n\n\n\n    _FDT((fdt_end_node(fdt)));\n\n\n\n    /* cpus */\n\n    _FDT((fdt_begin_node(fdt, \"cpus\")));\n\n\n\n    _FDT((fdt_property_cell(fdt, \"#address-cells\", 0x1)));\n\n    _FDT((fdt_property_cell(fdt, \"#size-cells\", 0x0)));\n\n\n\n    modelname = g_strdup(cpu_model);\n\n\n\n    for (i = 0; i < strlen(modelname); i++) {\n\n        modelname[i] = toupper(modelname[i]);\n\n    }\n\n\n\n    /* This is needed during FDT finalization */\n\n    spapr->cpu_model = g_strdup(modelname);\n\n\n\n    for (env = first_cpu; env != NULL; env = env->next_cpu) {\n\n        CPUState *cpu = CPU(ppc_env_get_cpu(env));\n\n        int index = cpu->cpu_index;\n\n        uint32_t servers_prop[smp_threads];\n\n        uint32_t gservers_prop[smp_threads * 2];\n\n        char *nodename;\n\n        uint32_t segs[] = {cpu_to_be32(28), cpu_to_be32(40),\n\n                           0xffffffff, 0xffffffff};\n\n        uint32_t tbfreq = kvm_enabled() ? kvmppc_get_tbfreq() : TIMEBASE_FREQ;\n\n        uint32_t cpufreq = kvm_enabled() ? kvmppc_get_clockfreq() : 1000000000;\n\n        uint32_t page_sizes_prop[64];\n\n        size_t page_sizes_prop_size;\n\n\n\n        if ((index % smt) != 0) {\n\n            continue;\n\n        }\n\n\n\n        if (asprintf(&nodename, \"%s@%x\", modelname, index) < 0) {\n\n            fprintf(stderr, \"Allocation failure\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        _FDT((fdt_begin_node(fdt, nodename)));\n\n\n\n        free(nodename);\n\n\n\n        _FDT((fdt_property_cell(fdt, \"reg\", index)));\n\n        _FDT((fdt_property_string(fdt, \"device_type\", \"cpu\")));\n\n\n\n        _FDT((fdt_property_cell(fdt, \"cpu-version\", env->spr[SPR_PVR])));\n\n        _FDT((fdt_property_cell(fdt, \"dcache-block-size\",\n\n                                env->dcache_line_size)));\n\n        _FDT((fdt_property_cell(fdt, \"icache-block-size\",\n\n                                env->icache_line_size)));\n\n        _FDT((fdt_property_cell(fdt, \"timebase-frequency\", tbfreq)));\n\n        _FDT((fdt_property_cell(fdt, \"clock-frequency\", cpufreq)));\n\n        _FDT((fdt_property_cell(fdt, \"ibm,slb-size\", env->slb_nr)));\n\n        _FDT((fdt_property_string(fdt, \"status\", \"okay\")));\n\n        _FDT((fdt_property(fdt, \"64-bit\", NULL, 0)));\n\n\n\n        /* Build interrupt servers and gservers properties */\n\n        for (i = 0; i < smp_threads; i++) {\n\n            servers_prop[i] = cpu_to_be32(index + i);\n\n            /* Hack, direct the group queues back to cpu 0 */\n\n            gservers_prop[i*2] = cpu_to_be32(index + i);\n\n            gservers_prop[i*2 + 1] = 0;\n\n        }\n\n        _FDT((fdt_property(fdt, \"ibm,ppc-interrupt-server#s\",\n\n                           servers_prop, sizeof(servers_prop))));\n\n        _FDT((fdt_property(fdt, \"ibm,ppc-interrupt-gserver#s\",\n\n                           gservers_prop, sizeof(gservers_prop))));\n\n\n\n        if (env->mmu_model & POWERPC_MMU_1TSEG) {\n\n            _FDT((fdt_property(fdt, \"ibm,processor-segment-sizes\",\n\n                               segs, sizeof(segs))));\n\n        }\n\n\n\n        /* Advertise VMX/VSX (vector extensions) if available\n\n         *   0 / no property == no vector extensions\n\n         *   1               == VMX / Altivec available\n\n         *   2               == VSX available */\n\n        if (env->insns_flags & PPC_ALTIVEC) {\n\n            uint32_t vmx = (env->insns_flags2 & PPC2_VSX) ? 2 : 1;\n\n\n\n            _FDT((fdt_property_cell(fdt, \"ibm,vmx\", vmx)));\n\n        }\n\n\n\n        /* Advertise DFP (Decimal Floating Point) if available\n\n         *   0 / no property == no DFP\n\n         *   1               == DFP available */\n\n        if (env->insns_flags2 & PPC2_DFP) {\n\n            _FDT((fdt_property_cell(fdt, \"ibm,dfp\", 1)));\n\n        }\n\n\n\n        page_sizes_prop_size = create_page_sizes_prop(env, page_sizes_prop,\n\n                                                      sizeof(page_sizes_prop));\n\n        if (page_sizes_prop_size) {\n\n            _FDT((fdt_property(fdt, \"ibm,segment-page-sizes\",\n\n                               page_sizes_prop, page_sizes_prop_size)));\n\n        }\n\n\n\n        _FDT((fdt_end_node(fdt)));\n\n    }\n\n\n\n    g_free(modelname);\n\n\n\n    _FDT((fdt_end_node(fdt)));\n\n\n\n    /* RTAS */\n\n    _FDT((fdt_begin_node(fdt, \"rtas\")));\n\n\n\n    _FDT((fdt_property(fdt, \"ibm,hypertas-functions\", hypertas_prop,\n\n                       sizeof(hypertas_prop))));\n\n    _FDT((fdt_property(fdt, \"qemu,hypertas-functions\", qemu_hypertas_prop,\n\n                       sizeof(qemu_hypertas_prop))));\n\n\n\n    _FDT((fdt_property(fdt, \"ibm,associativity-reference-points\",\n\n        refpoints, sizeof(refpoints))));\n\n\n\n    _FDT((fdt_property_cell(fdt, \"rtas-error-log-max\", RTAS_ERROR_LOG_MAX)));\n\n\n\n    _FDT((fdt_end_node(fdt)));\n\n\n\n    /* interrupt controller */\n\n    _FDT((fdt_begin_node(fdt, \"interrupt-controller\")));\n\n\n\n    _FDT((fdt_property_string(fdt, \"device_type\",\n\n                              \"PowerPC-External-Interrupt-Presentation\")));\n\n    _FDT((fdt_property_string(fdt, \"compatible\", \"IBM,ppc-xicp\")));\n\n    _FDT((fdt_property(fdt, \"interrupt-controller\", NULL, 0)));\n\n    _FDT((fdt_property(fdt, \"ibm,interrupt-server-ranges\",\n\n                       interrupt_server_ranges_prop,\n\n                       sizeof(interrupt_server_ranges_prop))));\n\n    _FDT((fdt_property_cell(fdt, \"#interrupt-cells\", 2)));\n\n    _FDT((fdt_property_cell(fdt, \"linux,phandle\", PHANDLE_XICP)));\n\n    _FDT((fdt_property_cell(fdt, \"phandle\", PHANDLE_XICP)));\n\n\n\n    _FDT((fdt_end_node(fdt)));\n\n\n\n    /* vdevice */\n\n    _FDT((fdt_begin_node(fdt, \"vdevice\")));\n\n\n\n    _FDT((fdt_property_string(fdt, \"device_type\", \"vdevice\")));\n\n    _FDT((fdt_property_string(fdt, \"compatible\", \"IBM,vdevice\")));\n\n    _FDT((fdt_property_cell(fdt, \"#address-cells\", 0x1)));\n\n    _FDT((fdt_property_cell(fdt, \"#size-cells\", 0x0)));\n\n    _FDT((fdt_property_cell(fdt, \"#interrupt-cells\", 0x2)));\n\n    _FDT((fdt_property(fdt, \"interrupt-controller\", NULL, 0)));\n\n\n\n    _FDT((fdt_end_node(fdt)));\n\n\n\n    /* event-sources */\n\n    spapr_events_fdt_skel(fdt, epow_irq);\n\n\n\n    _FDT((fdt_end_node(fdt))); /* close root node */\n\n    _FDT((fdt_finish(fdt)));\n\n\n\n    return fdt;\n\n}\n", "idx": 1578}
{"project": "qemu", "commit_id": "4bac52f5c4b3dd5d0bd7568377ad7e957d5e3c6a", "target": 1, "func": "static void add_qemu_cpu_model_features(S390FeatBitmap fbm)\n\n{\n\n    static const int feats[] = {\n\n        S390_FEAT_DAT_ENH,\n\n        S390_FEAT_IDTE_SEGMENT,\n\n        S390_FEAT_STFLE,\n\n        S390_FEAT_SENSE_RUNNING_STATUS,\n\n        S390_FEAT_EXTENDED_IMMEDIATE,\n\n        S390_FEAT_EXTENDED_TRANSLATION_2,\n\n        S390_FEAT_MSA,\n\n        S390_FEAT_EXTENDED_TRANSLATION_3,\n\n        S390_FEAT_LONG_DISPLACEMENT,\n\n        S390_FEAT_LONG_DISPLACEMENT_FAST,\n\n        S390_FEAT_ETF2_ENH,\n\n        S390_FEAT_STORE_CLOCK_FAST,\n\n        S390_FEAT_MOVE_WITH_OPTIONAL_SPEC,\n\n        S390_FEAT_ETF3_ENH,\n\n\n        S390_FEAT_COMPARE_AND_SWAP_AND_STORE,\n\n        S390_FEAT_COMPARE_AND_SWAP_AND_STORE_2,\n\n        S390_FEAT_GENERAL_INSTRUCTIONS_EXT,\n\n        S390_FEAT_EXECUTE_EXT,\n\n        S390_FEAT_FLOATING_POINT_SUPPPORT_ENH,\n\n        S390_FEAT_STFLE_45,\n\n        S390_FEAT_STFLE_49,\n\n        S390_FEAT_LOCAL_TLB_CLEARING,\n\n        S390_FEAT_INTERLOCKED_ACCESS_2,\n\n        S390_FEAT_STFLE_53,\n\n        S390_FEAT_MSA_EXT_5,\n\n        S390_FEAT_MSA_EXT_3,\n\n        S390_FEAT_MSA_EXT_4,\n\n    };\n\n    int i;\n\n\n\n    for (i = 0; i < ARRAY_SIZE(feats); i++) {\n\n        set_bit(feats[i], fbm);\n\n    }\n\n}", "idx": 1677}
{"project": "qemu", "commit_id": "91479dd0b5bd3b087b92ddd7bc3f2c54982cfe17", "target": 0, "func": "START_TEST(qobject_to_qlist_test)\n\n{\n\n    QList *qlist;\n\n\n\n    qlist = qlist_new();\n\n\n\n    fail_unless(qobject_to_qlist(QOBJECT(qlist)) == qlist);\n\n\n\n    // destroy doesn't exist yet\n\n    g_free(qlist);\n\n}\n", "idx": 1688}
{"project": "FFmpeg", "commit_id": "91767360d86ac786571593ab11c7291010ab3829", "target": 0, "func": "static int a64multi_encode_frame(AVCodecContext *avctx, AVPacket *pkt,\n\n                                 const AVFrame *pict, int *got_packet)\n\n{\n\n    A64Context *c = avctx->priv_data;\n\n    AVFrame *const p = avctx->coded_frame;\n\n\n\n    int frame;\n\n    int x, y;\n\n    int b_height;\n\n    int b_width;\n\n\n\n    int req_size, ret;\n\n    uint8_t *buf;\n\n\n\n    int *charmap     = c->mc_charmap;\n\n    uint8_t *colram  = c->mc_colram;\n\n    uint8_t *charset = c->mc_charset;\n\n    int *meta        = c->mc_meta_charset;\n\n    int *best_cb     = c->mc_best_cb;\n\n\n\n    int charset_size = 0x800 * (INTERLACED + 1);\n\n    int colram_size  = 0x100 * c->mc_use_5col;\n\n    int screen_size;\n\n\n\n    if(CROP_SCREENS) {\n\n        b_height = FFMIN(avctx->height,C64YRES) >> 3;\n\n        b_width  = FFMIN(avctx->width ,C64XRES) >> 3;\n\n        screen_size = b_width * b_height;\n\n    } else {\n\n        b_height = C64YRES >> 3;\n\n        b_width  = C64XRES >> 3;\n\n        screen_size = 0x400;\n\n    }\n\n\n\n    /* no data, means end encoding asap */\n\n    if (!pict) {\n\n        /* all done, end encoding */\n\n        if (!c->mc_lifetime) return 0;\n\n        /* no more frames in queue, prepare to flush remaining frames */\n\n        if (!c->mc_frame_counter) {\n\n            c->mc_lifetime = 0;\n\n        }\n\n        /* still frames in queue so limit lifetime to remaining frames */\n\n        else c->mc_lifetime = c->mc_frame_counter;\n\n    /* still new data available */\n\n    } else {\n\n        /* fill up mc_meta_charset with data until lifetime exceeds */\n\n        if (c->mc_frame_counter < c->mc_lifetime) {\n\n            *p = *pict;\n\n            p->pict_type = AV_PICTURE_TYPE_I;\n\n            p->key_frame = 1;\n\n            to_meta_with_crop(avctx, p, meta + 32000 * c->mc_frame_counter);\n\n            c->mc_frame_counter++;\n\n            if (c->next_pts == AV_NOPTS_VALUE)\n\n                c->next_pts = pict->pts;\n\n            /* lifetime is not reached so wait for next frame first */\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    /* lifetime reached so now convert X frames at once */\n\n    if (c->mc_frame_counter == c->mc_lifetime) {\n\n        req_size = 0;\n\n        /* any frames to encode? */\n\n        if (c->mc_lifetime) {\n\n            req_size = charset_size + c->mc_lifetime*(screen_size + colram_size);\n\n            if ((ret = ff_alloc_packet(pkt, req_size)) < 0) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Error getting output packet of size %d.\\n\", req_size);\n\n                return ret;\n\n            }\n\n            buf = pkt->data;\n\n\n\n            /* calc optimal new charset + charmaps */\n\n            ret = ff_init_elbg(meta, 32, 1000 * c->mc_lifetime, best_cb,\n\n                               CHARSET_CHARS, 50, charmap, &c->randctx);\n\n            if (ret < 0)\n\n                return ret;\n\n            ret = ff_do_elbg(meta, 32, 1000 * c->mc_lifetime, best_cb,\n\n                             CHARSET_CHARS, 50, charmap, &c->randctx);\n\n            if (ret < 0)\n\n                return ret;\n\n\n\n            /* create colorram map and a c64 readable charset */\n\n            render_charset(avctx, charset, colram);\n\n\n\n            /* copy charset to buf */\n\n            memcpy(buf, charset, charset_size);\n\n\n\n            /* advance pointers */\n\n            buf      += charset_size;\n\n            charset  += charset_size;\n\n        }\n\n\n\n        /* write x frames to buf */\n\n        for (frame = 0; frame < c->mc_lifetime; frame++) {\n\n            /* copy charmap to buf. buf is uchar*, charmap is int*, so no memcpy here, sorry */\n\n            for (y = 0; y < b_height; y++) {\n\n                for (x = 0; x < b_width; x++) {\n\n                    buf[y * b_width + x] = charmap[y * b_width + x];\n\n                }\n\n            }\n\n            /* advance pointers */\n\n            buf += screen_size;\n\n            req_size += screen_size;\n\n\n\n            /* compress and copy colram to buf */\n\n            if (c->mc_use_5col) {\n\n                a64_compress_colram(buf, charmap, colram);\n\n                /* advance pointers */\n\n                buf += colram_size;\n\n                req_size += colram_size;\n\n            }\n\n\n\n            /* advance to next charmap */\n\n            charmap += 1000;\n\n        }\n\n\n\n        AV_WB32(avctx->extradata + 4,  c->mc_frame_counter);\n\n        AV_WB32(avctx->extradata + 8,  charset_size);\n\n        AV_WB32(avctx->extradata + 12, screen_size + colram_size);\n\n\n\n        /* reset counter */\n\n        c->mc_frame_counter = 0;\n\n\n\n        pkt->pts = pkt->dts = c->next_pts;\n\n        c->next_pts         = AV_NOPTS_VALUE;\n\n\n\n        pkt->size   = req_size;\n\n        pkt->flags |= AV_PKT_FLAG_KEY;\n\n        *got_packet = !!req_size;\n\n    }\n\n    return 0;\n\n}\n", "idx": 1706}
{"project": "qemu", "commit_id": "88be7b4be4aa17c88247e162bdd7577ea79db94f", "target": 1, "func": "static void vm_completion(ReadLineState *rs, const char *str)\n\n{\n\n    size_t len;\n\n    BlockDriverState *bs;\n\n    BdrvNextIterator *it = NULL;\n\n\n\n    len = strlen(str);\n\n    readline_set_completion_index(rs, len);\n\n\n\n    while ((it = bdrv_next(it, &bs))) {\n\n        SnapshotInfoList *snapshots, *snapshot;\n\n        AioContext *ctx = bdrv_get_aio_context(bs);\n\n        bool ok = false;\n\n\n\n        aio_context_acquire(ctx);\n\n        if (bdrv_can_snapshot(bs)) {\n\n            ok = bdrv_query_snapshot_info_list(bs, &snapshots, NULL) == 0;\n\n        }\n\n        aio_context_release(ctx);\n\n        if (!ok) {\n\n            continue;\n\n        }\n\n\n\n        snapshot = snapshots;\n\n        while (snapshot) {\n\n            char *completion = snapshot->value->name;\n\n            if (!strncmp(str, completion, len)) {\n\n                readline_add_completion(rs, completion);\n\n            }\n\n            completion = snapshot->value->id;\n\n            if (!strncmp(str, completion, len)) {\n\n                readline_add_completion(rs, completion);\n\n            }\n\n            snapshot = snapshot->next;\n\n        }\n\n        qapi_free_SnapshotInfoList(snapshots);\n\n    }\n\n\n\n}\n", "idx": 1750}
{"project": "qemu", "commit_id": "b2bedb214469af55179d907a60cd67fed6b0779e", "target": 0, "func": "static uint32_t bonito_spciconf_readb(void *opaque, target_phys_addr_t addr)\n\n{\n\n    PCIBonitoState *s = opaque;\n\n    uint32_t pciaddr;\n\n    uint16_t status;\n\n\n\n    DPRINTF(\"bonito_spciconf_readb \"TARGET_FMT_plx\"  \\n\", addr);\n\n    pciaddr = bonito_sbridge_pciaddr(s, addr);\n\n\n\n    if (pciaddr == 0xffffffff) {\n\n        return 0xff;\n\n    }\n\n\n\n    /* set the pci address in s->config_reg */\n\n    s->pcihost->config_reg = (pciaddr) | (1u << 31);\n\n\n\n    /* clear PCI_STATUS_REC_MASTER_ABORT and PCI_STATUS_REC_TARGET_ABORT */\n\n    status = pci_get_word(s->dev.config + PCI_STATUS);\n\n    status &= ~(PCI_STATUS_REC_MASTER_ABORT | PCI_STATUS_REC_TARGET_ABORT);\n\n    pci_set_word(s->dev.config + PCI_STATUS, status);\n\n\n\n    return pci_data_read(s->pcihost->bus, s->pcihost->config_reg, 1);\n\n}\n", "idx": 1851}
{"project": "FFmpeg", "commit_id": "073c2593c9f0aa4445a6fc1b9b24e6e52a8cc2c1", "target": 1, "func": "static int mjpeg_decode_dht(MJpegDecodeContext *s)\n\n{\n\n    int len, index, i, class, n, v, code_max;\n\n    uint8_t bits_table[17];\n\n    uint8_t val_table[256];\n\n    \n\n    len = get_bits(&s->gb, 16) - 2;\n\n\n\n    while (len > 0) {\n\n        if (len < 17)\n\n            return -1;\n\n        class = get_bits(&s->gb, 4);\n\n        if (class >= 2)\n\n            return -1;\n\n        index = get_bits(&s->gb, 4);\n\n        if (index >= 4)\n\n            return -1;\n\n        n = 0;\n\n        for(i=1;i<=16;i++) {\n\n            bits_table[i] = get_bits(&s->gb, 8);\n\n            n += bits_table[i];\n\n        }\n\n        len -= 17;\n\n        if (len < n || n > 256)\n\n            return -1;\n\n\n\n        code_max = 0;\n\n        for(i=0;i<n;i++) {\n\n            v = get_bits(&s->gb, 8);\n\n            if (v > code_max)\n\n                code_max = v;\n\n            val_table[i] = v;\n\n        }\n\n        len -= n;\n\n\n\n        /* build VLC and flush previous vlc if present */\n\n        free_vlc(&s->vlcs[class][index]);\n\n        dprintf(\"class=%d index=%d nb_codes=%d\\n\",\n\n               class, index, code_max + 1);\n\n        if(build_vlc(&s->vlcs[class][index], bits_table, val_table, code_max + 1) < 0){\n\n            return -1;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 1872}
{"project": "qemu", "commit_id": "6ee5920243cc5fe35d219fa2883a673b91808c0f", "target": 0, "func": "START_TEST(escaped_string)\n\n{\n\n    int i;\n\n    struct {\n\n        const char *encoded;\n\n        const char *decoded;\n\n    } test_cases[] = {\n\n        { \"\\\"\\\\\\\"\\\"\", \"\\\"\" },\n\n        { \"\\\"hello world \\\\\\\"embedded string\\\\\\\"\\\"\",\n\n          \"hello world \\\"embedded string\\\"\" },\n\n        { \"\\\"hello world\\\\nwith new line\\\"\", \"hello world\\nwith new line\" },\n\n        { \"\\\"single byte utf-8 \\\\u0020\\\"\", \"single byte utf-8  \" },\n\n        { \"\\\"double byte utf-8 \\\\u00A2\\\"\", \"double byte utf-8 \\xc2\\xa2\" },\n\n        { \"\\\"triple byte utf-8 \\\\u20AC\\\"\", \"triple byte utf-8 \\xe2\\x82\\xac\" },\n\n        {}\n\n    };\n\n\n\n    for (i = 0; test_cases[i].encoded; i++) {\n\n        QObject *obj;\n\n        QString *str;\n\n\n\n        obj = qobject_from_json(test_cases[i].encoded);\n\n\n\n        fail_unless(obj != NULL);\n\n        fail_unless(qobject_type(obj) == QTYPE_QSTRING);\n\n        \n\n        str = qobject_to_qstring(obj);\n\n        fail_unless(strcmp(qstring_get_str(str), test_cases[i].decoded) == 0);\n\n\n\n        QDECREF(str);\n\n    }\n\n}\n", "idx": 1914}
{"project": "FFmpeg", "commit_id": "dcc39ee10e82833ce24aa57926c00ffeb1948198", "target": 0, "func": "void avcodec_register_all(void)\n\n{\n\n    static int initialized;\n\n\n\n    if (initialized)\n\n        return;\n\n    initialized = 1;\n\n\n\n    /* hardware accelerators */\n\n    REGISTER_HWACCEL(H263_VAAPI,        h263_vaapi);\n\n    REGISTER_HWACCEL(H264_D3D11VA,      h264_d3d11va);\n\n    REGISTER_HWACCEL(H264_DXVA2,        h264_dxva2);\n\n    REGISTER_HWACCEL(H264_MMAL,         h264_mmal);\n\n    REGISTER_HWACCEL(H264_QSV,          h264_qsv);\n\n    REGISTER_HWACCEL(H264_VAAPI,        h264_vaapi);\n\n    REGISTER_HWACCEL(H264_VDA,          h264_vda);\n\n    REGISTER_HWACCEL(H264_VDA_OLD,      h264_vda_old);\n\n    REGISTER_HWACCEL(H264_VDPAU,        h264_vdpau);\n\n    REGISTER_HWACCEL(HEVC_D3D11VA,      hevc_d3d11va);\n\n    REGISTER_HWACCEL(HEVC_DXVA2,        hevc_dxva2);\n\n    REGISTER_HWACCEL(HEVC_QSV,          hevc_qsv);\n\n    REGISTER_HWACCEL(HEVC_VAAPI,        hevc_vaapi);\n\n    REGISTER_HWACCEL(HEVC_VDPAU,        hevc_vdpau);\n\n    REGISTER_HWACCEL(MPEG1_VDPAU,       mpeg1_vdpau);\n\n    REGISTER_HWACCEL(MPEG2_D3D11VA,     mpeg2_d3d11va);\n\n    REGISTER_HWACCEL(MPEG2_DXVA2,       mpeg2_dxva2);\n\n    REGISTER_HWACCEL(MPEG2_MMAL,        mpeg2_mmal);\n\n    REGISTER_HWACCEL(MPEG2_QSV,         mpeg2_qsv);\n\n    REGISTER_HWACCEL(MPEG2_VAAPI,       mpeg2_vaapi);\n\n    REGISTER_HWACCEL(MPEG2_VDPAU,       mpeg2_vdpau);\n\n    REGISTER_HWACCEL(MPEG4_VAAPI,       mpeg4_vaapi);\n\n    REGISTER_HWACCEL(MPEG4_VDPAU,       mpeg4_vdpau);\n\n    REGISTER_HWACCEL(VC1_D3D11VA,       vc1_d3d11va);\n\n    REGISTER_HWACCEL(VC1_DXVA2,         vc1_dxva2);\n\n    REGISTER_HWACCEL(VC1_QSV,           vc1_qsv);\n\n    REGISTER_HWACCEL(VC1_VAAPI,         vc1_vaapi);\n\n    REGISTER_HWACCEL(VC1_VDPAU,         vc1_vdpau);\n\n    REGISTER_HWACCEL(VC1_MMAL,          vc1_mmal);\n\n    REGISTER_HWACCEL(VP8_QSV,           vp8_qsv);\n\n    REGISTER_HWACCEL(VP8_VAAPI,         vp8_vaapi);\n\n    REGISTER_HWACCEL(WMV3_D3D11VA,      wmv3_d3d11va);\n\n    REGISTER_HWACCEL(WMV3_DXVA2,        wmv3_dxva2);\n\n    REGISTER_HWACCEL(WMV3_VAAPI,        wmv3_vaapi);\n\n    REGISTER_HWACCEL(WMV3_VDPAU,        wmv3_vdpau);\n\n\n\n    /* video codecs */\n\n    REGISTER_ENCODER(A64MULTI,          a64multi);\n\n    REGISTER_ENCODER(A64MULTI5,         a64multi5);\n\n    REGISTER_DECODER(AASC,              aasc);\n\n    REGISTER_DECODER(AIC,               aic);\n\n    REGISTER_ENCDEC (ALIAS_PIX,         alias_pix);\n\n    REGISTER_DECODER(AMV,               amv);\n\n    REGISTER_DECODER(ANM,               anm);\n\n    REGISTER_DECODER(ANSI,              ansi);\n\n    REGISTER_ENCDEC (ASV1,              asv1);\n\n    REGISTER_ENCDEC (ASV2,              asv2);\n\n    REGISTER_DECODER(AURA,              aura);\n\n    REGISTER_DECODER(AURA2,             aura2);\n\n    REGISTER_DECODER(AVS,               avs);\n\n    REGISTER_DECODER(BETHSOFTVID,       bethsoftvid);\n\n    REGISTER_DECODER(BFI,               bfi);\n\n    REGISTER_DECODER(BINK,              bink);\n\n    REGISTER_ENCDEC (BMP,               bmp);\n\n    REGISTER_DECODER(BMV_VIDEO,         bmv_video);\n\n    REGISTER_DECODER(BRENDER_PIX,       brender_pix);\n\n    REGISTER_DECODER(C93,               c93);\n\n    REGISTER_DECODER(CAVS,              cavs);\n\n    REGISTER_DECODER(CDGRAPHICS,        cdgraphics);\n\n    REGISTER_DECODER(CDXL,              cdxl);\n\n    REGISTER_DECODER(CFHD,              cfhd);\n\n    REGISTER_DECODER(CINEPAK,           cinepak);\n\n    REGISTER_ENCDEC (CLJR,              cljr);\n\n    REGISTER_DECODER(CLLC,              cllc);\n\n    REGISTER_ENCDEC (COMFORTNOISE,      comfortnoise);\n\n    REGISTER_DECODER(CSCD,              cscd);\n\n    REGISTER_DECODER(CYUV,              cyuv);\n\n    REGISTER_DECODER(DDS,               dds);\n\n    REGISTER_DECODER(DFA,               dfa);\n\n    REGISTER_ENCDEC (DNXHD,             dnxhd);\n\n    REGISTER_ENCDEC (DPX,               dpx);\n\n    REGISTER_DECODER(DSICINVIDEO,       dsicinvideo);\n\n    REGISTER_ENCDEC (DVVIDEO,           dvvideo);\n\n    REGISTER_DECODER(DXA,               dxa);\n\n    REGISTER_DECODER(DXTORY,            dxtory);\n\n    REGISTER_DECODER(DXV,               dxv);\n\n    REGISTER_DECODER(EACMV,             eacmv);\n\n    REGISTER_DECODER(EAMAD,             eamad);\n\n    REGISTER_DECODER(EATGQ,             eatgq);\n\n    REGISTER_DECODER(EATGV,             eatgv);\n\n    REGISTER_DECODER(EATQI,             eatqi);\n\n    REGISTER_DECODER(EIGHTBPS,          eightbps);\n\n    REGISTER_DECODER(EIGHTSVX_EXP,      eightsvx_exp);\n\n    REGISTER_DECODER(EIGHTSVX_FIB,      eightsvx_fib);\n\n    REGISTER_DECODER(ESCAPE124,         escape124);\n\n    REGISTER_DECODER(ESCAPE130,         escape130);\n\n    REGISTER_DECODER(EXR,               exr);\n\n    REGISTER_ENCDEC (FFV1,              ffv1);\n\n    REGISTER_ENCDEC (FFVHUFF,           ffvhuff);\n\n    REGISTER_DECODER(FIC,               fic);\n\n    REGISTER_ENCDEC (FLASHSV,           flashsv);\n\n    REGISTER_DECODER(FLASHSV2,          flashsv2);\n\n    REGISTER_DECODER(FLIC,              flic);\n\n    REGISTER_ENCDEC (FLV,               flv);\n\n    REGISTER_DECODER(FOURXM,            fourxm);\n\n    REGISTER_DECODER(FRAPS,             fraps);\n\n    REGISTER_DECODER(FRWU,              frwu);\n\n    REGISTER_DECODER(G2M,               g2m);\n\n    REGISTER_ENCDEC (GIF,               gif);\n\n    REGISTER_ENCDEC (H261,              h261);\n\n    REGISTER_ENCDEC (H263,              h263);\n\n    REGISTER_DECODER(H263I,             h263i);\n\n    REGISTER_ENCODER(H263P,             h263p);\n\n    REGISTER_DECODER(H264,              h264);\n\n    REGISTER_DECODER(H264_MMAL,         h264_mmal);\n\n    REGISTER_DECODER(H264_QSV,          h264_qsv);\n\n    REGISTER_ENCDEC (HAP,               hap);\n\n    REGISTER_DECODER(HEVC,              hevc);\n\n    REGISTER_DECODER(HEVC_QSV,          hevc_qsv);\n\n    REGISTER_DECODER(HNM4_VIDEO,        hnm4_video);\n\n    REGISTER_DECODER(HQ_HQA,            hq_hqa);\n\n    REGISTER_DECODER(HQX,               hqx);\n\n    REGISTER_ENCDEC (HUFFYUV,           huffyuv);\n\n    REGISTER_DECODER(IDCIN,             idcin);\n\n    REGISTER_DECODER(IFF_BYTERUN1,      iff_byterun1);\n\n    REGISTER_DECODER(IFF_ILBM,          iff_ilbm);\n\n    REGISTER_DECODER(INDEO2,            indeo2);\n\n    REGISTER_DECODER(INDEO3,            indeo3);\n\n    REGISTER_DECODER(INDEO4,            indeo4);\n\n    REGISTER_DECODER(INDEO5,            indeo5);\n\n    REGISTER_DECODER(INTERPLAY_VIDEO,   interplay_video);\n\n    REGISTER_DECODER(JPEG2000,          jpeg2000);\n\n    REGISTER_ENCDEC (JPEGLS,            jpegls);\n\n    REGISTER_DECODER(JV,                jv);\n\n    REGISTER_DECODER(KGV1,              kgv1);\n\n    REGISTER_DECODER(KMVC,              kmvc);\n\n    REGISTER_DECODER(LAGARITH,          lagarith);\n\n    REGISTER_ENCODER(LJPEG,             ljpeg);\n\n    REGISTER_DECODER(LOCO,              loco);\n\n    REGISTER_DECODER(MAGICYUV,          magicyuv);\n\n    REGISTER_DECODER(MDEC,              mdec);\n\n    REGISTER_DECODER(MIMIC,             mimic);\n\n    REGISTER_ENCDEC (MJPEG,             mjpeg);\n\n    REGISTER_DECODER(MJPEGB,            mjpegb);\n\n    REGISTER_DECODER(MMVIDEO,           mmvideo);\n\n    REGISTER_DECODER(MOTIONPIXELS,      motionpixels);\n\n#if FF_API_XVMC\n\n    REGISTER_DECODER(MPEG_XVMC,         mpeg_xvmc);\n\n#endif /* FF_API_XVMC */\n\n    REGISTER_ENCDEC (MPEG1VIDEO,        mpeg1video);\n\n    REGISTER_ENCDEC (MPEG2VIDEO,        mpeg2video);\n\n    REGISTER_DECODER(MPEG2_MMAL,        mpeg2_mmal);\n\n    REGISTER_DECODER(MPEG2_QSV,         mpeg2_qsv);\n\n    REGISTER_ENCDEC (MPEG4,             mpeg4);\n\n    REGISTER_DECODER(MSA1,              msa1);\n\n    REGISTER_DECODER(MSMPEG4V1,         msmpeg4v1);\n\n    REGISTER_ENCDEC (MSMPEG4V2,         msmpeg4v2);\n\n    REGISTER_ENCDEC (MSMPEG4V3,         msmpeg4v3);\n\n    REGISTER_DECODER(MSRLE,             msrle);\n\n    REGISTER_DECODER(MSS1,              mss1);\n\n    REGISTER_DECODER(MSS2,              mss2);\n\n    REGISTER_DECODER(MSVIDEO1,          msvideo1);\n\n    REGISTER_DECODER(MSZH,              mszh);\n\n    REGISTER_DECODER(MTS2,              mts2);\n\n    REGISTER_DECODER(MVC1,              mvc1);\n\n    REGISTER_DECODER(MVC2,              mvc2);\n\n    REGISTER_DECODER(MXPEG,             mxpeg);\n\n    REGISTER_DECODER(NUV,               nuv);\n\n    REGISTER_DECODER(PAF_VIDEO,         paf_video);\n\n    REGISTER_ENCDEC (PAM,               pam);\n\n    REGISTER_ENCDEC (PBM,               pbm);\n\n    REGISTER_ENCDEC (PCX,               pcx);\n\n    REGISTER_ENCDEC (PGM,               pgm);\n\n    REGISTER_ENCDEC (PGMYUV,            pgmyuv);\n\n    REGISTER_DECODER(PICTOR,            pictor);\n\n    REGISTER_DECODER(PIXLET,            pixlet);\n\n    REGISTER_ENCDEC (PNG,               png);\n\n    REGISTER_ENCDEC (PPM,               ppm);\n\n    REGISTER_ENCDEC (PRORES,            prores);\n\n    REGISTER_DECODER(PTX,               ptx);\n\n    REGISTER_DECODER(QDRAW,             qdraw);\n\n    REGISTER_DECODER(QPEG,              qpeg);\n\n    REGISTER_ENCDEC (QTRLE,             qtrle);\n\n    REGISTER_DECODER(R10K,              r10k);\n\n    REGISTER_DECODER(R210,              r210);\n\n    REGISTER_ENCDEC (RAWVIDEO,          rawvideo);\n\n    REGISTER_DECODER(RL2,               rl2);\n\n    REGISTER_ENCDEC (ROQ,               roq);\n\n    REGISTER_DECODER(RPZA,              rpza);\n\n    REGISTER_DECODER(RSCC,              rscc);\n\n    REGISTER_ENCDEC (RV10,              rv10);\n\n    REGISTER_ENCDEC (RV20,              rv20);\n\n    REGISTER_DECODER(RV30,              rv30);\n\n    REGISTER_DECODER(RV40,              rv40);\n\n    REGISTER_DECODER(S302M,             s302m);\n\n    REGISTER_DECODER(SANM,              sanm);\n\n    REGISTER_DECODER(SCREENPRESSO,      screenpresso);\n\n    REGISTER_ENCDEC (SGI,               sgi);\n\n    REGISTER_DECODER(SGIRLE,            sgirle);\n\n    REGISTER_DECODER(SMACKER,           smacker);\n\n    REGISTER_DECODER(SMC,               smc);\n\n    REGISTER_DECODER(SP5X,              sp5x);\n\n    REGISTER_ENCDEC (SUNRAST,           sunrast);\n\n    REGISTER_ENCDEC (SVQ1,              svq1);\n\n    REGISTER_DECODER(SVQ3,              svq3);\n\n    REGISTER_ENCDEC (TARGA,             targa);\n\n    REGISTER_DECODER(TDSC,              tdsc);\n\n    REGISTER_DECODER(THEORA,            theora);\n\n    REGISTER_DECODER(THP,               thp);\n\n    REGISTER_DECODER(TIERTEXSEQVIDEO,   tiertexseqvideo);\n\n    REGISTER_ENCDEC (TIFF,              tiff);\n\n    REGISTER_DECODER(TMV,               tmv);\n\n    REGISTER_DECODER(TRUEMOTION1,       truemotion1);\n\n    REGISTER_DECODER(TRUEMOTION2,       truemotion2);\n\n    REGISTER_DECODER(TRUEMOTION2RT,     truemotion2rt);\n\n    REGISTER_DECODER(TSCC,              tscc);\n\n    REGISTER_DECODER(TSCC2,             tscc2);\n\n    REGISTER_DECODER(TXD,               txd);\n\n    REGISTER_DECODER(ULTI,              ulti);\n\n    REGISTER_ENCDEC (UTVIDEO,           utvideo);\n\n    REGISTER_ENCDEC (V210,              v210);\n\n    REGISTER_DECODER(V210X,             v210x);\n\n    REGISTER_ENCDEC (V410,              v410);\n\n    REGISTER_DECODER(VB,                vb);\n\n    REGISTER_DECODER(VBLE,              vble);\n\n    REGISTER_DECODER(VC1,               vc1);\n\n    REGISTER_DECODER(VC1IMAGE,          vc1image);\n\n    REGISTER_DECODER(VC1_MMAL,          vc1_mmal);\n\n    REGISTER_DECODER(VC1_QSV,           vc1_qsv);\n\n    REGISTER_DECODER(VCR1,              vcr1);\n\n    REGISTER_DECODER(VMDVIDEO,          vmdvideo);\n\n    REGISTER_DECODER(VMNC,              vmnc);\n\n    REGISTER_DECODER(VP3,               vp3);\n\n    REGISTER_DECODER(VP5,               vp5);\n\n    REGISTER_DECODER(VP6,               vp6);\n\n    REGISTER_DECODER(VP6A,              vp6a);\n\n    REGISTER_DECODER(VP6F,              vp6f);\n\n    REGISTER_DECODER(VP7,               vp7);\n\n    REGISTER_DECODER(VP8,               vp8);\n\n    REGISTER_DECODER(VP8_QSV,           vp8_qsv);\n\n    REGISTER_DECODER(VP9,               vp9);\n\n    REGISTER_DECODER(VQA,               vqa);\n\n    REGISTER_DECODER(WEBP,              webp);\n\n    REGISTER_ENCODER(WRAPPED_AVFRAME,   wrapped_avframe);\n\n    REGISTER_ENCDEC (WMV1,              wmv1);\n\n    REGISTER_ENCDEC (WMV2,              wmv2);\n\n    REGISTER_DECODER(WMV3,              wmv3);\n\n    REGISTER_DECODER(WMV3IMAGE,         wmv3image);\n\n    REGISTER_DECODER(WNV1,              wnv1);\n\n    REGISTER_DECODER(XAN_WC3,           xan_wc3);\n\n    REGISTER_DECODER(XAN_WC4,           xan_wc4);\n\n    REGISTER_ENCDEC (XBM,               xbm);\n\n    REGISTER_DECODER(XL,                xl);\n\n    REGISTER_ENCDEC (XWD,               xwd);\n\n    REGISTER_DECODER(YOP,               yop);\n\n    REGISTER_DECODER(ZEROCODEC,         zerocodec);\n\n    REGISTER_ENCDEC (ZLIB,              zlib);\n\n    REGISTER_ENCDEC (ZMBV,              zmbv);\n\n\n\n    /* audio codecs */\n\n    REGISTER_ENCDEC (AAC,               aac);\n\n    REGISTER_DECODER(AAC_LATM,          aac_latm);\n\n    REGISTER_ENCDEC (AC3,               ac3);\n\n    REGISTER_ENCODER(AC3_FIXED,         ac3_fixed);\n\n    REGISTER_ENCDEC (ALAC,              alac);\n\n    REGISTER_DECODER(ALS,               als);\n\n    REGISTER_DECODER(AMRNB,             amrnb);\n\n    REGISTER_DECODER(AMRWB,             amrwb);\n\n    REGISTER_DECODER(APE,               ape);\n\n    REGISTER_DECODER(ATRAC1,            atrac1);\n\n    REGISTER_DECODER(ATRAC3,            atrac3);\n\n    REGISTER_DECODER(ATRAC3P,           atrac3p);\n\n    REGISTER_DECODER(BINKAUDIO_DCT,     binkaudio_dct);\n\n    REGISTER_DECODER(BINKAUDIO_RDFT,    binkaudio_rdft);\n\n    REGISTER_DECODER(BMV_AUDIO,         bmv_audio);\n\n    REGISTER_DECODER(COOK,              cook);\n\n    REGISTER_DECODER(DCA,               dca);\n\n    REGISTER_DECODER(DSICINAUDIO,       dsicinaudio);\n\n    REGISTER_DECODER(DSS_SP,            dss_sp);\n\n    REGISTER_ENCDEC (EAC3,              eac3);\n\n    REGISTER_ENCDEC (FLAC,              flac);\n\n    REGISTER_ENCDEC (G723_1,            g723_1);\n\n    REGISTER_DECODER(GSM,               gsm);\n\n    REGISTER_DECODER(GSM_MS,            gsm_ms);\n\n    REGISTER_DECODER(IAC,               iac);\n\n    REGISTER_DECODER(IMC,               imc);\n\n    REGISTER_DECODER(MACE3,             mace3);\n\n    REGISTER_DECODER(MACE6,             mace6);\n\n    REGISTER_DECODER(METASOUND,         metasound);\n\n    REGISTER_DECODER(MLP,               mlp);\n\n    REGISTER_DECODER(MP1,               mp1);\n\n    REGISTER_DECODER(MP1FLOAT,          mp1float);\n\n    REGISTER_ENCDEC (MP2,               mp2);\n\n    REGISTER_DECODER(MP2FLOAT,          mp2float);\n\n    REGISTER_DECODER(MP3,               mp3);\n\n    REGISTER_DECODER(MP3FLOAT,          mp3float);\n\n    REGISTER_DECODER(MP3ADU,            mp3adu);\n\n    REGISTER_DECODER(MP3ADUFLOAT,       mp3adufloat);\n\n    REGISTER_DECODER(MP3ON4,            mp3on4);\n\n    REGISTER_DECODER(MP3ON4FLOAT,       mp3on4float);\n\n    REGISTER_DECODER(MPC7,              mpc7);\n\n    REGISTER_DECODER(MPC8,              mpc8);\n\n    REGISTER_ENCDEC (NELLYMOSER,        nellymoser);\n\n    REGISTER_DECODER(ON2AVC,            on2avc);\n\n    REGISTER_DECODER(OPUS,              opus);\n\n    REGISTER_DECODER(PAF_AUDIO,         paf_audio);\n\n    REGISTER_DECODER(QCELP,             qcelp);\n\n    REGISTER_DECODER(QDM2,              qdm2);\n\n    REGISTER_ENCDEC (RA_144,            ra_144);\n\n    REGISTER_DECODER(RA_288,            ra_288);\n\n    REGISTER_DECODER(RALF,              ralf);\n\n    REGISTER_DECODER(SHORTEN,           shorten);\n\n    REGISTER_DECODER(SIPR,              sipr);\n\n    REGISTER_DECODER(SMACKAUD,          smackaud);\n\n    REGISTER_DECODER(TAK,               tak);\n\n    REGISTER_DECODER(TRUEHD,            truehd);\n\n    REGISTER_DECODER(TRUESPEECH,        truespeech);\n\n    REGISTER_DECODER(TTA,               tta);\n\n    REGISTER_DECODER(TWINVQ,            twinvq);\n\n    REGISTER_DECODER(VMDAUDIO,          vmdaudio);\n\n    REGISTER_ENCDEC (VORBIS,            vorbis);\n\n    REGISTER_DECODER(WAVPACK,           wavpack);\n\n    REGISTER_DECODER(WMALOSSLESS,       wmalossless);\n\n    REGISTER_DECODER(WMAPRO,            wmapro);\n\n    REGISTER_ENCDEC (WMAV1,             wmav1);\n\n    REGISTER_ENCDEC (WMAV2,             wmav2);\n\n    REGISTER_DECODER(WMAVOICE,          wmavoice);\n\n    REGISTER_DECODER(WS_SND1,           ws_snd1);\n\n\n\n    /* PCM codecs */\n\n    REGISTER_ENCDEC (PCM_ALAW,          pcm_alaw);\n\n    REGISTER_DECODER(PCM_BLURAY,        pcm_bluray);\n\n    REGISTER_DECODER(PCM_DVD,           pcm_dvd);\n\n    REGISTER_ENCDEC (PCM_F32BE,         pcm_f32be);\n\n    REGISTER_ENCDEC (PCM_F32LE,         pcm_f32le);\n\n    REGISTER_ENCDEC (PCM_F64BE,         pcm_f64be);\n\n    REGISTER_ENCDEC (PCM_F64LE,         pcm_f64le);\n\n    REGISTER_DECODER(PCM_LXF,           pcm_lxf);\n\n    REGISTER_ENCDEC (PCM_MULAW,         pcm_mulaw);\n\n    REGISTER_ENCDEC (PCM_S8,            pcm_s8);\n\n    REGISTER_DECODER(PCM_S8_PLANAR,     pcm_s8_planar);\n\n    REGISTER_ENCDEC (PCM_S16BE,         pcm_s16be);\n\n    REGISTER_DECODER(PCM_S16BE_PLANAR,  pcm_s16be_planar);\n\n    REGISTER_ENCDEC (PCM_S16LE,         pcm_s16le);\n\n    REGISTER_DECODER(PCM_S16LE_PLANAR,  pcm_s16le_planar);\n\n    REGISTER_ENCDEC (PCM_S24BE,         pcm_s24be);\n\n    REGISTER_ENCDEC (PCM_S24DAUD,       pcm_s24daud);\n\n    REGISTER_ENCDEC (PCM_S24LE,         pcm_s24le);\n\n    REGISTER_DECODER(PCM_S24LE_PLANAR,  pcm_s24le_planar);\n\n    REGISTER_ENCDEC (PCM_S32BE,         pcm_s32be);\n\n    REGISTER_ENCDEC (PCM_S32LE,         pcm_s32le);\n\n    REGISTER_DECODER(PCM_S32LE_PLANAR,  pcm_s32le_planar);\n\n    REGISTER_ENCDEC (PCM_U8,            pcm_u8);\n\n    REGISTER_ENCDEC (PCM_U16BE,         pcm_u16be);\n\n    REGISTER_ENCDEC (PCM_U16LE,         pcm_u16le);\n\n    REGISTER_ENCDEC (PCM_U24BE,         pcm_u24be);\n\n    REGISTER_ENCDEC (PCM_U24LE,         pcm_u24le);\n\n    REGISTER_ENCDEC (PCM_U32BE,         pcm_u32be);\n\n    REGISTER_ENCDEC (PCM_U32LE,         pcm_u32le);\n\n    REGISTER_DECODER(PCM_ZORK ,         pcm_zork);\n\n\n\n    /* DPCM codecs */\n\n    REGISTER_DECODER(INTERPLAY_DPCM,    interplay_dpcm);\n\n    REGISTER_ENCDEC (ROQ_DPCM,          roq_dpcm);\n\n    REGISTER_DECODER(SOL_DPCM,          sol_dpcm);\n\n    REGISTER_DECODER(XAN_DPCM,          xan_dpcm);\n\n\n\n    /* ADPCM codecs */\n\n    REGISTER_DECODER(ADPCM_4XM,         adpcm_4xm);\n\n    REGISTER_ENCDEC (ADPCM_ADX,         adpcm_adx);\n\n    REGISTER_DECODER(ADPCM_CT,          adpcm_ct);\n\n    REGISTER_DECODER(ADPCM_EA,          adpcm_ea);\n\n    REGISTER_DECODER(ADPCM_EA_MAXIS_XA, adpcm_ea_maxis_xa);\n\n    REGISTER_DECODER(ADPCM_EA_R1,       adpcm_ea_r1);\n\n    REGISTER_DECODER(ADPCM_EA_R2,       adpcm_ea_r2);\n\n    REGISTER_DECODER(ADPCM_EA_R3,       adpcm_ea_r3);\n\n    REGISTER_DECODER(ADPCM_EA_XAS,      adpcm_ea_xas);\n\n    REGISTER_ENCDEC (ADPCM_G722,        adpcm_g722);\n\n    REGISTER_ENCDEC (ADPCM_G726,        adpcm_g726);\n\n    REGISTER_DECODER(ADPCM_IMA_AMV,     adpcm_ima_amv);\n\n    REGISTER_DECODER(ADPCM_IMA_APC,     adpcm_ima_apc);\n\n    REGISTER_DECODER(ADPCM_IMA_DK3,     adpcm_ima_dk3);\n\n    REGISTER_DECODER(ADPCM_IMA_DK4,     adpcm_ima_dk4);\n\n    REGISTER_DECODER(ADPCM_IMA_EA_EACS, adpcm_ima_ea_eacs);\n\n    REGISTER_DECODER(ADPCM_IMA_EA_SEAD, adpcm_ima_ea_sead);\n\n    REGISTER_DECODER(ADPCM_IMA_ISS,     adpcm_ima_iss);\n\n    REGISTER_ENCDEC (ADPCM_IMA_QT,      adpcm_ima_qt);\n\n    REGISTER_DECODER(ADPCM_IMA_SMJPEG,  adpcm_ima_smjpeg);\n\n    REGISTER_ENCDEC (ADPCM_IMA_WAV,     adpcm_ima_wav);\n\n    REGISTER_DECODER(ADPCM_IMA_WS,      adpcm_ima_ws);\n\n    REGISTER_ENCDEC (ADPCM_MS,          adpcm_ms);\n\n    REGISTER_DECODER(ADPCM_SBPRO_2,     adpcm_sbpro_2);\n\n    REGISTER_DECODER(ADPCM_SBPRO_3,     adpcm_sbpro_3);\n\n    REGISTER_DECODER(ADPCM_SBPRO_4,     adpcm_sbpro_4);\n\n    REGISTER_ENCDEC (ADPCM_SWF,         adpcm_swf);\n\n    REGISTER_DECODER(ADPCM_THP,         adpcm_thp);\n\n    REGISTER_DECODER(ADPCM_VIMA,        adpcm_vima);\n\n    REGISTER_DECODER(ADPCM_XA,          adpcm_xa);\n\n    REGISTER_ENCDEC (ADPCM_YAMAHA,      adpcm_yamaha);\n\n\n\n    /* subtitles */\n\n    REGISTER_ENCDEC (ASS,               ass);\n\n    REGISTER_ENCDEC (DVBSUB,            dvbsub);\n\n    REGISTER_ENCDEC (DVDSUB,            dvdsub);\n\n    REGISTER_DECODER(PGSSUB,            pgssub);\n\n    REGISTER_DECODER(SRT,               srt);\n\n    REGISTER_ENCDEC (XSUB,              xsub);\n\n\n\n    /* external libraries */\n\n    REGISTER_DECODER(LIBDCADEC,         libdcadec)\n\n    REGISTER_ENCODER(LIBFAAC,           libfaac);\n\n    REGISTER_ENCDEC (LIBFDK_AAC,        libfdk_aac);\n\n    REGISTER_ENCDEC (LIBGSM,            libgsm);\n\n    REGISTER_ENCDEC (LIBGSM_MS,         libgsm_ms);\n\n    REGISTER_ENCDEC (LIBILBC,           libilbc);\n\n    REGISTER_ENCODER(LIBMP3LAME,        libmp3lame);\n\n    REGISTER_ENCDEC (LIBOPENCORE_AMRNB, libopencore_amrnb);\n\n    REGISTER_DECODER(LIBOPENCORE_AMRWB, libopencore_amrwb);\n\n    REGISTER_ENCDEC (LIBOPENJPEG,       libopenjpeg);\n\n    REGISTER_ENCDEC (LIBOPUS,           libopus);\n\n    REGISTER_ENCDEC (LIBSCHROEDINGER,   libschroedinger);\n\n    REGISTER_ENCDEC (LIBSPEEX,          libspeex);\n\n    REGISTER_ENCODER(LIBTHEORA,         libtheora);\n\n    REGISTER_ENCODER(LIBTWOLAME,        libtwolame);\n\n    REGISTER_ENCODER(LIBVO_AACENC,      libvo_aacenc);\n\n    REGISTER_ENCODER(LIBVO_AMRWBENC,    libvo_amrwbenc);\n\n    REGISTER_ENCODER(LIBVORBIS,         libvorbis);\n\n    REGISTER_ENCDEC (LIBVPX_VP8,        libvpx_vp8);\n\n    REGISTER_ENCDEC (LIBVPX_VP9,        libvpx_vp9);\n\n    REGISTER_ENCODER(LIBWAVPACK,        libwavpack);\n\n    REGISTER_ENCODER(LIBWEBP,           libwebp);\n\n    REGISTER_ENCODER(LIBX262,           libx262);\n\n    REGISTER_ENCODER(LIBX264,           libx264);\n\n    REGISTER_ENCODER(LIBX265,           libx265);\n\n    REGISTER_ENCODER(LIBXAVS,           libxavs);\n\n    REGISTER_ENCODER(LIBXVID,           libxvid);\n\n\n\n    /* external libraries, that shouldn't be used by default if one of the\n\n     * above is available */\n\n    REGISTER_ENCDEC (LIBOPENH264,       libopenh264);\n\n    REGISTER_ENCODER(H264_NVENC,        h264_nvenc);\n\n    REGISTER_ENCODER(H264_OMX,          h264_omx);\n\n    REGISTER_ENCODER(H264_QSV,          h264_qsv);\n\n    REGISTER_ENCODER(H264_VAAPI,        h264_vaapi);\n\n    REGISTER_ENCODER(LIBKVAZAAR,        libkvazaar);\n\n    REGISTER_ENCODER(HEVC_NVENC,        hevc_nvenc);\n\n    REGISTER_ENCODER(HEVC_QSV,          hevc_qsv);\n\n    REGISTER_ENCODER(HEVC_VAAPI,        hevc_vaapi);\n\n    REGISTER_ENCODER(MJPEG_VAAPI,       mjpeg_vaapi);\n\n    REGISTER_ENCODER(MPEG2_QSV,         mpeg2_qsv);\n\n    REGISTER_ENCODER(MPEG2_VAAPI,       mpeg2_vaapi);\n\n    REGISTER_ENCODER(MPEG4_OMX,         mpeg4_omx);\n\n#if FF_API_NVENC_OLD_NAME\n\n    REGISTER_ENCODER(NVENC_H264,        nvenc_h264);\n\n    REGISTER_ENCODER(NVENC_HEVC,        nvenc_hevc);\n\n#endif\n\n    REGISTER_ENCODER(VP8_VAAPI,         vp8_vaapi);\n\n\n\n    /* parsers */\n\n    REGISTER_PARSER(AAC,                aac);\n\n    REGISTER_PARSER(AAC_LATM,           aac_latm);\n\n    REGISTER_PARSER(AC3,                ac3);\n\n    REGISTER_PARSER(ADX,                adx);\n\n    REGISTER_PARSER(BMP,                bmp);\n\n    REGISTER_PARSER(CAVSVIDEO,          cavsvideo);\n\n    REGISTER_PARSER(COOK,               cook);\n\n    REGISTER_PARSER(DCA,                dca);\n\n    REGISTER_PARSER(DIRAC,              dirac);\n\n    REGISTER_PARSER(DNXHD,              dnxhd);\n\n    REGISTER_PARSER(DPX,                dpx);\n\n    REGISTER_PARSER(DVBSUB,             dvbsub);\n\n    REGISTER_PARSER(DVDSUB,             dvdsub);\n\n    REGISTER_PARSER(FLAC,               flac);\n\n    REGISTER_PARSER(GSM,                gsm);\n\n    REGISTER_PARSER(H261,               h261);\n\n    REGISTER_PARSER(H263,               h263);\n\n    REGISTER_PARSER(H264,               h264);\n\n    REGISTER_PARSER(HEVC,               hevc);\n\n    REGISTER_PARSER(MJPEG,              mjpeg);\n\n    REGISTER_PARSER(MLP,                mlp);\n\n    REGISTER_PARSER(MPEG4VIDEO,         mpeg4video);\n\n    REGISTER_PARSER(MPEGAUDIO,          mpegaudio);\n\n    REGISTER_PARSER(MPEGVIDEO,          mpegvideo);\n\n    REGISTER_PARSER(OPUS,               opus);\n\n    REGISTER_PARSER(PNG,                png);\n\n    REGISTER_PARSER(PNM,                pnm);\n\n    REGISTER_PARSER(RV30,               rv30);\n\n    REGISTER_PARSER(RV40,               rv40);\n\n    REGISTER_PARSER(TAK,                tak);\n\n    REGISTER_PARSER(VC1,                vc1);\n\n    REGISTER_PARSER(VORBIS,             vorbis);\n\n    REGISTER_PARSER(VP3,                vp3);\n\n    REGISTER_PARSER(VP8,                vp8);\n\n}\n", "idx": 2091}
{"project": "FFmpeg", "commit_id": "202a6697ba54293235ce2d7bd5724f4f461e417f", "target": 0, "func": "static PayloadContext *h264_new_extradata(void)\n\n{\n\n    PayloadContext *data =\n\n        av_mallocz(sizeof(PayloadContext) +\n\n                   FF_INPUT_BUFFER_PADDING_SIZE);\n\n\n\n    if (data) {\n\n        data->cookie = MAGIC_COOKIE;\n\n    }\n\n\n\n    return data;\n\n}\n", "idx": 2160}
{"project": "qemu", "commit_id": "6ab3fc32ea640026726bc5f9f4db622d0954fb8a", "target": 1, "func": "void vty_putchars(VIOsPAPRDevice *sdev, uint8_t *buf, int len)\n\n{\n\n    VIOsPAPRVTYDevice *dev = VIO_SPAPR_VTY_DEVICE(sdev);\n\n\n\n    /* FIXME: should check the qemu_chr_fe_write() return value */\n\n    qemu_chr_fe_write(dev->chardev, buf, len);\n\n}\n", "idx": 2326}
{"project": "FFmpeg", "commit_id": "0cbff0275b0cff4021e7026ba6060594225fcab5", "target": 1, "func": "int av_find_stream_info(AVFormatContext *ic)\n\n{\n\n    int i, count, ret, read_size, j;\n\n    AVStream *st;\n\n    AVPacket pkt1, *pkt;\n\n    AVPacketList *pktl=NULL, **ppktl;\n\n    int64_t last_dts[MAX_STREAMS];\n\n    int duration_count[MAX_STREAMS]={0};\n\n    double duration_error[MAX_STREAMS][MAX_STD_TIMEBASES]={{0}}; //FIXME malloc()?\n\n    offset_t old_offset = url_ftell(&ic->pb);\n\n\n\n    for(i=0;i<ic->nb_streams;i++) {\n\n        st = ic->streams[i];\n\n        if(st->codec->codec_type == CODEC_TYPE_VIDEO){\n\n/*            if(!st->time_base.num)\n\n                st->time_base= */\n\n            if(!st->codec->time_base.num)\n\n                st->codec->time_base= st->time_base;\n\n        }\n\n        //only for the split stuff\n\n        if (!st->parser) {\n\n            st->parser = av_parser_init(st->codec->codec_id);\n\n            if(st->need_parsing == 2 && st->parser){\n\n                st->parser->flags |= PARSER_FLAG_COMPLETE_FRAMES;\n\n            }\n\n        }\n\n    }\n\n\n\n    for(i=0;i<MAX_STREAMS;i++){\n\n        last_dts[i]= AV_NOPTS_VALUE;\n\n    }\n\n\n\n    count = 0;\n\n    read_size = 0;\n\n    ppktl = &ic->packet_buffer;\n\n    for(;;) {\n\n        /* check if one codec still needs to be handled */\n\n        for(i=0;i<ic->nb_streams;i++) {\n\n            st = ic->streams[i];\n\n            if (!has_codec_parameters(st->codec))\n\n                break;\n\n            /* variable fps and no guess at the real fps */\n\n            if(   st->codec->time_base.den >= 101LL*st->codec->time_base.num\n\n               && duration_count[i]<20 && st->codec->codec_type == CODEC_TYPE_VIDEO)\n\n                break;\n\n            if(st->parser && st->parser->parser->split && !st->codec->extradata)\n\n                break;\n\n        }\n\n        if (i == ic->nb_streams) {\n\n            /* NOTE: if the format has no header, then we need to read\n\n               some packets to get most of the streams, so we cannot\n\n               stop here */\n\n            if (!(ic->ctx_flags & AVFMTCTX_NOHEADER)) {\n\n                /* if we found the info for all the codecs, we can stop */\n\n                ret = count;\n\n                break;\n\n            }\n\n        }\n\n        /* we did not get all the codec info, but we read too much data */\n\n        if (read_size >= MAX_READ_SIZE) {\n\n            ret = count;\n\n            break;\n\n        }\n\n\n\n        /* NOTE: a new stream can be added there if no header in file\n\n           (AVFMTCTX_NOHEADER) */\n\n        ret = av_read_frame_internal(ic, &pkt1);\n\n        if (ret < 0) {\n\n            /* EOF or error */\n\n            ret = -1; /* we could not have all the codec parameters before EOF */\n\n            for(i=0;i<ic->nb_streams;i++) {\n\n                st = ic->streams[i];\n\n                if (!has_codec_parameters(st->codec)){\n\n                    char buf[256];\n\n                    avcodec_string(buf, sizeof(buf), st->codec, 0);\n\n                    av_log(ic, AV_LOG_INFO, \"Could not find codec parameters (%s)\\n\", buf);\n\n                } else {\n\n                    ret = 0;\n\n                }\n\n            }\n\n            break;\n\n        }\n\n\n\n        pktl = av_mallocz(sizeof(AVPacketList));\n\n        if (!pktl) {\n\n            ret = AVERROR_NOMEM;\n\n            break;\n\n        }\n\n\n\n        /* add the packet in the buffered packet list */\n\n        *ppktl = pktl;\n\n        ppktl = &pktl->next;\n\n\n\n        pkt = &pktl->pkt;\n\n        *pkt = pkt1;\n\n\n\n        /* duplicate the packet */\n\n        if (av_dup_packet(pkt) < 0) {\n\n            ret = AVERROR_NOMEM;\n\n            break;\n\n        }\n\n\n\n        read_size += pkt->size;\n\n\n\n        st = ic->streams[pkt->stream_index];\n\n        if(st->codec_info_nb_frames>1) //FIXME move codec_info_nb_frames and codec_info_duration from AVStream into this func\n\n            st->codec_info_duration += pkt->duration;\n\n        if (pkt->duration != 0)\n\n            st->codec_info_nb_frames++;\n\n\n\n        {\n\n            int index= pkt->stream_index;\n\n            int64_t last= last_dts[index];\n\n            int64_t duration= pkt->dts - last;\n\n\n\n            if(pkt->dts != AV_NOPTS_VALUE && last != AV_NOPTS_VALUE && duration>0){\n\n                double dur= duration * av_q2d(st->time_base);\n\n\n\n//                if(st->codec->codec_type == CODEC_TYPE_VIDEO)\n\n//                    av_log(NULL, AV_LOG_ERROR, \"%f\\n\", dur);\n\n                if(duration_count[index] < 2)\n\n                    memset(duration_error, 0, sizeof(duration_error));\n\n                for(i=1; i<MAX_STD_TIMEBASES; i++){\n\n                    int framerate= get_std_framerate(i);\n\n                    int ticks= lrintf(dur*framerate/(1001*12));\n\n                    double error= dur - ticks*1001*12/(double)framerate;\n\n                    duration_error[index][i] += error*error;\n\n                }\n\n                duration_count[index]++;\n\n\n\n                if(st->codec_info_nb_frames == 0 && 0)\n\n                    st->codec_info_duration += duration;\n\n            }\n\n            if(last == AV_NOPTS_VALUE || duration_count[index]<=1)\n\n                last_dts[pkt->stream_index]= pkt->dts;\n\n        }\n\n        if(st->parser && st->parser->parser->split && !st->codec->extradata){\n\n            int i= st->parser->parser->split(st->codec, pkt->data, pkt->size);\n\n            if(i){\n\n                st->codec->extradata_size= i;\n\n                st->codec->extradata= av_malloc(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n                memcpy(st->codec->extradata, pkt->data, st->codec->extradata_size);\n\n                memset(st->codec->extradata + i, 0, FF_INPUT_BUFFER_PADDING_SIZE);\n\n            }\n\n        }\n\n\n\n        /* if still no information, we try to open the codec and to\n\n           decompress the frame. We try to avoid that in most cases as\n\n           it takes longer and uses more memory. For MPEG4, we need to\n\n           decompress for Quicktime. */\n\n        if (!has_codec_parameters(st->codec) /*&&\n\n            (st->codec->codec_id == CODEC_ID_FLV1 ||\n\n             st->codec->codec_id == CODEC_ID_H264 ||\n\n             st->codec->codec_id == CODEC_ID_H263 ||\n\n             st->codec->codec_id == CODEC_ID_H261 ||\n\n             st->codec->codec_id == CODEC_ID_VORBIS ||\n\n             st->codec->codec_id == CODEC_ID_MJPEG ||\n\n             st->codec->codec_id == CODEC_ID_PNG ||\n\n             st->codec->codec_id == CODEC_ID_PAM ||\n\n             st->codec->codec_id == CODEC_ID_PGM ||\n\n             st->codec->codec_id == CODEC_ID_PGMYUV ||\n\n             st->codec->codec_id == CODEC_ID_PBM ||\n\n             st->codec->codec_id == CODEC_ID_PPM ||\n\n             st->codec->codec_id == CODEC_ID_SHORTEN ||\n\n             (st->codec->codec_id == CODEC_ID_MPEG4 && !st->need_parsing))*/)\n\n            try_decode_frame(st, pkt->data, pkt->size);\n\n\n\n        if (av_rescale_q(st->codec_info_duration, st->time_base, AV_TIME_BASE_Q) >= ic->max_analyze_duration) {\n\n            break;\n\n        }\n\n        count++;\n\n    }\n\n\n\n    // close codecs which where opened in try_decode_frame()\n\n    for(i=0;i<ic->nb_streams;i++) {\n\n        st = ic->streams[i];\n\n        if(st->codec->codec)\n\n            avcodec_close(st->codec);\n\n    }\n\n    for(i=0;i<ic->nb_streams;i++) {\n\n        st = ic->streams[i];\n\n        if (st->codec->codec_type == CODEC_TYPE_VIDEO) {\n\n            if(st->codec->codec_id == CODEC_ID_RAWVIDEO && !st->codec->codec_tag && !st->codec->bits_per_sample)\n\n                st->codec->codec_tag= avcodec_pix_fmt_to_codec_tag(st->codec->pix_fmt);\n\n\n\n            if(duration_count[i]\n\n               && (st->codec->time_base.num*101LL <= st->codec->time_base.den || st->codec->codec_id == CODEC_ID_MPEG2VIDEO) /*&&\n\n               //FIXME we should not special case mpeg2, but this needs testing with non mpeg2 ...\n\n               st->time_base.num*duration_sum[i]/duration_count[i]*101LL > st->time_base.den*/){\n\n                double best_error= 2*av_q2d(st->time_base);\n\n                best_error= best_error*best_error*duration_count[i]*1000*12*30;\n\n\n\n                for(j=1; j<MAX_STD_TIMEBASES; j++){\n\n                    double error= duration_error[i][j] * get_std_framerate(j);\n\n//                    if(st->codec->codec_type == CODEC_TYPE_VIDEO)\n\n//                        av_log(NULL, AV_LOG_ERROR, \"%f %f\\n\", get_std_framerate(j) / 12.0/1001, error);\n\n                    if(error < best_error){\n\n                        best_error= error;\n\n                        av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, get_std_framerate(j), 12*1001, INT_MAX);\n\n                    }\n\n                }\n\n            }\n\n\n\n            if (!st->r_frame_rate.num){\n\n                if(    st->codec->time_base.den * (int64_t)st->time_base.num\n\n                    <= st->codec->time_base.num * (int64_t)st->time_base.den){\n\n                    st->r_frame_rate.num = st->codec->time_base.den;\n\n                    st->r_frame_rate.den = st->codec->time_base.num;\n\n                }else{\n\n                    st->r_frame_rate.num = st->time_base.den;\n\n                    st->r_frame_rate.den = st->time_base.num;\n\n                }\n\n            }\n\n        }else if(st->codec->codec_type == CODEC_TYPE_AUDIO) {\n\n            if(!st->codec->bits_per_sample)\n\n                st->codec->bits_per_sample= av_get_bits_per_sample(st->codec->codec_id);\n\n        }\n\n    }\n\n\n\n    av_estimate_timings(ic, old_offset);\n\n#if 0\n\n    /* correct DTS for b frame streams with no timestamps */\n\n    for(i=0;i<ic->nb_streams;i++) {\n\n        st = ic->streams[i];\n\n        if (st->codec->codec_type == CODEC_TYPE_VIDEO) {\n\n            if(b-frames){\n\n                ppktl = &ic->packet_buffer;\n\n                while(ppkt1){\n\n                    if(ppkt1->stream_index != i)\n\n                        continue;\n\n                    if(ppkt1->pkt->dts < 0)\n\n                        break;\n\n                    if(ppkt1->pkt->pts != AV_NOPTS_VALUE)\n\n                        break;\n\n                    ppkt1->pkt->dts -= delta;\n\n                    ppkt1= ppkt1->next;\n\n                }\n\n                if(ppkt1)\n\n                    continue;\n\n                st->cur_dts -= delta;\n\n            }\n\n        }\n\n    }\n\n#endif\n\n    return ret;\n\n}\n", "idx": 2335}
{"project": "FFmpeg", "commit_id": "5ae484e350e4f1b20b31802dac59ca3519627c0a", "target": 0, "func": "static void frame_erasure(EVRCContext *e, float *samples)\n\n{\n\n    float ilspf[FILTER_ORDER], ilpc[FILTER_ORDER], idelay[NB_SUBFRAMES],\n\n          tmp[SUBFRAME_SIZE + 6], f;\n\n    int i, j;\n\n\n\n    for (i = 0; i < FILTER_ORDER; i++) {\n\n        if (e->bitrate != RATE_QUANT)\n\n            e->lspf[i] = e->prev_lspf[i] * 0.875 + 0.125 * (i + 1) * 0.048;\n\n        else\n\n            e->lspf[i] = e->prev_lspf[i];\n\n    }\n\n\n\n    if (e->prev_error_flag)\n\n        e->avg_acb_gain *= 0.75;\n\n    if (e->bitrate == RATE_FULL)\n\n        memcpy(e->pitch_back, e->pitch, ACB_SIZE * sizeof(float));\n\n    if (e->last_valid_bitrate == RATE_QUANT)\n\n        e->bitrate = RATE_QUANT;\n\n    else\n\n        e->bitrate = RATE_FULL;\n\n\n\n    if (e->bitrate == RATE_FULL || e->bitrate == RATE_HALF) {\n\n        e->pitch_delay = e->prev_pitch_delay;\n\n    } else {\n\n        float sum = 0;\n\n\n\n        idelay[0] = idelay[1] = idelay[2] = MIN_DELAY;\n\n\n\n        for (i = 0; i < NB_SUBFRAMES; i++)\n\n            sum += evrc_energy_quant[e->prev_energy_gain][i];\n\n        sum /= (float) NB_SUBFRAMES;\n\n        sum  = pow(10, sum);\n\n        for (i = 0; i < NB_SUBFRAMES; i++)\n\n            e->energy_vector[i] = sum;\n\n    }\n\n\n\n    if (fabs(e->pitch_delay - e->prev_pitch_delay) > 15)\n\n        e->prev_pitch_delay = e->pitch_delay;\n\n\n\n    for (i = 0; i < NB_SUBFRAMES; i++) {\n\n        int subframe_size = subframe_sizes[i];\n\n        int pitch_lag;\n\n\n\n        interpolate_lsp(ilspf, e->lspf, e->prev_lspf, i);\n\n\n\n        if (e->bitrate != RATE_QUANT) {\n\n            if (e->avg_acb_gain < 0.3) {\n\n                idelay[0] = estimation_delay[i];\n\n                idelay[1] = estimation_delay[i + 1];\n\n                idelay[2] = estimation_delay[i + 2];\n\n            } else {\n\n                interpolate_delay(idelay, e->pitch_delay, e->prev_pitch_delay, i);\n\n            }\n\n        }\n\n\n\n        pitch_lag = lrintf((idelay[1] + idelay[0]) / 2.0);\n\n        decode_predictor_coeffs(ilspf, ilpc);\n\n\n\n        if (e->bitrate != RATE_QUANT) {\n\n            acb_excitation(e, e->pitch + ACB_SIZE,\n\n                           e->avg_acb_gain, idelay, subframe_size);\n\n            for (j = 0; j < subframe_size; j++)\n\n                e->pitch[ACB_SIZE + j] *= e->fade_scale;\n\n            e->fade_scale = FFMAX(e->fade_scale - 0.05, 0.0);\n\n        } else {\n\n            for (j = 0; j < subframe_size; j++)\n\n                e->pitch[ACB_SIZE + j] = e->energy_vector[i];\n\n        }\n\n\n\n        memcpy(e->pitch, e->pitch + subframe_size, ACB_SIZE * sizeof(float));\n\n\n\n        if (e->bitrate != RATE_QUANT && e->avg_acb_gain < 0.4) {\n\n            f = 0.1 * e->avg_fcb_gain;\n\n            for (j = 0; j < subframe_size; j++)\n\n                e->pitch[ACB_SIZE + j] += f;\n\n        } else if (e->bitrate == RATE_QUANT) {\n\n            for (j = 0; j < subframe_size; j++)\n\n                e->pitch[ACB_SIZE + j] = e->energy_vector[i];\n\n        }\n\n\n\n        synthesis_filter(e->pitch + ACB_SIZE, ilpc,\n\n                         e->synthesis, subframe_size, tmp);\n\n        postfilter(e, tmp, ilpc, samples, pitch_lag,\n\n                   &postfilter_coeffs[e->bitrate], subframe_size);\n\n\n\n        samples += subframe_size;\n\n    }\n\n}\n", "idx": 2431}
{"project": "qemu", "commit_id": "e5b8b0d4ba29fe1268ba049519a1b0cf8552a21a", "target": 0, "func": "set_rdt(E1000State *s, int index, uint32_t val)\n\n{\n\n    s->check_rxov = 0;\n\n    s->mac_reg[index] = val & 0xffff;\n\n    if (e1000_has_rxbufs(s, 1)) {\n\n        qemu_flush_queued_packets(&s->nic->nc);\n\n    }\n\n}\n", "idx": 2483}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void omap_clkm_init(MemoryRegion *memory, target_phys_addr_t mpu_base,\n\n                target_phys_addr_t dsp_base, struct omap_mpu_state_s *s)\n\n{\n\n    memory_region_init_io(&s->clkm_iomem, &omap_clkm_ops, s,\n\n                          \"omap-clkm\", 0x100);\n\n    memory_region_init_io(&s->clkdsp_iomem, &omap_clkdsp_ops, s,\n\n                          \"omap-clkdsp\", 0x1000);\n\n\n\n    s->clkm.arm_idlect1 = 0x03ff;\n\n    s->clkm.arm_idlect2 = 0x0100;\n\n    s->clkm.dsp_idlect1 = 0x0002;\n\n    omap_clkm_reset(s);\n\n    s->clkm.cold_start = 0x3a;\n\n\n\n    memory_region_add_subregion(memory, mpu_base, &s->clkm_iomem);\n\n    memory_region_add_subregion(memory, dsp_base, &s->clkdsp_iomem);\n\n}\n", "idx": 2508}
{"project": "FFmpeg", "commit_id": "398f015f077c6a2406deffd9e37ff34b9c7bb3bc", "target": 0, "func": "static void do_video_out(AVFormatContext *s,\n\n                         OutputStream *ost,\n\n                         AVFrame *in_picture,\n\n                         int *frame_size)\n\n{\n\n    int ret, format_video_sync;\n\n    AVPacket pkt;\n\n    AVCodecContext *enc = ost->enc_ctx;\n\n\n\n    *frame_size = 0;\n\n\n\n    format_video_sync = video_sync_method;\n\n    if (format_video_sync == VSYNC_AUTO)\n\n        format_video_sync = (s->oformat->flags & AVFMT_NOTIMESTAMPS) ? VSYNC_PASSTHROUGH :\n\n                            (s->oformat->flags & AVFMT_VARIABLE_FPS) ? VSYNC_VFR : VSYNC_CFR;\n\n    if (format_video_sync != VSYNC_PASSTHROUGH &&\n\n        ost->frame_number &&\n\n        in_picture->pts != AV_NOPTS_VALUE &&\n\n        in_picture->pts < ost->sync_opts) {\n\n        nb_frames_drop++;\n\n        av_log(NULL, AV_LOG_WARNING,\n\n               \"*** dropping frame %d from stream %d at ts %\"PRId64\"\\n\",\n\n               ost->frame_number, ost->st->index, in_picture->pts);\n\n        return;\n\n    }\n\n\n\n    if (in_picture->pts == AV_NOPTS_VALUE)\n\n        in_picture->pts = ost->sync_opts;\n\n    ost->sync_opts = in_picture->pts;\n\n\n\n\n\n    if (!ost->frame_number)\n\n        ost->first_pts = in_picture->pts;\n\n\n\n    av_init_packet(&pkt);\n\n    pkt.data = NULL;\n\n    pkt.size = 0;\n\n\n\n    if (ost->frame_number >= ost->max_frames)\n\n        return;\n\n\n\n    if (enc->flags & (AV_CODEC_FLAG_INTERLACED_DCT | AV_CODEC_FLAG_INTERLACED_ME) &&\n\n        ost->top_field_first >= 0)\n\n        in_picture->top_field_first = !!ost->top_field_first;\n\n\n\n    in_picture->quality = enc->global_quality;\n\n    in_picture->pict_type = 0;\n\n    if (ost->forced_kf_index < ost->forced_kf_count &&\n\n        in_picture->pts >= ost->forced_kf_pts[ost->forced_kf_index]) {\n\n        in_picture->pict_type = AV_PICTURE_TYPE_I;\n\n        ost->forced_kf_index++;\n\n    }\n\n\n\n    ost->frames_encoded++;\n\n\n\n    ret = avcodec_send_frame(enc, in_picture);\n\n    if (ret < 0)\n\n        goto error;\n\n\n\n    /*\n\n     * For video, there may be reordering, so we can't throw away frames on\n\n     * encoder flush, we need to limit them here, before they go into encoder.\n\n     */\n\n    ost->frame_number++;\n\n\n\n    while (1) {\n\n        ret = avcodec_receive_packet(enc, &pkt);\n\n        if (ret == AVERROR(EAGAIN))\n\n            break;\n\n        if (ret < 0)\n\n            goto error;\n\n\n\n        av_packet_rescale_ts(&pkt, enc->time_base, ost->st->time_base);\n\n        output_packet(s, &pkt, ost);\n\n        *frame_size = pkt.size;\n\n\n\n        /* if two pass, output log */\n\n        if (ost->logfile && enc->stats_out) {\n\n            fprintf(ost->logfile, \"%s\", enc->stats_out);\n\n        }\n\n\n\n        ost->sync_opts++;\n\n    }\n\n\n\n    return;\n\nerror:\n\n    av_assert0(ret != AVERROR(EAGAIN) && ret != AVERROR_EOF);\n\n    av_log(NULL, AV_LOG_FATAL, \"Video encoding failed\\n\");\n\n    exit_program(1);\n\n}\n", "idx": 2753}
{"project": "FFmpeg", "commit_id": "53c8443ad2376a50c76e5d7c69435bd01b0abc42", "target": 0, "func": "static int decode_frame_mp3on4(AVCodecContext * avctx,\n\n                        void *data, int *data_size,\n\n                        AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    MP3On4DecodeContext *s = avctx->priv_data;\n\n    MPADecodeContext *m;\n\n    int fsize, len = buf_size, out_size = 0;\n\n    uint32_t header;\n\n    OUT_INT *out_samples = data;\n\n    OUT_INT *outptr, *bp;\n\n    int fr, j, n;\n\n\n\n    if(*data_size < MPA_FRAME_SIZE * MPA_MAX_CHANNELS * s->frames * sizeof(OUT_INT))\n\n        return -1;\n\n\n\n    *data_size = 0;\n\n    // Discard too short frames\n\n    if (buf_size < HEADER_SIZE)\n\n        return -1;\n\n\n\n    // If only one decoder interleave is not needed\n\n    outptr = s->frames == 1 ? out_samples : s->decoded_buf;\n\n\n\n    avctx->bit_rate = 0;\n\n\n\n    for (fr = 0; fr < s->frames; fr++) {\n\n        fsize = AV_RB16(buf) >> 4;\n\n        fsize = FFMIN3(fsize, len, MPA_MAX_CODED_FRAME_SIZE);\n\n        m = s->mp3decctx[fr];\n\n        assert (m != NULL);\n\n\n\n        header = (AV_RB32(buf) & 0x000fffff) | s->syncword; // patch header\n\n\n\n        if (ff_mpa_check_header(header) < 0) // Bad header, discard block\n\n            break;\n\n\n\n        avpriv_mpegaudio_decode_header((MPADecodeHeader *)m, header);\n\n        out_size += mp_decode_frame(m, outptr, buf, fsize);\n\n        buf += fsize;\n\n        len -= fsize;\n\n\n\n        if(s->frames > 1) {\n\n            n = m->avctx->frame_size*m->nb_channels;\n\n            /* interleave output data */\n\n            bp = out_samples + s->coff[fr];\n\n            if(m->nb_channels == 1) {\n\n                for(j = 0; j < n; j++) {\n\n                    *bp = s->decoded_buf[j];\n\n                    bp += avctx->channels;\n\n                }\n\n            } else {\n\n                for(j = 0; j < n; j++) {\n\n                    bp[0] = s->decoded_buf[j++];\n\n                    bp[1] = s->decoded_buf[j];\n\n                    bp += avctx->channels;\n\n                }\n\n            }\n\n        }\n\n        avctx->bit_rate += m->bit_rate;\n\n    }\n\n\n\n    /* update codec info */\n\n    avctx->sample_rate = s->mp3decctx[0]->sample_rate;\n\n\n\n    *data_size = out_size;\n\n    return buf_size;\n\n}\n", "idx": 2789}
{"project": "qemu", "commit_id": "026aeffcb4752054830ba203020ed6eb05bcaba8", "target": 0, "func": "static void cirrus_bitblt_rop_nop(CirrusVGAState *s,\n\n                                  uint8_t *dst,const uint8_t *src,\n\n                                  int dstpitch,int srcpitch,\n\n                                  int bltwidth,int bltheight)\n\n{\n\n}\n", "idx": 2797}
{"project": "qemu", "commit_id": "b26177d7ec3f50157a5f37f804ffcace3b2a3945", "target": 0, "func": "int svm_check_intercept_param(uint32_t type, uint64_t param)\n\n{\n\n    switch(type) {\n\n    case SVM_EXIT_READ_CR0 ... SVM_EXIT_READ_CR0 + 8:\n\n        if (INTERCEPTEDw(_cr_read, (1 << (type - SVM_EXIT_READ_CR0)))) {\n\n            vmexit(type, param);\n\n            return 1;\n\n        }\n\n        break;\n\n    case SVM_EXIT_READ_DR0 ... SVM_EXIT_READ_DR0 + 8:\n\n        if (INTERCEPTEDw(_dr_read, (1 << (type - SVM_EXIT_READ_DR0)))) {\n\n            vmexit(type, param);\n\n            return 1;\n\n        }\n\n        break;\n\n    case SVM_EXIT_WRITE_CR0 ... SVM_EXIT_WRITE_CR0 + 8:\n\n        if (INTERCEPTEDw(_cr_write, (1 << (type - SVM_EXIT_WRITE_CR0)))) {\n\n            vmexit(type, param);\n\n            return 1;\n\n        }\n\n        break;\n\n    case SVM_EXIT_WRITE_DR0 ... SVM_EXIT_WRITE_DR0 + 8:\n\n        if (INTERCEPTEDw(_dr_write, (1 << (type - SVM_EXIT_WRITE_DR0)))) {\n\n            vmexit(type, param);\n\n            return 1;\n\n        }\n\n        break;\n\n    case SVM_EXIT_EXCP_BASE ... SVM_EXIT_EXCP_BASE + 16:\n\n        if (INTERCEPTEDl(_exceptions, (1 << (type - SVM_EXIT_EXCP_BASE)))) {\n\n            vmexit(type, param);\n\n            return 1;\n\n        }\n\n        break;\n\n    case SVM_EXIT_IOIO:\n\n        if (INTERCEPTED(1ULL << INTERCEPT_IOIO_PROT)) {\n\n            /* FIXME: this should be read in at vmrun (faster this way?) */\n\n            uint64_t addr = ldq_phys(env->vm_vmcb + offsetof(struct vmcb, control.iopm_base_pa));\n\n            uint16_t port = (uint16_t) (param >> 16);\n\n\n\n            if(ldub_phys(addr + port / 8) & (1 << (port % 8)))\n\n                vmexit(type, param);\n\n        }\n\n        break;\n\n\n\n    case SVM_EXIT_MSR:\n\n        if (INTERCEPTED(1ULL << INTERCEPT_MSR_PROT)) {\n\n            /* FIXME: this should be read in at vmrun (faster this way?) */\n\n            uint64_t addr = ldq_phys(env->vm_vmcb + offsetof(struct vmcb, control.msrpm_base_pa));\n\n            switch((uint32_t)ECX) {\n\n            case 0 ... 0x1fff:\n\n                T0 = (ECX * 2) % 8;\n\n                T1 = ECX / 8;\n\n                break;\n\n            case 0xc0000000 ... 0xc0001fff:\n\n                T0 = (8192 + ECX - 0xc0000000) * 2;\n\n                T1 = (T0 / 8);\n\n                T0 %= 8;\n\n                break;\n\n            case 0xc0010000 ... 0xc0011fff:\n\n                T0 = (16384 + ECX - 0xc0010000) * 2;\n\n                T1 = (T0 / 8);\n\n                T0 %= 8;\n\n                break;\n\n            default:\n\n                vmexit(type, param);\n\n                return 1;\n\n            }\n\n            if (ldub_phys(addr + T1) & ((1 << param) << T0))\n\n                vmexit(type, param);\n\n            return 1;\n\n        }\n\n        break;\n\n    default:\n\n        if (INTERCEPTED((1ULL << ((type - SVM_EXIT_INTR) + INTERCEPT_INTR)))) {\n\n            vmexit(type, param);\n\n            return 1;\n\n        }\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 2811}
{"project": "qemu", "commit_id": "b4fe97c8230c34ebd407a9f23894b9c614807540", "target": 0, "func": "static void guest_file_init(void)\n\n{\n\n    QTAILQ_INIT(&guest_file_state.filehandles);\n\n}\n", "idx": 2892}
{"project": "qemu", "commit_id": "ca6b6e1e68ac44b2e8895da10dd1c80dc03d08b7", "target": 0, "func": "static QDict *qmp_check_input_obj(QObject *input_obj, Error **errp)\n\n{\n\n    const QDictEntry *ent;\n\n    int has_exec_key = 0;\n\n    QDict *input_dict;\n\n\n\n    if (qobject_type(input_obj) != QTYPE_QDICT) {\n\n        error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT, \"object\");\n\n        return NULL;\n\n    }\n\n\n\n    input_dict = qobject_to_qdict(input_obj);\n\n\n\n    for (ent = qdict_first(input_dict); ent; ent = qdict_next(input_dict, ent)){\n\n        const char *arg_name = qdict_entry_key(ent);\n\n        const QObject *arg_obj = qdict_entry_value(ent);\n\n\n\n        if (!strcmp(arg_name, \"execute\")) {\n\n            if (qobject_type(arg_obj) != QTYPE_QSTRING) {\n\n                error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT_MEMBER,\n\n                           \"execute\", \"string\");\n\n                return NULL;\n\n            }\n\n            has_exec_key = 1;\n\n        } else if (!strcmp(arg_name, \"arguments\")) {\n\n            if (qobject_type(arg_obj) != QTYPE_QDICT) {\n\n                error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT_MEMBER,\n\n                           \"arguments\", \"object\");\n\n                return NULL;\n\n            }\n\n        } else if (!strcmp(arg_name, \"id\")) {\n\n            /* Any string is acceptable as \"id\", so nothing to check */\n\n        } else {\n\n            error_setg(errp, QERR_QMP_EXTRA_MEMBER, arg_name);\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    if (!has_exec_key) {\n\n        error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT, \"execute\");\n\n        return NULL;\n\n    }\n\n\n\n    return input_dict;\n\n}\n", "idx": 2982}
{"project": "qemu", "commit_id": "42bb9c9178ae7ac4c439172b1ae99cc29188a5c6", "target": 0, "func": "xilinx_axienet_data_stream_push(StreamSlave *obj, uint8_t *buf, size_t size,\n\n                                uint32_t *hdr)\n\n{\n\n    XilinxAXIEnetStreamSlave *ds = XILINX_AXI_ENET_DATA_STREAM(obj);\n\n    XilinxAXIEnet *s = ds->enet;\n\n\n\n    /* TX enable ?  */\n\n    if (!(s->tc & TC_TX)) {\n\n        return size;\n\n    }\n\n\n\n    /* Jumbo or vlan sizes ?  */\n\n    if (!(s->tc & TC_JUM)) {\n\n        if (size > 1518 && size <= 1522 && !(s->tc & TC_VLAN)) {\n\n            return size;\n\n        }\n\n    }\n\n\n\n    if (hdr[0] & 1) {\n\n        unsigned int start_off = hdr[1] >> 16;\n\n        unsigned int write_off = hdr[1] & 0xffff;\n\n        uint32_t tmp_csum;\n\n        uint16_t csum;\n\n\n\n        tmp_csum = net_checksum_add(size - start_off,\n\n                                    (uint8_t *)buf + start_off);\n\n        /* Accumulate the seed.  */\n\n        tmp_csum += hdr[2] & 0xffff;\n\n\n\n        /* Fold the 32bit partial checksum.  */\n\n        csum = net_checksum_finish(tmp_csum);\n\n\n\n        /* Writeback.  */\n\n        buf[write_off] = csum >> 8;\n\n        buf[write_off + 1] = csum & 0xff;\n\n    }\n\n\n\n    qemu_send_packet(qemu_get_queue(s->nic), buf, size);\n\n\n\n    s->stats.tx_bytes += size;\n\n    s->regs[R_IS] |= IS_TX_COMPLETE;\n\n    enet_update_irq(s);\n\n\n\n    return size;\n\n}\n", "idx": 3039}
{"project": "qemu", "commit_id": "1ac157da77c863b62b1d2f467626a440d57cf17d", "target": 0, "func": "void cpu_x86_set_a20(CPUX86State *env, int a20_state)\n\n{\n\n    a20_state = (a20_state != 0);\n\n    if (a20_state != a20_enabled) {\n\n#if defined(DEBUG_MMU)\n\n        printf(\"A20 update: a20=%d\\n\", a20_state);\n\n#endif\n\n        /* if the cpu is currently executing code, we must unlink it and\n\n           all the potentially executing TB */\n\n        cpu_interrupt(env, 0);\n\n\n\n        /* when a20 is changed, all the MMU mappings are invalid, so\n\n           we must flush everything */\n\n        tlb_flush(env);\n\n        a20_enabled = a20_state;\n\n        if (a20_enabled)\n\n            a20_mask = 0xffffffff;\n\n        else\n\n            a20_mask = 0xffefffff;\n\n    }\n\n}\n", "idx": 3047}
{"project": "qemu", "commit_id": "92f2b4e71e988ad2751c71717e9fe3387753442a", "target": 0, "func": "uint64_t HELPER(cvd)(int32_t bin)\n\n{\n\n    /* positive 0 */\n\n    uint64_t dec = 0x0c;\n\n    int shift = 4;\n\n\n\n    if (bin < 0) {\n\n        bin = -bin;\n\n        dec = 0x0d;\n\n    }\n\n\n\n    for (shift = 4; (shift < 64) && bin; shift += 4) {\n\n        int current_number = bin % 10;\n\n\n\n        dec |= (current_number) << shift;\n\n        bin /= 10;\n\n    }\n\n\n\n    return dec;\n\n}\n", "idx": 3059}
{"project": "qemu", "commit_id": "59800ec8e52bcfa271fa61fb0aae19205ef1b7f1", "target": 0, "func": "static inline uint64_t do_fri(CPUPPCState *env, uint64_t arg,\n\n                              int rounding_mode)\n\n{\n\n    CPU_DoubleU farg;\n\n\n\n    farg.ll = arg;\n\n\n\n    if (unlikely(float64_is_signaling_nan(farg.d))) {\n\n        /* sNaN round */\n\n        farg.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN |\n\n                                        POWERPC_EXCP_FP_VXCVI);\n\n    } else if (unlikely(float64_is_quiet_nan(farg.d) ||\n\n                        float64_is_infinity(farg.d))) {\n\n        /* qNan / infinity round */\n\n        farg.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXCVI);\n\n    } else {\n\n        set_float_rounding_mode(rounding_mode, &env->fp_status);\n\n        farg.ll = float64_round_to_int(farg.d, &env->fp_status);\n\n        /* Restore rounding mode from FPSCR */\n\n        fpscr_set_rounding_mode(env);\n\n    }\n\n    return farg.ll;\n\n}\n", "idx": 3339}
{"project": "qemu", "commit_id": "749763864208b14f100f1f8319aeb931134430fa", "target": 0, "func": "static void tcx_realizefn(DeviceState *dev, Error **errp)\n\n{\n\n    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);\n\n    TCXState *s = TCX(dev);\n\n    ram_addr_t vram_offset = 0;\n\n    int size, ret;\n\n    uint8_t *vram_base;\n\n    char *fcode_filename;\n\n\n\n    memory_region_init_ram(&s->vram_mem, OBJECT(s), \"tcx.vram\",\n\n                           s->vram_size * (1 + 4 + 4), &error_fatal);\n\n    vmstate_register_ram_global(&s->vram_mem);\n\n    memory_region_set_log(&s->vram_mem, true, DIRTY_MEMORY_VGA);\n\n    vram_base = memory_region_get_ram_ptr(&s->vram_mem);\n\n\n\n    /* 10/ROM : FCode ROM */\n\n    vmstate_register_ram_global(&s->rom);\n\n    fcode_filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, TCX_ROM_FILE);\n\n    if (fcode_filename) {\n\n        ret = load_image_targphys(fcode_filename, s->prom_addr,\n\n                                  FCODE_MAX_ROM_SIZE);\n\n        g_free(fcode_filename);\n\n        if (ret < 0 || ret > FCODE_MAX_ROM_SIZE) {\n\n            error_report(\"tcx: could not load prom '%s'\", TCX_ROM_FILE);\n\n        }\n\n    }\n\n\n\n    /* 0/DFB8 : 8-bit plane */\n\n    s->vram = vram_base;\n\n    size = s->vram_size;\n\n    memory_region_init_alias(&s->vram_8bit, OBJECT(s), \"tcx.vram.8bit\",\n\n                             &s->vram_mem, vram_offset, size);\n\n    sysbus_init_mmio(sbd, &s->vram_8bit);\n\n    vram_offset += size;\n\n    vram_base += size;\n\n\n\n    /* 1/DFB24 : 24bit plane */\n\n    size = s->vram_size * 4;\n\n    s->vram24 = (uint32_t *)vram_base;\n\n    s->vram24_offset = vram_offset;\n\n    memory_region_init_alias(&s->vram_24bit, OBJECT(s), \"tcx.vram.24bit\",\n\n                             &s->vram_mem, vram_offset, size);\n\n    sysbus_init_mmio(sbd, &s->vram_24bit);\n\n    vram_offset += size;\n\n    vram_base += size;\n\n\n\n    /* 4/RDFB32 : Raw Framebuffer */\n\n    size = s->vram_size * 4;\n\n    s->cplane = (uint32_t *)vram_base;\n\n    s->cplane_offset = vram_offset;\n\n    memory_region_init_alias(&s->vram_cplane, OBJECT(s), \"tcx.vram.cplane\",\n\n                             &s->vram_mem, vram_offset, size);\n\n    sysbus_init_mmio(sbd, &s->vram_cplane);\n\n\n\n    /* 9/THC24bits : NetBSD writes here even with 8-bit display: dummy */\n\n    if (s->depth == 8) {\n\n        memory_region_init_io(&s->thc24, OBJECT(s), &tcx_dummy_ops, s,\n\n                              \"tcx.thc24\", TCX_THC_NREGS);\n\n        sysbus_init_mmio(sbd, &s->thc24);\n\n    }\n\n\n\n    sysbus_init_irq(sbd, &s->irq);\n\n\n\n    if (s->depth == 8) {\n\n        s->con = graphic_console_init(DEVICE(dev), 0, &tcx_ops, s);\n\n    } else {\n\n        s->con = graphic_console_init(DEVICE(dev), 0, &tcx24_ops, s);\n\n    }\n\n    s->thcmisc = 0;\n\n\n\n    qemu_console_resize(s->con, s->width, s->height);\n\n}\n", "idx": 3356}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "LinuxAioState *aio_get_linux_aio(AioContext *ctx)\n\n{\n\n    if (!ctx->linux_aio) {\n\n        ctx->linux_aio = laio_init();\n\n        laio_attach_aio_context(ctx->linux_aio, ctx);\n\n    }\n\n    return ctx->linux_aio;\n\n}\n", "idx": 3365}
{"project": "FFmpeg", "commit_id": "aaebdce3d90725ff93a31678690a306da6e12bbb", "target": 0, "func": "static int gif_read_header1(GifState *s)\n\n{\n\n    uint8_t sig[6];\n\n    int v, n;\n\n    int background_color_index;\n\n\n\n    if (bytestream2_get_bytes_left(&s->gb) < 13)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    /* read gif signature */\n\n    bytestream2_get_bufferu(&s->gb, sig, 6);\n\n    if (memcmp(sig, gif87a_sig, 6) != 0 &&\n\n        memcmp(sig, gif89a_sig, 6) != 0)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    /* read screen header */\n\n    s->transparent_color_index = -1;\n\n    s->screen_width = bytestream2_get_le16u(&s->gb);\n\n    s->screen_height = bytestream2_get_le16u(&s->gb);\n\n    if(   (unsigned)s->screen_width  > 32767\n\n       || (unsigned)s->screen_height > 32767){\n\n        av_log(s->avctx, AV_LOG_ERROR, \"picture size too large\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    av_fast_malloc(&s->idx_line, &s->idx_line_size, s->screen_width);\n\n    if (!s->idx_line)\n\n        return AVERROR(ENOMEM);\n\n\n\n    v = bytestream2_get_byteu(&s->gb);\n\n    s->color_resolution = ((v & 0x70) >> 4) + 1;\n\n    s->has_global_palette = (v & 0x80);\n\n    s->bits_per_pixel = (v & 0x07) + 1;\n\n    background_color_index = bytestream2_get_byteu(&s->gb);\n\n    n = bytestream2_get_byteu(&s->gb);\n\n    if (n) {\n\n        s->avctx->sample_aspect_ratio.num = n + 15;\n\n        s->avctx->sample_aspect_ratio.den = 64;\n\n    }\n\n\n\n    av_dlog(s->avctx, \"screen_w=%d screen_h=%d bpp=%d global_palette=%d\\n\",\n\n           s->screen_width, s->screen_height, s->bits_per_pixel,\n\n           s->has_global_palette);\n\n\n\n    if (s->has_global_palette) {\n\n        s->background_color_index = background_color_index;\n\n        n = 1 << s->bits_per_pixel;\n\n        if (bytestream2_get_bytes_left(&s->gb) < n * 3)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        gif_read_palette(s, s->global_palette, n);\n\n        s->bg_color = s->global_palette[s->background_color_index];\n\n    } else\n\n        s->background_color_index = -1;\n\n\n\n    return 0;\n\n}\n", "idx": 3383}
{"project": "qemu", "commit_id": "e4f4fb1eca795e36f363b4647724221e774523c1", "target": 1, "func": "static void vtd_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    X86IOMMUClass *x86_class = X86_IOMMU_CLASS(klass);\n\n\n\n    dc->reset = vtd_reset;\n\n    dc->vmsd = &vtd_vmstate;\n\n    dc->props = vtd_properties;\n\n    dc->hotpluggable = false;\n\n    x86_class->realize = vtd_realize;\n\n    x86_class->int_remap = vtd_int_remap;\n\n\n\n\n\n\n}", "idx": 3477}
{"project": "qemu", "commit_id": "4abf12f4ea866779b493ecf4606bd0b6d35f8348", "target": 1, "func": "static uint32_t rtl8139_io_readb(void *opaque, uint8_t addr)\n\n{\n\n    RTL8139State *s = opaque;\n\n    int ret;\n\n\n\n    addr &= 0xff;\n\n\n\n    switch (addr)\n\n    {\n\n        case MAC0 ... MAC0+5:\n\n            ret = s->phys[addr - MAC0];\n\n            break;\n\n        case MAC0+6 ... MAC0+7:\n\n            ret = 0;\n\n            break;\n\n        case MAR0 ... MAR0+7:\n\n            ret = s->mult[addr - MAR0];\n\n            break;\n\n        case ChipCmd:\n\n            ret = rtl8139_ChipCmd_read(s);\n\n            break;\n\n        case Cfg9346:\n\n            ret = rtl8139_Cfg9346_read(s);\n\n            break;\n\n        case Config0:\n\n            ret = rtl8139_Config0_read(s);\n\n            break;\n\n        case Config1:\n\n            ret = rtl8139_Config1_read(s);\n\n            break;\n\n        case Config3:\n\n            ret = rtl8139_Config3_read(s);\n\n            break;\n\n        case Config4:\n\n            ret = rtl8139_Config4_read(s);\n\n            break;\n\n        case Config5:\n\n            ret = rtl8139_Config5_read(s);\n\n            break;\n\n\n\n        case MediaStatus:\n\n            ret = 0xd0;\n\n            DPRINTF(\"MediaStatus read 0x%x\\n\", ret);\n\n            break;\n\n\n\n        case HltClk:\n\n            ret = s->clock_enabled;\n\n            DPRINTF(\"HltClk read 0x%x\\n\", ret);\n\n            break;\n\n\n\n        case PCIRevisionID:\n\n            ret = RTL8139_PCI_REVID;\n\n            DPRINTF(\"PCI Revision ID read 0x%x\\n\", ret);\n\n            break;\n\n\n\n        case TxThresh:\n\n            ret = s->TxThresh;\n\n            DPRINTF(\"C+ TxThresh read(b) val=0x%02x\\n\", ret);\n\n            break;\n\n\n\n        case 0x43: /* Part of TxConfig register. Windows driver tries to read it */\n\n            ret = s->TxConfig >> 24;\n\n            DPRINTF(\"RTL8139C TxConfig at 0x43 read(b) val=0x%02x\\n\", ret);\n\n            break;\n\n\n\n        default:\n\n            DPRINTF(\"not implemented read(b) addr=0x%x\\n\", addr);\n\n            ret = 0;\n\n            break;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 3600}
{"project": "qemu", "commit_id": "eb700029c7836798046191d62d595363d92c84d4", "target": 0, "func": "void net_tx_pkt_update_ip_checksums(struct NetTxPkt *pkt)\n\n{\n\n    uint16_t csum;\n\n    uint32_t ph_raw_csum;\n\n    assert(pkt);\n\n    uint8_t gso_type = pkt->virt_hdr.gso_type & ~VIRTIO_NET_HDR_GSO_ECN;\n\n    struct ip_header *ip_hdr;\n\n\n\n    if (VIRTIO_NET_HDR_GSO_TCPV4 != gso_type &&\n\n        VIRTIO_NET_HDR_GSO_UDP != gso_type) {\n\n        return;\n\n    }\n\n\n\n    ip_hdr = pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base;\n\n\n\n    if (pkt->payload_len + pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len >\n\n        ETH_MAX_IP_DGRAM_LEN) {\n\n        return;\n\n    }\n\n\n\n    ip_hdr->ip_len = cpu_to_be16(pkt->payload_len +\n\n        pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len);\n\n\n\n    /* Calculate IP header checksum                    */\n\n    ip_hdr->ip_sum = 0;\n\n    csum = net_raw_checksum((uint8_t *)ip_hdr,\n\n        pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len);\n\n    ip_hdr->ip_sum = cpu_to_be16(csum);\n\n\n\n    /* Calculate IP pseudo header checksum             */\n\n    ph_raw_csum = eth_calc_pseudo_hdr_csum(ip_hdr, pkt->payload_len);\n\n    csum = cpu_to_be16(~net_checksum_finish(ph_raw_csum));\n\n    iov_from_buf(&pkt->vec[NET_TX_PKT_PL_START_FRAG], pkt->payload_frags,\n\n                 pkt->virt_hdr.csum_offset, &csum, sizeof(csum));\n\n}\n", "idx": 3662}
{"project": "qemu", "commit_id": "32bafa8fdd098d52fbf1102d5a5e48d29398c0aa", "target": 0, "func": "void replay_save_input_event(InputEvent *evt)\n\n{\n\n    InputKeyEvent *key;\n\n    InputBtnEvent *btn;\n\n    InputMoveEvent *move;\n\n    replay_put_dword(evt->type);\n\n\n\n    switch (evt->type) {\n\n    case INPUT_EVENT_KIND_KEY:\n\n        key = evt->u.key;\n\n        replay_put_dword(key->key->type);\n\n\n\n        switch (key->key->type) {\n\n        case KEY_VALUE_KIND_NUMBER:\n\n            replay_put_qword(key->key->u.number);\n\n            replay_put_byte(key->down);\n\n            break;\n\n        case KEY_VALUE_KIND_QCODE:\n\n            replay_put_dword(key->key->u.qcode);\n\n            replay_put_byte(key->down);\n\n            break;\n\n        case KEY_VALUE_KIND__MAX:\n\n            /* keep gcc happy */\n\n            break;\n\n        }\n\n        break;\n\n    case INPUT_EVENT_KIND_BTN:\n\n        btn = evt->u.btn;\n\n        replay_put_dword(btn->button);\n\n        replay_put_byte(btn->down);\n\n        break;\n\n    case INPUT_EVENT_KIND_REL:\n\n        move = evt->u.rel;\n\n        replay_put_dword(move->axis);\n\n        replay_put_qword(move->value);\n\n        break;\n\n    case INPUT_EVENT_KIND_ABS:\n\n        move = evt->u.abs;\n\n        replay_put_dword(move->axis);\n\n        replay_put_qword(move->value);\n\n        break;\n\n    case INPUT_EVENT_KIND__MAX:\n\n        /* keep gcc happy */\n\n        break;\n\n    }\n\n}\n", "idx": 3761}
{"project": "FFmpeg", "commit_id": "a37fd7f9578d2dfbe20a109aae91e5f0a4b58874", "target": 1, "func": "void rgb24toyv12_c(const uint8_t *src, uint8_t *ydst, uint8_t *udst,\n\n                   uint8_t *vdst, int width, int height, int lumStride,\n\n                   int chromStride, int srcStride)\n\n{\n\n    int y;\n\n    const int chromWidth = width >> 1;\n\n\n\n    for (y = 0; y < height; y += 2) {\n\n        int i;\n\n        for (i = 0; i < chromWidth; i++) {\n\n            unsigned int b = src[6 * i + 0];\n\n            unsigned int g = src[6 * i + 1];\n\n            unsigned int r = src[6 * i + 2];\n\n\n\n            unsigned int Y = ((RY * r + GY * g + BY * b) >> RGB2YUV_SHIFT) +  16;\n\n            unsigned int V = ((RV * r + GV * g + BV * b) >> RGB2YUV_SHIFT) + 128;\n\n            unsigned int U = ((RU * r + GU * g + BU * b) >> RGB2YUV_SHIFT) + 128;\n\n\n\n            udst[i]     = U;\n\n            vdst[i]     = V;\n\n            ydst[2 * i] = Y;\n\n\n\n            b = src[6 * i + 3];\n\n            g = src[6 * i + 4];\n\n            r = src[6 * i + 5];\n\n\n\n            Y = ((RY * r + GY * g + BY * b) >> RGB2YUV_SHIFT) + 16;\n\n            ydst[2 * i + 1] = Y;\n\n        }\n\n        ydst += lumStride;\n\n        src  += srcStride;\n\n\n\n        if (y+1 == height)\n\n            break;\n\n\n\n        for (i = 0; i < chromWidth; i++) {\n\n            unsigned int b = src[6 * i + 0];\n\n            unsigned int g = src[6 * i + 1];\n\n            unsigned int r = src[6 * i + 2];\n\n\n\n            unsigned int Y = ((RY * r + GY * g + BY * b) >> RGB2YUV_SHIFT) + 16;\n\n\n\n            ydst[2 * i] = Y;\n\n\n\n            b = src[6 * i + 3];\n\n            g = src[6 * i + 4];\n\n            r = src[6 * i + 5];\n\n\n\n            Y = ((RY * r + GY * g + BY * b) >> RGB2YUV_SHIFT) + 16;\n\n            ydst[2 * i + 1] = Y;\n\n        }\n\n        udst += chromStride;\n\n        vdst += chromStride;\n\n        ydst += lumStride;\n\n        src  += srcStride;\n\n    }\n\n}\n", "idx": 3873}
{"project": "qemu", "commit_id": "bea60dd7679364493a0d7f5b54316c767cf894ef", "target": 1, "func": "static void framebuffer_update_request(VncState *vs, int incremental,\n\n                                       int x_position, int y_position,\n\n                                       int w, int h)\n\n{\n\n    int i;\n\n    const size_t width = surface_width(vs->vd->ds) / VNC_DIRTY_PIXELS_PER_BIT;\n\n    const size_t height = surface_height(vs->vd->ds);\n\n\n\n    if (y_position > height) {\n\n        y_position = height;\n\n    }\n\n    if (y_position + h >= height) {\n\n        h = height - y_position;\n\n    }\n\n\n\n    vs->need_update = 1;\n\n    if (!incremental) {\n\n        vs->force_update = 1;\n\n        for (i = 0; i < h; i++) {\n\n            bitmap_set(vs->dirty[y_position + i], 0, width);\n\n            bitmap_clear(vs->dirty[y_position + i], width,\n\n                         VNC_DIRTY_BITS - width);\n\n        }\n\n    }\n\n}\n", "idx": 3907}
{"project": "qemu", "commit_id": "54c16572a03e3c9c5694653361f9bfa3959fcb59", "target": 1, "func": "static int qcow_snapshot_create(BlockDriverState *bs,\n\n                                QEMUSnapshotInfo *sn_info)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    QCowSnapshot *snapshots1, sn1, *sn = &sn1;\n\n    int i, ret;\n\n    uint64_t *l1_table = NULL;\n\n\n\n    memset(sn, 0, sizeof(*sn));\n\n\n\n    if (sn_info->id_str[0] == '\\0') {\n\n        /* compute a new id */\n\n        find_new_snapshot_id(bs, sn_info->id_str, sizeof(sn_info->id_str));\n\n    }\n\n\n\n    /* check that the ID is unique */\n\n    if (find_snapshot_by_id(bs, sn_info->id_str) >= 0)\n\n        return -ENOENT;\n\n\n\n    sn->id_str = qemu_strdup(sn_info->id_str);\n\n    if (!sn->id_str)\n\n        goto fail;\n\n    sn->name = qemu_strdup(sn_info->name);\n\n    if (!sn->name)\n\n        goto fail;\n\n    sn->vm_state_size = sn_info->vm_state_size;\n\n    sn->date_sec = sn_info->date_sec;\n\n    sn->date_nsec = sn_info->date_nsec;\n\n    sn->vm_clock_nsec = sn_info->vm_clock_nsec;\n\n\n\n    ret = update_snapshot_refcount(bs, s->l1_table_offset, s->l1_size, 1);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    /* create the L1 table of the snapshot */\n\n    sn->l1_table_offset = alloc_clusters(bs, s->l1_size * sizeof(uint64_t));\n\n    sn->l1_size = s->l1_size;\n\n\n\n    l1_table = qemu_malloc(s->l1_size * sizeof(uint64_t));\n\n    if (!l1_table)\n\n        goto fail;\n\n    for(i = 0; i < s->l1_size; i++) {\n\n        l1_table[i] = cpu_to_be64(s->l1_table[i]);\n\n    }\n\n    if (bdrv_pwrite(s->hd, sn->l1_table_offset,\n\n                    l1_table, s->l1_size * sizeof(uint64_t)) !=\n\n        (s->l1_size * sizeof(uint64_t)))\n\n        goto fail;\n\n    qemu_free(l1_table);\n\n    l1_table = NULL;\n\n\n\n    snapshots1 = qemu_malloc((s->nb_snapshots + 1) * sizeof(QCowSnapshot));\n\n    if (!snapshots1)\n\n        goto fail;\n\n    memcpy(snapshots1, s->snapshots, s->nb_snapshots * sizeof(QCowSnapshot));\n\n\n    s->snapshots = snapshots1;\n\n    s->snapshots[s->nb_snapshots++] = *sn;\n\n\n\n    if (qcow_write_snapshots(bs) < 0)\n\n        goto fail;\n\n#ifdef DEBUG_ALLOC\n\n    check_refcounts(bs);\n\n#endif\n\n    return 0;\n\n fail:\n\n    qemu_free(sn->name);\n\n    qemu_free(l1_table);\n\n    return -1;\n\n}", "idx": 4072}
{"project": "qemu", "commit_id": "a980a065fb5e86d6dec337e6cb6ff432f1a143c9", "target": 0, "func": "static int usb_net_handle_dataout(USBNetState *s, USBPacket *p)\n\n{\n\n    int ret = p->len;\n\n    int sz = sizeof(s->out_buf) - s->out_ptr;\n\n    struct rndis_packet_msg_type *msg =\n\n            (struct rndis_packet_msg_type *) s->out_buf;\n\n    uint32_t len;\n\n\n\n#ifdef TRAFFIC_DEBUG\n\n    fprintf(stderr, \"usbnet: data out len %u\\n\", p->len);\n\n    {\n\n        int i;\n\n        fprintf(stderr, \":\");\n\n        for (i = 0; i < p->len; i++) {\n\n            if (!(i & 15))\n\n                fprintf(stderr, \"\\n%04x:\", i);\n\n            fprintf(stderr, \" %02x\", p->data[i]);\n\n        }\n\n        fprintf(stderr, \"\\n\\n\");\n\n    }\n\n#endif\n\n\n\n    if (sz > ret)\n\n        sz = ret;\n\n    memcpy(&s->out_buf[s->out_ptr], p->data, sz);\n\n    s->out_ptr += sz;\n\n\n\n    if (!s->rndis) {\n\n        if (ret < 64) {\n\n            qemu_send_packet(&s->nic->nc, s->out_buf, s->out_ptr);\n\n            s->out_ptr = 0;\n\n        }\n\n        return ret;\n\n    }\n\n    len = le32_to_cpu(msg->MessageLength);\n\n    if (s->out_ptr < 8 || s->out_ptr < len)\n\n        return ret;\n\n    if (le32_to_cpu(msg->MessageType) == RNDIS_PACKET_MSG) {\n\n        uint32_t offs = 8 + le32_to_cpu(msg->DataOffset);\n\n        uint32_t size = le32_to_cpu(msg->DataLength);\n\n        if (offs + size <= len)\n\n            qemu_send_packet(&s->nic->nc, s->out_buf + offs, size);\n\n    }\n\n    s->out_ptr -= len;\n\n    memmove(s->out_buf, &s->out_buf[len], s->out_ptr);\n\n\n\n    return ret;\n\n}\n", "idx": 4112}
{"project": "FFmpeg", "commit_id": "431f8af8242c41ef922f9daf791b0be26dc0bba4", "target": 0, "func": "static int normalize_bits(int num, int width)\n\n{\n\n    int i = 0;\n\n    int bits = (width) ? 31 : 15;\n\n    int limit = 1 << (bits - 1);\n\n\n\n    if (num) {\n\n        if (num == -1)\n\n            return bits;\n\n        if (num < 0)\n\n            num = ~num;\n\n        for (i = 0; num < limit; i++)\n\n            num <<= 1;\n\n    }\n\n    return i;\n\n}\n", "idx": 4239}
{"project": "qemu", "commit_id": "36ab3c3400ac941e4d9afc044be08143ff9eea62", "target": 1, "func": "static int handle_cmd(AHCIState *s, int port, int slot)\n\n{\n\n    IDEState *ide_state;\n\n    uint32_t opts;\n\n    uint64_t tbl_addr;\n\n    AHCICmdHdr *cmd;\n\n    uint8_t *cmd_fis;\n\n    dma_addr_t cmd_len;\n\n\n\n    if (s->dev[port].port.ifs[0].status & (BUSY_STAT|DRQ_STAT)) {\n\n        /* Engine currently busy, try again later */\n\n        DPRINTF(port, \"engine busy\\n\");\n\n        return -1;\n\n    }\n\n\n\n    cmd = &((AHCICmdHdr *)s->dev[port].lst)[slot];\n\n\n\n    if (!s->dev[port].lst) {\n\n        DPRINTF(port, \"error: lst not given but cmd handled\");\n\n        return -1;\n\n    }\n\n\n\n    /* remember current slot handle for later */\n\n    s->dev[port].cur_cmd = cmd;\n\n\n\n    opts = le32_to_cpu(cmd->opts);\n\n    tbl_addr = le64_to_cpu(cmd->tbl_addr);\n\n\n\n    cmd_len = 0x80;\n\n    cmd_fis = dma_memory_map(s->as, tbl_addr, &cmd_len,\n\n                             DMA_DIRECTION_FROM_DEVICE);\n\n\n\n    if (!cmd_fis) {\n\n        DPRINTF(port, \"error: guest passed us an invalid cmd fis\\n\");\n\n        return -1;\n\n    }\n\n\n\n    /* The device we are working for */\n\n    ide_state = &s->dev[port].port.ifs[0];\n\n\n\n    if (!ide_state->blk) {\n\n        DPRINTF(port, \"error: guest accessed unused port\");\n\n        goto out;\n\n    }\n\n\n\n    debug_print_fis(cmd_fis, 0x90);\n\n    //debug_print_fis(cmd_fis, (opts & AHCI_CMD_HDR_CMD_FIS_LEN) * 4);\n\n\n\n    switch (cmd_fis[0]) {\n\n        case SATA_FIS_TYPE_REGISTER_H2D:\n\n            break;\n\n        default:\n\n            DPRINTF(port, \"unknown command cmd_fis[0]=%02x cmd_fis[1]=%02x \"\n\n                          \"cmd_fis[2]=%02x\\n\", cmd_fis[0], cmd_fis[1],\n\n                          cmd_fis[2]);\n\n            goto out;\n\n            break;\n\n    }\n\n\n\n    switch (cmd_fis[1]) {\n\n        case SATA_FIS_REG_H2D_UPDATE_COMMAND_REGISTER:\n\n            break;\n\n        case 0:\n\n            break;\n\n        default:\n\n            DPRINTF(port, \"unknown command cmd_fis[0]=%02x cmd_fis[1]=%02x \"\n\n                          \"cmd_fis[2]=%02x\\n\", cmd_fis[0], cmd_fis[1],\n\n                          cmd_fis[2]);\n\n            goto out;\n\n            break;\n\n    }\n\n\n\n    if (!(cmd_fis[1] & SATA_FIS_REG_H2D_UPDATE_COMMAND_REGISTER)) {\n\n        switch (s->dev[port].port_state) {\n\n        case STATE_RUN:\n\n            if (cmd_fis[15] & ATA_SRST) {\n\n                s->dev[port].port_state = STATE_RESET;\n\n            }\n\n            break;\n\n        case STATE_RESET:\n\n            if (!(cmd_fis[15] & ATA_SRST)) {\n\n                ahci_reset_port(s, port);\n\n            }\n\n            break;\n\n        }\n\n    }\n\n\n\n    else if (cmd_fis[1] & SATA_FIS_REG_H2D_UPDATE_COMMAND_REGISTER) {\n\n\n\n        /* Check for NCQ command */\n\n        if (is_ncq(cmd_fis[2])) {\n\n            process_ncq_command(s, port, cmd_fis, slot);\n\n            goto out;\n\n        }\n\n\n\n        /* Decompose the FIS:\n\n         * AHCI does not interpret FIS packets, it only forwards them.\n\n         * SATA 1.0 describes how to decode LBA28 and CHS FIS packets.\n\n         * Later specifications, e.g, SATA 3.2, describe LBA48 FIS packets.\n\n         *\n\n         * ATA4 describes sector number for LBA28/CHS commands.\n\n         * ATA6 describes sector number for LBA48 commands.\n\n         * ATA8 deprecates CHS fully, describing only LBA28/48.\n\n         *\n\n         * We dutifully convert the FIS into IDE registers, and allow the\n\n         * core layer to interpret them as needed. */\n\n        ide_state->feature = cmd_fis[3];\n\n        ide_state->sector = cmd_fis[4];     /* LBA 7:0 */\n\n        ide_state->lcyl = cmd_fis[5];       /* LBA 15:8  */\n\n        ide_state->hcyl = cmd_fis[6];       /* LBA 23:16 */\n\n        ide_state->select = cmd_fis[7];     /* LBA 27:24 (LBA28) */\n\n        ide_state->hob_sector = cmd_fis[8]; /* LBA 31:24 */\n\n        ide_state->hob_lcyl = cmd_fis[9];   /* LBA 39:32 */\n\n        ide_state->hob_hcyl = cmd_fis[10];  /* LBA 47:40 */\n\n        ide_state->hob_feature = cmd_fis[11];\n\n        ide_state->nsector = (int64_t)((cmd_fis[13] << 8) | cmd_fis[12]);\n\n        /* 14, 16, 17, 18, 19: Reserved (SATA 1.0) */\n\n        /* 15: Only valid when UPDATE_COMMAND not set. */\n\n\n\n        /* Copy the ACMD field (ATAPI packet, if any) from the AHCI command\n\n         * table to ide_state->io_buffer\n\n         */\n\n        if (opts & AHCI_CMD_ATAPI) {\n\n            memcpy(ide_state->io_buffer, &cmd_fis[AHCI_COMMAND_TABLE_ACMD], 0x10);\n\n            debug_print_fis(ide_state->io_buffer, 0x10);\n\n            s->dev[port].done_atapi_packet = false;\n\n            /* XXX send PIO setup FIS */\n\n        }\n\n\n\n        ide_state->error = 0;\n\n\n\n        /* Reset transferred byte counter */\n\n        cmd->status = 0;\n\n\n\n        /* We're ready to process the command in FIS byte 2. */\n\n        ide_exec_cmd(&s->dev[port].port, cmd_fis[2]);\n\n    }\n\n\n\nout:\n\n    dma_memory_unmap(s->as, cmd_fis, cmd_len, DMA_DIRECTION_FROM_DEVICE,\n\n                     cmd_len);\n\n\n\n    if (s->dev[port].port.ifs[0].status & (BUSY_STAT|DRQ_STAT)) {\n\n        /* async command, complete later */\n\n        s->dev[port].busy_slot = slot;\n\n        return -1;\n\n    }\n\n\n\n    /* done handling the command */\n\n    return 0;\n\n}\n", "idx": 4263}
{"project": "FFmpeg", "commit_id": "662234a9a22f1cd0f0ac83b8bb1ffadedca90c0a", "target": 0, "func": "static void avc_luma_midv_qrt_and_aver_dst_8w_msa(const uint8_t *src,\n\n                                                  int32_t src_stride,\n\n                                                  uint8_t *dst,\n\n                                                  int32_t dst_stride,\n\n                                                  int32_t height,\n\n                                                  uint8_t vert_offset)\n\n{\n\n    int32_t loop_cnt;\n\n    v16i8 src0, src1, src2, src3, src4;\n\n    v16u8 dst0, dst1, dst2, dst3;\n\n    v16i8 mask0, mask1, mask2;\n\n    v8i16 hz_out0, hz_out1, hz_out2, hz_out3;\n\n    v8i16 hz_out4, hz_out5, hz_out6, hz_out7, hz_out8;\n\n    v8i16 res0, res1, res2, res3;\n\n    v8i16 res4, res5, res6, res7;\n\n\n\n    LD_SB3(&luma_mask_arr[0], 16, mask0, mask1, mask2);\n\n\n\n    LD_SB5(src, src_stride, src0, src1, src2, src3, src4);\n\n    XORI_B5_128_SB(src0, src1, src2, src3, src4);\n\n    src += (5 * src_stride);\n\n\n\n    hz_out0 = AVC_HORZ_FILTER_SH(src0, mask0, mask1, mask2);\n\n    hz_out1 = AVC_HORZ_FILTER_SH(src1, mask0, mask1, mask2);\n\n    hz_out2 = AVC_HORZ_FILTER_SH(src2, mask0, mask1, mask2);\n\n    hz_out3 = AVC_HORZ_FILTER_SH(src3, mask0, mask1, mask2);\n\n    hz_out4 = AVC_HORZ_FILTER_SH(src4, mask0, mask1, mask2);\n\n\n\n    for (loop_cnt = (height >> 2); loop_cnt--;) {\n\n        LD_SB4(src, src_stride, src0, src1, src2, src3);\n\n        XORI_B4_128_SB(src0, src1, src2, src3);\n\n        src += (4 * src_stride);\n\n\n\n        LD_UB4(dst, dst_stride, dst0, dst1, dst2, dst3);\n\n\n\n        hz_out5 = AVC_HORZ_FILTER_SH(src0, mask0, mask1, mask2);\n\n        hz_out6 = AVC_HORZ_FILTER_SH(src1, mask0, mask1, mask2);\n\n        hz_out7 = AVC_HORZ_FILTER_SH(src2, mask0, mask1, mask2);\n\n        hz_out8 = AVC_HORZ_FILTER_SH(src3, mask0, mask1, mask2);\n\n\n\n        res0 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out0, hz_out1, hz_out2,\n\n                                               hz_out3, hz_out4, hz_out5);\n\n        res2 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out1, hz_out2, hz_out3,\n\n                                               hz_out4, hz_out5, hz_out6);\n\n        res4 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out2, hz_out3, hz_out4,\n\n                                               hz_out5, hz_out6, hz_out7);\n\n        res6 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out3, hz_out4, hz_out5,\n\n                                               hz_out6, hz_out7, hz_out8);\n\n\n\n        if (vert_offset) {\n\n            res1 = __msa_srari_h(hz_out3, 5);\n\n            res3 = __msa_srari_h(hz_out4, 5);\n\n            res5 = __msa_srari_h(hz_out5, 5);\n\n            res7 = __msa_srari_h(hz_out6, 5);\n\n        } else {\n\n            res1 = __msa_srari_h(hz_out2, 5);\n\n            res3 = __msa_srari_h(hz_out3, 5);\n\n            res5 = __msa_srari_h(hz_out4, 5);\n\n            res7 = __msa_srari_h(hz_out5, 5);\n\n        }\n\n\n\n        SAT_SH4_SH(res1, res3, res5, res7, 7);\n\n\n\n        res0 = __msa_aver_s_h(res0, res1);\n\n        res1 = __msa_aver_s_h(res2, res3);\n\n        res2 = __msa_aver_s_h(res4, res5);\n\n        res3 = __msa_aver_s_h(res6, res7);\n\n        ILVR_D2_UB(dst1, dst0, dst3, dst2, dst0, dst1);\n\n        CONVERT_UB_AVG_ST8x4_UB(res0, res1, res2, res3, dst0, dst1,\n\n                                dst, dst_stride);\n\n        dst += (4 * dst_stride);\n\n\n\n        hz_out0 = hz_out4;\n\n        hz_out1 = hz_out5;\n\n        hz_out2 = hz_out6;\n\n        hz_out3 = hz_out7;\n\n        hz_out4 = hz_out8;\n\n    }\n\n}\n", "idx": 4343}
{"project": "qemu", "commit_id": "f24582d6ad8a080e008974c000bf0ae635d036ac", "target": 1, "func": "void qmp_output_visitor_cleanup(QmpOutputVisitor *v)\n\n{\n\n    QStackEntry *e, *tmp;\n\n\n\n    QTAILQ_FOREACH_SAFE(e, &v->stack, node, tmp) {\n\n        QTAILQ_REMOVE(&v->stack, e, node);\n\n        if (e->value) {\n\n            qobject_decref(e->value);\n\n        }\n\n        g_free(e);\n\n    }\n\n\n\n    g_free(v);\n\n}\n", "idx": 4351}
{"project": "FFmpeg", "commit_id": "1c37848f9029985d1271da9a0d161c2ebf0aca81", "target": 1, "func": "static int webm_dash_manifest_write_trailer(AVFormatContext *s)\n\n{\n\n    WebMDashMuxContext *w = s->priv_data;\n\n    int i;\n\n    for (i = 0; i < w->nb_as; i++) {\n\n        av_freep(&w->as[i].streams);\n\n    }\n\n    av_freep(&w->as);\n\n    return 0;\n\n}\n", "idx": 4427}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "static bool bdrv_requests_pending(BlockDriverState *bs)\n\n{\n\n    if (!QLIST_EMPTY(&bs->tracked_requests)) {\n\n        return true;\n\n    }\n\n    if (!qemu_co_queue_empty(&bs->throttled_reqs[0])) {\n\n        return true;\n\n    }\n\n    if (!qemu_co_queue_empty(&bs->throttled_reqs[1])) {\n\n        return true;\n\n    }\n\n    if (bs->file && bdrv_requests_pending(bs->file)) {\n\n        return true;\n\n    }\n\n    if (bs->backing_hd && bdrv_requests_pending(bs->backing_hd)) {\n\n        return true;\n\n    }\n\n    return false;\n\n}\n", "idx": 4511}
{"project": "qemu", "commit_id": "fa131d94a5c00c6bbea39358d4bca7bf98f6c1f5", "target": 1, "func": "ObjectClass *object_class_dynamic_cast_assert(ObjectClass *class,\n\n                                              const char *typename,\n\n                                              const char *file, int line,\n\n                                              const char *func)\n\n{\n\n    ObjectClass *ret = object_class_dynamic_cast(class, typename);\n\n\n\n    if (!ret && class) {\n\n        fprintf(stderr, \"%s:%d:%s: Object %p is not an instance of type %s\\n\",\n\n                file, line, func, class, typename);\n\n        abort();\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 4583}
{"project": "qemu", "commit_id": "a907ec52cc1aefc820768b6e341b56f8f3caaca7", "target": 1, "func": "static void nvme_set_bootindex(Object *obj, Visitor *v, void *opaque,\n\n                                  const char *name, Error **errp)\n\n{\n\n    NvmeCtrl *s = NVME(obj);\n\n    int32_t boot_index;\n\n    Error *local_err = NULL;\n\n\n\n    visit_type_int32(v, &boot_index, name, &local_err);\n\n    if (local_err) {\n\n        goto out;\n\n    }\n\n    /* check whether bootindex is present in fw_boot_order list  */\n\n    check_boot_index(boot_index, &local_err);\n\n    if (local_err) {\n\n        goto out;\n\n    }\n\n    /* change bootindex to a new one */\n\n    s->conf.bootindex = boot_index;\n\n\n\nout:\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n    }\n\n}\n", "idx": 4594}
{"project": "qemu", "commit_id": "32bafa8fdd098d52fbf1102d5a5e48d29398c0aa", "target": 0, "func": "static void vnc_init_basic_info(SocketAddress *addr,\n\n                                VncBasicInfo *info,\n\n                                Error **errp)\n\n{\n\n    switch (addr->type) {\n\n    case SOCKET_ADDRESS_KIND_INET:\n\n        info->host = g_strdup(addr->u.inet->host);\n\n        info->service = g_strdup(addr->u.inet->port);\n\n        if (addr->u.inet->ipv6) {\n\n            info->family = NETWORK_ADDRESS_FAMILY_IPV6;\n\n        } else {\n\n            info->family = NETWORK_ADDRESS_FAMILY_IPV4;\n\n        }\n\n        break;\n\n\n\n    case SOCKET_ADDRESS_KIND_UNIX:\n\n        info->host = g_strdup(\"\");\n\n        info->service = g_strdup(addr->u.q_unix->path);\n\n        info->family = NETWORK_ADDRESS_FAMILY_UNIX;\n\n        break;\n\n\n\n    default:\n\n        error_setg(errp, \"Unsupported socket kind %d\",\n\n                   addr->type);\n\n        break;\n\n    }\n\n\n\n    return;\n\n}\n", "idx": 4612}
{"project": "qemu", "commit_id": "6c2934db949aa259ed47b126b5c6838ac57a3f6f", "target": 1, "func": "void cpu_physical_memory_rw(target_phys_addr_t addr, uint8_t *buf,\n\n                            int len, int is_write)\n\n{\n\n    int l, io_index;\n\n    uint8_t *ptr;\n\n    uint32_t val;\n\n    target_phys_addr_t page;\n\n    unsigned long pd;\n\n    PhysPageDesc *p;\n\n\n\n    while (len > 0) {\n\n        page = addr & TARGET_PAGE_MASK;\n\n        l = (page + TARGET_PAGE_SIZE) - addr;\n\n        if (l > len)\n\n            l = len;\n\n        p = phys_page_find(page >> TARGET_PAGE_BITS);\n\n        if (!p) {\n\n            pd = IO_MEM_UNASSIGNED;\n\n        } else {\n\n            pd = p->phys_offset;\n\n        }\n\n\n\n        if (is_write) {\n\n            if ((pd & ~TARGET_PAGE_MASK) != IO_MEM_RAM) {\n\n                io_index = (pd >> IO_MEM_SHIFT) & (IO_MEM_NB_ENTRIES - 1);\n\n                if (p)\n\n                    addr = (addr & ~TARGET_PAGE_MASK) + p->region_offset;\n\n                /* XXX: could force cpu_single_env to NULL to avoid\n\n                   potential bugs */\n\n                if (l >= 4 && ((addr & 3) == 0)) {\n\n                    /* 32 bit write access */\n\n                    val = ldl_p(buf);\n\n                    io_mem_write[io_index][2](io_mem_opaque[io_index], addr, val);\n\n                    l = 4;\n\n                } else if (l >= 2 && ((addr & 1) == 0)) {\n\n                    /* 16 bit write access */\n\n                    val = lduw_p(buf);\n\n                    io_mem_write[io_index][1](io_mem_opaque[io_index], addr, val);\n\n                    l = 2;\n\n                } else {\n\n                    /* 8 bit write access */\n\n                    val = ldub_p(buf);\n\n                    io_mem_write[io_index][0](io_mem_opaque[io_index], addr, val);\n\n                    l = 1;\n\n                }\n\n            } else {\n\n                unsigned long addr1;\n\n                addr1 = (pd & TARGET_PAGE_MASK) + (addr & ~TARGET_PAGE_MASK);\n\n                /* RAM case */\n\n                ptr = phys_ram_base + addr1;\n\n                memcpy(ptr, buf, l);\n\n                if (!cpu_physical_memory_is_dirty(addr1)) {\n\n                    /* invalidate code */\n\n                    tb_invalidate_phys_page_range(addr1, addr1 + l, 0);\n\n                    /* set dirty bit */\n\n                    phys_ram_dirty[addr1 >> TARGET_PAGE_BITS] |=\n\n                        (0xff & ~CODE_DIRTY_FLAG);\n\n                }\n\n            }\n\n        } else {\n\n            if ((pd & ~TARGET_PAGE_MASK) > IO_MEM_ROM &&\n\n                !(pd & IO_MEM_ROMD)) {\n\n                /* I/O case */\n\n                io_index = (pd >> IO_MEM_SHIFT) & (IO_MEM_NB_ENTRIES - 1);\n\n                if (p)\n\n                    addr = (addr & ~TARGET_PAGE_MASK) + p->region_offset;\n\n                if (l >= 4 && ((addr & 3) == 0)) {\n\n                    /* 32 bit read access */\n\n                    val = io_mem_read[io_index][2](io_mem_opaque[io_index], addr);\n\n                    stl_p(buf, val);\n\n                    l = 4;\n\n                } else if (l >= 2 && ((addr & 1) == 0)) {\n\n                    /* 16 bit read access */\n\n                    val = io_mem_read[io_index][1](io_mem_opaque[io_index], addr);\n\n                    stw_p(buf, val);\n\n                    l = 2;\n\n                } else {\n\n                    /* 8 bit read access */\n\n                    val = io_mem_read[io_index][0](io_mem_opaque[io_index], addr);\n\n                    stb_p(buf, val);\n\n                    l = 1;\n\n                }\n\n            } else {\n\n                /* RAM case */\n\n                ptr = phys_ram_base + (pd & TARGET_PAGE_MASK) +\n\n                    (addr & ~TARGET_PAGE_MASK);\n\n                memcpy(buf, ptr, l);\n\n            }\n\n        }\n\n        len -= l;\n\n        buf += l;\n\n        addr += l;\n\n    }\n\n}\n", "idx": 4640}
{"project": "FFmpeg", "commit_id": "5d590d87b30c59dfb853ebde6276d36f8a8bbc58", "target": 1, "func": "static int av_dict_set_fxp(AVDictionary **pm, const char *key, uint64_t value, unsigned int digits,\n\n                int flags)\n\n{\n\n    char valuestr[44];\n\n    snprintf(valuestr, sizeof(valuestr), \"%\"PRId64\".%0*\"PRId64,\n\n             value / PRECISION, digits, ( value % PRECISION ) / ( PRECISION / uintpow(10,digits) ));\n\n    return av_dict_set(pm, key, valuestr, flags);\n\n}\n", "idx": 4647}
{"project": "FFmpeg", "commit_id": "fde5c7dc79eb017790ba232442ad2a4eecea4bf1", "target": 1, "func": "int ff_h264_pred_weight_table(GetBitContext *gb, const SPS *sps,\n\n                              const int *ref_count, int slice_type_nos,\n\n                              H264PredWeightTable *pwt,\n\n                              int picture_structure, void *logctx)\n\n{\n\n    int list, i, j;\n\n    int luma_def, chroma_def;\n\n\n\n    pwt->use_weight             = 0;\n\n    pwt->use_weight_chroma      = 0;\n\n    pwt->luma_log2_weight_denom = get_ue_golomb(gb);\n\n    if (sps->chroma_format_idc)\n\n        pwt->chroma_log2_weight_denom = get_ue_golomb(gb);\n\n\n\n    if (pwt->luma_log2_weight_denom > 7U) {\n\n        av_log(logctx, AV_LOG_ERROR, \"luma_log2_weight_denom %d is out of range\\n\", pwt->luma_log2_weight_denom);\n\n        pwt->luma_log2_weight_denom = 0;\n\n    }\n\n    if (pwt->chroma_log2_weight_denom > 7U) {\n\n        av_log(logctx, AV_LOG_ERROR, \"chroma_log2_weight_denom %d is out of range\\n\", pwt->chroma_log2_weight_denom);\n\n        pwt->chroma_log2_weight_denom = 0;\n\n    }\n\n\n\n    luma_def   = 1 << pwt->luma_log2_weight_denom;\n\n    chroma_def = 1 << pwt->chroma_log2_weight_denom;\n\n\n\n    for (list = 0; list < 2; list++) {\n\n        pwt->luma_weight_flag[list]   = 0;\n\n        pwt->chroma_weight_flag[list] = 0;\n\n        for (i = 0; i < ref_count[list]; i++) {\n\n            int luma_weight_flag, chroma_weight_flag;\n\n\n\n            luma_weight_flag = get_bits1(gb);\n\n            if (luma_weight_flag) {\n\n                pwt->luma_weight[i][list][0] = get_se_golomb(gb);\n\n                pwt->luma_weight[i][list][1] = get_se_golomb(gb);\n\n                if ((int8_t)pwt->luma_weight[i][list][0] != pwt->luma_weight[i][list][0] ||\n\n                    (int8_t)pwt->luma_weight[i][list][1] != pwt->luma_weight[i][list][1])\n\n                    goto out_range_weight;\n\n                if (pwt->luma_weight[i][list][0] != luma_def ||\n\n                    pwt->luma_weight[i][list][1] != 0) {\n\n                    pwt->use_weight             = 1;\n\n                    pwt->luma_weight_flag[list] = 1;\n\n                }\n\n            } else {\n\n                pwt->luma_weight[i][list][0] = luma_def;\n\n                pwt->luma_weight[i][list][1] = 0;\n\n            }\n\n\n\n            if (sps->chroma_format_idc) {\n\n                chroma_weight_flag = get_bits1(gb);\n\n                if (chroma_weight_flag) {\n\n                    int j;\n\n                    for (j = 0; j < 2; j++) {\n\n                        pwt->chroma_weight[i][list][j][0] = get_se_golomb(gb);\n\n                        pwt->chroma_weight[i][list][j][1] = get_se_golomb(gb);\n\n                        if ((int8_t)pwt->chroma_weight[i][list][j][0] != pwt->chroma_weight[i][list][j][0] ||\n\n                            (int8_t)pwt->chroma_weight[i][list][j][1] != pwt->chroma_weight[i][list][j][1])\n\n                            goto out_range_weight;\n\n                        if (pwt->chroma_weight[i][list][j][0] != chroma_def ||\n\n                            pwt->chroma_weight[i][list][j][1] != 0) {\n\n                            pwt->use_weight_chroma        = 1;\n\n                            pwt->chroma_weight_flag[list] = 1;\n\n                        }\n\n                    }\n\n                } else {\n\n                    int j;\n\n                    for (j = 0; j < 2; j++) {\n\n                        pwt->chroma_weight[i][list][j][0] = chroma_def;\n\n                        pwt->chroma_weight[i][list][j][1] = 0;\n\n                    }\n\n                }\n\n            }\n\n\n\n            // for MBAFF\n\n            if (picture_structure == PICT_FRAME) {\n\n                pwt->luma_weight[16 + 2 * i][list][0] = pwt->luma_weight[16 + 2 * i + 1][list][0] = pwt->luma_weight[i][list][0];\n\n                pwt->luma_weight[16 + 2 * i][list][1] = pwt->luma_weight[16 + 2 * i + 1][list][1] = pwt->luma_weight[i][list][1];\n\n                for (j = 0; j < 2; j++) {\n\n                    pwt->chroma_weight[16 + 2 * i][list][j][0] = pwt->chroma_weight[16 + 2 * i + 1][list][j][0] = pwt->chroma_weight[i][list][j][0];\n\n                    pwt->chroma_weight[16 + 2 * i][list][j][1] = pwt->chroma_weight[16 + 2 * i + 1][list][j][1] = pwt->chroma_weight[i][list][j][1];\n\n                }\n\n            }\n\n        }\n\n        if (slice_type_nos != AV_PICTURE_TYPE_B)\n\n            break;\n\n    }\n\n    pwt->use_weight = pwt->use_weight || pwt->use_weight_chroma;\n\n    return 0;\n\nout_range_weight:\n\n    avpriv_request_sample(logctx, \"Out of range weight\\n\");\n\n    return AVERROR_INVALIDDATA;\n\n}\n", "idx": 4654}
{"project": "FFmpeg", "commit_id": "33d69a90085d30af8a292d9364b835a26565d6b9", "target": 0, "func": "static JavaVM *get_java_vm(const char *name, void *log_ctx)\n\n{\n\n    JavaVM *vm = NULL;\n\n    jsize nb_vm = 0;\n\n\n\n    void *handle = NULL;\n\n    jint (*get_created_java_vms) (JavaVM ** vmBuf, jsize bufLen, jsize *nVMs) = NULL;\n\n\n\n    handle = dlopen(name, RTLD_LOCAL);\n\n    if (!handle) {\n\n        return NULL;\n\n    }\n\n\n\n    get_created_java_vms = (jint (*)(JavaVM **, jsize, jsize *)) dlsym(handle, \"JNI_GetCreatedJavaVMs\");\n\n    if (!get_created_java_vms) {\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Could not find JNI_GetCreatedJavaVMs symbol in library '%s'\\n\", name);\n\n        goto done;\n\n    }\n\n\n\n    if (get_created_java_vms(&vm, 1, &nb_vm) != JNI_OK) {\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Could not get created Java virtual machines\\n\");\n\n        goto done;\n\n    }\n\n\n\ndone:\n\n    if (handle) {\n\n        dlclose(handle);\n\n    }\n\n\n\n    return vm;\n\n}\n", "idx": 4686}
{"project": "FFmpeg", "commit_id": "617c461625daa5d569345df55e6cedc4b6100ec1", "target": 0, "func": "static int mpegts_push_data(MpegTSFilter *filter,\n\n                            const uint8_t *buf, int buf_size, int is_start,\n\n                            int64_t pos)\n\n{\n\n    PESContext *pes = filter->u.pes_filter.opaque;\n\n    MpegTSContext *ts = pes->ts;\n\n    const uint8_t *p;\n\n    int len, code;\n\n\n\n    if(!ts->pkt)\n\n        return 0;\n\n\n\n    if (is_start) {\n\n        if (pes->state == MPEGTS_PAYLOAD && pes->data_index > 0) {\n\n            new_pes_packet(pes, ts->pkt);\n\n            ts->stop_parse = 1;\n\n        }\n\n        pes->state = MPEGTS_HEADER;\n\n        pes->data_index = 0;\n\n        pes->ts_packet_pos = pos;\n\n    }\n\n    p = buf;\n\n    while (buf_size > 0) {\n\n        switch(pes->state) {\n\n        case MPEGTS_HEADER:\n\n            len = PES_START_SIZE - pes->data_index;\n\n            if (len > buf_size)\n\n                len = buf_size;\n\n            memcpy(pes->header + pes->data_index, p, len);\n\n            pes->data_index += len;\n\n            p += len;\n\n            buf_size -= len;\n\n            if (pes->data_index == PES_START_SIZE) {\n\n                /* we got all the PES or section header. We can now\n\n                   decide */\n\n#if 0\n\n                av_hex_dump_log(pes->stream, AV_LOG_DEBUG, pes->header, pes->data_index);\n\n#endif\n\n                if (pes->header[0] == 0x00 && pes->header[1] == 0x00 &&\n\n                    pes->header[2] == 0x01) {\n\n                    /* it must be an mpeg2 PES stream */\n\n                    code = pes->header[3] | 0x100;\n\n                    dprintf(pes->stream, \"pid=%x pes_code=%#x\\n\", pes->pid, code);\n\n\n\n                    if ((pes->st && pes->st->discard == AVDISCARD_ALL) ||\n\n                        code == 0x1be) /* padding_stream */\n\n                        goto skip;\n\n\n\n                    /* stream not present in PMT */\n\n                    if (!pes->st)\n\n                        pes->st = new_pes_av_stream(pes, 0, code);\n\n                    if (!pes->st)\n\n                        return AVERROR(ENOMEM);\n\n\n\n                    pes->total_size = AV_RB16(pes->header + 4);\n\n                    /* NOTE: a zero total size means the PES size is\n\n                       unbounded */\n\n                    if (!pes->total_size)\n\n                        pes->total_size = MAX_PES_PAYLOAD;\n\n\n\n                    /* allocate pes buffer */\n\n                    pes->buffer = av_malloc(pes->total_size+FF_INPUT_BUFFER_PADDING_SIZE);\n\n                    if (!pes->buffer)\n\n                        return AVERROR(ENOMEM);\n\n\n\n                    if (code != 0x1bc && code != 0x1bf && /* program_stream_map, private_stream_2 */\n\n                        code != 0x1f0 && code != 0x1f1 && /* ECM, EMM */\n\n                        code != 0x1ff && code != 0x1f2 && /* program_stream_directory, DSMCC_stream */\n\n                        code != 0x1f8) {                  /* ITU-T Rec. H.222.1 type E stream */\n\n                        pes->state = MPEGTS_PESHEADER_FILL;\n\n                        pes->pes_header_size = pes->header[8] + 9;\n\n                    } else {\n\n                        pes->state = MPEGTS_PAYLOAD;\n\n                        pes->data_index = 0;\n\n                    }\n\n                } else {\n\n                    /* otherwise, it should be a table */\n\n                    /* skip packet */\n\n                skip:\n\n                    pes->state = MPEGTS_SKIP;\n\n                    continue;\n\n                }\n\n            }\n\n            break;\n\n            /**********************************************/\n\n            /* PES packing parsing */\n\n        case MPEGTS_PESHEADER_FILL:\n\n            len = pes->pes_header_size - pes->data_index;\n\n            if (len < 0)\n\n                return -1;\n\n            if (len > buf_size)\n\n                len = buf_size;\n\n            memcpy(pes->header + pes->data_index, p, len);\n\n            pes->data_index += len;\n\n            p += len;\n\n            buf_size -= len;\n\n            if (pes->data_index == pes->pes_header_size) {\n\n                const uint8_t *r;\n\n                unsigned int flags;\n\n\n\n                flags = pes->header[7];\n\n                r = pes->header + 9;\n\n                pes->pts = AV_NOPTS_VALUE;\n\n                pes->dts = AV_NOPTS_VALUE;\n\n                if ((flags & 0xc0) == 0x80) {\n\n                    pes->dts = pes->pts = get_pts(r);\n\n                    r += 5;\n\n                } else if ((flags & 0xc0) == 0xc0) {\n\n                    pes->pts = get_pts(r);\n\n                    r += 5;\n\n                    pes->dts = get_pts(r);\n\n                    r += 5;\n\n                }\n\n\n\n                /* we got the full header. We parse it and get the payload */\n\n                pes->state = MPEGTS_PAYLOAD;\n\n                pes->data_index = 0;\n\n            }\n\n            break;\n\n        case MPEGTS_PAYLOAD:\n\n            if (buf_size > 0) {\n\n                if (pes->data_index+buf_size > pes->total_size) {\n\n                    new_pes_packet(pes, ts->pkt);\n\n                    pes->total_size = MAX_PES_PAYLOAD;\n\n                    pes->buffer = av_malloc(pes->total_size+FF_INPUT_BUFFER_PADDING_SIZE);\n\n                    if (!pes->buffer)\n\n                        return AVERROR(ENOMEM);\n\n                    ts->stop_parse = 1;\n\n                }\n\n                memcpy(pes->buffer+pes->data_index, p, buf_size);\n\n                pes->data_index += buf_size;\n\n            }\n\n            buf_size = 0;\n\n            break;\n\n        case MPEGTS_SKIP:\n\n            buf_size = 0;\n\n            break;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 4701}
{"project": "qemu", "commit_id": "966439a67830239a6c520c5df6c55627b8153c8b", "target": 1, "func": "void OPPROTO op_check_addo (void)\n\n{\n\n    if (likely(!(((uint32_t)T2 ^ (uint32_t)T1 ^ UINT32_MAX) &\n\n                 ((uint32_t)T2 ^ (uint32_t)T0) & (1UL << 31)))) {\n\n        xer_ov = 0;\n\n    } else {\n\n        xer_so = 1;\n\n        xer_ov = 1;\n\n    }\n\n    RETURN();\n\n}\n", "idx": 4757}
{"project": "qemu", "commit_id": "5379229a2708df3a1506113315214c3ce5325859", "target": 0, "func": "sosendto(struct socket *so, struct mbuf *m)\n\n{\n\n\tSlirp *slirp = so->slirp;\n\n\tint ret;\n\n\tstruct sockaddr_in addr;\n\n\n\n\tDEBUG_CALL(\"sosendto\");\n\n\tDEBUG_ARG(\"so = %p\", so);\n\n\tDEBUG_ARG(\"m = %p\", m);\n\n\n\n        addr.sin_family = AF_INET;\n\n\tif ((so->so_faddr.s_addr & slirp->vnetwork_mask.s_addr) ==\n\n\t    slirp->vnetwork_addr.s_addr) {\n\n\t  /* It's an alias */\n\n\t  if (so->so_faddr.s_addr == slirp->vnameserver_addr.s_addr) {\n\n\t    if (get_dns_addr(&addr.sin_addr) < 0)\n\n\t      addr.sin_addr = loopback_addr;\n\n\t  } else {\n\n\t    addr.sin_addr = loopback_addr;\n\n\t  }\n\n\t} else\n\n\t  addr.sin_addr = so->so_faddr;\n\n\taddr.sin_port = so->so_fport;\n\n\n\n\tDEBUG_MISC((dfd, \" sendto()ing, addr.sin_port=%d, addr.sin_addr.s_addr=%.16s\\n\", ntohs(addr.sin_port), inet_ntoa(addr.sin_addr)));\n\n\n\n\t/* Don't care what port we get */\n\n\tret = sendto(so->s, m->m_data, m->m_len, 0,\n\n\t\t     (struct sockaddr *)&addr, sizeof (struct sockaddr));\n\n\tif (ret < 0)\n\n\t\treturn -1;\n\n\n\n\t/*\n\n\t * Kill the socket if there's no reply in 4 minutes,\n\n\t * but only if it's an expirable socket\n\n\t */\n\n\tif (so->so_expire)\n\n\t\tso->so_expire = curtime + SO_EXPIRE;\n\n\tso->so_state &= SS_PERSISTENT_MASK;\n\n\tso->so_state |= SS_ISFCONNECTED; /* So that it gets select()ed */\n\n\treturn 0;\n\n}\n", "idx": 4847}
{"project": "FFmpeg", "commit_id": "bf2bc926f04dcdde0a22c137d08a0bb546e0179e", "target": 1, "func": "static int advanced_decode_picture_primary_header(VC9Context *v)\n\n{\n\n    GetBitContext *gb = &v->s.gb;\n\n    static const int type_table[4] = { P_TYPE, B_TYPE, I_TYPE, BI_TYPE };\n\n    int type, i;\n\n\n\n    if (v->interlace)\n\n    {\n\n        v->fcm = get_bits(gb, 1);\n\n        if (v->fcm) v->fcm = 2+get_bits(gb, 1);\n\n    }\n\n\n\n    type = get_prefix(gb, 0, 4);\n\n    if (type > 4 || type < 0) return FRAME_SKIPED;\n\n    v->s.pict_type = type_table[type];\n\n    av_log(v->s.avctx, AV_LOG_INFO, \"AP Frame Type: %i\\n\", v->s.pict_type);\n\n\n\n    if (v->tfcntrflag) v->tfcntr = get_bits(gb, 8);\n\n    if (v->broadcast)\n\n    {\n\n        if (!v->interlace) v->rptfrm = get_bits(gb, 2);\n\n        else\n\n        {\n\n            v->tff = get_bits(gb, 1);\n\n            v->rff = get_bits(gb, 1);\n\n        }\n\n    }\n\n\n\n    if (v->panscanflag)\n\n    {\n\n#if 0\n\n        for (i=0; i<v->numpanscanwin; i++)\n\n        {\n\n            v->topleftx[i] = get_bits(gb, 16);\n\n            v->toplefty[i] = get_bits(gb, 16);\n\n            v->bottomrightx[i] = get_bits(gb, 16);\n\n            v->bottomrighty[i] = get_bits(gb, 16);\n\n        }\n\n#else\n\n        skip_bits(gb, 16*4*v->numpanscanwin);\n\n#endif\n\n    }\n\n    v->s.no_rounding = !get_bits(gb, 1);\n\n    v->uvsamp = get_bits(gb, 1);\n\n    if (v->finterpflag == 1) v->interpfrm = get_bits(gb, 1);\n\n\n\n    switch(v->s.pict_type)\n\n    {\n\n    case I_TYPE: if (decode_i_picture_header(v) < 0) return -1;\n\n    case P_TYPE: if (decode_p_picture_primary_header(v) < 0) return -1;\n\n    case BI_TYPE:\n\n    case B_TYPE: if (decode_b_picture_primary_header(v) < 0) return FRAME_SKIPED;\n\n    default: break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 4861}
{"project": "FFmpeg", "commit_id": "68aefbe81cb3b9dd002108782bb8d798e1c12806", "target": 1, "func": "static double get_video_clock(VideoState *is)\n\n{\n\n    if (is->paused) {\n\n        return is->video_current_pts;\n\n    } else {\n\n        return is->video_current_pts + (av_gettime() - is->video_current_pts_time) / 1000000.0;\n\n    }\n\n}\n", "idx": 4876}
{"project": "qemu", "commit_id": "00cf57747db98c6a9e4219cea39ac3113dde6993", "target": 0, "func": "static uint32_t check_alarm(RTCState *s)\n\n{\n\n    uint8_t alarm_hour, alarm_min, alarm_sec;\n\n    uint8_t cur_hour, cur_min, cur_sec;\n\n\n\n    alarm_sec = rtc_from_bcd(s, s->cmos_data[RTC_SECONDS_ALARM]);\n\n    alarm_min = rtc_from_bcd(s, s->cmos_data[RTC_MINUTES_ALARM]);\n\n    alarm_hour = rtc_from_bcd(s, s->cmos_data[RTC_HOURS_ALARM]);\n\n    alarm_hour = convert_hour(s, alarm_hour);\n\n\n\n    cur_sec = rtc_from_bcd(s, s->cmos_data[RTC_SECONDS]);\n\n    cur_min = rtc_from_bcd(s, s->cmos_data[RTC_MINUTES]);\n\n    cur_hour = rtc_from_bcd(s, s->cmos_data[RTC_HOURS]);\n\n    cur_hour = convert_hour(s, cur_hour);\n\n\n\n    if (((s->cmos_data[RTC_SECONDS_ALARM] & 0xc0) == 0xc0\n\n                || alarm_sec == cur_sec) &&\n\n            ((s->cmos_data[RTC_MINUTES_ALARM] & 0xc0) == 0xc0\n\n             || alarm_min == cur_min) &&\n\n            ((s->cmos_data[RTC_HOURS_ALARM] & 0xc0) == 0xc0\n\n             || alarm_hour == cur_hour)) {\n\n        return 1;\n\n    }\n\n    return 0;\n\n\n\n}\n", "idx": 4930}
{"project": "qemu", "commit_id": "3a55fc0f243104998bee5106b121cff257df5d33", "target": 1, "func": "static void test_ivshmem_server(bool msi)\n\n{\n\n    IVState state1, state2, *s1, *s2;\n\n    ServerThread thread;\n\n    IvshmemServer server;\n\n    int ret, vm1, vm2;\n\n    int nvectors = 2;\n\n    guint64 end_time = g_get_monotonic_time() + 5 * G_TIME_SPAN_SECOND;\n\n\n\n    ret = ivshmem_server_init(&server, tmpserver, tmpshm, true,\n\n                              TMPSHMSIZE, nvectors,\n\n                              g_test_verbose());\n\n    g_assert_cmpint(ret, ==, 0);\n\n\n\n    ret = ivshmem_server_start(&server);\n\n    g_assert_cmpint(ret, ==, 0);\n\n\n\n    setup_vm_with_server(&state1, nvectors, msi);\n\n    s1 = &state1;\n\n    setup_vm_with_server(&state2, nvectors, msi);\n\n    s2 = &state2;\n\n\n\n    /* check state before server sends stuff */\n\n    g_assert_cmpuint(in_reg(s1, IVPOSITION), ==, 0xffffffff);\n\n    g_assert_cmpuint(in_reg(s2, IVPOSITION), ==, 0xffffffff);\n\n    g_assert_cmpuint(qtest_readb(s1->qtest, (uintptr_t)s1->mem_base), ==, 0x00);\n\n\n\n    thread.server = &server;\n\n    ret = pipe(thread.pipe);\n\n    g_assert_cmpint(ret, ==, 0);\n\n    thread.thread = g_thread_new(\"ivshmem-server\", server_thread, &thread);\n\n    g_assert(thread.thread != NULL);\n\n\n\n    /* waiting for devices to become operational */\n\n    while (g_get_monotonic_time() < end_time) {\n\n        g_usleep(1000);\n\n        if ((int)in_reg(s1, IVPOSITION) >= 0 &&\n\n            (int)in_reg(s2, IVPOSITION) >= 0) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* check got different VM ids */\n\n    vm1 = in_reg(s1, IVPOSITION);\n\n    vm2 = in_reg(s2, IVPOSITION);\n\n    g_assert_cmpuint(vm1, !=, vm2);\n\n\n\n    /* check number of MSI-X vectors */\n\n    global_qtest = s1->qtest;\n\n    if (msi) {\n\n        ret = qpci_msix_table_size(s1->dev);\n\n        g_assert_cmpuint(ret, ==, nvectors);\n\n    }\n\n\n\n    /* TODO test behavior before MSI-X is enabled */\n\n\n\n    /* ping vm2 -> vm1 on vector 0 */\n\n    if (msi) {\n\n        ret = qpci_msix_pending(s1->dev, 0);\n\n        g_assert_cmpuint(ret, ==, 0);\n\n    } else {\n\n        g_assert_cmpuint(in_reg(s1, INTRSTATUS), ==, 0);\n\n    }\n\n    out_reg(s2, DOORBELL, vm1 << 16);\n\n    do {\n\n        g_usleep(10000);\n\n        ret = msi ? qpci_msix_pending(s1->dev, 0) : in_reg(s1, INTRSTATUS);\n\n    } while (ret == 0 && g_get_monotonic_time() < end_time);\n\n    g_assert_cmpuint(ret, !=, 0);\n\n\n\n    /* ping vm1 -> vm2 on vector 1 */\n\n    global_qtest = s2->qtest;\n\n    if (msi) {\n\n        ret = qpci_msix_pending(s2->dev, 1);\n\n        g_assert_cmpuint(ret, ==, 0);\n\n    } else {\n\n        g_assert_cmpuint(in_reg(s2, INTRSTATUS), ==, 0);\n\n    }\n\n    out_reg(s1, DOORBELL, vm2 << 16 | 1);\n\n    do {\n\n        g_usleep(10000);\n\n        ret = msi ? qpci_msix_pending(s2->dev, 1) : in_reg(s2, INTRSTATUS);\n\n    } while (ret == 0 && g_get_monotonic_time() < end_time);\n\n    g_assert_cmpuint(ret, !=, 0);\n\n\n\n    cleanup_vm(s2);\n\n    cleanup_vm(s1);\n\n\n\n    if (qemu_write_full(thread.pipe[1], \"q\", 1) != 1) {\n\n        g_error(\"qemu_write_full: %s\", g_strerror(errno));\n\n    }\n\n\n\n    g_thread_join(thread.thread);\n\n\n\n    ivshmem_server_close(&server);\n\n    close(thread.pipe[1]);\n\n    close(thread.pipe[0]);\n\n}\n", "idx": 4973}
{"project": "FFmpeg", "commit_id": "2caf19e90f270abe1e80a3e85acaf0eb5c9d0aac", "target": 1, "func": "static void FUNCC(pred8x8_horizontal)(uint8_t *_src, int stride){\n\n    int i;\n\n    pixel *src = (pixel*)_src;\n\n    stride /= sizeof(pixel);\n\n\n\n    for(i=0; i<8; i++){\n\n        ((pixel4*)(src+i*stride))[0]=\n\n        ((pixel4*)(src+i*stride))[1]= PIXEL_SPLAT_X4(src[-1+i*stride]);\n\n    }\n\n}\n", "idx": 4991}
{"project": "qemu", "commit_id": "f8b6cc0070aab8b75bd082582c829be1353f395f", "target": 0, "func": "SCSIDevice *scsi_bus_legacy_add_drive(SCSIBus *bus, DriveInfo *dinfo, int unit)\n\n{\n\n    const char *driver;\n\n    DeviceState *dev;\n\n\n\n    driver = bdrv_is_sg(dinfo->bdrv) ? \"scsi-generic\" : \"scsi-disk\";\n\n    dev = qdev_create(&bus->qbus, driver);\n\n    qdev_prop_set_uint32(dev, \"scsi-id\", unit);\n\n    qdev_prop_set_drive(dev, \"drive\", dinfo);\n\n    if (qdev_init(dev) < 0)\n\n        return NULL;\n\n    return DO_UPCAST(SCSIDevice, qdev, dev);\n\n}\n", "idx": 5020}
{"project": "qemu", "commit_id": "100f738850639a108d6767316ce4dcc1d1ea4ae4", "target": 0, "func": "static void icp_realize(DeviceState *dev, Error **errp)\n\n{\n\n    ICPState *icp = ICP(dev);\n\n    ICPStateClass *icpc = ICP_GET_CLASS(dev);\n\n    Object *obj;\n\n    Error *err = NULL;\n\n\n\n    obj = object_property_get_link(OBJECT(dev), ICP_PROP_XICS, &err);\n\n    if (!obj) {\n\n        error_setg(errp, \"%s: required link '\" ICP_PROP_XICS \"' not found: %s\",\n\n                   __func__, error_get_pretty(err));\n\n        return;\n\n    }\n\n\n\n    icp->xics = XICS_FABRIC(obj);\n\n\n\n    if (icpc->realize) {\n\n        icpc->realize(dev, errp);\n\n    }\n\n\n\n    qemu_register_reset(icp_reset, dev);\n\n}\n", "idx": 5085}
{"project": "qemu", "commit_id": "e53f27b9d9df73461308618151fa6e6392aebd85", "target": 1, "func": "static void tcp_chr_read(void *opaque)\n\n{\n\n    CharDriverState *chr = opaque;\n\n    TCPCharDriver *s = chr->opaque;\n\n    uint8_t buf[READ_BUF_LEN];\n\n    int len, size;\n\n\n\n    if (!s->connected || s->max_size <= 0)\n\n        return;\n\n    len = sizeof(buf);\n\n    if (len > s->max_size)\n\n        len = s->max_size;\n\n    size = tcp_chr_recv(chr, (void *)buf, len);\n\n    if (size == 0) {\n\n        /* connection closed */\n\n        s->connected = 0;\n\n        if (s->listen_fd >= 0) {\n\n            qemu_set_fd_handler(s->listen_fd, tcp_chr_accept, NULL, chr);\n\n        }\n\n        qemu_set_fd_handler(s->fd, NULL, NULL, NULL);\n\n        closesocket(s->fd);\n\n        s->fd = -1;\n\n        qemu_chr_event(chr, CHR_EVENT_CLOSED);\n\n    } else if (size > 0) {\n\n        if (s->do_telnetopt)\n\n            tcp_chr_process_IAC_bytes(chr, s, buf, &size);\n\n        if (size > 0)\n\n            qemu_chr_read(chr, buf, size);\n\n        if (s->msgfd != -1) {\n\n            close(s->msgfd);\n\n            s->msgfd = -1;\n\n        }\n\n    }\n\n}\n", "idx": 5158}
{"project": "FFmpeg", "commit_id": "d81be0a60a6dea2bc48ec29f9466eee63984ed34", "target": 1, "func": "static int hwmap_filter_frame(AVFilterLink *link, AVFrame *input)\n\n{\n\n    AVFilterContext *avctx = link->dst;\n\n    AVFilterLink  *outlink = avctx->outputs[0];\n\n    HWMapContext      *ctx = avctx->priv;\n\n    AVFrame *map = NULL;\n\n    int err;\n\n\n\n    av_log(ctx, AV_LOG_DEBUG, \"Filter input: %s, %ux%u (%\"PRId64\").\\n\",\n\n           av_get_pix_fmt_name(input->format),\n\n           input->width, input->height, input->pts);\n\n\n\n    map = av_frame_alloc();\n\n    if (!map) {\n\n        err = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    map->format = outlink->format;\n\n    map->hw_frames_ctx = av_buffer_ref(ctx->hwframes_ref);\n\n    if (!map->hw_frames_ctx) {\n\n        err = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    if (ctx->map_backwards && !input->hw_frames_ctx) {\n\n        // If we mapped backwards from hardware to software, we need\n\n        // to attach the hardware frame context to the input frame to\n\n        // make the mapping visible to av_hwframe_map().\n\n        input->hw_frames_ctx = av_buffer_ref(ctx->hwframes_ref);\n\n        if (!input->hw_frames_ctx) {\n\n            err = AVERROR(ENOMEM);\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    err = av_hwframe_map(map, input, ctx->mode);\n\n    if (err < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Failed to map frame: %d.\\n\", err);\n\n        goto fail;\n\n    }\n\n\n\n    err = av_frame_copy_props(map, input);\n\n    if (err < 0)\n\n        goto fail;\n\n\n\n    av_frame_free(&input);\n\n\n\n    av_log(ctx, AV_LOG_DEBUG, \"Filter output: %s, %ux%u (%\"PRId64\").\\n\",\n\n           av_get_pix_fmt_name(map->format),\n\n           map->width, map->height, map->pts);\n\n\n\n    return ff_filter_frame(outlink, map);\n\n\n\nfail:\n\n    av_frame_free(&input);\n\n    av_frame_free(&map);\n\n    return err;\n\n}\n", "idx": 5176}
{"project": "qemu", "commit_id": "ef76dc59fa5203d146a2acf85a0ad5a5971a4824", "target": 0, "func": "START_TEST(keyword_literal)\n\n{\n\n    QObject *obj;\n\n    QBool *qbool;\n\n    QString *str;\n\n\n\n    obj = qobject_from_json(\"true\");\n\n    fail_unless(obj != NULL);\n\n    fail_unless(qobject_type(obj) == QTYPE_QBOOL);\n\n\n\n    qbool = qobject_to_qbool(obj);\n\n    fail_unless(qbool_get_int(qbool) != 0);\n\n\n\n    str = qobject_to_json(obj);\n\n    fail_unless(strcmp(qstring_get_str(str), \"true\") == 0);\n\n    QDECREF(str);\n\n\n\n    QDECREF(qbool);\n\n\n\n    obj = qobject_from_json(\"false\");\n\n    fail_unless(obj != NULL);\n\n    fail_unless(qobject_type(obj) == QTYPE_QBOOL);\n\n\n\n    qbool = qobject_to_qbool(obj);\n\n    fail_unless(qbool_get_int(qbool) == 0);\n\n\n\n    str = qobject_to_json(obj);\n\n    fail_unless(strcmp(qstring_get_str(str), \"false\") == 0);\n\n    QDECREF(str);\n\n\n\n    QDECREF(qbool);\n\n\n\n    obj = qobject_from_jsonf(\"%i\", false);\n\n    fail_unless(obj != NULL);\n\n    fail_unless(qobject_type(obj) == QTYPE_QBOOL);\n\n\n\n    qbool = qobject_to_qbool(obj);\n\n    fail_unless(qbool_get_int(qbool) == 0);\n\n\n\n    QDECREF(qbool);\n\n    \n\n    obj = qobject_from_jsonf(\"%i\", true);\n\n    fail_unless(obj != NULL);\n\n    fail_unless(qobject_type(obj) == QTYPE_QBOOL);\n\n\n\n    qbool = qobject_to_qbool(obj);\n\n    fail_unless(qbool_get_int(qbool) != 0);\n\n\n\n    QDECREF(qbool);\n\n}\n", "idx": 5290}
{"project": "qemu", "commit_id": "016d2e1dfa21b64a524d3629fdd317d4c25bc3b8", "target": 1, "func": "long do_rt_sigreturn(CPUAlphaState *env)\n\n{\n\n    abi_ulong frame_addr = env->ir[IR_A0];\n\n    struct target_rt_sigframe *frame;\n\n    sigset_t set;\n\n\n\n    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1)) {\n\n        goto badframe;\n\n    }\n\n    target_to_host_sigset(&set, &frame->uc.tuc_sigmask);\n\n    do_sigprocmask(SIG_SETMASK, &set, NULL);\n\n\n\n    if (restore_sigcontext(env, &frame->uc.tuc_mcontext)) {\n\n        goto badframe;\n\n    }\n\n    if (do_sigaltstack(frame_addr + offsetof(struct target_rt_sigframe,\n\n                                             uc.tuc_stack),\n\n                       0, env->ir[IR_SP]) == -EFAULT) {\n\n        goto badframe;\n\n    }\n\n\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    return env->ir[IR_V0];\n\n\n\n\n\n badframe:\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    force_sig(TARGET_SIGSEGV);\n\n}\n", "idx": 5359}
{"project": "qemu", "commit_id": "9bcec938aab22a1b7ced916a6895e5029d4ed04f", "target": 1, "func": "void apic_reset_irq_delivered(void)\n\n{\n\n    trace_apic_reset_irq_delivered(apic_irq_delivered);\n\n\n\n    apic_irq_delivered = 0;\n\n}\n", "idx": 5402}
{"project": "FFmpeg", "commit_id": "636ced8e1dc8248a1353b416240b93d70ad03edb", "target": 1, "func": "static void do_streamcopy(InputStream *ist, OutputStream *ost, const AVPacket *pkt)\n\n{\n\n    OutputFile *of = output_files[ost->file_index];\n\n    int64_t ost_tb_start_time = av_rescale_q(of->start_time, AV_TIME_BASE_Q, ost->st->time_base);\n\n    AVPacket opkt;\n\n\n\n    av_init_packet(&opkt);\n\n\n\n    if ((!ost->frame_number && !(pkt->flags & AV_PKT_FLAG_KEY)) &&\n\n        !ost->copy_initial_nonkeyframes)\n\n        return;\n\n\n\n    if (of->recording_time != INT64_MAX &&\n\n        ist->last_dts >= of->recording_time + of->start_time) {\n\n        ost->finished = 1;\n\n        return;\n\n    }\n\n\n\n    /* force the input stream PTS */\n\n    if (ost->st->codec->codec_type == AVMEDIA_TYPE_AUDIO)\n\n        audio_size += pkt->size;\n\n    else if (ost->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n        video_size += pkt->size;\n\n        ost->sync_opts++;\n\n    }\n\n\n\n    if (pkt->pts != AV_NOPTS_VALUE)\n\n        opkt.pts = av_rescale_q(pkt->pts, ist->st->time_base, ost->st->time_base) - ost_tb_start_time;\n\n    else\n\n        opkt.pts = AV_NOPTS_VALUE;\n\n\n\n    if (pkt->dts == AV_NOPTS_VALUE)\n\n        opkt.dts = av_rescale_q(ist->last_dts, AV_TIME_BASE_Q, ost->st->time_base);\n\n    else\n\n        opkt.dts = av_rescale_q(pkt->dts, ist->st->time_base, ost->st->time_base);\n\n    opkt.dts -= ost_tb_start_time;\n\n\n\n    opkt.duration = av_rescale_q(pkt->duration, ist->st->time_base, ost->st->time_base);\n\n    opkt.flags    = pkt->flags;\n\n\n\n    // FIXME remove the following 2 lines they shall be replaced by the bitstream filters\n\n    if (  ost->st->codec->codec_id != AV_CODEC_ID_H264\n\n       && ost->st->codec->codec_id != AV_CODEC_ID_MPEG1VIDEO\n\n       && ost->st->codec->codec_id != AV_CODEC_ID_MPEG2VIDEO\n\n       && ost->st->codec->codec_id != AV_CODEC_ID_VC1\n\n       ) {\n\n        if (av_parser_change(ist->st->parser, ost->st->codec, &opkt.data, &opkt.size, pkt->data, pkt->size, pkt->flags & AV_PKT_FLAG_KEY)) {\n\n            opkt.buf = av_buffer_create(opkt.data, opkt.size, av_buffer_default_free, NULL, 0);\n\n            if (!opkt.buf)\n\n                exit(1);\n\n        }\n\n    } else {\n\n        opkt.data = pkt->data;\n\n        opkt.size = pkt->size;\n\n    }\n\n\n\n    write_frame(of->ctx, &opkt, ost);\n\n    ost->st->codec->frame_number++;\n\n}\n", "idx": 5503}
{"project": "qemu", "commit_id": "f3a06403b82c7f036564e4caf18b52ce6885fcfb", "target": 1, "func": "struct GuestAgentInfo *qmp_guest_info(Error **errp)\n\n{\n\n    GuestAgentInfo *info = g_malloc0(sizeof(GuestAgentInfo));\n\n\n\n    info->version = g_strdup(QEMU_VERSION);\n\n    qmp_for_each_command(qmp_command_info, info);\n\n    return info;\n\n}\n", "idx": 5510}
{"project": "qemu", "commit_id": "550830f9351291c585c963204ad9127998b1c1ce", "target": 0, "func": "static int cow_test_bit(int64_t bitnum, const uint8_t *bitmap)\n\n{\n\n    return (bitmap[bitnum / 8] & (1 << (bitnum & 7))) != 0;\n\n}\n", "idx": 5566}
{"project": "FFmpeg", "commit_id": "75ef6898846fb14dd47691cad6ce8850c9106723", "target": 1, "func": "static FFPsyWindowInfo psy_3gpp_window(FFPsyContext *ctx,\n\n                                       const int16_t *audio, const int16_t *la,\n\n                                       int channel, int prev_type)\n\n{\n\n    int i, j;\n\n    int br               = ctx->avctx->bit_rate / ctx->avctx->channels;\n\n    int attack_ratio     = br <= 16000 ? 18 : 10;\n\n    Psy3gppContext *pctx = (Psy3gppContext*) ctx->model_priv_data;\n\n    Psy3gppChannel *pch  = &pctx->ch[channel];\n\n    uint8_t grouping     = 0;\n\n    FFPsyWindowInfo wi;\n\n\n\n    memset(&wi, 0, sizeof(wi));\n\n    if (la) {\n\n        float s[8], v;\n\n        int switch_to_eight = 0;\n\n        float sum = 0.0, sum2 = 0.0;\n\n        int attack_n = 0;\n\n        for (i = 0; i < 8; i++) {\n\n            for (j = 0; j < 128; j++) {\n\n                v = iir_filter(la[(i*128+j)*ctx->avctx->channels], pch->iir_state);\n\n                sum += v*v;\n\n            }\n\n            s[i]  = sum;\n\n            sum2 += sum;\n\n        }\n\n        for (i = 0; i < 8; i++) {\n\n            if (s[i] > pch->win_energy * attack_ratio) {\n\n                attack_n        = i + 1;\n\n                switch_to_eight = 1;\n\n                break;\n\n            }\n\n        }\n\n        pch->win_energy = pch->win_energy*7/8 + sum2/64;\n\n\n\n        wi.window_type[1] = prev_type;\n\n        switch (prev_type) {\n\n        case ONLY_LONG_SEQUENCE:\n\n            wi.window_type[0] = switch_to_eight ? LONG_START_SEQUENCE : ONLY_LONG_SEQUENCE;\n\n            break;\n\n        case LONG_START_SEQUENCE:\n\n            wi.window_type[0] = EIGHT_SHORT_SEQUENCE;\n\n            grouping = pch->next_grouping;\n\n            break;\n\n        case LONG_STOP_SEQUENCE:\n\n            wi.window_type[0] = ONLY_LONG_SEQUENCE;\n\n            break;\n\n        case EIGHT_SHORT_SEQUENCE:\n\n            wi.window_type[0] = switch_to_eight ? EIGHT_SHORT_SEQUENCE : LONG_STOP_SEQUENCE;\n\n            grouping = switch_to_eight ? pch->next_grouping : 0;\n\n            break;\n\n        }\n\n        pch->next_grouping = window_grouping[attack_n];\n\n    } else {\n\n        for (i = 0; i < 3; i++)\n\n            wi.window_type[i] = prev_type;\n\n        grouping = (prev_type == EIGHT_SHORT_SEQUENCE) ? window_grouping[0] : 0;\n\n    }\n\n\n\n    wi.window_shape   = 1;\n\n    if (wi.window_type[0] != EIGHT_SHORT_SEQUENCE) {\n\n        wi.num_windows = 1;\n\n        wi.grouping[0] = 1;\n\n    } else {\n\n        int lastgrp = 0;\n\n        wi.num_windows = 8;\n\n        for (i = 0; i < 8; i++) {\n\n            if (!((grouping >> i) & 1))\n\n                lastgrp = i;\n\n            wi.grouping[lastgrp]++;\n\n        }\n\n    }\n\n\n\n    return wi;\n\n}\n", "idx": 5611}
{"project": "qemu", "commit_id": "27a69bb088bee6d4efea254659422fb9c751b3c7", "target": 0, "func": "static inline void gen_evfsneg(DisasContext *ctx)\n\n{\n\n    if (unlikely(!ctx->spe_enabled)) {\n\n        gen_exception(ctx, POWERPC_EXCP_APU);\n\n        return;\n\n    }\n\n#if defined(TARGET_PPC64)\n\n    tcg_gen_xori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000080000000LL);\n\n#else\n\n    tcg_gen_xori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x80000000);\n\n    tcg_gen_xori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);\n\n#endif\n\n}\n", "idx": 5640}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "void aio_set_event_notifier_poll(AioContext *ctx,\n\n                                 EventNotifier *notifier,\n\n                                 EventNotifierHandler *io_poll_begin,\n\n                                 EventNotifierHandler *io_poll_end)\n\n{\n\n    aio_set_fd_poll(ctx, event_notifier_get_fd(notifier),\n\n                    (IOHandler *)io_poll_begin,\n\n                    (IOHandler *)io_poll_end);\n\n}\n", "idx": 5674}
{"project": "FFmpeg", "commit_id": "f015e411d78d9e9ae179170beafe4951b778ac50", "target": 1, "func": "static int amr_read_packet(AVFormatContext *s,\n\n                          AVPacket *pkt)\n\n{\n\n    AVCodecContext *enc = s->streams[0]->codec;\n\n    int read, size, toc, mode;\n\n\n\n    if (url_feof(&s->pb))\n\n    {\n\n        return AVERROR_IO;\n\n    }\n\n\n\n//FIXME this is wrong, this should rather be in a AVParset\n\n    toc=get_byte(&s->pb);\n\n    mode = (toc >> 3) & 0x0F;\n\n\n\n    if (enc->codec_id == CODEC_ID_AMR_NB)\n\n    {\n\n        static const uint8_t packed_size[16] = {12, 13, 15, 17, 19, 20, 26, 31, 5, 0, 0, 0, 0, 0, 0, 0};\n\n\n\n        size=packed_size[mode]+1;\n\n    }\n\n    else if(enc->codec_id == CODEC_ID_AMR_WB)\n\n    {\n\n        static uint8_t packed_size[16] = {18, 24, 33, 37, 41, 47, 51, 59, 61, 6, 6, 0, 0, 0, 1, 1};\n\n\n\n        size=packed_size[mode];\n\n    }\n\n    else\n\n    {\n\n        assert(0);\n\n    }\n\n\n\n    if ( (size==0) || av_new_packet(pkt, size))\n\n    {\n\n        return AVERROR_IO;\n\n    }\n\n\n\n    pkt->stream_index = 0;\n\n    pkt->pos= url_ftell(&s->pb);\n\n    pkt->data[0]=toc;\n\n    pkt->duration= enc->codec_id == CODEC_ID_AMR_NB ? 160 : 320;\n\n    read = get_buffer(&s->pb, pkt->data+1, size-1);\n\n\n\n    if (read != size-1)\n\n    {\n\n        av_free_packet(pkt);\n\n        return AVERROR_IO;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 5715}
{"project": "FFmpeg", "commit_id": "559fd1e79524ca47efde195e28feb4499dd48761", "target": 1, "func": "static int nut_read_packet(AVFormatContext *s, AVPacket *pkt)\n\n{\n\n    NUTContext *nut = s->priv_data;\n\n    ByteIOContext *bc = &s->pb;\n\n    int i, frame_code=0, ret, skip;\n\n    int64_t ts, back_ptr;\n\n\n\n    for(;;){\n\n        int64_t pos= url_ftell(bc);\n\n        uint64_t tmp= nut->next_startcode;\n\n        nut->next_startcode=0;\n\n\n\n        if (url_feof(bc))\n\n            return -1;\n\n\n\n        if(tmp){\n\n            pos-=8;\n\n        }else{\n\n            frame_code = get_byte(bc);\n\n            if(frame_code == 'N'){\n\n                tmp= frame_code;\n\n                for(i=1; i<8; i++)\n\n                    tmp = (tmp<<8) + get_byte(bc);\n\n            }\n\n        }\n\n        switch(tmp){\n\n        case MAIN_STARTCODE:\n\n        case STREAM_STARTCODE:\n\n        case INDEX_STARTCODE:\n\n            skip= get_packetheader(nut, bc, 0);\n\n            url_fseek(bc, skip, SEEK_CUR);\n\n            break;\n\n        case INFO_STARTCODE:\n\n            if(decode_info_header(nut)<0)\n\n                goto resync;\n\n            break;\n\n        case SYNCPOINT_STARTCODE:\n\n            if(decode_syncpoint(nut, &ts, &back_ptr)<0)\n\n                goto resync;\n\n            frame_code = get_byte(bc);\n\n        case 0:\n\n            ret= decode_frame(nut, pkt, frame_code);\n\n            if(ret==0)\n\n                return 0;\n\n            else if(ret==1) //ok but discard packet\n\n                break;\n\n        default:\n\nresync:\n\nav_log(s, AV_LOG_DEBUG, \"syncing from %\"PRId64\"\\n\", pos);\n\n            tmp= find_any_startcode(bc, nut->last_syncpoint_pos+1);\n\n            if(tmp==0)\n\n                return -1;\n\nav_log(s, AV_LOG_DEBUG, \"sync\\n\");\n\n            nut->next_startcode= tmp;\n\n        }\n\n    }\n\n}\n", "idx": 5741}
{"project": "FFmpeg", "commit_id": "edcc51fb8e15b704955d742559215697598927bb", "target": 1, "func": "static int add_metadata(int count, int type,\n\n                        const char *name, const char *sep, TiffContext *s)\n\n{\n\n    switch(type) {\n\n    case TIFF_DOUBLE: return add_doubles_metadata(count, name, sep, s);\n\n    case TIFF_SHORT : return add_shorts_metadata(count, name, sep, s);\n\n    case TIFF_STRING: return add_string_metadata(count, name, s);\n\n    default         : return AVERROR_INVALIDDATA;\n\n    };\n\n}\n", "idx": 5847}
{"project": "qemu", "commit_id": "ddcb73b7782cb6104479503faea04cc224f982b5", "target": 1, "func": "e1000_receive(NetClientState *nc, const uint8_t *buf, size_t size)\n\n{\n\n    E1000State *s = qemu_get_nic_opaque(nc);\n\n    struct e1000_rx_desc desc;\n\n    dma_addr_t base;\n\n    unsigned int n, rdt;\n\n    uint32_t rdh_start;\n\n    uint16_t vlan_special = 0;\n\n    uint8_t vlan_status = 0, vlan_offset = 0;\n\n    uint8_t min_buf[MIN_BUF_SIZE];\n\n    size_t desc_offset;\n\n    size_t desc_size;\n\n    size_t total_size;\n\n\n\n    if (!(s->mac_reg[RCTL] & E1000_RCTL_EN))\n\n        return -1;\n\n\n\n    /* Pad to minimum Ethernet frame length */\n\n    if (size < sizeof(min_buf)) {\n\n        memcpy(min_buf, buf, size);\n\n        memset(&min_buf[size], 0, sizeof(min_buf) - size);\n\n        buf = min_buf;\n\n        size = sizeof(min_buf);\n\n    }\n\n\n\n    /* Discard oversized packets if !LPE and !SBP. */\n\n    if ((size > MAXIMUM_ETHERNET_LPE_SIZE ||\n\n        (size > MAXIMUM_ETHERNET_VLAN_SIZE\n\n        && !(s->mac_reg[RCTL] & E1000_RCTL_LPE)))\n\n        && !(s->mac_reg[RCTL] & E1000_RCTL_SBP)) {\n\n        return size;\n\n    }\n\n\n\n    if (!receive_filter(s, buf, size))\n\n        return size;\n\n\n\n    if (vlan_enabled(s) && is_vlan_packet(s, buf)) {\n\n        vlan_special = cpu_to_le16(be16_to_cpup((uint16_t *)(buf + 14)));\n\n        memmove((uint8_t *)buf + 4, buf, 12);\n\n        vlan_status = E1000_RXD_STAT_VP;\n\n        vlan_offset = 4;\n\n        size -= 4;\n\n    }\n\n\n\n    rdh_start = s->mac_reg[RDH];\n\n    desc_offset = 0;\n\n    total_size = size + fcs_len(s);\n\n    if (!e1000_has_rxbufs(s, total_size)) {\n\n            set_ics(s, 0, E1000_ICS_RXO);\n\n            return -1;\n\n    }\n\n    do {\n\n        desc_size = total_size - desc_offset;\n\n        if (desc_size > s->rxbuf_size) {\n\n            desc_size = s->rxbuf_size;\n\n        }\n\n        base = rx_desc_base(s) + sizeof(desc) * s->mac_reg[RDH];\n\n        pci_dma_read(&s->dev, base, &desc, sizeof(desc));\n\n        desc.special = vlan_special;\n\n        desc.status |= (vlan_status | E1000_RXD_STAT_DD);\n\n        if (desc.buffer_addr) {\n\n            if (desc_offset < size) {\n\n                size_t copy_size = size - desc_offset;\n\n                if (copy_size > s->rxbuf_size) {\n\n                    copy_size = s->rxbuf_size;\n\n                }\n\n                pci_dma_write(&s->dev, le64_to_cpu(desc.buffer_addr),\n\n                              buf + desc_offset + vlan_offset, copy_size);\n\n            }\n\n            desc_offset += desc_size;\n\n            desc.length = cpu_to_le16(desc_size);\n\n            if (desc_offset >= total_size) {\n\n                desc.status |= E1000_RXD_STAT_EOP | E1000_RXD_STAT_IXSM;\n\n            } else {\n\n                /* Guest zeroing out status is not a hardware requirement.\n\n                   Clear EOP in case guest didn't do it. */\n\n                desc.status &= ~E1000_RXD_STAT_EOP;\n\n            }\n\n        } else { // as per intel docs; skip descriptors with null buf addr\n\n            DBGOUT(RX, \"Null RX descriptor!!\\n\");\n\n        }\n\n        pci_dma_write(&s->dev, base, &desc, sizeof(desc));\n\n\n\n        if (++s->mac_reg[RDH] * sizeof(desc) >= s->mac_reg[RDLEN])\n\n            s->mac_reg[RDH] = 0;\n\n        /* see comment in start_xmit; same here */\n\n        if (s->mac_reg[RDH] == rdh_start) {\n\n            DBGOUT(RXERR, \"RDH wraparound @%x, RDT %x, RDLEN %x\\n\",\n\n                   rdh_start, s->mac_reg[RDT], s->mac_reg[RDLEN]);\n\n            set_ics(s, 0, E1000_ICS_RXO);\n\n            return -1;\n\n        }\n\n    } while (desc_offset < total_size);\n\n\n\n    s->mac_reg[GPRC]++;\n\n    s->mac_reg[TPR]++;\n\n    /* TOR - Total Octets Received:\n\n     * This register includes bytes received in a packet from the <Destination\n\n     * Address> field through the <CRC> field, inclusively.\n\n     */\n\n    n = s->mac_reg[TORL] + size + /* Always include FCS length. */ 4;\n\n    if (n < s->mac_reg[TORL])\n\n        s->mac_reg[TORH]++;\n\n    s->mac_reg[TORL] = n;\n\n\n\n    n = E1000_ICS_RXT0;\n\n    if ((rdt = s->mac_reg[RDT]) < s->mac_reg[RDH])\n\n        rdt += s->mac_reg[RDLEN] / sizeof(desc);\n\n    if (((rdt - s->mac_reg[RDH]) * sizeof(desc)) <= s->mac_reg[RDLEN] >>\n\n        s->rxbuf_min_shift)\n\n        n |= E1000_ICS_RXDMT0;\n\n\n\n    set_ics(s, 0, n);\n\n\n\n    return size;\n\n}\n", "idx": 5852}
{"project": "FFmpeg", "commit_id": "655b6dcb34b25d591e15ede17673ea6cb8074711", "target": 0, "func": "real_parse_asm_rule(AVStream *st, const char *p, const char *end)\n\n{\n\n    do {\n\n        /* can be either averagebandwidth= or AverageBandwidth= */\n\n#if AV_HAVE_INCOMPATIBLE_LIBAV_ABI\n\n        if (sscanf(p, \" %*1[Aa]verage%*1[Bb]andwidth=%d\", &st->codec->bit_rate) == 1)\n\n#else\n\n        if (sscanf(p, \" %*1[Aa]verage%*1[Bb]andwidth=%\"SCNd64, &st->codec->bit_rate) == 1)\n\n#endif\n\n            break;\n\n        if (!(p = strchr(p, ',')) || p > end)\n\n            p = end;\n\n        p++;\n\n    } while (p < end);\n\n}\n", "idx": 5860}
{"project": "qemu", "commit_id": "09aaa1602f9381c0e0fb539390b1793e51bdfc7b", "target": 1, "func": "int select_watchdog(const char *p)\n\n{\n\n    WatchdogTimerModel *model;\n\n\n\n    if (watchdog) {\n\n        fprintf(stderr,\n\n                 \"qemu: only one watchdog option may be given\\n\");\n\n        return 1;\n\n    }\n\n\n\n    /* -watchdog ? lists available devices and exits cleanly. */\n\n    if (strcmp(p, \"?\") == 0) {\n\n        LIST_FOREACH(model, &watchdog_list, entry) {\n\n            fprintf(stderr, \"\\t%s\\t%s\\n\",\n\n                     model->wdt_name, model->wdt_description);\n\n        }\n\n        return 2;\n\n    }\n\n\n\n    LIST_FOREACH(model, &watchdog_list, entry) {\n\n        if (strcasecmp(model->wdt_name, p) == 0) {\n\n            watchdog = model;\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    fprintf(stderr, \"Unknown -watchdog device. Supported devices are:\\n\");\n\n    LIST_FOREACH(model, &watchdog_list, entry) {\n\n        fprintf(stderr, \"\\t%s\\t%s\\n\",\n\n                 model->wdt_name, model->wdt_description);\n\n    }\n\n    return 1;\n\n}\n", "idx": 5867}
{"project": "FFmpeg", "commit_id": "e72d2d12216844a692d7211f97abfbc1867fb01d", "target": 1, "func": "static int vp3_decode_frame(AVCodecContext *avctx,\n\n                            void *data, int *data_size,\n\n                            AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    Vp3DecodeContext *s = avctx->priv_data;\n\n    GetBitContext gb;\n\n    static int counter = 0;\n\n    int i;\n\n\n\n    init_get_bits(&gb, buf, buf_size * 8);\n\n\n\n    if (s->theora && get_bits1(&gb))\n\n    {\n\n        av_log(avctx, AV_LOG_ERROR, \"Header packet passed to frame decoder, skipping\\n\");\n\n        return -1;\n\n    }\n\n\n\n    s->keyframe = !get_bits1(&gb);\n\n    if (!s->theora)\n\n        skip_bits(&gb, 1);\n\n    for (i = 0; i < 3; i++)\n\n        s->last_qps[i] = s->qps[i];\n\n\n\n    s->nqps=0;\n\n    do{\n\n        s->qps[s->nqps++]= get_bits(&gb, 6);\n\n    } while(s->theora >= 0x030200 && s->nqps<3 && get_bits1(&gb));\n\n    for (i = s->nqps; i < 3; i++)\n\n        s->qps[i] = -1;\n\n\n\n    if (s->avctx->debug & FF_DEBUG_PICT_INFO)\n\n        av_log(s->avctx, AV_LOG_INFO, \" VP3 %sframe #%d: Q index = %d\\n\",\n\n            s->keyframe?\"key\":\"\", counter, s->qps[0]);\n\n    counter++;\n\n\n\n    if (s->qps[0] != s->last_qps[0])\n\n        init_loop_filter(s);\n\n\n\n    for (i = 0; i < s->nqps; i++)\n\n        // reinit all dequantizers if the first one changed, because\n\n        // the DC of the first quantizer must be used for all matrices\n\n        if (s->qps[i] != s->last_qps[i] || s->qps[0] != s->last_qps[0])\n\n            init_dequantizer(s, i);\n\n\n\n    if (avctx->skip_frame >= AVDISCARD_NONKEY && !s->keyframe)\n\n        return buf_size;\n\n\n\n    s->current_frame.reference = 3;\n\n    if (avctx->get_buffer(avctx, &s->current_frame) < 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (s->keyframe) {\n\n        if (!s->theora)\n\n        {\n\n            skip_bits(&gb, 4); /* width code */\n\n            skip_bits(&gb, 4); /* height code */\n\n            if (s->version)\n\n            {\n\n                s->version = get_bits(&gb, 5);\n\n                if (counter == 1)\n\n                    av_log(s->avctx, AV_LOG_DEBUG, \"VP version: %d\\n\", s->version);\n\n            }\n\n        }\n\n        if (s->version || s->theora)\n\n        {\n\n                if (get_bits1(&gb))\n\n                    av_log(s->avctx, AV_LOG_ERROR, \"Warning, unsupported keyframe coding type?!\\n\");\n\n            skip_bits(&gb, 2); /* reserved? */\n\n        }\n\n    } else {\n\n        if (!s->golden_frame.data[0]) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"vp3: first frame not a keyframe\\n\");\n\n            avctx->release_buffer(avctx, &s->current_frame);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    s->current_frame.qscale_table= s->qscale_table; //FIXME allocate individual tables per AVFrame\n\n    s->current_frame.qstride= 0;\n\n\n\n    init_frame(s, &gb);\n\n\n\n    if (unpack_superblocks(s, &gb)){\n\n        av_log(s->avctx, AV_LOG_ERROR, \"error in unpack_superblocks\\n\");\n\n        return -1;\n\n    }\n\n    if (unpack_modes(s, &gb)){\n\n        av_log(s->avctx, AV_LOG_ERROR, \"error in unpack_modes\\n\");\n\n        return -1;\n\n    }\n\n    if (unpack_vectors(s, &gb)){\n\n        av_log(s->avctx, AV_LOG_ERROR, \"error in unpack_vectors\\n\");\n\n        return -1;\n\n    }\n\n    if (unpack_block_qpis(s, &gb)){\n\n        av_log(s->avctx, AV_LOG_ERROR, \"error in unpack_block_qpis\\n\");\n\n        return -1;\n\n    }\n\n    if (unpack_dct_coeffs(s, &gb)){\n\n        av_log(s->avctx, AV_LOG_ERROR, \"error in unpack_dct_coeffs\\n\");\n\n        return -1;\n\n    }\n\n\n\n    for (i = 0; i < 3; i++) {\n\n        if (s->flipped_image)\n\n            s->data_offset[i] = 0;\n\n        else\n\n            s->data_offset[i] = ((s->height>>!!i)-1) * s->current_frame.linesize[i];\n\n    }\n\n\n\n    s->last_slice_end = 0;\n\n    for (i = 0; i < s->c_superblock_height; i++)\n\n        render_slice(s, i);\n\n\n\n    // filter the last row\n\n    for (i = 0; i < 3; i++) {\n\n        int row = (s->height >> (3+!!i)) - 1;\n\n        apply_loop_filter(s, i, row, row+1);\n\n    }\n\n    vp3_draw_horiz_band(s, s->height);\n\n\n\n    *data_size=sizeof(AVFrame);\n\n    *(AVFrame*)data= s->current_frame;\n\n\n\n    /* release the last frame, if it is allocated and if it is not the\n\n     * golden frame */\n\n    if ((s->last_frame.data[0]) &&\n\n        (s->last_frame.data[0] != s->golden_frame.data[0]))\n\n        avctx->release_buffer(avctx, &s->last_frame);\n\n\n\n    /* shuffle frames (last = current) */\n\n    s->last_frame= s->current_frame;\n\n\n\n    if (s->keyframe) {\n\n        if (s->golden_frame.data[0])\n\n            avctx->release_buffer(avctx, &s->golden_frame);\n\n        s->golden_frame = s->current_frame;\n\n    }\n\n\n\n    s->current_frame.data[0]= NULL; /* ensure that we catch any access to this released frame */\n\n\n\n    return buf_size;\n\n}\n", "idx": 5869}
{"project": "qemu", "commit_id": "2f9606b3736c3be4dbd606c46525c7b770ced119", "target": 1, "func": "static char *vnc_socket_remote_addr(const char *format, int fd) {\n\n    struct sockaddr_storage sa;\n\n    socklen_t salen;\n\n\n\n    salen = sizeof(sa);\n\n    if (getpeername(fd, (struct sockaddr*)&sa, &salen) < 0)\n\n        return NULL;\n\n\n\n    return addr_to_string(format, &sa, salen);\n\n}\n", "idx": 5913}
{"project": "qemu", "commit_id": "e9db8ff38e539260a2cb5a7918d1155b7d92a264", "target": 1, "func": "static int qemu_gluster_open(BlockDriverState *bs,  QDict *options,\n\n                             int bdrv_flags, Error **errp)\n\n{\n\n    BDRVGlusterState *s = bs->opaque;\n\n    int open_flags = 0;\n\n    int ret = 0;\n\n    BlockdevOptionsGluster *gconf = NULL;\n\n    QemuOpts *opts;\n\n    Error *local_err = NULL;\n\n    const char *filename;\n\n\n\n    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);\n\n    qemu_opts_absorb_qdict(opts, options, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    filename = qemu_opt_get(opts, GLUSTER_OPT_FILENAME);\n\n\n\n    s->debug_level = qemu_opt_get_number(opts, GLUSTER_OPT_DEBUG,\n\n                                         GLUSTER_DEBUG_DEFAULT);\n\n    if (s->debug_level < 0) {\n\n        s->debug_level = 0;\n\n    } else if (s->debug_level > GLUSTER_DEBUG_MAX) {\n\n        s->debug_level = GLUSTER_DEBUG_MAX;\n\n    }\n\n\n\n    gconf = g_new0(BlockdevOptionsGluster, 1);\n\n    gconf->debug_level = s->debug_level;\n\n    gconf->has_debug_level = true;\n\n    s->glfs = qemu_gluster_init(gconf, filename, options, errp);\n\n    if (!s->glfs) {\n\n        ret = -errno;\n\n        goto out;\n\n    }\n\n\n\n#ifdef CONFIG_GLUSTERFS_XLATOR_OPT\n\n    /* Without this, if fsync fails for a recoverable reason (for instance,\n\n     * ENOSPC), gluster will dump its cache, preventing retries.  This means\n\n     * almost certain data loss.  Not all gluster versions support the\n\n     * 'resync-failed-syncs-after-fsync' key value, but there is no way to\n\n     * discover during runtime if it is supported (this api returns success for\n\n     * unknown key/value pairs) */\n\n    ret = glfs_set_xlator_option(s->glfs, \"*-write-behind\",\n\n                                          \"resync-failed-syncs-after-fsync\",\n\n                                          \"on\");\n\n    if (ret < 0) {\n\n        error_setg_errno(errp, errno, \"Unable to set xlator key/value pair\");\n\n        ret = -errno;\n\n        goto out;\n\n    }\n\n#endif\n\n\n\n    qemu_gluster_parse_flags(bdrv_flags, &open_flags);\n\n\n\n    s->fd = glfs_open(s->glfs, gconf->path, open_flags);\n\n    if (!s->fd) {\n\n        ret = -errno;\n\n    }\n\n\n\n    s->supports_seek_data = qemu_gluster_test_seek(s->fd);\n\n\n\nout:\n\n    qemu_opts_del(opts);\n\n    qapi_free_BlockdevOptionsGluster(gconf);\n\n    if (!ret) {\n\n        return ret;\n\n    }\n\n    if (s->fd) {\n\n        glfs_close(s->fd);\n\n    }\n\n    if (s->glfs) {\n\n        glfs_fini(s->glfs);\n\n    }\n\n    return ret;\n\n}\n", "idx": 5915}
{"project": "qemu", "commit_id": "3604a76fea6ff37738d4a8f596be38407be74a83", "target": 1, "func": "static void dec_wcsr(DisasContext *dc)\n\n{\n\n    int no;\n\n\n\n    LOG_DIS(\"wcsr r%d, %d\\n\", dc->r1, dc->csr);\n\n\n\n    switch (dc->csr) {\n\n    case CSR_IE:\n\n        tcg_gen_mov_tl(cpu_ie, cpu_R[dc->r1]);\n\n        tcg_gen_movi_tl(cpu_pc, dc->pc + 4);\n\n        dc->is_jmp = DISAS_UPDATE;\n\n        break;\n\n    case CSR_IM:\n\n        /* mark as an io operation because it could cause an interrupt */\n\n        if (use_icount) {\n\n            gen_io_start();\n\n        }\n\n        gen_helper_wcsr_im(cpu_env, cpu_R[dc->r1]);\n\n        tcg_gen_movi_tl(cpu_pc, dc->pc + 4);\n\n        if (use_icount) {\n\n            gen_io_end();\n\n        }\n\n        dc->is_jmp = DISAS_UPDATE;\n\n        break;\n\n    case CSR_IP:\n\n        /* mark as an io operation because it could cause an interrupt */\n\n        if (use_icount) {\n\n            gen_io_start();\n\n        }\n\n        gen_helper_wcsr_ip(cpu_env, cpu_R[dc->r1]);\n\n        tcg_gen_movi_tl(cpu_pc, dc->pc + 4);\n\n        if (use_icount) {\n\n            gen_io_end();\n\n        }\n\n        dc->is_jmp = DISAS_UPDATE;\n\n        break;\n\n    case CSR_ICC:\n\n        /* TODO */\n\n        break;\n\n    case CSR_DCC:\n\n        /* TODO */\n\n        break;\n\n    case CSR_EBA:\n\n        tcg_gen_mov_tl(cpu_eba, cpu_R[dc->r1]);\n\n        break;\n\n    case CSR_DEBA:\n\n        tcg_gen_mov_tl(cpu_deba, cpu_R[dc->r1]);\n\n        break;\n\n    case CSR_JTX:\n\n        gen_helper_wcsr_jtx(cpu_env, cpu_R[dc->r1]);\n\n        break;\n\n    case CSR_JRX:\n\n        gen_helper_wcsr_jrx(cpu_env, cpu_R[dc->r1]);\n\n        break;\n\n    case CSR_DC:\n\n        tcg_gen_mov_tl(cpu_dc, cpu_R[dc->r1]);\n\n        break;\n\n    case CSR_BP0:\n\n    case CSR_BP1:\n\n    case CSR_BP2:\n\n    case CSR_BP3:\n\n        no = dc->csr - CSR_BP0;\n\n        if (dc->env->num_bps <= no) {\n\n            cpu_abort(dc->env, \"breakpoint #%i is not available\\n\", no);\n\n        }\n\n        tcg_gen_mov_tl(cpu_bp[no], cpu_R[dc->r1]);\n\n        break;\n\n    case CSR_WP0:\n\n    case CSR_WP1:\n\n    case CSR_WP2:\n\n    case CSR_WP3:\n\n        no = dc->csr - CSR_WP0;\n\n        if (dc->env->num_wps <= no) {\n\n            cpu_abort(dc->env, \"watchpoint #%i is not available\\n\", no);\n\n        }\n\n        tcg_gen_mov_tl(cpu_wp[no], cpu_R[dc->r1]);\n\n        break;\n\n    case CSR_CC:\n\n    case CSR_CFG:\n\n        cpu_abort(dc->env, \"invalid write access csr=%x\\n\", dc->csr);\n\n        break;\n\n    default:\n\n        cpu_abort(dc->env, \"write_csr unknown csr=%x\\n\", dc->csr);\n\n        break;\n\n    }\n\n}\n", "idx": 5999}
{"project": "qemu", "commit_id": "c508277335e3b6b20cf18e6ea3a35c1fa835c64a", "target": 1, "func": "vmxnet3_pop_rxc_descr(VMXNET3State *s, int qidx, uint32_t *descr_gen)\n\n{\n\n    uint8_t ring_gen;\n\n    struct Vmxnet3_RxCompDesc rxcd;\n\n\n\n    hwaddr daddr =\n\n        vmxnet3_ring_curr_cell_pa(&s->rxq_descr[qidx].comp_ring);\n\n\n\n    pci_dma_read(PCI_DEVICE(s), daddr,\n\n                 &rxcd, sizeof(struct Vmxnet3_RxCompDesc));\n\n\n\n    ring_gen = vmxnet3_ring_curr_gen(&s->rxq_descr[qidx].comp_ring);\n\n\n\n    if (rxcd.gen != ring_gen) {\n\n        *descr_gen = ring_gen;\n\n        vmxnet3_inc_rx_completion_counter(s, qidx);\n\n        return daddr;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 6027}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_mtsr(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n#else\n\n    TCGv t0;\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n        return;\n\n    }\n\n    t0 = tcg_const_tl(SR(ctx->opcode));\n\n    gen_helper_store_sr(cpu_env, t0, cpu_gpr[rS(ctx->opcode)]);\n\n    tcg_temp_free(t0);\n\n#endif\n\n}\n", "idx": 6207}
{"project": "qemu", "commit_id": "69b302b2044a9a0f6d157d25b39a91ff7124c61f", "target": 1, "func": "VirtIODevice *virtio_blk_init(DeviceState *dev, VirtIOBlkConf *blk)\n\n{\n\n    VirtIOBlock *s;\n\n    static int virtio_blk_id;\n\n\n\n    if (!blk->conf.bs) {\n\n        error_report(\"drive property not set\");\n\n        return NULL;\n\n    }\n\n    if (!bdrv_is_inserted(blk->conf.bs)) {\n\n        error_report(\"Device needs media, but drive is empty\");\n\n        return NULL;\n\n    }\n\n\n\n    blkconf_serial(&blk->conf, &blk->serial);\n\n    if (blkconf_geometry(&blk->conf, NULL, 65535, 255, 255) < 0) {\n\n        return NULL;\n\n    }\n\n\n\n    s = (VirtIOBlock *)virtio_common_init(\"virtio-blk\", VIRTIO_ID_BLOCK,\n\n                                          sizeof(struct virtio_blk_config),\n\n                                          sizeof(VirtIOBlock));\n\n\n\n    s->vdev.get_config = virtio_blk_update_config;\n\n    s->vdev.set_config = virtio_blk_set_config;\n\n    s->vdev.get_features = virtio_blk_get_features;\n\n    s->vdev.set_status = virtio_blk_set_status;\n\n    s->vdev.reset = virtio_blk_reset;\n\n    s->bs = blk->conf.bs;\n\n    s->conf = &blk->conf;\n\n    s->blk = blk;\n\n    s->rq = NULL;\n\n    s->sector_mask = (s->conf->logical_block_size / BDRV_SECTOR_SIZE) - 1;\n\n\n\n    s->vq = virtio_add_queue(&s->vdev, 128, virtio_blk_handle_output);\n\n#ifdef CONFIG_VIRTIO_BLK_DATA_PLANE\n\n    if (!virtio_blk_data_plane_create(&s->vdev, blk, &s->dataplane)) {\n\n        virtio_cleanup(&s->vdev);\n\n        return NULL;\n\n    }\n\n#endif\n\n\n\n    qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s);\n\n    s->qdev = dev;\n\n    register_savevm(dev, \"virtio-blk\", virtio_blk_id++, 2,\n\n                    virtio_blk_save, virtio_blk_load, s);\n\n    bdrv_set_dev_ops(s->bs, &virtio_block_ops, s);\n\n    bdrv_set_buffer_alignment(s->bs, s->conf->logical_block_size);\n\n\n\n    bdrv_iostatus_enable(s->bs);\n\n    add_boot_device_path(s->conf->bootindex, dev, \"/disk@0,0\");\n\n\n\n    return &s->vdev;\n\n}\n", "idx": 6361}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void a9_scu_write(void *opaque, target_phys_addr_t offset,\n\n                         uint64_t value, unsigned size)\n\n{\n\n    a9mp_priv_state *s = (a9mp_priv_state *)opaque;\n\n    uint32_t mask;\n\n    uint32_t shift;\n\n    switch (size) {\n\n    case 1:\n\n        mask = 0xff;\n\n        break;\n\n    case 2:\n\n        mask = 0xffff;\n\n        break;\n\n    case 4:\n\n        mask = 0xffffffff;\n\n        break;\n\n    default:\n\n        fprintf(stderr, \"Invalid size %u in write to a9 scu register %x\\n\",\n\n                size, (unsigned)offset);\n\n        return;\n\n    }\n\n\n\n    switch (offset) {\n\n    case 0x00: /* Control */\n\n        s->scu_control = value & 1;\n\n        break;\n\n    case 0x4: /* Configuration: RO */\n\n        break;\n\n    case 0x08: case 0x09: case 0x0A: case 0x0B: /* Power Control */\n\n        shift = (offset - 0x8) * 8;\n\n        s->scu_status &= ~(mask << shift);\n\n        s->scu_status |= ((value & mask) << shift);\n\n        break;\n\n    case 0x0c: /* Invalidate All Registers In Secure State */\n\n        /* no-op as we do not implement caches */\n\n        break;\n\n    case 0x40: /* Filtering Start Address Register */\n\n    case 0x44: /* Filtering End Address Register */\n\n        /* RAZ/WI, like an implementation with only one AXI master */\n\n        break;\n\n    case 0x50: /* SCU Access Control Register */\n\n    case 0x54: /* SCU Non-secure Access Control Register */\n\n        /* unimplemented, fall through */\n\n    default:\n\n        break;\n\n    }\n\n}\n", "idx": 6401}
{"project": "qemu", "commit_id": "6acbe4c6f18e7de00481ff30574262b58526de45", "target": 0, "func": "static void s390_virtio_net_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    VirtIOS390DeviceClass *k = VIRTIO_S390_DEVICE_CLASS(klass);\n\n\n\n    k->init = s390_virtio_net_init;\n\n    dc->props = s390_virtio_net_properties;\n\n    dc->alias = \"virtio-net\";\n\n}\n", "idx": 6404}
{"project": "qemu", "commit_id": "e537112b418306229eb74c53de93751dd7b484d0", "target": 1, "func": "static void unassign_storage(SCLPDevice *sclp, SCCB *sccb)\n\n{\n\n    MemoryRegion *mr = NULL;\n\n    AssignStorage *assign_info = (AssignStorage *) sccb;\n\n    sclpMemoryHotplugDev *mhd = get_sclp_memory_hotplug_dev();\n\n    ram_addr_t unassign_addr;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n\n\n    if (!mhd) {\n\n        sccb->h.response_code = cpu_to_be16(SCLP_RC_INVALID_SCLP_COMMAND);\n\n        return;\n\n    }\n\n    unassign_addr = (assign_info->rn - 1) * mhd->rzm;\n\n\n\n    /* if the addr is a multiple of 256 MB */\n\n    if ((unassign_addr % MEM_SECTION_SIZE == 0) &&\n\n        (unassign_addr >= mhd->padded_ram_size)) {\n\n        mhd->standby_state_map[(unassign_addr -\n\n                           mhd->padded_ram_size) / MEM_SECTION_SIZE] = 0;\n\n\n\n        /* find the specified memory region and destroy it */\n\n        mr = memory_region_find(sysmem, unassign_addr, 1).mr;\n\n        memory_region_unref(mr);\n\n        if (mr) {\n\n            int i;\n\n            int is_removable = 1;\n\n            ram_addr_t map_offset = (unassign_addr - mhd->padded_ram_size -\n\n                                     (unassign_addr - mhd->padded_ram_size)\n\n                                     % mhd->standby_subregion_size);\n\n            /* Mark all affected subregions as 'standby' once again */\n\n            for (i = 0;\n\n                 i < (mhd->standby_subregion_size / MEM_SECTION_SIZE);\n\n                 i++) {\n\n\n\n                if (mhd->standby_state_map[i + map_offset / MEM_SECTION_SIZE]) {\n\n                    is_removable = 0;\n\n                    break;\n\n                }\n\n            }\n\n            if (is_removable) {\n\n                memory_region_del_subregion(sysmem, mr);\n\n                object_unref(OBJECT(mr));\n\n            }\n\n        }\n\n    }\n\n    sccb->h.response_code = cpu_to_be16(SCLP_RC_NORMAL_COMPLETION);\n\n}\n", "idx": 6495}
{"project": "qemu", "commit_id": "45876e913e169bf156a3fc36f21eb0adf6ec3671", "target": 0, "func": "static void an5206_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    M68kCPU *cpu;\n\n    CPUM68KState *env;\n\n    int kernel_size;\n\n    uint64_t elf_entry;\n\n    hwaddr entry;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *sram = g_new(MemoryRegion, 1);\n\n\n\n    if (!cpu_model) {\n\n        cpu_model = \"m5206\";\n\n    }\n\n    cpu = M68K_CPU(cpu_generic_init(TYPE_M68K_CPU, cpu_model));\n\n    env = &cpu->env;\n\n\n\n    /* Initialize CPU registers.  */\n\n    env->vbr = 0;\n\n    /* TODO: allow changing MBAR and RAMBAR.  */\n\n    env->mbar = AN5206_MBAR_ADDR | 1;\n\n    env->rambar0 = AN5206_RAMBAR_ADDR | 1;\n\n\n\n    /* DRAM at address zero */\n\n    memory_region_allocate_system_memory(ram, NULL, \"an5206.ram\", ram_size);\n\n    memory_region_add_subregion(address_space_mem, 0, ram);\n\n\n\n    /* Internal SRAM.  */\n\n    memory_region_init_ram(sram, NULL, \"an5206.sram\", 512, &error_fatal);\n\n    memory_region_add_subregion(address_space_mem, AN5206_RAMBAR_ADDR, sram);\n\n\n\n    mcf5206_init(address_space_mem, AN5206_MBAR_ADDR, cpu);\n\n\n\n    /* Load kernel.  */\n\n    if (!kernel_filename) {\n\n        if (qtest_enabled()) {\n\n            return;\n\n        }\n\n        fprintf(stderr, \"Kernel image must be specified\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    kernel_size = load_elf(kernel_filename, NULL, NULL, &elf_entry,\n\n                           NULL, NULL, 1, EM_68K, 0, 0);\n\n    entry = elf_entry;\n\n    if (kernel_size < 0) {\n\n        kernel_size = load_uimage(kernel_filename, &entry, NULL, NULL,\n\n                                  NULL, NULL);\n\n    }\n\n    if (kernel_size < 0) {\n\n        kernel_size = load_image_targphys(kernel_filename, KERNEL_LOAD_ADDR,\n\n                                          ram_size - KERNEL_LOAD_ADDR);\n\n        entry = KERNEL_LOAD_ADDR;\n\n    }\n\n    if (kernel_size < 0) {\n\n        fprintf(stderr, \"qemu: could not load kernel '%s'\\n\", kernel_filename);\n\n        exit(1);\n\n    }\n\n\n\n    env->pc = entry;\n\n}\n", "idx": 6612}
{"project": "FFmpeg", "commit_id": "0d4a66ee7f48c65ac67f4d91c8f8f2bfd47afa0d", "target": 0, "func": "int ffio_ensure_seekback(AVIOContext *s, int buf_size)\n\n{\n\n    uint8_t *buffer;\n\n    int max_buffer_size = s->max_packet_size ?\n\n                          s->max_packet_size : IO_BUFFER_SIZE;\n\n\n\n    buf_size += s->buf_ptr - s->buffer + max_buffer_size;\n\n\n\n    if (buf_size < s->buffer_size || s->seekable)\n\n        return 0;\n\n    av_assert0(!s->write_flag);\n\n\n\n    buffer = av_malloc(buf_size);\n\n    if (!buffer)\n\n        return AVERROR(ENOMEM);\n\n\n\n    memcpy(buffer, s->buffer, s->buffer_size);\n\n    av_free(s->buffer);\n\n    s->buf_ptr = buffer + (s->buf_ptr - s->buffer);\n\n    s->buf_end = buffer + (s->buf_end - s->buffer);\n\n    s->buffer = buffer;\n\n    s->buffer_size = buf_size;\n\n    return 0;\n\n}\n", "idx": 6619}
{"project": "FFmpeg", "commit_id": "114f3f526e5ad1557c514fe1213dd87f4ebe6f6a", "target": 0, "func": "static int plot_cqt(AVFilterLink *inlink)\n\n{\n\n    AVFilterContext *ctx = inlink->dst;\n\n    ShowCQTContext *s = ctx->priv;\n\n    AVFilterLink *outlink = ctx->outputs[0];\n\n    int fft_len = 1 << s->fft_bits;\n\n    FFTSample result[VIDEO_WIDTH][4];\n\n    int x, y, ret = 0;\n\n    int linesize = s->outpicref->linesize[0];\n\n    int video_scale = s->fullhd ? 2 : 1;\n\n    int video_width = (VIDEO_WIDTH/2) * video_scale;\n\n    int spectogram_height = (SPECTOGRAM_HEIGHT/2) * video_scale;\n\n    int spectogram_start = (SPECTOGRAM_START/2) * video_scale;\n\n    int font_height = (FONT_HEIGHT/2) * video_scale;\n\n\n\n    /* real part contains left samples, imaginary part contains right samples */\n\n    memcpy(s->fft_result, s->fft_data, fft_len * sizeof(*s->fft_data));\n\n    av_fft_permute(s->fft_context, s->fft_result);\n\n    av_fft_calc(s->fft_context, s->fft_result);\n\n    s->fft_result[fft_len] = s->fft_result[0];\n\n\n\n    /* calculating cqt */\n\n    for (x = 0; x < VIDEO_WIDTH; x++) {\n\n        int u;\n\n        FFTComplex v = {0,0};\n\n        FFTComplex w = {0,0};\n\n        FFTComplex l, r;\n\n\n\n        for (u = 0; u < s->coeffs[x].len; u++) {\n\n            FFTSample value = s->coeffs[x].values[u];\n\n            int index = s->coeffs[x].start + u;\n\n            v.re += value * s->fft_result[index].re;\n\n            v.im += value * s->fft_result[index].im;\n\n            w.re += value * s->fft_result[fft_len - index].re;\n\n            w.im += value * s->fft_result[fft_len - index].im;\n\n        }\n\n\n\n        /* separate left and right, (and multiply by 2.0) */\n\n        l.re = v.re + w.re;\n\n        l.im = v.im - w.im;\n\n        r.re = w.im + v.im;\n\n        r.im = w.re - v.re;\n\n        /* result is power, not amplitude */\n\n        result[x][0] = l.re * l.re + l.im * l.im;\n\n        result[x][2] = r.re * r.re + r.im * r.im;\n\n        result[x][1] = 0.5f * (result[x][0] + result[x][2]);\n\n\n\n        if (s->gamma2 == 1.0f)\n\n            result[x][3] = result[x][1];\n\n        else if (s->gamma2 == 2.0f)\n\n            result[x][3] = sqrtf(result[x][1]);\n\n        else if (s->gamma2 == 3.0f)\n\n            result[x][3] = cbrtf(result[x][1]);\n\n        else if (s->gamma2 == 4.0f)\n\n            result[x][3] = sqrtf(sqrtf(result[x][1]));\n\n        else\n\n            result[x][3] = expf(logf(result[x][1]) * (1.0f / s->gamma2));\n\n\n\n        result[x][0] = FFMIN(1.0f, result[x][0]);\n\n        result[x][1] = FFMIN(1.0f, result[x][1]);\n\n        result[x][2] = FFMIN(1.0f, result[x][2]);\n\n        if (s->gamma == 1.0f) {\n\n            result[x][0] = 255.0f * result[x][0];\n\n            result[x][1] = 255.0f * result[x][1];\n\n            result[x][2] = 255.0f * result[x][2];\n\n        } else if (s->gamma == 2.0f) {\n\n            result[x][0] = 255.0f * sqrtf(result[x][0]);\n\n            result[x][1] = 255.0f * sqrtf(result[x][1]);\n\n            result[x][2] = 255.0f * sqrtf(result[x][2]);\n\n        } else if (s->gamma == 3.0f) {\n\n            result[x][0] = 255.0f * cbrtf(result[x][0]);\n\n            result[x][1] = 255.0f * cbrtf(result[x][1]);\n\n            result[x][2] = 255.0f * cbrtf(result[x][2]);\n\n        } else if (s->gamma == 4.0f) {\n\n            result[x][0] = 255.0f * sqrtf(sqrtf(result[x][0]));\n\n            result[x][1] = 255.0f * sqrtf(sqrtf(result[x][1]));\n\n            result[x][2] = 255.0f * sqrtf(sqrtf(result[x][2]));\n\n        } else {\n\n            result[x][0] = 255.0f * expf(logf(result[x][0]) * (1.0f / s->gamma));\n\n            result[x][1] = 255.0f * expf(logf(result[x][1]) * (1.0f / s->gamma));\n\n            result[x][2] = 255.0f * expf(logf(result[x][2]) * (1.0f / s->gamma));\n\n        }\n\n    }\n\n\n\n    if (!s->fullhd) {\n\n        for (x = 0; x < video_width; x++) {\n\n            result[x][0] = 0.5f * (result[2*x][0] + result[2*x+1][0]);\n\n            result[x][1] = 0.5f * (result[2*x][1] + result[2*x+1][1]);\n\n            result[x][2] = 0.5f * (result[2*x][2] + result[2*x+1][2]);\n\n            result[x][3] = 0.5f * (result[2*x][3] + result[2*x+1][3]);\n\n        }\n\n    }\n\n\n\n    for (x = 0; x < video_width; x++) {\n\n        s->spectogram[s->spectogram_index*linesize + 3*x] = result[x][0] + 0.5f;\n\n        s->spectogram[s->spectogram_index*linesize + 3*x + 1] = result[x][1] + 0.5f;\n\n        s->spectogram[s->spectogram_index*linesize + 3*x + 2] = result[x][2] + 0.5f;\n\n    }\n\n\n\n    /* drawing */\n\n    if (!s->spectogram_count) {\n\n        uint8_t *data = (uint8_t*) s->outpicref->data[0];\n\n        float rcp_result[VIDEO_WIDTH];\n\n        int total_length = linesize * spectogram_height;\n\n        int back_length = linesize * s->spectogram_index;\n\n\n\n        for (x = 0; x < video_width; x++)\n\n            rcp_result[x] = 1.0f / (result[x][3]+0.0001f);\n\n\n\n        /* drawing bar */\n\n        for (y = 0; y < spectogram_height; y++) {\n\n            float height = (spectogram_height - y) * (1.0f/spectogram_height);\n\n            uint8_t *lineptr = data + y * linesize;\n\n            for (x = 0; x < video_width; x++) {\n\n                float mul;\n\n                if (result[x][3] <= height) {\n\n                    *lineptr++ = 0;\n\n                    *lineptr++ = 0;\n\n                    *lineptr++ = 0;\n\n                } else {\n\n                    mul = (result[x][3] - height) * rcp_result[x];\n\n                    *lineptr++ = mul * result[x][0] + 0.5f;\n\n                    *lineptr++ = mul * result[x][1] + 0.5f;\n\n                    *lineptr++ = mul * result[x][2] + 0.5f;\n\n                }\n\n            }\n\n        }\n\n\n\n        /* drawing font */\n\n        if (s->font_alpha && s->draw_text) {\n\n            for (y = 0; y < font_height; y++) {\n\n                uint8_t *lineptr = data + (spectogram_height + y) * linesize;\n\n                uint8_t *spectogram_src = s->spectogram + s->spectogram_index * linesize;\n\n                uint8_t *fontcolor_value = s->fontcolor_value;\n\n                for (x = 0; x < video_width; x++) {\n\n                    uint8_t alpha = s->font_alpha[y*video_width+x];\n\n                    lineptr[3*x] = (spectogram_src[3*x] * (255-alpha) + fontcolor_value[0] * alpha + 255) >> 8;\n\n                    lineptr[3*x+1] = (spectogram_src[3*x+1] * (255-alpha) + fontcolor_value[1] * alpha + 255) >> 8;\n\n                    lineptr[3*x+2] = (spectogram_src[3*x+2] * (255-alpha) + fontcolor_value[2] * alpha + 255) >> 8;\n\n                    fontcolor_value += 3;\n\n                }\n\n            }\n\n        } else if (s->draw_text) {\n\n            for (y = 0; y < font_height; y++) {\n\n                uint8_t *lineptr = data + (spectogram_height + y) * linesize;\n\n                memcpy(lineptr, s->spectogram + s->spectogram_index * linesize, video_width*3);\n\n            }\n\n            for (x = 0; x < video_width; x += video_width/10) {\n\n                int u;\n\n                static const char str[] = \"EF G A BC D \";\n\n                uint8_t *startptr = data + spectogram_height * linesize + x * 3;\n\n                for (u = 0; str[u]; u++) {\n\n                    int v;\n\n                    for (v = 0; v < 16; v++) {\n\n                        uint8_t *p = startptr + v * linesize * video_scale + 8 * 3 * u * video_scale;\n\n                        int ux = x + 8 * u * video_scale;\n\n                        int mask;\n\n                        for (mask = 0x80; mask; mask >>= 1) {\n\n                            if (mask & avpriv_vga16_font[str[u] * 16 + v]) {\n\n                                p[0] = s->fontcolor_value[3*ux];\n\n                                p[1] = s->fontcolor_value[3*ux+1];\n\n                                p[2] = s->fontcolor_value[3*ux+2];\n\n                                if (video_scale == 2) {\n\n                                    p[linesize] = p[0];\n\n                                    p[linesize+1] = p[1];\n\n                                    p[linesize+2] = p[2];\n\n                                    p[3] = p[linesize+3] = s->fontcolor_value[3*ux+3];\n\n                                    p[4] = p[linesize+4] = s->fontcolor_value[3*ux+4];\n\n                                    p[5] = p[linesize+5] = s->fontcolor_value[3*ux+5];\n\n                                }\n\n                            }\n\n                            p  += 3 * video_scale;\n\n                            ux += video_scale;\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n        } else {\n\n            for (y = 0; y < font_height; y++) {\n\n                uint8_t *lineptr = data + (spectogram_height + y) * linesize;\n\n                uint8_t *spectogram_src = s->spectogram + s->spectogram_index * linesize;\n\n                for (x = 0; x < video_width; x++) {\n\n                    lineptr[3*x] = spectogram_src[3*x];\n\n                    lineptr[3*x+1] = spectogram_src[3*x+1];\n\n                    lineptr[3*x+2] = spectogram_src[3*x+2];\n\n                }\n\n            }\n\n        }\n\n\n\n        /* drawing spectogram/sonogram */\n\n        data += spectogram_start * linesize;\n\n        memcpy(data, s->spectogram + s->spectogram_index*linesize, total_length - back_length);\n\n\n\n        data += total_length - back_length;\n\n        if (back_length)\n\n            memcpy(data, s->spectogram, back_length);\n\n\n\n        s->outpicref->pts = s->frame_count;\n\n        ret = ff_filter_frame(outlink, av_frame_clone(s->outpicref));\n\n        s->req_fullfilled = 1;\n\n        s->frame_count++;\n\n    }\n\n    s->spectogram_count = (s->spectogram_count + 1) % s->count;\n\n    s->spectogram_index = (s->spectogram_index + spectogram_height - 1) % spectogram_height;\n\n    return ret;\n\n}\n", "idx": 6632}
{"project": "FFmpeg", "commit_id": "a8de60ba2740185c53cabbee6c00ed67a0d530e2", "target": 1, "func": "static void tqi_calculate_qtable(TqiContext *t, int quant)\n\n{\n\n    const int qscale = (215 - 2*quant)*5;\n\n    int i;\n\n\n\n    t->intra_matrix[0] = (ff_inv_aanscales[0] * ff_mpeg1_default_intra_matrix[0]) >> 11;\n\n    for(i=1; i<64; i++)\n\n        t->intra_matrix[i] = (ff_inv_aanscales[i] * ff_mpeg1_default_intra_matrix[i] * qscale + 32) >> 14;\n\n}\n", "idx": 6697}
{"project": "qemu", "commit_id": "4cad3867b6df2c0826ae508a9fe15dd0b9d8936a", "target": 1, "func": "int fw_cfg_add_i64(FWCfgState *s, uint16_t key, uint64_t value)\n\n{\n\n    uint64_t *copy;\n\n\n\n    copy = g_malloc(sizeof(value));\n\n    *copy = cpu_to_le64(value);\n\n    return fw_cfg_add_bytes(s, key, (uint8_t *)copy, sizeof(value));\n\n}\n", "idx": 6815}
{"project": "FFmpeg", "commit_id": "4f03bebc79f76df3a3e5bb9e1bc32baabfb7797c", "target": 1, "func": "void avcodec_string(char *buf, int buf_size, AVCodecContext *enc, int encode)\n\n{\n\n    const char *codec_type;\n\n    const char *codec_name;\n\n    const char *profile = NULL;\n\n    const AVCodec *p;\n\n    int64_t bitrate;\n\n    int new_line = 0;\n\n    AVRational display_aspect_ratio;\n\n    const char *separator = enc->dump_separator ? (const char *)enc->dump_separator : \", \";\n\n\n\n    if (!buf || buf_size <= 0)\n\n        return;\n\n    codec_type = av_get_media_type_string(enc->codec_type);\n\n    codec_name = avcodec_get_name(enc->codec_id);\n\n    if (enc->profile != FF_PROFILE_UNKNOWN) {\n\n        if (enc->codec)\n\n            p = enc->codec;\n\n        else\n\n            p = encode ? avcodec_find_encoder(enc->codec_id) :\n\n                        avcodec_find_decoder(enc->codec_id);\n\n        if (p)\n\n            profile = av_get_profile_name(p, enc->profile);\n\n    }\n\n\n\n    snprintf(buf, buf_size, \"%s: %s\", codec_type ? codec_type : \"unknown\",\n\n             codec_name);\n\n    buf[0] ^= 'a' ^ 'A'; /* first letter in uppercase */\n\n\n\n    if (enc->codec && strcmp(enc->codec->name, codec_name))\n\n        snprintf(buf + strlen(buf), buf_size - strlen(buf), \" (%s)\", enc->codec->name);\n\n\n\n    if (profile)\n\n        snprintf(buf + strlen(buf), buf_size - strlen(buf), \" (%s)\", profile);\n\n    if (   enc->codec_type == AVMEDIA_TYPE_VIDEO\n\n        && av_log_get_level() >= AV_LOG_VERBOSE\n\n        && enc->refs)\n\n        snprintf(buf + strlen(buf), buf_size - strlen(buf),\n\n                 \", %d reference frame%s\",\n\n                 enc->refs, enc->refs > 1 ? \"s\" : \"\");\n\n\n\n    if (enc->codec_tag) {\n\n        char tag_buf[32];\n\n        av_get_codec_tag_string(tag_buf, sizeof(tag_buf), enc->codec_tag);\n\n        snprintf(buf + strlen(buf), buf_size - strlen(buf),\n\n                 \" (%s / 0x%04X)\", tag_buf, enc->codec_tag);\n\n    }\n\n\n\n    switch (enc->codec_type) {\n\n    case AVMEDIA_TYPE_VIDEO:\n\n        {\n\n            char detail[256] = \"(\";\n\n\n\n            av_strlcat(buf, separator, buf_size);\n\n\n\n            snprintf(buf + strlen(buf), buf_size - strlen(buf),\n\n                 \"%s\", enc->pix_fmt == AV_PIX_FMT_NONE ? \"none\" :\n\n                     av_get_pix_fmt_name(enc->pix_fmt));\n\n            if (enc->bits_per_raw_sample && enc->pix_fmt != AV_PIX_FMT_NONE &&\n\n                enc->bits_per_raw_sample < av_pix_fmt_desc_get(enc->pix_fmt)->comp[0].depth)\n\n                av_strlcatf(detail, sizeof(detail), \"%d bpc, \", enc->bits_per_raw_sample);\n\n            if (enc->color_range != AVCOL_RANGE_UNSPECIFIED)\n\n                av_strlcatf(detail, sizeof(detail), \"%s, \",\n\n                            av_color_range_name(enc->color_range));\n\n\n\n            if (enc->colorspace != AVCOL_SPC_UNSPECIFIED ||\n\n                enc->color_primaries != AVCOL_PRI_UNSPECIFIED ||\n\n                enc->color_trc != AVCOL_TRC_UNSPECIFIED) {\n\n                if (enc->colorspace != (int)enc->color_primaries ||\n\n                    enc->colorspace != (int)enc->color_trc) {\n\n                    new_line = 1;\n\n                    av_strlcatf(detail, sizeof(detail), \"%s/%s/%s, \",\n\n                                av_color_space_name(enc->colorspace),\n\n                                av_color_primaries_name(enc->color_primaries),\n\n                                av_color_transfer_name(enc->color_trc));\n\n                } else\n\n                    av_strlcatf(detail, sizeof(detail), \"%s, \",\n\n                                av_get_colorspace_name(enc->colorspace));\n\n            }\n\n\n\n            if (av_log_get_level() >= AV_LOG_DEBUG &&\n\n                enc->chroma_sample_location != AVCHROMA_LOC_UNSPECIFIED)\n\n                av_strlcatf(detail, sizeof(detail), \"%s, \",\n\n                            av_chroma_location_name(enc->chroma_sample_location));\n\n\n\n            if (strlen(detail) > 1) {\n\n                detail[strlen(detail) - 2] = 0;\n\n                av_strlcatf(buf, buf_size, \"%s)\", detail);\n\n            }\n\n        }\n\n\n\n        if (enc->width) {\n\n            av_strlcat(buf, new_line ? separator : \", \", buf_size);\n\n\n\n            snprintf(buf + strlen(buf), buf_size - strlen(buf),\n\n                     \"%dx%d\",\n\n                     enc->width, enc->height);\n\n\n\n            if (av_log_get_level() >= AV_LOG_VERBOSE &&\n\n                (enc->width != enc->coded_width ||\n\n                 enc->height != enc->coded_height))\n\n                snprintf(buf + strlen(buf), buf_size - strlen(buf),\n\n                         \" (%dx%d)\", enc->coded_width, enc->coded_height);\n\n\n\n            if (enc->sample_aspect_ratio.num) {\n\n                av_reduce(&display_aspect_ratio.num, &display_aspect_ratio.den,\n\n                          enc->width * enc->sample_aspect_ratio.num,\n\n                          enc->height * enc->sample_aspect_ratio.den,\n\n                          1024 * 1024);\n\n                snprintf(buf + strlen(buf), buf_size - strlen(buf),\n\n                         \" [SAR %d:%d DAR %d:%d]\",\n\n                         enc->sample_aspect_ratio.num, enc->sample_aspect_ratio.den,\n\n                         display_aspect_ratio.num, display_aspect_ratio.den);\n\n            }\n\n            if (av_log_get_level() >= AV_LOG_DEBUG) {\n\n                int g = av_gcd(enc->time_base.num, enc->time_base.den);\n\n                snprintf(buf + strlen(buf), buf_size - strlen(buf),\n\n                         \", %d/%d\",\n\n                         enc->time_base.num / g, enc->time_base.den / g);\n\n            }\n\n        }\n\n        if (encode) {\n\n            snprintf(buf + strlen(buf), buf_size - strlen(buf),\n\n                     \", q=%d-%d\", enc->qmin, enc->qmax);\n\n        } else {\n\n            if (enc->properties & FF_CODEC_PROPERTY_CLOSED_CAPTIONS)\n\n                snprintf(buf + strlen(buf), buf_size - strlen(buf),\n\n                         \", Closed Captions\");\n\n            if (enc->properties & FF_CODEC_PROPERTY_LOSSLESS)\n\n                snprintf(buf + strlen(buf), buf_size - strlen(buf),\n\n                         \", lossless\");\n\n        }\n\n        break;\n\n    case AVMEDIA_TYPE_AUDIO:\n\n        av_strlcat(buf, separator, buf_size);\n\n\n\n        if (enc->sample_rate) {\n\n            snprintf(buf + strlen(buf), buf_size - strlen(buf),\n\n                     \"%d Hz, \", enc->sample_rate);\n\n        }\n\n        av_get_channel_layout_string(buf + strlen(buf), buf_size - strlen(buf), enc->channels, enc->channel_layout);\n\n        if (enc->sample_fmt != AV_SAMPLE_FMT_NONE) {\n\n            snprintf(buf + strlen(buf), buf_size - strlen(buf),\n\n                     \", %s\", av_get_sample_fmt_name(enc->sample_fmt));\n\n        }\n\n        if (   enc->bits_per_raw_sample > 0\n\n            && enc->bits_per_raw_sample != av_get_bytes_per_sample(enc->sample_fmt) * 8)\n\n            snprintf(buf + strlen(buf), buf_size - strlen(buf),\n\n                     \" (%d bit)\", enc->bits_per_raw_sample);\n\n        break;\n\n    case AVMEDIA_TYPE_DATA:\n\n        if (av_log_get_level() >= AV_LOG_DEBUG) {\n\n            int g = av_gcd(enc->time_base.num, enc->time_base.den);\n\n            if (g)\n\n                snprintf(buf + strlen(buf), buf_size - strlen(buf),\n\n                         \", %d/%d\",\n\n                         enc->time_base.num / g, enc->time_base.den / g);\n\n        }\n\n        break;\n\n    case AVMEDIA_TYPE_SUBTITLE:\n\n        if (enc->width)\n\n            snprintf(buf + strlen(buf), buf_size - strlen(buf),\n\n                     \", %dx%d\", enc->width, enc->height);\n\n        break;\n\n    default:\n\n        return;\n\n    }\n\n    if (encode) {\n\n        if (enc->flags & AV_CODEC_FLAG_PASS1)\n\n            snprintf(buf + strlen(buf), buf_size - strlen(buf),\n\n                     \", pass 1\");\n\n        if (enc->flags & AV_CODEC_FLAG_PASS2)\n\n            snprintf(buf + strlen(buf), buf_size - strlen(buf),\n\n                     \", pass 2\");\n\n    }\n\n    bitrate = get_bit_rate(enc);\n\n    if (bitrate != 0) {\n\n        snprintf(buf + strlen(buf), buf_size - strlen(buf),\n\n                 \", %\"PRId64\" kb/s\", bitrate / 1000);\n\n    } else if (enc->rc_max_rate > 0) {\n\n        snprintf(buf + strlen(buf), buf_size - strlen(buf),\n\n                 \", max. %\"PRId64\" kb/s\", (int64_t)enc->rc_max_rate / 1000);\n\n    }\n\n}\n", "idx": 6818}
{"project": "qemu", "commit_id": "2a7e6857cd3178d705a49c4adde2f3af26ed3ae1", "target": 0, "func": "static void qmp_query_auth(VncDisplay *vd, VncInfo2 *info)\n\n{\n\n    switch (vd->auth) {\n\n    case VNC_AUTH_VNC:\n\n        info->auth = VNC_PRIMARY_AUTH_VNC;\n\n        break;\n\n    case VNC_AUTH_RA2:\n\n        info->auth = VNC_PRIMARY_AUTH_RA2;\n\n        break;\n\n    case VNC_AUTH_RA2NE:\n\n        info->auth = VNC_PRIMARY_AUTH_RA2NE;\n\n        break;\n\n    case VNC_AUTH_TIGHT:\n\n        info->auth = VNC_PRIMARY_AUTH_TIGHT;\n\n        break;\n\n    case VNC_AUTH_ULTRA:\n\n        info->auth = VNC_PRIMARY_AUTH_ULTRA;\n\n        break;\n\n    case VNC_AUTH_TLS:\n\n        info->auth = VNC_PRIMARY_AUTH_TLS;\n\n        break;\n\n    case VNC_AUTH_VENCRYPT:\n\n        info->auth = VNC_PRIMARY_AUTH_VENCRYPT;\n\n        info->has_vencrypt = true;\n\n        switch (vd->subauth) {\n\n        case VNC_AUTH_VENCRYPT_PLAIN:\n\n            info->vencrypt = VNC_VENCRYPT_SUB_AUTH_PLAIN;\n\n            break;\n\n        case VNC_AUTH_VENCRYPT_TLSNONE:\n\n            info->vencrypt = VNC_VENCRYPT_SUB_AUTH_TLS_NONE;\n\n            break;\n\n        case VNC_AUTH_VENCRYPT_TLSVNC:\n\n            info->vencrypt = VNC_VENCRYPT_SUB_AUTH_TLS_VNC;\n\n            break;\n\n        case VNC_AUTH_VENCRYPT_TLSPLAIN:\n\n            info->vencrypt = VNC_VENCRYPT_SUB_AUTH_TLS_PLAIN;\n\n            break;\n\n        case VNC_AUTH_VENCRYPT_X509NONE:\n\n            info->vencrypt = VNC_VENCRYPT_SUB_AUTH_X509_NONE;\n\n            break;\n\n        case VNC_AUTH_VENCRYPT_X509VNC:\n\n            info->vencrypt = VNC_VENCRYPT_SUB_AUTH_X509_VNC;\n\n            break;\n\n        case VNC_AUTH_VENCRYPT_X509PLAIN:\n\n            info->vencrypt = VNC_VENCRYPT_SUB_AUTH_X509_PLAIN;\n\n            break;\n\n        case VNC_AUTH_VENCRYPT_TLSSASL:\n\n            info->vencrypt = VNC_VENCRYPT_SUB_AUTH_TLS_SASL;\n\n            break;\n\n        case VNC_AUTH_VENCRYPT_X509SASL:\n\n            info->vencrypt = VNC_VENCRYPT_SUB_AUTH_X509_SASL;\n\n            break;\n\n        default:\n\n            info->has_vencrypt = false;\n\n            break;\n\n        }\n\n        break;\n\n    case VNC_AUTH_SASL:\n\n        info->auth = VNC_PRIMARY_AUTH_SASL;\n\n        break;\n\n    case VNC_AUTH_NONE:\n\n    default:\n\n        info->auth = VNC_PRIMARY_AUTH_NONE;\n\n        break;\n\n    }\n\n}\n", "idx": 6833}
{"project": "qemu", "commit_id": "2f4dc3c1b2a453a8255d9b97c7cb87860123e495", "target": 0, "func": "AioContext *aio_context_new(void)\n\n{\n\n    return (AioContext *) g_source_new(&aio_source_funcs, sizeof(AioContext));\n\n}\n", "idx": 6839}
{"project": "qemu", "commit_id": "28290f37e20cda27574f15be9e9499493e3d0fe8", "target": 0, "func": "void ppce500_init(QEMUMachineInitArgs *args, PPCE500Params *params)\n\n{\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    PCIBus *pci_bus;\n\n    CPUPPCState *env = NULL;\n\n    uint64_t elf_entry;\n\n    uint64_t elf_lowaddr;\n\n    hwaddr entry=0;\n\n    hwaddr loadaddr=UIMAGE_LOAD_BASE;\n\n    target_long kernel_size=0;\n\n    target_ulong dt_base = 0;\n\n    target_ulong initrd_base = 0;\n\n    target_long initrd_size = 0;\n\n    target_ulong cur_base = 0;\n\n    int i;\n\n    unsigned int pci_irq_nrs[4] = {1, 2, 3, 4};\n\n    qemu_irq **irqs, *mpic;\n\n    DeviceState *dev;\n\n    CPUPPCState *firstenv = NULL;\n\n    MemoryRegion *ccsr_addr_space;\n\n    SysBusDevice *s;\n\n    PPCE500CCSRState *ccsr;\n\n\n\n    /* Setup CPUs */\n\n    if (args->cpu_model == NULL) {\n\n        args->cpu_model = \"e500v2_v30\";\n\n    }\n\n\n\n    irqs = g_malloc0(smp_cpus * sizeof(qemu_irq *));\n\n    irqs[0] = g_malloc0(smp_cpus * sizeof(qemu_irq) * OPENPIC_OUTPUT_NB);\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        PowerPCCPU *cpu;\n\n        CPUState *cs;\n\n        qemu_irq *input;\n\n\n\n        cpu = cpu_ppc_init(args->cpu_model);\n\n        if (cpu == NULL) {\n\n            fprintf(stderr, \"Unable to initialize CPU!\\n\");\n\n            exit(1);\n\n        }\n\n        env = &cpu->env;\n\n        cs = CPU(cpu);\n\n\n\n        if (!firstenv) {\n\n            firstenv = env;\n\n        }\n\n\n\n        irqs[i] = irqs[0] + (i * OPENPIC_OUTPUT_NB);\n\n        input = (qemu_irq *)env->irq_inputs;\n\n        irqs[i][OPENPIC_OUTPUT_INT] = input[PPCE500_INPUT_INT];\n\n        irqs[i][OPENPIC_OUTPUT_CINT] = input[PPCE500_INPUT_CINT];\n\n        env->spr[SPR_BOOKE_PIR] = cs->cpu_index = i;\n\n        env->mpic_iack = MPC8544_CCSRBAR_BASE +\n\n                         MPC8544_MPIC_REGS_OFFSET + 0xa0;\n\n\n\n        ppc_booke_timers_init(cpu, 400000000, PPC_TIMER_E500);\n\n\n\n        /* Register reset handler */\n\n        if (!i) {\n\n            /* Primary CPU */\n\n            struct boot_info *boot_info;\n\n            boot_info = g_malloc0(sizeof(struct boot_info));\n\n            qemu_register_reset(ppce500_cpu_reset, cpu);\n\n            env->load_info = boot_info;\n\n        } else {\n\n            /* Secondary CPUs */\n\n            qemu_register_reset(ppce500_cpu_reset_sec, cpu);\n\n        }\n\n    }\n\n\n\n    env = firstenv;\n\n\n\n    /* Fixup Memory size on a alignment boundary */\n\n    ram_size &= ~(RAM_SIZES_ALIGN - 1);\n\n    args->ram_size = ram_size;\n\n\n\n    /* Register Memory */\n\n    memory_region_init_ram(ram, NULL, \"mpc8544ds.ram\", ram_size);\n\n    vmstate_register_ram_global(ram);\n\n    memory_region_add_subregion(address_space_mem, 0, ram);\n\n\n\n    dev = qdev_create(NULL, \"e500-ccsr\");\n\n    object_property_add_child(qdev_get_machine(), \"e500-ccsr\",\n\n                              OBJECT(dev), NULL);\n\n    qdev_init_nofail(dev);\n\n    ccsr = CCSR(dev);\n\n    ccsr_addr_space = &ccsr->ccsr_space;\n\n    memory_region_add_subregion(address_space_mem, MPC8544_CCSRBAR_BASE,\n\n                                ccsr_addr_space);\n\n\n\n    mpic = ppce500_init_mpic(params, ccsr_addr_space, irqs);\n\n\n\n    /* Serial */\n\n    if (serial_hds[0]) {\n\n        serial_mm_init(ccsr_addr_space, MPC8544_SERIAL0_REGS_OFFSET,\n\n                       0, mpic[42], 399193,\n\n                       serial_hds[0], DEVICE_BIG_ENDIAN);\n\n    }\n\n\n\n    if (serial_hds[1]) {\n\n        serial_mm_init(ccsr_addr_space, MPC8544_SERIAL1_REGS_OFFSET,\n\n                       0, mpic[42], 399193,\n\n                       serial_hds[1], DEVICE_BIG_ENDIAN);\n\n    }\n\n\n\n    /* General Utility device */\n\n    dev = qdev_create(NULL, \"mpc8544-guts\");\n\n    qdev_init_nofail(dev);\n\n    s = SYS_BUS_DEVICE(dev);\n\n    memory_region_add_subregion(ccsr_addr_space, MPC8544_UTIL_OFFSET,\n\n                                sysbus_mmio_get_region(s, 0));\n\n\n\n    /* PCI */\n\n    dev = qdev_create(NULL, \"e500-pcihost\");\n\n    qdev_prop_set_uint32(dev, \"first_slot\", params->pci_first_slot);\n\n    qdev_init_nofail(dev);\n\n    s = SYS_BUS_DEVICE(dev);\n\n    sysbus_connect_irq(s, 0, mpic[pci_irq_nrs[0]]);\n\n    sysbus_connect_irq(s, 1, mpic[pci_irq_nrs[1]]);\n\n    sysbus_connect_irq(s, 2, mpic[pci_irq_nrs[2]]);\n\n    sysbus_connect_irq(s, 3, mpic[pci_irq_nrs[3]]);\n\n    memory_region_add_subregion(ccsr_addr_space, MPC8544_PCI_REGS_OFFSET,\n\n                                sysbus_mmio_get_region(s, 0));\n\n\n\n    pci_bus = (PCIBus *)qdev_get_child_bus(dev, \"pci.0\");\n\n    if (!pci_bus)\n\n        printf(\"couldn't create PCI controller!\\n\");\n\n\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(dev), 1, MPC8544_PCI_IO);\n\n\n\n    if (pci_bus) {\n\n        /* Register network interfaces. */\n\n        for (i = 0; i < nb_nics; i++) {\n\n            pci_nic_init_nofail(&nd_table[i], pci_bus, \"virtio\", NULL);\n\n        }\n\n    }\n\n\n\n    /* Register spinning region */\n\n    sysbus_create_simple(\"e500-spin\", MPC8544_SPIN_BASE, NULL);\n\n\n\n    /* Load kernel. */\n\n    if (args->kernel_filename) {\n\n        kernel_size = load_uimage(args->kernel_filename, &entry,\n\n                                  &loadaddr, NULL);\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_elf(args->kernel_filename, NULL, NULL,\n\n                                   &elf_entry, &elf_lowaddr, NULL, 1,\n\n                                   ELF_MACHINE, 0);\n\n            entry = elf_entry;\n\n            loadaddr = elf_lowaddr;\n\n        }\n\n        /* XXX try again as binary */\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    args->kernel_filename);\n\n            exit(1);\n\n        }\n\n\n\n        cur_base = loadaddr + kernel_size;\n\n\n\n        /* Reserve space for dtb */\n\n        dt_base = (cur_base + DTC_LOAD_PAD) & ~DTC_PAD_MASK;\n\n        cur_base += DTB_MAX_SIZE;\n\n    }\n\n\n\n    /* Load initrd. */\n\n    if (args->initrd_filename) {\n\n        initrd_base = (cur_base + INITRD_LOAD_PAD) & ~INITRD_PAD_MASK;\n\n        initrd_size = load_image_targphys(args->initrd_filename, initrd_base,\n\n                                          ram_size - initrd_base);\n\n\n\n        if (initrd_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                    args->initrd_filename);\n\n            exit(1);\n\n        }\n\n\n\n        cur_base = initrd_base + initrd_size;\n\n    }\n\n\n\n    /* If we're loading a kernel directly, we must load the device tree too. */\n\n    if (args->kernel_filename) {\n\n        struct boot_info *boot_info;\n\n        int dt_size;\n\n\n\n        dt_size = ppce500_load_device_tree(env, args, params, dt_base,\n\n                                           initrd_base, initrd_size);\n\n        if (dt_size < 0) {\n\n            fprintf(stderr, \"couldn't load device tree\\n\");\n\n            exit(1);\n\n        }\n\n        assert(dt_size < DTB_MAX_SIZE);\n\n\n\n        boot_info = env->load_info;\n\n        boot_info->entry = entry;\n\n        boot_info->dt_base = dt_base;\n\n        boot_info->dt_size = dt_size;\n\n    }\n\n\n\n    if (kvm_enabled()) {\n\n        kvmppc_init();\n\n    }\n\n}\n", "idx": 6864}
{"project": "FFmpeg", "commit_id": "837112c0c84dd9de67421b57664933a0d27843f9", "target": 1, "func": "static av_cold int channelmap_init(AVFilterContext *ctx)\n\n{\n\n    ChannelMapContext *s = ctx->priv;\n\n    int ret;\n\n    char *mapping, separator = '|';\n\n    int map_entries = 0;\n\n    char buf[256];\n\n    enum MappingMode mode;\n\n    uint64_t out_ch_mask = 0;\n\n    int i;\n\n\n\n    mapping = s->mapping_str;\n\n\n\n    if (!mapping) {\n\n        mode = MAP_NONE;\n\n    } else {\n\n        char *dash = strchr(mapping, '-');\n\n        if (!dash) {  // short mapping\n\n            if (av_isdigit(*mapping))\n\n                mode = MAP_ONE_INT;\n\n            else\n\n                mode = MAP_ONE_STR;\n\n        } else if (av_isdigit(*mapping)) {\n\n            if (av_isdigit(*(dash+1)))\n\n                mode = MAP_PAIR_INT_INT;\n\n            else\n\n                mode = MAP_PAIR_INT_STR;\n\n        } else {\n\n            if (av_isdigit(*(dash+1)))\n\n                mode = MAP_PAIR_STR_INT;\n\n            else\n\n                mode = MAP_PAIR_STR_STR;\n\n        }\n\n#if FF_API_OLD_FILTER_OPTS\n\n        if (strchr(mapping, ',')) {\n\n            av_log(ctx, AV_LOG_WARNING, \"This syntax is deprecated, use \"\n\n                   \"'|' to separate the mappings.\\n\");\n\n            separator = ',';\n\n        }\n\n#endif\n\n    }\n\n\n\n    if (mode != MAP_NONE) {\n\n        char *sep = mapping;\n\n        map_entries = 1;\n\n        while ((sep = strchr(sep, separator))) {\n\n            if (*++sep)  // Allow trailing comma\n\n                map_entries++;\n\n        }\n\n    }\n\n\n\n    if (map_entries > MAX_CH) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Too many channels mapped: '%d'.\\n\", map_entries);\n\n        ret = AVERROR(EINVAL);\n\n        goto fail;\n\n    }\n\n\n\n    for (i = 0; i < map_entries; i++) {\n\n        int in_ch_idx = -1, out_ch_idx = -1;\n\n        uint64_t in_ch = 0, out_ch = 0;\n\n        static const char err[] = \"Failed to parse channel map\\n\";\n\n        switch (mode) {\n\n        case MAP_ONE_INT:\n\n            if (get_channel_idx(&mapping, &in_ch_idx, separator, MAX_CH) < 0) {\n\n                ret = AVERROR(EINVAL);\n\n                av_log(ctx, AV_LOG_ERROR, err);\n\n                goto fail;\n\n            }\n\n            s->map[i].in_channel_idx  = in_ch_idx;\n\n            s->map[i].out_channel_idx = i;\n\n            break;\n\n        case MAP_ONE_STR:\n\n            if (!get_channel(&mapping, &in_ch, separator)) {\n\n                av_log(ctx, AV_LOG_ERROR, err);\n\n                ret = AVERROR(EINVAL);\n\n                goto fail;\n\n            }\n\n            s->map[i].in_channel      = in_ch;\n\n            s->map[i].out_channel_idx = i;\n\n            break;\n\n        case MAP_PAIR_INT_INT:\n\n            if (get_channel_idx(&mapping, &in_ch_idx, '-', MAX_CH) < 0 ||\n\n                get_channel_idx(&mapping, &out_ch_idx, separator, MAX_CH) < 0) {\n\n                av_log(ctx, AV_LOG_ERROR, err);\n\n                ret = AVERROR(EINVAL);\n\n                goto fail;\n\n            }\n\n            s->map[i].in_channel_idx  = in_ch_idx;\n\n            s->map[i].out_channel_idx = out_ch_idx;\n\n            break;\n\n        case MAP_PAIR_INT_STR:\n\n            if (get_channel_idx(&mapping, &in_ch_idx, '-', MAX_CH) < 0 ||\n\n                get_channel(&mapping, &out_ch, separator) < 0 ||\n\n                out_ch & out_ch_mask) {\n\n                av_log(ctx, AV_LOG_ERROR, err);\n\n                ret = AVERROR(EINVAL);\n\n                goto fail;\n\n            }\n\n            s->map[i].in_channel_idx  = in_ch_idx;\n\n            s->map[i].out_channel     = out_ch;\n\n            out_ch_mask |= out_ch;\n\n            break;\n\n        case MAP_PAIR_STR_INT:\n\n            if (get_channel(&mapping, &in_ch, '-') < 0 ||\n\n                get_channel_idx(&mapping, &out_ch_idx, separator, MAX_CH) < 0) {\n\n                av_log(ctx, AV_LOG_ERROR, err);\n\n                ret = AVERROR(EINVAL);\n\n                goto fail;\n\n            }\n\n            s->map[i].in_channel      = in_ch;\n\n            s->map[i].out_channel_idx = out_ch_idx;\n\n            break;\n\n        case MAP_PAIR_STR_STR:\n\n            if (get_channel(&mapping, &in_ch, '-') < 0 ||\n\n                get_channel(&mapping, &out_ch, separator) < 0 ||\n\n                out_ch & out_ch_mask) {\n\n                av_log(ctx, AV_LOG_ERROR, err);\n\n                ret = AVERROR(EINVAL);\n\n                goto fail;\n\n            }\n\n            s->map[i].in_channel = in_ch;\n\n            s->map[i].out_channel = out_ch;\n\n            out_ch_mask |= out_ch;\n\n            break;\n\n        }\n\n    }\n\n    s->mode          = mode;\n\n    s->nch           = map_entries;\n\n    s->output_layout = out_ch_mask ? out_ch_mask :\n\n                       av_get_default_channel_layout(map_entries);\n\n\n\n    if (s->channel_layout_str) {\n\n        uint64_t fmt;\n\n        if ((fmt = av_get_channel_layout(s->channel_layout_str)) == 0) {\n\n            av_log(ctx, AV_LOG_ERROR, \"Error parsing channel layout: '%s'.\\n\",\n\n                   s->channel_layout_str);\n\n            ret = AVERROR(EINVAL);\n\n            goto fail;\n\n        }\n\n        if (mode == MAP_NONE) {\n\n            int i;\n\n            s->nch = av_get_channel_layout_nb_channels(fmt);\n\n            for (i = 0; i < s->nch; i++) {\n\n                s->map[i].in_channel_idx  = i;\n\n                s->map[i].out_channel_idx = i;\n\n            }\n\n        } else if (out_ch_mask && out_ch_mask != fmt) {\n\n            av_get_channel_layout_string(buf, sizeof(buf), 0, out_ch_mask);\n\n            av_log(ctx, AV_LOG_ERROR,\n\n                   \"Output channel layout '%s' does not match the list of channel mapped: '%s'.\\n\",\n\n                   s->channel_layout_str, buf);\n\n            ret = AVERROR(EINVAL);\n\n            goto fail;\n\n        } else if (s->nch != av_get_channel_layout_nb_channels(fmt)) {\n\n            av_log(ctx, AV_LOG_ERROR,\n\n                   \"Output channel layout %s does not match the number of channels mapped %d.\\n\",\n\n                   s->channel_layout_str, s->nch);\n\n            ret = AVERROR(EINVAL);\n\n            goto fail;\n\n        }\n\n        s->output_layout = fmt;\n\n    }\n\n    ff_add_channel_layout(&s->channel_layouts, s->output_layout);\n\n\n\n    if (mode == MAP_PAIR_INT_STR || mode == MAP_PAIR_STR_STR) {\n\n        for (i = 0; i < s->nch; i++) {\n\n            s->map[i].out_channel_idx = av_get_channel_layout_channel_index(\n\n                s->output_layout, s->map[i].out_channel);\n\n        }\n\n    }\n\n\n\nfail:\n\n    av_opt_free(s);\n\n    return ret;\n\n}\n", "idx": 6967}
{"project": "FFmpeg", "commit_id": "3c895fc098f7637f6d5ec3a9d6766e724a8b9e41", "target": 0, "func": "static void do_audio_out(AVFormatContext *s, \n\n                         AVOutputStream *ost, \n\n                         AVInputStream *ist,\n\n                         unsigned char *buf, int size)\n\n{\n\n    uint8_t *buftmp;\n\n    static uint8_t *audio_buf = NULL;\n\n    static uint8_t *audio_out = NULL;\n\n    const int audio_out_size= 4*MAX_AUDIO_PACKET_SIZE;\n\n\n\n    int size_out, frame_bytes, ret;\n\n    AVCodecContext *enc;\n\n\n\n    /* SC: dynamic allocation of buffers */\n\n    if (!audio_buf)\n\n        audio_buf = av_malloc(2*MAX_AUDIO_PACKET_SIZE);\n\n    if (!audio_out)\n\n        audio_out = av_malloc(audio_out_size);\n\n    if (!audio_buf || !audio_out)\n\n        return;               /* Should signal an error ! */\n\n\n\n    \n\n    enc = &ost->st->codec;\n\n\n\n    if (ost->audio_resample) {\n\n        buftmp = audio_buf;\n\n        size_out = audio_resample(ost->resample, \n\n                                  (short *)buftmp, (short *)buf,\n\n                                  size / (ist->st->codec.channels * 2));\n\n        size_out = size_out * enc->channels * 2;\n\n    } else {\n\n        buftmp = buf;\n\n        size_out = size;\n\n    }\n\n\n\n    /* now encode as many frames as possible */\n\n    if (enc->frame_size > 1) {\n\n        /* output resampled raw samples */\n\n        fifo_write(&ost->fifo, buftmp, size_out, \n\n                   &ost->fifo.wptr);\n\n\n\n        frame_bytes = enc->frame_size * 2 * enc->channels;\n\n        \n\n        while (fifo_read(&ost->fifo, audio_buf, frame_bytes, \n\n                     &ost->fifo.rptr) == 0) {\n\n            AVPacket pkt;\n\n            av_init_packet(&pkt);\n\n\n\n            ret = avcodec_encode_audio(enc, audio_out, audio_out_size, \n\n                                       (short *)audio_buf);\n\n            audio_size += ret;\n\n            pkt.stream_index= ost->index;\n\n            pkt.data= audio_out;\n\n            pkt.size= ret;\n\n            if(enc->coded_frame)\n\n                pkt.pts= enc->coded_frame->pts;\n\n            pkt.flags |= PKT_FLAG_KEY;\n\n            av_write_frame(s, &pkt);\n\n        }\n\n    } else {\n\n        AVPacket pkt;\n\n        av_init_packet(&pkt);\n\n        /* output a pcm frame */\n\n        /* XXX: change encoding codec API to avoid this ? */\n\n        switch(enc->codec->id) {\n\n        case CODEC_ID_PCM_S16LE:\n\n        case CODEC_ID_PCM_S16BE:\n\n        case CODEC_ID_PCM_U16LE:\n\n        case CODEC_ID_PCM_U16BE:\n\n            break;\n\n        default:\n\n            size_out = size_out >> 1;\n\n            break;\n\n        }\n\n        ret = avcodec_encode_audio(enc, audio_out, size_out, \n\n\t\t\t\t   (short *)buftmp);\n\n        audio_size += ret;\n\n        pkt.stream_index= ost->index;\n\n        pkt.data= audio_out;\n\n        pkt.size= ret;\n\n        if(enc->coded_frame)\n\n            pkt.pts= enc->coded_frame->pts;\n\n        pkt.flags |= PKT_FLAG_KEY;\n\n        av_write_frame(s, &pkt);\n\n    }\n\n}\n", "idx": 7037}
{"project": "qemu", "commit_id": "0ff0fad23d3693ecf7a0c462cdb48f0e60f93808", "target": 0, "func": "static void tcp_chr_disconnect(CharDriverState *chr)\n\n{\n\n    TCPCharDriver *s = chr->opaque;\n\n\n\n    s->connected = 0;\n\n    if (s->listen_chan) {\n\n        s->listen_tag = g_io_add_watch(s->listen_chan, G_IO_IN,\n\n                                       tcp_chr_accept, chr);\n\n    }\n\n    remove_fd_in_watch(chr);\n\n    g_io_channel_unref(s->chan);\n\n    s->chan = NULL;\n\n    closesocket(s->fd);\n\n    s->fd = -1;\n\n    SocketAddress_to_str(chr->filename, CHR_MAX_FILENAME_SIZE,\n\n                         \"disconnected:\", s->addr, s->is_listen, s->is_telnet);\n\n    qemu_chr_be_event(chr, CHR_EVENT_CLOSED);\n\n    if (s->reconnect_time) {\n\n        qemu_chr_socket_restart_timer(chr);\n\n    }\n\n}\n", "idx": 7070}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "float64 HELPER(ucf64_si2df)(float32 x, CPUUniCore32State *env)\n\n{\n\n    return int32_to_float64(ucf64_stoi(x), &env->ucf64.fp_status);\n\n}\n", "idx": 7073}
{"project": "qemu", "commit_id": "97a83ec3a9d83f2e86b8b93178d8e8b64ccc7486", "target": 0, "func": "static void i440fx_pcihost_initfn(Object *obj)\n\n{\n\n    PCIHostState *s = PCI_HOST_BRIDGE(obj);\n\n    I440FXState *d = I440FX_PCI_HOST_BRIDGE(obj);\n\n\n\n    memory_region_init_io(&s->conf_mem, obj, &pci_host_conf_le_ops, s,\n\n                          \"pci-conf-idx\", 4);\n\n    memory_region_init_io(&s->data_mem, obj, &pci_host_data_le_ops, s,\n\n                          \"pci-conf-data\", 4);\n\n\n\n    object_property_add(obj, PCI_HOST_PROP_PCI_HOLE_START, \"int\",\n\n                        i440fx_pcihost_get_pci_hole_start,\n\n                        NULL, NULL, NULL, NULL);\n\n\n\n    object_property_add(obj, PCI_HOST_PROP_PCI_HOLE_END, \"int\",\n\n                        i440fx_pcihost_get_pci_hole_end,\n\n                        NULL, NULL, NULL, NULL);\n\n\n\n    object_property_add(obj, PCI_HOST_PROP_PCI_HOLE64_START, \"int\",\n\n                        i440fx_pcihost_get_pci_hole64_start,\n\n                        NULL, NULL, NULL, NULL);\n\n\n\n    object_property_add(obj, PCI_HOST_PROP_PCI_HOLE64_END, \"int\",\n\n                        i440fx_pcihost_get_pci_hole64_end,\n\n                        NULL, NULL, NULL, NULL);\n\n\n\n    d->pci_info.w32.end = IO_APIC_DEFAULT_ADDRESS;\n\n}\n", "idx": 7115}
{"project": "qemu", "commit_id": "12d4536f7d911b6d87a766ad7300482ea663cea2", "target": 1, "func": "void qemu_mutex_unlock_iothread(void) {}\n", "idx": 7152}
{"project": "qemu", "commit_id": "13d1fd44c46629aad672f192abbf02238c6cbf36", "target": 1, "func": "static int qxl_init_secondary(PCIDevice *dev)\n\n{\n\n    static int device_id = 1;\n\n    PCIQXLDevice *qxl = DO_UPCAST(PCIQXLDevice, pci, dev);\n\n\n\n    qxl->id = device_id++;\n\n    qxl_init_ramsize(qxl, 16);\n\n    memory_region_init_ram(&qxl->vga.vram, \"qxl.vgavram\", qxl->vga.vram_size);\n\n    vmstate_register_ram(&qxl->vga.vram, &qxl->pci.qdev);\n\n    qxl->vga.vram_ptr = memory_region_get_ram_ptr(&qxl->vga.vram);\n\n\n\n    return qxl_init_common(qxl);\n\n}\n", "idx": 7171}
{"project": "qemu", "commit_id": "84961407a50bb02d34ab9cca7a21cdb4ff7c25fe", "target": 1, "func": "static void gd_set_keycode_type(GtkDisplayState *s)\n{\n#ifdef GDK_WINDOWING_X11\n    GdkDisplay *display = gtk_widget_get_display(s->window);\n    if (GDK_IS_X11_DISPLAY(display)) {\n        Display *x11_display = gdk_x11_display_get_xdisplay(display);\n        XkbDescPtr desc = XkbGetKeyboard(x11_display, XkbGBN_AllComponentsMask,\n                                         XkbUseCoreKbd);\n        char *keycodes = NULL;\n        if (desc && desc->names) {\n            keycodes = XGetAtomName(x11_display, desc->names->keycodes);\n        if (keycodes == NULL) {\n            fprintf(stderr, \"could not lookup keycode name\\n\");\n        } else if (strstart(keycodes, \"evdev\", NULL)) {\n            s->has_evdev = true;\n        } else if (!strstart(keycodes, \"xfree86\", NULL)) {\n            fprintf(stderr, \"unknown keycodes `%s', please report to \"\n                    \"qemu-devel@nongnu.org\\n\", keycodes);\n#endif", "idx": 7206}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "func": "static void kvm_client_set_memory(struct CPUPhysMemoryClient *client,\n\n\t\t\t\t  target_phys_addr_t start_addr,\n\n\t\t\t\t  ram_addr_t size,\n\n\t\t\t\t  ram_addr_t phys_offset)\n\n{\n\n\tkvm_set_phys_mem(start_addr, size, phys_offset);\n\n}\n", "idx": 7211}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "static inline void RENAME(rgb24tobgr16)(const uint8_t *src, uint8_t *dst, unsigned int src_size)\n\n{\n\n\tconst uint8_t *s = src;\n\n\tconst uint8_t *end;\n\n#ifdef HAVE_MMX\n\n\tconst uint8_t *mm_end;\n\n#endif\n\n\tuint16_t *d = (uint16_t *)dst;\n\n\tend = s + src_size;\n\n#ifdef HAVE_MMX\n\n\t__asm __volatile(PREFETCH\"\t%0\"::\"m\"(*src):\"memory\");\n\n\t__asm __volatile(\n\n\t    \"movq\t%0, %%mm7\\n\\t\"\n\n\t    \"movq\t%1, %%mm6\\n\\t\"\n\n\t    ::\"m\"(red_16mask),\"m\"(green_16mask));\n\n\tmm_end = end - 15;\n\n\twhile(s < mm_end)\n\n\t{\n\n\t    __asm __volatile(\n\n\t\tPREFETCH\" 32%1\\n\\t\"\n\n\t\t\"movd\t%1, %%mm0\\n\\t\"\n\n\t\t\"movd\t3%1, %%mm3\\n\\t\"\n\n\t\t\"punpckldq 6%1, %%mm0\\n\\t\"\n\n\t\t\"punpckldq 9%1, %%mm3\\n\\t\"\n\n\t\t\"movq\t%%mm0, %%mm1\\n\\t\"\n\n\t\t\"movq\t%%mm0, %%mm2\\n\\t\"\n\n\t\t\"movq\t%%mm3, %%mm4\\n\\t\"\n\n\t\t\"movq\t%%mm3, %%mm5\\n\\t\"\n\n\t\t\"psllq\t$8, %%mm0\\n\\t\"\n\n\t\t\"psllq\t$8, %%mm3\\n\\t\"\n\n\t\t\"pand\t%%mm7, %%mm0\\n\\t\"\n\n\t\t\"pand\t%%mm7, %%mm3\\n\\t\"\n\n\t\t\"psrlq\t$5, %%mm1\\n\\t\"\n\n\t\t\"psrlq\t$5, %%mm4\\n\\t\"\n\n\t\t\"pand\t%%mm6, %%mm1\\n\\t\"\n\n\t\t\"pand\t%%mm6, %%mm4\\n\\t\"\n\n\t\t\"psrlq\t$19, %%mm2\\n\\t\"\n\n\t\t\"psrlq\t$19, %%mm5\\n\\t\"\n\n\t\t\"pand\t%2, %%mm2\\n\\t\"\n\n\t\t\"pand\t%2, %%mm5\\n\\t\"\n\n\t\t\"por\t%%mm1, %%mm0\\n\\t\"\n\n\t\t\"por\t%%mm4, %%mm3\\n\\t\"\n\n\t\t\"por\t%%mm2, %%mm0\\n\\t\"\n\n\t\t\"por\t%%mm5, %%mm3\\n\\t\"\n\n\t\t\"psllq\t$16, %%mm3\\n\\t\"\n\n\t\t\"por\t%%mm3, %%mm0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm0, %0\\n\\t\"\n\n\t\t:\"=m\"(*d):\"m\"(*s),\"m\"(blue_16mask):\"memory\");\n\n\t\td += 4;\n\n\t\ts += 12;\n\n\t}\n\n\t__asm __volatile(SFENCE:::\"memory\");\n\n\t__asm __volatile(EMMS:::\"memory\");\n\n#endif\n\n\twhile(s < end)\n\n\t{\n\n\t\tconst int r= *s++;\n\n\t\tconst int g= *s++;\n\n\t\tconst int b= *s++;\n\n\t\t*d++ = (b>>3) | ((g&0xFC)<<3) | ((r&0xF8)<<8);\n\n\t}\n\n}\n", "idx": 7250}
{"project": "qemu", "commit_id": "6e13610aa454beba52944e8df6d93158d68ab911", "target": 1, "func": "static int qcow2_save_vmstate(BlockDriverState *bs, QEMUIOVector *qiov,\n\n                              int64_t pos)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int64_t total_sectors = bs->total_sectors;\n\n    int growable = bs->growable;\n\n\n    int ret;\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_VMSTATE_SAVE);\n\n    bs->growable = 1;\n\n\n    ret = bdrv_pwritev(bs, qcow2_vm_state_offset(s) + pos, qiov);\n\n    bs->growable = growable;\n\n\n\n\n    /* bdrv_co_do_writev will have increased the total_sectors value to include\n\n     * the VM state - the VM state is however not an actual part of the block\n\n     * device, therefore, we need to restore the old value. */\n\n    bs->total_sectors = total_sectors;\n\n\n\n    return ret;\n\n}", "idx": 7263}
{"project": "FFmpeg", "commit_id": "1ca7dc60d2f2cac8fce1bdb53d3d5bae195161b0", "target": 1, "func": "yuv2422_1_c_template(SwsContext *c, const int16_t *buf0,\n\n                     const int16_t *ubuf[2], const int16_t *vbuf[2],\n\n                     const int16_t *abuf0, uint8_t *dest, int dstW,\n\n                     int uvalpha, int y, enum PixelFormat target)\n\n{\n\n    const int16_t *ubuf0 = ubuf[0], *ubuf1 = ubuf[1],\n\n                  *vbuf0 = vbuf[0], *vbuf1 = vbuf[1];\n\n    int i;\n\n\n\n    if (uvalpha < 2048) {\n\n        for (i = 0; i < (dstW >> 1); i++) {\n\n            int Y1 = buf0[i * 2]     >> 7;\n\n            int Y2 = buf0[i * 2 + 1] >> 7;\n\n            int U  = ubuf1[i]        >> 7;\n\n            int V  = vbuf1[i]        >> 7;\n\n\n\n            output_pixels(i * 4, Y1, U, Y2, V);\n\n        }\n\n    } else {\n\n        for (i = 0; i < (dstW >> 1); i++) {\n\n            int Y1 =  buf0[i * 2]          >> 7;\n\n            int Y2 =  buf0[i * 2 + 1]      >> 7;\n\n            int U  = (ubuf0[i] + ubuf1[i]) >> 8;\n\n            int V  = (vbuf0[i] + vbuf1[i]) >> 8;\n\n\n\n            output_pixels(i * 4, Y1, U, Y2, V);\n\n        }\n\n    }\n\n}\n", "idx": 7295}
{"project": "qemu", "commit_id": "99f2cf4b2dad7b37c69759deb0d0b19d3ec1a24a", "target": 1, "func": "static void local_mapped_file_attr(int dirfd, const char *name,\n\n                                   struct stat *stbuf)\n\n{\n\n    FILE *fp;\n\n    char buf[ATTR_MAX];\n\n    int map_dirfd;\n\n\n\n    map_dirfd = openat(dirfd, VIRTFS_META_DIR,\n\n                       O_RDONLY | O_DIRECTORY | O_NOFOLLOW);\n\n    if (map_dirfd == -1) {\n\n        return;\n\n    }\n\n\n\n    fp = local_fopenat(map_dirfd, name, \"r\");\n\n    close_preserve_errno(map_dirfd);\n\n    if (!fp) {\n\n        return;\n\n    }\n\n    memset(buf, 0, ATTR_MAX);\n\n    while (fgets(buf, ATTR_MAX, fp)) {\n\n        if (!strncmp(buf, \"virtfs.uid\", 10)) {\n\n            stbuf->st_uid = atoi(buf+11);\n\n        } else if (!strncmp(buf, \"virtfs.gid\", 10)) {\n\n            stbuf->st_gid = atoi(buf+11);\n\n        } else if (!strncmp(buf, \"virtfs.mode\", 11)) {\n\n            stbuf->st_mode = atoi(buf+12);\n\n        } else if (!strncmp(buf, \"virtfs.rdev\", 11)) {\n\n            stbuf->st_rdev = atoi(buf+12);\n\n        }\n\n        memset(buf, 0, ATTR_MAX);\n\n    }\n\n    fclose(fp);\n\n}\n", "idx": 7308}
{"project": "qemu", "commit_id": "c169998802505c244b8bcad562633f29de7d74a4", "target": 0, "func": "PITState *pit_init(int base, qemu_irq irq)\n\n{\n\n    PITState *pit = &pit_state;\n\n    PITChannelState *s;\n\n\n\n    s = &pit->channels[0];\n\n    /* the timer 0 is connected to an IRQ */\n\n    s->irq_timer = qemu_new_timer(vm_clock, pit_irq_timer, s);\n\n    s->irq = irq;\n\n\n\n    vmstate_register(base, &vmstate_pit, pit);\n\n    qemu_register_reset(pit_reset, pit);\n\n    register_ioport_write(base, 4, 1, pit_ioport_write, pit);\n\n    register_ioport_read(base, 3, 1, pit_ioport_read, pit);\n\n\n\n    pit_reset(pit);\n\n\n\n    return pit;\n\n}\n", "idx": 7322}
{"project": "qemu", "commit_id": "96c05abc904c6f74b60981d956cee531920e4cdf", "target": 0, "func": "static int qxl_init_common(PCIQXLDevice *qxl)\n\n{\n\n    uint8_t* config = qxl->pci.config;\n\n    uint32_t pci_device_id;\n\n    uint32_t pci_device_rev;\n\n    uint32_t io_size;\n\n\n\n    qxl->mode = QXL_MODE_UNDEFINED;\n\n    qxl->generation = 1;\n\n    qxl->num_memslots = NUM_MEMSLOTS;\n\n    qxl->num_surfaces = NUM_SURFACES;\n\n\n\n    switch (qxl->revision) {\n\n    case 1: /* spice 0.4 -- qxl-1 */\n\n        pci_device_id  = QXL_DEVICE_ID_STABLE;\n\n        pci_device_rev = QXL_REVISION_STABLE_V04;\n\n        break;\n\n    case 2: /* spice 0.6 -- qxl-2 */\n\n        pci_device_id  = QXL_DEVICE_ID_STABLE;\n\n        pci_device_rev = QXL_REVISION_STABLE_V06;\n\n        break;\n\n    default: /* experimental */\n\n        pci_device_id  = QXL_DEVICE_ID_DEVEL;\n\n        pci_device_rev = 1;\n\n        break;\n\n    }\n\n\n\n    pci_config_set_vendor_id(config, REDHAT_PCI_VENDOR_ID);\n\n    pci_config_set_device_id(config, pci_device_id);\n\n    pci_set_byte(&config[PCI_REVISION_ID], pci_device_rev);\n\n    pci_set_byte(&config[PCI_INTERRUPT_PIN], 1);\n\n\n\n    qxl->rom_size = qxl_rom_size();\n\n    qxl->rom_offset = qemu_ram_alloc(&qxl->pci.qdev, \"qxl.vrom\", qxl->rom_size);\n\n    init_qxl_rom(qxl);\n\n    init_qxl_ram(qxl);\n\n\n\n    if (qxl->vram_size < 16 * 1024 * 1024) {\n\n        qxl->vram_size = 16 * 1024 * 1024;\n\n    }\n\n    if (qxl->revision == 1) {\n\n        qxl->vram_size = 4096;\n\n    }\n\n    qxl->vram_size = msb_mask(qxl->vram_size * 2 - 1);\n\n    qxl->vram_offset = qemu_ram_alloc(&qxl->pci.qdev, \"qxl.vram\", qxl->vram_size);\n\n\n\n    io_size = msb_mask(QXL_IO_RANGE_SIZE * 2 - 1);\n\n    if (qxl->revision == 1) {\n\n        io_size = 8;\n\n    }\n\n\n\n    pci_register_bar(&qxl->pci, QXL_IO_RANGE_INDEX,\n\n                     io_size, PCI_BASE_ADDRESS_SPACE_IO, qxl_map);\n\n\n\n    pci_register_bar(&qxl->pci, QXL_ROM_RANGE_INDEX,\n\n                     qxl->rom_size, PCI_BASE_ADDRESS_SPACE_MEMORY,\n\n                     qxl_map);\n\n\n\n    pci_register_bar(&qxl->pci, QXL_RAM_RANGE_INDEX,\n\n                     qxl->vga.vram_size, PCI_BASE_ADDRESS_SPACE_MEMORY,\n\n                     qxl_map);\n\n\n\n    pci_register_bar(&qxl->pci, QXL_VRAM_RANGE_INDEX, qxl->vram_size,\n\n                     PCI_BASE_ADDRESS_SPACE_MEMORY, qxl_map);\n\n\n\n    qxl->ssd.qxl.base.sif = &qxl_interface.base;\n\n    qxl->ssd.qxl.id = qxl->id;\n\n    qemu_spice_add_interface(&qxl->ssd.qxl.base);\n\n    qemu_add_vm_change_state_handler(qxl_vm_change_state_handler, qxl);\n\n\n\n    init_pipe_signaling(qxl);\n\n    qxl_reset_state(qxl);\n\n\n\n    return 0;\n\n}\n", "idx": 7325}
{"project": "qemu", "commit_id": "1f00b27f17518a1bcb4cedca49eaec96a4d560bd", "target": 0, "func": "static TCGReg tcg_out_tlb_read(TCGContext* s, TCGReg addr_reg, TCGMemOp opc,\n\n                               int mem_index, bool is_ld)\n\n{\n\n    int s_mask = (1 << (opc & MO_SIZE)) - 1;\n\n    int ofs, a_off;\n\n    uint64_t tlb_mask;\n\n\n\n    /* For aligned accesses, we check the first byte and include the alignment\n\n       bits within the address.  For unaligned access, we check that we don't\n\n       cross pages using the address of the last byte of the access.  */\n\n    if ((opc & MO_AMASK) == MO_ALIGN || s_mask == 0) {\n\n        a_off = 0;\n\n        tlb_mask = TARGET_PAGE_MASK | s_mask;\n\n    } else {\n\n        a_off = s_mask;\n\n        tlb_mask = TARGET_PAGE_MASK;\n\n    }\n\n\n\n    if (facilities & FACILITY_GEN_INST_EXT) {\n\n        tcg_out_risbg(s, TCG_REG_R2, addr_reg,\n\n                      64 - CPU_TLB_BITS - CPU_TLB_ENTRY_BITS,\n\n                      63 - CPU_TLB_ENTRY_BITS,\n\n                      64 + CPU_TLB_ENTRY_BITS - TARGET_PAGE_BITS, 1);\n\n        if (a_off) {\n\n            tcg_out_insn(s, RX, LA, TCG_REG_R3, addr_reg, TCG_REG_NONE, a_off);\n\n            tgen_andi(s, TCG_TYPE_TL, TCG_REG_R3, tlb_mask);\n\n        } else {\n\n            tgen_andi_risbg(s, TCG_REG_R3, addr_reg, tlb_mask);\n\n        }\n\n    } else {\n\n        tcg_out_sh64(s, RSY_SRLG, TCG_REG_R2, addr_reg, TCG_REG_NONE,\n\n                     TARGET_PAGE_BITS - CPU_TLB_ENTRY_BITS);\n\n        tcg_out_insn(s, RX, LA, TCG_REG_R3, addr_reg, TCG_REG_NONE, a_off);\n\n        tgen_andi(s, TCG_TYPE_I64, TCG_REG_R2,\n\n                  (CPU_TLB_SIZE - 1) << CPU_TLB_ENTRY_BITS);\n\n        tgen_andi(s, TCG_TYPE_TL, TCG_REG_R3, tlb_mask);\n\n    }\n\n\n\n    if (is_ld) {\n\n        ofs = offsetof(CPUArchState, tlb_table[mem_index][0].addr_read);\n\n    } else {\n\n        ofs = offsetof(CPUArchState, tlb_table[mem_index][0].addr_write);\n\n    }\n\n    if (TARGET_LONG_BITS == 32) {\n\n        tcg_out_mem(s, RX_C, RXY_CY, TCG_REG_R3, TCG_REG_R2, TCG_AREG0, ofs);\n\n    } else {\n\n        tcg_out_mem(s, 0, RXY_CG, TCG_REG_R3, TCG_REG_R2, TCG_AREG0, ofs);\n\n    }\n\n\n\n    ofs = offsetof(CPUArchState, tlb_table[mem_index][0].addend);\n\n    tcg_out_mem(s, 0, RXY_LG, TCG_REG_R2, TCG_REG_R2, TCG_AREG0, ofs);\n\n\n\n    if (TARGET_LONG_BITS == 32) {\n\n        tgen_ext32u(s, TCG_REG_R3, addr_reg);\n\n        return TCG_REG_R3;\n\n    }\n\n    return addr_reg;\n\n}\n", "idx": 7331}
{"project": "qemu", "commit_id": "be09ac4194bd0a61c0d9412c32431fbe2273cba1", "target": 0, "func": "static abi_long do_getpeername(int fd, abi_ulong target_addr,\n\n                               abi_ulong target_addrlen_addr)\n\n{\n\n    socklen_t addrlen;\n\n    void *addr;\n\n    abi_long ret;\n\n\n\n    if (get_user_u32(addrlen, target_addrlen_addr))\n\n        return -TARGET_EFAULT;\n\n\n\n    if (addrlen < 0 || addrlen > MAX_SOCK_ADDR)\n\n        return -TARGET_EINVAL;\n\n\n\n    addr = alloca(addrlen);\n\n\n\n    ret = get_errno(getpeername(fd, addr, &addrlen));\n\n    if (!is_error(ret)) {\n\n        host_to_target_sockaddr(target_addr, addr, addrlen);\n\n        if (put_user_u32(addrlen, target_addrlen_addr))\n\n            ret = -TARGET_EFAULT;\n\n    }\n\n    return ret;\n\n}\n", "idx": 7378}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static void do_spawn_thread(ThreadPool *pool)\n\n{\n\n    QemuThread t;\n\n\n\n    /* Runs with lock taken.  */\n\n    if (!pool->new_threads) {\n\n        return;\n\n    }\n\n\n\n    pool->new_threads--;\n\n    pool->pending_threads++;\n\n\n\n    qemu_thread_create(&t, \"worker\", worker_thread, pool, QEMU_THREAD_DETACHED);\n\n}\n", "idx": 7487}
{"project": "FFmpeg", "commit_id": "c1847c932b1576e8224c38e112a5fd29fa8a6098", "target": 1, "func": "static int rtcp_parse_packet(RTPDemuxContext *s, const unsigned char *buf, int len)\n\n{\n\n    int payload_len;\n\n    while (len >= 2) {\n\n        switch (buf[1]) {\n\n        case RTCP_SR:\n\n            if (len < 16) {\n\n                av_log(NULL, AV_LOG_ERROR, \"Invalid length for RTCP SR packet\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            payload_len = (AV_RB16(buf + 2) + 1) * 4;\n\n\n\n            s->last_rtcp_ntp_time = AV_RB64(buf + 8);\n\n            s->last_rtcp_timestamp = AV_RB32(buf + 16);\n\n            if (s->first_rtcp_ntp_time == AV_NOPTS_VALUE) {\n\n                s->first_rtcp_ntp_time = s->last_rtcp_ntp_time;\n\n                if (!s->base_timestamp)\n\n                    s->base_timestamp = s->last_rtcp_timestamp;\n\n                s->rtcp_ts_offset = s->last_rtcp_timestamp - s->base_timestamp;\n\n            }\n\n\n\n            buf += payload_len;\n\n            len -= payload_len;\n\n            break;\n\n        case RTCP_BYE:\n\n            return -RTCP_BYE;\n\n        default:\n\n            return -1;\n\n        }\n\n    }\n\n    return -1;\n\n}\n", "idx": 7689}
{"project": "qemu", "commit_id": "36cf2a37132c7f01fa9adb5f95f5312b27742fd4", "target": 1, "func": "void virtqueue_map_sg(struct iovec *sg, hwaddr *addr,\n    size_t num_sg, int is_write)\n{\n    unsigned int i;\n    hwaddr len;\n    for (i = 0; i < num_sg; i++) {\n        len = sg[i].iov_len;\n        sg[i].iov_base = cpu_physical_memory_map(addr[i], &len, is_write);\n        if (sg[i].iov_base == NULL || len != sg[i].iov_len) {\n            error_report(\"virtio: trying to map MMIO memory\");", "idx": 7690}
{"project": "FFmpeg", "commit_id": "47c5a3058eeae2043bd0dc2704b024cac8adcb3b", "target": 1, "func": "static int handle_p_frame_apng(AVCodecContext *avctx, PNGDecContext *s,\n\n                               AVFrame *p)\n\n{\n\n    size_t x, y;\n\n    uint8_t *buffer = av_malloc(s->image_linesize * s->height);\n\n\n\n    if (!buffer)\n\n        return AVERROR(ENOMEM);\n\n\n\n    if (s->blend_op == APNG_BLEND_OP_OVER &&\n\n        avctx->pix_fmt != AV_PIX_FMT_RGBA &&\n\n        avctx->pix_fmt != AV_PIX_FMT_GRAY8A &&\n\n        avctx->pix_fmt != AV_PIX_FMT_PAL8) {\n\n        avpriv_request_sample(avctx, \"Blending with pixel format %s\",\n\n                              av_get_pix_fmt_name(avctx->pix_fmt));\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    // Do the disposal operation specified by the last frame on the frame\n\n    if (s->last_dispose_op != APNG_DISPOSE_OP_PREVIOUS) {\n\n        ff_thread_await_progress(&s->last_picture, INT_MAX, 0);\n\n        memcpy(buffer, s->last_picture.f->data[0], s->image_linesize * s->height);\n\n\n\n        if (s->last_dispose_op == APNG_DISPOSE_OP_BACKGROUND)\n\n            for (y = s->last_y_offset; y < s->last_y_offset + s->last_h; ++y)\n\n                memset(buffer + s->image_linesize * y + s->bpp * s->last_x_offset, 0, s->bpp * s->last_w);\n\n\n\n        memcpy(s->previous_picture.f->data[0], buffer, s->image_linesize * s->height);\n\n        ff_thread_report_progress(&s->previous_picture, INT_MAX, 0);\n\n    } else {\n\n        ff_thread_await_progress(&s->previous_picture, INT_MAX, 0);\n\n        memcpy(buffer, s->previous_picture.f->data[0], s->image_linesize * s->height);\n\n    }\n\n\n\n    // Perform blending\n\n    if (s->blend_op == APNG_BLEND_OP_SOURCE) {\n\n        for (y = s->y_offset; y < s->y_offset + s->cur_h; ++y) {\n\n            size_t row_start = s->image_linesize * y + s->bpp * s->x_offset;\n\n            memcpy(buffer + row_start, p->data[0] + row_start, s->bpp * s->cur_w);\n\n        }\n\n    } else { // APNG_BLEND_OP_OVER\n\n        for (y = s->y_offset; y < s->y_offset + s->cur_h; ++y) {\n\n            uint8_t *foreground = p->data[0] + s->image_linesize * y + s->bpp * s->x_offset;\n\n            uint8_t *background = buffer + s->image_linesize * y + s->bpp * s->x_offset;\n\n            for (x = s->x_offset; x < s->x_offset + s->cur_w; ++x, foreground += s->bpp, background += s->bpp) {\n\n                size_t b;\n\n                uint8_t foreground_alpha, background_alpha, output_alpha;\n\n                uint8_t output[4];\n\n\n\n                // Since we might be blending alpha onto alpha, we use the following equations:\n\n                // output_alpha = foreground_alpha + (1 - foreground_alpha) * background_alpha\n\n                // output = (foreground_alpha * foreground + (1 - foreground_alpha) * background_alpha * background) / output_alpha\n\n\n\n                switch (avctx->pix_fmt) {\n\n                case AV_PIX_FMT_RGBA:\n\n                    foreground_alpha = foreground[3];\n\n                    background_alpha = background[3];\n\n                    break;\n\n\n\n                case AV_PIX_FMT_GRAY8A:\n\n                    foreground_alpha = foreground[1];\n\n                    background_alpha = background[1];\n\n                    break;\n\n\n\n                case AV_PIX_FMT_PAL8:\n\n                    foreground_alpha = s->palette[foreground[0]] >> 24;\n\n                    background_alpha = s->palette[background[0]] >> 24;\n\n                    break;\n\n                }\n\n\n\n                if (foreground_alpha == 0)\n\n                    continue;\n\n\n\n                if (foreground_alpha == 255) {\n\n                    memcpy(background, foreground, s->bpp);\n\n                    continue;\n\n                }\n\n\n\n                if (avctx->pix_fmt == AV_PIX_FMT_PAL8) {\n\n                    // TODO: Alpha blending with PAL8 will likely need the entire image converted over to RGBA first\n\n                    avpriv_request_sample(avctx, \"Alpha blending palette samples\");\n\n                    background[0] = foreground[0];\n\n                    continue;\n\n                }\n\n\n\n                output_alpha = foreground_alpha + FAST_DIV255((255 - foreground_alpha) * background_alpha);\n\n\n\n                for (b = 0; b < s->bpp - 1; ++b) {\n\n                    if (output_alpha == 0) {\n\n                        output[b] = 0;\n\n                    } else if (background_alpha == 255) {\n\n                        output[b] = FAST_DIV255(foreground_alpha * foreground[b] + (255 - foreground_alpha) * background[b]);\n\n                    } else {\n\n                        output[b] = (255 * foreground_alpha * foreground[b] + (255 - foreground_alpha) * background_alpha * background[b]) / (255 * output_alpha);\n\n                    }\n\n                }\n\n                output[b] = output_alpha;\n\n                memcpy(background, output, s->bpp);\n\n            }\n\n        }\n\n    }\n\n\n\n    // Copy blended buffer into the frame and free\n\n    memcpy(p->data[0], buffer, s->image_linesize * s->height);\n\n    av_free(buffer);\n\n\n\n    return 0;\n\n}\n", "idx": 7772}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t m5206_mbar_readl(void *opaque, target_phys_addr_t offset)\n\n{\n\n    m5206_mbar_state *s = (m5206_mbar_state *)opaque;\n\n    int width;\n\n    offset &= 0x3ff;\n\n    if (offset >= 0x200) {\n\n        hw_error(\"Bad MBAR read offset 0x%x\", (int)offset);\n\n    }\n\n    width = m5206_mbar_width[offset >> 2];\n\n    if (width < 4) {\n\n        uint32_t val;\n\n        val = m5206_mbar_readw(opaque, offset) << 16;\n\n        val |= m5206_mbar_readw(opaque, offset + 2);\n\n        return val;\n\n    }\n\n    return m5206_mbar_read(s, offset, 4);\n\n}\n", "idx": 7819}
{"project": "qemu", "commit_id": "0fb6395c0cb5046432a80d608ddde7a3b2f8a9ae", "target": 0, "func": "void commit_active_start(BlockDriverState *bs, BlockDriverState *base,\n\n                         int64_t speed,\n\n                         BlockdevOnError on_error,\n\n                         BlockDriverCompletionFunc *cb,\n\n                         void *opaque, Error **errp)\n\n{\n\n    int64_t length, base_length;\n\n    int orig_base_flags;\n\n    int ret;\n\n    Error *local_err = NULL;\n\n\n\n    orig_base_flags = bdrv_get_flags(base);\n\n\n\n    if (bdrv_reopen(base, bs->open_flags, errp)) {\n\n        return;\n\n    }\n\n\n\n    length = bdrv_getlength(bs);\n\n    if (length < 0) {\n\n        error_setg_errno(errp, -length,\n\n                         \"Unable to determine length of %s\", bs->filename);\n\n        goto error_restore_flags;\n\n    }\n\n\n\n    base_length = bdrv_getlength(base);\n\n    if (base_length < 0) {\n\n        error_setg_errno(errp, -base_length,\n\n                         \"Unable to determine length of %s\", base->filename);\n\n        goto error_restore_flags;\n\n    }\n\n\n\n    if (length > base_length) {\n\n        ret = bdrv_truncate(base, length);\n\n        if (ret < 0) {\n\n            error_setg_errno(errp, -ret,\n\n                            \"Top image %s is larger than base image %s, and \"\n\n                             \"resize of base image failed\",\n\n                             bs->filename, base->filename);\n\n            goto error_restore_flags;\n\n        }\n\n    }\n\n\n\n    bdrv_ref(base);\n\n    mirror_start_job(bs, base, speed, 0, 0,\n\n                     on_error, on_error, cb, opaque, &local_err,\n\n                     &commit_active_job_driver, false, base);\n\n    if (error_is_set(&local_err)) {\n\n        error_propagate(errp, local_err);\n\n        goto error_restore_flags;\n\n    }\n\n\n\n    return;\n\n\n\nerror_restore_flags:\n\n    /* ignore error and errp for bdrv_reopen, because we want to propagate\n\n     * the original error */\n\n    bdrv_reopen(base, orig_base_flags, NULL);\n\n    return;\n\n}\n", "idx": 7858}
{"project": "FFmpeg", "commit_id": "695af8eed642ff0104834495652d1ee784a4c14d", "target": 0, "func": "static int field_end(H264Context *h, int in_setup)\n\n{\n\n    MpegEncContext *const s     = &h->s;\n\n    AVCodecContext *const avctx = s->avctx;\n\n    int err = 0;\n\n    s->mb_y = 0;\n\n\n\n    if (!in_setup && !s->droppable)\n\n        ff_thread_report_progress(&s->current_picture_ptr->f, INT_MAX,\n\n                                  s->picture_structure == PICT_BOTTOM_FIELD);\n\n\n\n    if (CONFIG_H264_VDPAU_DECODER &&\n\n        s->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU)\n\n        ff_vdpau_h264_set_reference_frames(s);\n\n\n\n    if (in_setup || !(avctx->active_thread_type & FF_THREAD_FRAME)) {\n\n        if (!s->droppable) {\n\n            err = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index);\n\n            h->prev_poc_msb = h->poc_msb;\n\n            h->prev_poc_lsb = h->poc_lsb;\n\n        }\n\n        h->prev_frame_num_offset = h->frame_num_offset;\n\n        h->prev_frame_num        = h->frame_num;\n\n        h->outputed_poc          = h->next_outputed_poc;\n\n    }\n\n\n\n    if (avctx->hwaccel) {\n\n        if (avctx->hwaccel->end_frame(avctx) < 0)\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"hardware accelerator failed to decode picture\\n\");\n\n    }\n\n\n\n    if (CONFIG_H264_VDPAU_DECODER &&\n\n        s->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU)\n\n        ff_vdpau_h264_picture_complete(s);\n\n\n\n    /*\n\n     * FIXME: Error handling code does not seem to support interlaced\n\n     * when slices span multiple rows\n\n     * The ff_er_add_slice calls don't work right for bottom\n\n     * fields; they cause massive erroneous error concealing\n\n     * Error marking covers both fields (top and bottom).\n\n     * This causes a mismatched s->error_count\n\n     * and a bad error table. Further, the error count goes to\n\n     * INT_MAX when called for bottom field, because mb_y is\n\n     * past end by one (callers fault) and resync_mb_y != 0\n\n     * causes problems for the first MB line, too.\n\n     */\n\n    if (!FIELD_PICTURE && h->current_slice)\n\n        ff_er_frame_end(s);\n\n\n\n    ff_MPV_frame_end(s);\n\n\n\n    h->current_slice = 0;\n\n\n\n    return err;\n\n}\n", "idx": 7907}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int get_uint16(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint16_t *v = pv;\n\n    qemu_get_be16s(f, v);\n\n    return 0;\n\n}\n", "idx": 7949}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "float64 int32_to_float64( int32 a STATUS_PARAM )\n\n{\n\n    flag zSign;\n\n    uint32 absA;\n\n    int8 shiftCount;\n\n    bits64 zSig;\n\n\n\n    if ( a == 0 ) return 0;\n\n    zSign = ( a < 0 );\n\n    absA = zSign ? - a : a;\n\n    shiftCount = countLeadingZeros32( absA ) + 21;\n\n    zSig = absA;\n\n    return packFloat64( zSign, 0x432 - shiftCount, zSig<<shiftCount );\n\n\n\n}\n", "idx": 7995}
{"project": "qemu", "commit_id": "577d0a38070d1d6c4c7fab5c2054380770b1ec6b", "target": 0, "func": "void blkconf_serial(BlockConf *conf, char **serial)\n\n{\n\n    DriveInfo *dinfo;\n\n\n\n    if (!*serial) {\n\n        /* try to fall back to value set with legacy -drive serial=... */\n\n        dinfo = drive_get_by_blockdev(conf->bs);\n\n        if (*dinfo->serial) {\n\n            *serial = g_strdup(dinfo->serial);\n\n        }\n\n    }\n\n}\n", "idx": 7998}
{"project": "FFmpeg", "commit_id": "6f600ab35424823fb682b5669241edcc66590a8d", "target": 0, "func": "static av_cold int oggvorbis_encode_init(AVCodecContext *avccontext)\n\n{\n\n    OggVorbisContext *context = avccontext->priv_data;\n\n    ogg_packet header, header_comm, header_code;\n\n    uint8_t *p;\n\n    unsigned int offset;\n\n\n\n    vorbis_info_init(&context->vi);\n\n    if (oggvorbis_init_encoder(&context->vi, avccontext) < 0) {\n\n        av_log(avccontext, AV_LOG_ERROR, \"oggvorbis_encode_init: init_encoder failed\\n\");\n\n        return -1;\n\n    }\n\n    vorbis_analysis_init(&context->vd, &context->vi);\n\n    vorbis_block_init(&context->vd, &context->vb);\n\n\n\n    vorbis_comment_init(&context->vc);\n\n    vorbis_comment_add_tag(&context->vc, \"encoder\", LIBAVCODEC_IDENT);\n\n\n\n    vorbis_analysis_headerout(&context->vd, &context->vc, &header,\n\n                              &header_comm, &header_code);\n\n\n\n    avccontext->extradata_size =\n\n        1 + xiph_len(header.bytes) + xiph_len(header_comm.bytes) +\n\n        header_code.bytes;\n\n    p = avccontext->extradata =\n\n            av_malloc(avccontext->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n    p[0]    = 2;\n\n    offset  = 1;\n\n    offset += av_xiphlacing(&p[offset], header.bytes);\n\n    offset += av_xiphlacing(&p[offset], header_comm.bytes);\n\n    memcpy(&p[offset], header.packet, header.bytes);\n\n    offset += header.bytes;\n\n    memcpy(&p[offset], header_comm.packet, header_comm.bytes);\n\n    offset += header_comm.bytes;\n\n    memcpy(&p[offset], header_code.packet, header_code.bytes);\n\n    offset += header_code.bytes;\n\n    assert(offset == avccontext->extradata_size);\n\n\n\n#if 0\n\n    vorbis_block_clear(&context->vb);\n\n    vorbis_dsp_clear(&context->vd);\n\n    vorbis_info_clear(&context->vi);\n\n#endif\n\n    vorbis_comment_clear(&context->vc);\n\n\n\n    avccontext->frame_size = OGGVORBIS_FRAME_SIZE;\n\n\n\n    avccontext->coded_frame = avcodec_alloc_frame();\n\n\n\n    return 0;\n\n}\n", "idx": 8093}
{"project": "qemu", "commit_id": "bea60dd7679364493a0d7f5b54316c767cf894ef", "target": 1, "func": "static void pointer_event(VncState *vs, int button_mask, int x, int y)\n\n{\n\n    static uint32_t bmap[INPUT_BUTTON_MAX] = {\n\n        [INPUT_BUTTON_LEFT]       = 0x01,\n\n        [INPUT_BUTTON_MIDDLE]     = 0x02,\n\n        [INPUT_BUTTON_RIGHT]      = 0x04,\n\n        [INPUT_BUTTON_WHEEL_UP]   = 0x08,\n\n        [INPUT_BUTTON_WHEEL_DOWN] = 0x10,\n\n    };\n\n    QemuConsole *con = vs->vd->dcl.con;\n\n    int width = surface_width(vs->vd->ds);\n\n    int height = surface_height(vs->vd->ds);\n\n\n\n    if (vs->last_bmask != button_mask) {\n\n        qemu_input_update_buttons(con, bmap, vs->last_bmask, button_mask);\n\n        vs->last_bmask = button_mask;\n\n    }\n\n\n\n    if (vs->absolute) {\n\n        qemu_input_queue_abs(con, INPUT_AXIS_X, x, width);\n\n        qemu_input_queue_abs(con, INPUT_AXIS_Y, y, height);\n\n    } else if (vnc_has_feature(vs, VNC_FEATURE_POINTER_TYPE_CHANGE)) {\n\n        qemu_input_queue_rel(con, INPUT_AXIS_X, x - 0x7FFF);\n\n        qemu_input_queue_rel(con, INPUT_AXIS_Y, y - 0x7FFF);\n\n    } else {\n\n        if (vs->last_x != -1) {\n\n            qemu_input_queue_rel(con, INPUT_AXIS_X, x - vs->last_x);\n\n            qemu_input_queue_rel(con, INPUT_AXIS_Y, y - vs->last_y);\n\n        }\n\n        vs->last_x = x;\n\n        vs->last_y = y;\n\n    }\n\n    qemu_input_event_sync();\n\n}\n", "idx": 8173}
{"project": "FFmpeg", "commit_id": "ed7fa39c2dd63607fd5c5ed3c607a11a8a33bbe3", "target": 0, "func": "static int mov_write_avcc_tag(ByteIOContext *pb, MOVTrack *track)\n\n{\n\n    offset_t pos = url_ftell(pb);\n\n\n\n    put_be32(pb, 0);\n\n    put_tag(pb, \"avcC\");\n\n    if (track->vosLen > 6) {\n\n        /* check for h264 start code */\n\n        if (AV_RB32(track->vosData) == 0x00000001) {\n\n            uint8_t *buf, *end;\n\n            uint32_t sps_size=0, pps_size=0;\n\n            uint8_t *sps=0, *pps=0;\n\n\n\n            avc_parse_nal_units(&track->vosData, &track->vosLen);\n\n            buf = track->vosData;\n\n            end = track->vosData + track->vosLen;\n\n\n\n            /* look for sps and pps */\n\n            while (buf < end) {\n\n                unsigned int size;\n\n                uint8_t nal_type;\n\n                size = AV_RB32(buf);\n\n                nal_type = buf[4] & 0x1f;\n\n                if (nal_type == 7) { /* SPS */\n\n                    sps = buf + 4;\n\n                    sps_size = size;\n\n                } else if (nal_type == 8) { /* PPS */\n\n                    pps = buf + 4;\n\n                    pps_size = size;\n\n                }\n\n                buf += size + 4;\n\n            }\n\n            assert(sps);\n\n            assert(pps);\n\n\n\n            put_byte(pb, 1); /* version */\n\n            put_byte(pb, sps[1]); /* profile */\n\n            put_byte(pb, sps[2]); /* profile compat */\n\n            put_byte(pb, sps[3]); /* level */\n\n            put_byte(pb, 0xff); /* 6 bits reserved (111111) + 2 bits nal size length - 1 (11) */\n\n            put_byte(pb, 0xe1); /* 3 bits reserved (111) + 5 bits number of sps (00001) */\n\n\n\n            put_be16(pb, sps_size);\n\n            put_buffer(pb, sps, sps_size);\n\n            put_byte(pb, 1); /* number of pps */\n\n            put_be16(pb, pps_size);\n\n            put_buffer(pb, pps, pps_size);\n\n        } else {\n\n            put_buffer(pb, track->vosData, track->vosLen);\n\n        }\n\n    }\n\n    return updateSize(pb, pos);\n\n}\n", "idx": 8190}
{"project": "qemu", "commit_id": "7c560456707bfe53eb1728fcde759be7d9418b62", "target": 0, "func": "static void ecc_mem_writeb(void *opaque, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    printf(\"ECC: Unsupported write 0x\" TARGET_FMT_plx \" %02x\\n\",\n\n           addr, val & 0xff);\n\n}\n", "idx": 8250}
{"project": "qemu", "commit_id": "f8c35c1d59c9fecf79f6d5a02cd09f472a6f411d", "target": 0, "func": "static int bdrv_write_em(BlockDriverState *bs, int64_t sector_num,\n\n                         const uint8_t *buf, int nb_sectors)\n\n{\n\n    int async_ret;\n\n    BlockDriverAIOCB *acb;\n\n    struct iovec iov;\n\n    QEMUIOVector qiov;\n\n\n\n    async_ret = NOT_DONE;\n\n    iov.iov_base = (void *)buf;\n\n    iov.iov_len = nb_sectors * BDRV_SECTOR_SIZE;\n\n    qemu_iovec_init_external(&qiov, &iov, 1);\n\n\n\n    acb = bs->drv->bdrv_aio_writev(bs, sector_num, &qiov, nb_sectors,\n\n                                   bdrv_rw_em_cb, &async_ret);\n\n    if (acb == NULL) {\n\n        async_ret = -1;\n\n        goto fail;\n\n    }\n\n    while (async_ret == NOT_DONE) {\n\n        qemu_aio_wait();\n\n    }\n\n\n\nfail:\n\n    return async_ret;\n\n}\n", "idx": 8255}
{"project": "qemu", "commit_id": "0cd09c3a6cc2230ba38c462fc410b4acce59eb6f", "target": 0, "func": "static uint32_t virtio_9p_get_features(VirtIODevice *vdev, uint32_t features)\n\n{\n\n    features |= 1 << VIRTIO_9P_MOUNT_TAG;\n\n    return features;\n\n}\n", "idx": 8262}
{"project": "qemu", "commit_id": "24355b79bdaf6ab12f7c610b032fc35ec045cd55", "target": 1, "func": "static void scsi_write_same_complete(void *opaque, int ret)\n\n{\n\n    WriteSameCBData *data = opaque;\n\n    SCSIDiskReq *r = data->r;\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n\n\n    assert(r->req.aiocb != NULL);\n\n    r->req.aiocb = NULL;\n\n    aio_context_acquire(blk_get_aio_context(s->qdev.conf.blk));\n\n    if (scsi_disk_req_check_error(r, ret, true)) {\n\n        goto done;\n\n    }\n\n\n\n    block_acct_done(blk_get_stats(s->qdev.conf.blk), &r->acct);\n\n\n\n    data->nb_sectors -= data->iov.iov_len / 512;\n\n    data->sector += data->iov.iov_len / 512;\n\n    data->iov.iov_len = MIN(data->nb_sectors * 512, data->iov.iov_len);\n\n    if (data->iov.iov_len) {\n\n        block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct,\n\n                         data->iov.iov_len, BLOCK_ACCT_WRITE);\n\n        /* Reinitialize qiov, to handle unaligned WRITE SAME request\n\n         * where final qiov may need smaller size */\n\n        qemu_iovec_init_external(&data->qiov, &data->iov, 1);\n\n        r->req.aiocb = blk_aio_pwritev(s->qdev.conf.blk,\n\n                                       data->sector << BDRV_SECTOR_BITS,\n\n                                       &data->qiov, 0,\n\n                                       scsi_write_same_complete, data);\n\n\n        return;\n\n    }\n\n\n\n    scsi_req_complete(&r->req, GOOD);\n\n\n\ndone:\n\n    scsi_req_unref(&r->req);\n\n    qemu_vfree(data->iov.iov_base);\n\n    g_free(data);\n\n\n}", "idx": 8469}
{"project": "FFmpeg", "commit_id": "baf4c489e5f468a208596cd128a6f1c49e6ae35b", "target": 0, "func": "int avio_printf(AVIOContext *s, const char *fmt, ...)\n\n{\n\n    va_list ap;\n\n    char buf[4096];\n\n    int ret;\n\n\n\n    va_start(ap, fmt);\n\n    ret = vsnprintf(buf, sizeof(buf), fmt, ap);\n\n    va_end(ap);\n\n    avio_write(s, buf, strlen(buf));\n\n    return ret;\n\n}\n", "idx": 8573}
{"project": "qemu", "commit_id": "91cda45b69e45a089f9989979a65db3f710c9925", "target": 0, "func": "static int ppc_hash64_check_prot(int prot, int rw, int access_type)\n\n{\n\n    int ret;\n\n\n\n    if (access_type == ACCESS_CODE) {\n\n        if (prot & PAGE_EXEC) {\n\n            ret = 0;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    } else if (rw) {\n\n        if (prot & PAGE_WRITE) {\n\n            ret = 0;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    } else {\n\n        if (prot & PAGE_READ) {\n\n            ret = 0;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 8574}
{"project": "qemu", "commit_id": "479125d53eb8509d69a0548f131028a65fcbd65a", "target": 0, "func": "static void colo_process_checkpoint(MigrationState *s)\n\n{\n\n    QIOChannelBuffer *bioc;\n\n    QEMUFile *fb = NULL;\n\n    int64_t current_time, checkpoint_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    failover_init_state();\n\n\n\n    s->rp_state.from_dst_file = qemu_file_get_return_path(s->to_dst_file);\n\n    if (!s->rp_state.from_dst_file) {\n\n        error_report(\"Open QEMUFile from_dst_file failed\");\n\n        goto out;\n\n    }\n\n\n\n    /*\n\n     * Wait for Secondary finish loading VM states and enter COLO\n\n     * restore.\n\n     */\n\n    colo_receive_check_message(s->rp_state.from_dst_file,\n\n                       COLO_MESSAGE_CHECKPOINT_READY, &local_err);\n\n    if (local_err) {\n\n        goto out;\n\n    }\n\n    bioc = qio_channel_buffer_new(COLO_BUFFER_BASE_SIZE);\n\n    fb = qemu_fopen_channel_output(QIO_CHANNEL(bioc));\n\n    object_unref(OBJECT(bioc));\n\n\n\n    qemu_mutex_lock_iothread();\n\n    vm_start();\n\n    qemu_mutex_unlock_iothread();\n\n    trace_colo_vm_state_change(\"stop\", \"run\");\n\n\n\n    while (s->state == MIGRATION_STATUS_COLO) {\n\n        if (failover_get_state() != FAILOVER_STATUS_NONE) {\n\n            error_report(\"failover request\");\n\n            goto out;\n\n        }\n\n\n\n        current_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);\n\n        if (current_time - checkpoint_time <\n\n            s->parameters.x_checkpoint_delay) {\n\n            int64_t delay_ms;\n\n\n\n            delay_ms = s->parameters.x_checkpoint_delay -\n\n                       (current_time - checkpoint_time);\n\n            g_usleep(delay_ms * 1000);\n\n        }\n\n        ret = colo_do_checkpoint_transaction(s, bioc, fb);\n\n        if (ret < 0) {\n\n            goto out;\n\n        }\n\n        checkpoint_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);\n\n    }\n\n\n\nout:\n\n    /* Throw the unreported error message after exited from loop */\n\n    if (local_err) {\n\n        error_report_err(local_err);\n\n    }\n\n\n\n    if (fb) {\n\n        qemu_fclose(fb);\n\n    }\n\n\n\n    if (s->rp_state.from_dst_file) {\n\n        qemu_fclose(s->rp_state.from_dst_file);\n\n    }\n\n}\n", "idx": 8626}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void ecc_mem_write(void *opaque, target_phys_addr_t addr, uint64_t val,\n\n                          unsigned size)\n\n{\n\n    ECCState *s = opaque;\n\n\n\n    switch (addr >> 2) {\n\n    case ECC_MER:\n\n        if (s->version == ECC_MCC)\n\n            s->regs[ECC_MER] = (val & ECC_MER_MASK_0);\n\n        else if (s->version == ECC_EMC)\n\n            s->regs[ECC_MER] = s->version | (val & ECC_MER_MASK_1);\n\n        else if (s->version == ECC_SMC)\n\n            s->regs[ECC_MER] = s->version | (val & ECC_MER_MASK_2);\n\n        trace_ecc_mem_writel_mer(val);\n\n        break;\n\n    case ECC_MDR:\n\n        s->regs[ECC_MDR] =  val & ECC_MDR_MASK;\n\n        trace_ecc_mem_writel_mdr(val);\n\n        break;\n\n    case ECC_MFSR:\n\n        s->regs[ECC_MFSR] =  val;\n\n        qemu_irq_lower(s->irq);\n\n        trace_ecc_mem_writel_mfsr(val);\n\n        break;\n\n    case ECC_VCR:\n\n        s->regs[ECC_VCR] =  val;\n\n        trace_ecc_mem_writel_vcr(val);\n\n        break;\n\n    case ECC_DR:\n\n        s->regs[ECC_DR] =  val;\n\n        trace_ecc_mem_writel_dr(val);\n\n        break;\n\n    case ECC_ECR0:\n\n        s->regs[ECC_ECR0] =  val;\n\n        trace_ecc_mem_writel_ecr0(val);\n\n        break;\n\n    case ECC_ECR1:\n\n        s->regs[ECC_ECR0] =  val;\n\n        trace_ecc_mem_writel_ecr1(val);\n\n        break;\n\n    }\n\n}\n", "idx": 8647}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static void gen_op_mull_T0_T1(void)\n\n{\n\n    TCGv tmp1 = tcg_temp_new(TCG_TYPE_I64);\n\n    TCGv tmp2 = tcg_temp_new(TCG_TYPE_I64);\n\n\n\n    tcg_gen_extu_i32_i64(tmp1, cpu_T[0]);\n\n    tcg_gen_extu_i32_i64(tmp2, cpu_T[1]);\n\n    tcg_gen_mul_i64(tmp1, tmp1, tmp2);\n\n    tcg_gen_trunc_i64_i32(cpu_T[0], tmp1);\n\n    tcg_gen_shri_i64(tmp1, tmp1, 32);\n\n    tcg_gen_trunc_i64_i32(cpu_T[1], tmp1);\n\n}\n", "idx": 8666}
{"project": "FFmpeg", "commit_id": "3920d1387834e2bc334aff9f518f4beb24e470bd", "target": 1, "func": "static int allocate_buffers(ALACContext *alac)\n\n{\n\n    int ch;\n\n    int buf_size = alac->max_samples_per_frame * sizeof(int32_t);\n\n\n\n    for (ch = 0; ch < FFMIN(alac->channels, 2); ch++) {\n\n        FF_ALLOC_OR_GOTO(alac->avctx, alac->predict_error_buffer[ch],\n\n                         buf_size, buf_alloc_fail);\n\n\n\n        alac->direct_output = alac->sample_size > 16 && av_sample_fmt_is_planar(alac->avctx->sample_fmt);\n\n        if (!alac->direct_output) {\n\n            FF_ALLOC_OR_GOTO(alac->avctx, alac->output_samples_buffer[ch],\n\n                             buf_size, buf_alloc_fail);\n\n        }\n\n\n\n        FF_ALLOC_OR_GOTO(alac->avctx, alac->extra_bits_buffer[ch],\n\n                         buf_size, buf_alloc_fail);\n\n    }\n\n    return 0;\n\nbuf_alloc_fail:\n\n    alac_decode_close(alac->avctx);\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 8702}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static void t_gen_btst(TCGv d, TCGv a, TCGv b)\n\n{\n\n        TCGv sbit;\n\n        TCGv bset;\n\n        TCGv t0;\n\n\tint l1;\n\n\n\n        /* des ref:\n\n           The N flag is set according to the selected bit in the dest reg.\n\n           The Z flag is set if the selected bit and all bits to the right are\n\n           zero.\n\n           The X flag is cleared.\n\n           Other flags are left untouched.\n\n           The destination reg is not affected.\n\n\n\n        unsigned int fz, sbit, bset, mask, masked_t0;\n\n\n\n        sbit = T1 & 31;\n\n        bset = !!(T0 & (1 << sbit));\n\n        mask = sbit == 31 ? -1 : (1 << (sbit + 1)) - 1;\n\n        masked_t0 = T0 & mask;\n\n        fz = !(masked_t0 | bset);\n\n\n\n        // Clear the X, N and Z flags.\n\n        T0 = env->pregs[PR_CCS] & ~(X_FLAG | N_FLAG | Z_FLAG);\n\n        // Set the N and Z flags accordingly.\n\n        T0 |= (bset << 3) | (fz << 2);\n\n        */\n\n\n\n\tl1 = gen_new_label();\n\n        sbit = tcg_temp_new(TCG_TYPE_TL);\n\n        bset = tcg_temp_new(TCG_TYPE_TL);\n\n        t0 = tcg_temp_new(TCG_TYPE_TL);\n\n\n\n        /* Compute bset and sbit.  */\n\n        tcg_gen_andi_tl(sbit, b, 31);\n\n        tcg_gen_shl_tl(t0, tcg_const_tl(1), sbit);\n\n        tcg_gen_and_tl(bset, a, t0);\n\n        tcg_gen_shr_tl(bset, bset, sbit);\n\n\t/* Displace to N_FLAG.  */\n\n        tcg_gen_shli_tl(bset, bset, 3);\n\n\n\n        tcg_gen_shl_tl(sbit, tcg_const_tl(2), sbit);\n\n        tcg_gen_subi_tl(sbit, sbit, 1);\n\n        tcg_gen_and_tl(sbit, a, sbit);\n\n\n\n        tcg_gen_andi_tl(d, cpu_PR[PR_CCS], ~(X_FLAG | N_FLAG | Z_FLAG));\n\n\t/* or in the N_FLAG.  */\n\n        tcg_gen_or_tl(d, d, bset);\n\n\ttcg_gen_brcondi_tl(TCG_COND_NE, sbit, 0, l1);\n\n\t/* or in the Z_FLAG.  */\n\n\ttcg_gen_ori_tl(d, d, Z_FLAG);\n\n\tgen_set_label(l1);\n\n\n\n        tcg_temp_free(sbit);\n\n        tcg_temp_free(bset);\n\n}\n", "idx": 8750}
{"project": "qemu", "commit_id": "cf070d7ec0b8fb21faa9a630ed5cc66f90844a08", "target": 0, "func": "read_f(int argc, char **argv)\n\n{\n\n\tstruct timeval t1, t2;\n\n\tint Cflag = 0, pflag = 0, qflag = 0, vflag = 0;\n\n\tint Pflag = 0, sflag = 0, lflag = 0, bflag = 0;\n\n\tint c, cnt;\n\n\tchar *buf;\n\n\tint64_t offset;\n\n\tint count;\n\n        /* Some compilers get confused and warn if this is not initialized.  */\n\n        int total = 0;\n\n\tint pattern = 0, pattern_offset = 0, pattern_count = 0;\n\n\n\n\twhile ((c = getopt(argc, argv, \"bCl:pP:qs:v\")) != EOF) {\n\n\t\tswitch (c) {\n\n\t\tcase 'b':\n\n\t\t\tbflag = 1;\n\n\t\t\tbreak;\n\n\t\tcase 'C':\n\n\t\t\tCflag = 1;\n\n\t\t\tbreak;\n\n\t\tcase 'l':\n\n\t\t\tlflag = 1;\n\n\t\t\tpattern_count = cvtnum(optarg);\n\n\t\t\tif (pattern_count < 0) {\n\n\t\t\t\tprintf(\"non-numeric length argument -- %s\\n\", optarg);\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 'p':\n\n\t\t\tpflag = 1;\n\n\t\t\tbreak;\n\n\t\tcase 'P':\n\n\t\t\tPflag = 1;\n\n\t\t\tpattern = atoi(optarg);\n\n\t\t\tbreak;\n\n\t\tcase 'q':\n\n\t\t\tqflag = 1;\n\n\t\t\tbreak;\n\n\t\tcase 's':\n\n\t\t\tsflag = 1;\n\n\t\t\tpattern_offset = cvtnum(optarg);\n\n\t\t\tif (pattern_offset < 0) {\n\n\t\t\t\tprintf(\"non-numeric length argument -- %s\\n\", optarg);\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 'v':\n\n\t\t\tvflag = 1;\n\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\treturn command_usage(&read_cmd);\n\n\t\t}\n\n\t}\n\n\n\n\tif (optind != argc - 2)\n\n\t\treturn command_usage(&read_cmd);\n\n\n\n\tif (bflag && pflag) {\n\n\t\tprintf(\"-b and -p cannot be specified at the same time\\n\");\n\n\t\treturn 0;\n\n\t}\n\n\n\n\toffset = cvtnum(argv[optind]);\n\n\tif (offset < 0) {\n\n\t\tprintf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n\t\treturn 0;\n\n\t}\n\n\n\n\toptind++;\n\n\tcount = cvtnum(argv[optind]);\n\n\tif (count < 0) {\n\n\t\tprintf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n\t\treturn 0;\n\n\t}\n\n\n\n    if (!Pflag && (lflag || sflag)) {\n\n        return command_usage(&read_cmd);\n\n    }\n\n\n\n    if (!lflag) {\n\n        pattern_count = count - pattern_offset;\n\n    }\n\n\n\n    if ((pattern_count < 0) || (pattern_count + pattern_offset > count))  {\n\n        printf(\"pattern verfication range exceeds end of read data\\n\");\n\n        return 0;\n\n    }\n\n\n\n\tif (!pflag)\n\n\t\tif (offset & 0x1ff) {\n\n\t\t\tprintf(\"offset %lld is not sector aligned\\n\",\n\n\t\t\t\t(long long)offset);\n\n\t\t\treturn 0;\n\n\n\n\t\tif (count & 0x1ff) {\n\n\t\t\tprintf(\"count %d is not sector aligned\\n\",\n\n\t\t\t\tcount);\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t}\n\n\n\n\tbuf = qemu_io_alloc(count, 0xab);\n\n\n\n\tgettimeofday(&t1, NULL);\n\n\tif (pflag)\n\n\t\tcnt = do_pread(buf, offset, count, &total);\n\n\telse if (bflag)\n\n\t\tcnt = do_load_vmstate(buf, offset, count, &total);\n\n\telse\n\n\t\tcnt = do_read(buf, offset, count, &total);\n\n\tgettimeofday(&t2, NULL);\n\n\n\n\tif (cnt < 0) {\n\n\t\tprintf(\"read failed: %s\\n\", strerror(-cnt));\n\n\t\tgoto out;\n\n\t}\n\n\n\n\tif (Pflag) {\n\n\t\tvoid* cmp_buf = malloc(pattern_count);\n\n\t\tmemset(cmp_buf, pattern, pattern_count);\n\n\t\tif (memcmp(buf + pattern_offset, cmp_buf, pattern_count)) {\n\n\t\t\tprintf(\"Pattern verification failed at offset %lld, \"\n\n\t\t\t\t\"%d bytes\\n\",\n\n\t\t\t\t(long long) offset + pattern_offset, pattern_count);\n\n\t\t}\n\n\t\tfree(cmp_buf);\n\n\t}\n\n\n\n\tif (qflag)\n\n\t\tgoto out;\n\n\n\n        if (vflag)\n\n\t\tdump_buffer(buf, offset, count);\n\n\n\n\t/* Finally, report back -- -C gives a parsable format */\n\n\tt2 = tsub(t2, t1);\n\n\tprint_report(\"read\", &t2, offset, count, total, cnt, Cflag);\n\n\n\nout:\n\n\tqemu_io_free(buf);\n\n\n\n\treturn 0;\n\n}\n", "idx": 8758}
{"project": "FFmpeg", "commit_id": "e83aae283975ad5657c626912f9f225d7fe673f0", "target": 1, "func": "static int handle_connect_error(URLContext *s, const char *desc)\n\n{\n\n    RTMPContext *rt = s->priv_data;\n\n    char buf[300], *ptr, authmod[15];\n\n    int i = 0, ret = 0;\n\n    const char *user = \"\", *salt = \"\", *opaque = NULL,\n\n               *challenge = NULL, *cptr = NULL, *nonce = NULL;\n\n\n\n    if (!(cptr = strstr(desc, \"authmod=adobe\")) &&\n\n        !(cptr = strstr(desc, \"authmod=llnw\"))) {\n\n        av_log(s, AV_LOG_ERROR,\n\n               \"Unknown connect error (unsupported authentication method?)\\n\");\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n    cptr += strlen(\"authmod=\");\n\n    while (*cptr && *cptr != ' ' && i < sizeof(authmod) - 1)\n\n        authmod[i++] = *cptr++;\n\n    authmod[i] = '\\0';\n\n\n\n    if (!rt->username[0] || !rt->password[0]) {\n\n        av_log(s, AV_LOG_ERROR, \"No credentials set\\n\");\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    if (strstr(desc, \"?reason=authfailed\")) {\n\n        av_log(s, AV_LOG_ERROR, \"Incorrect username/password\\n\");\n\n        return AVERROR_UNKNOWN;\n\n    } else if (strstr(desc, \"?reason=nosuchuser\")) {\n\n        av_log(s, AV_LOG_ERROR, \"Incorrect username\\n\");\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    if (rt->auth_tried) {\n\n        av_log(s, AV_LOG_ERROR, \"Authentication failed\\n\");\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    rt->auth_params[0] = '\\0';\n\n\n\n    if (strstr(desc, \"code=403 need auth\")) {\n\n        snprintf(rt->auth_params, sizeof(rt->auth_params),\n\n                 \"?authmod=%s&user=%s\", authmod, rt->username);\n\n        return 0;\n\n    }\n\n\n\n    if (!(cptr = strstr(desc, \"?reason=needauth\"))) {\n\n        av_log(s, AV_LOG_ERROR, \"No auth parameters found\\n\");\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    av_strlcpy(buf, cptr + 1, sizeof(buf));\n\n    ptr = buf;\n\n\n\n    while (ptr) {\n\n        char *next  = strchr(ptr, '&');\n\n        char *value = strchr(ptr, '=');\n\n        if (next)\n\n            *next++ = '\\0';\n\n        if (value)\n\n            *value++ = '\\0';\n\n        if (!strcmp(ptr, \"user\")) {\n\n            user = value;\n\n        } else if (!strcmp(ptr, \"salt\")) {\n\n            salt = value;\n\n        } else if (!strcmp(ptr, \"opaque\")) {\n\n            opaque = value;\n\n        } else if (!strcmp(ptr, \"challenge\")) {\n\n            challenge = value;\n\n        } else if (!strcmp(ptr, \"nonce\")) {\n\n            nonce = value;\n\n        }\n\n        ptr = next;\n\n    }\n\n\n\n    if (!strcmp(authmod, \"adobe\")) {\n\n        if ((ret = do_adobe_auth(rt, user, salt, opaque, challenge)) < 0)\n\n            return ret;\n\n    } else {\n\n        if ((ret = do_llnw_auth(rt, user, nonce)) < 0)\n\n            return ret;\n\n    }\n\n\n\n    rt->auth_tried = 1;\n\n    return 0;\n\n}\n", "idx": 8802}
{"project": "FFmpeg", "commit_id": "90fc00a623de44e137fe1601b91356e8cd8bdd54", "target": 1, "func": "static int jacosub_probe(AVProbeData *p)\n\n{\n\n    const char *ptr     = p->buf;\n\n    const char *ptr_end = p->buf + p->buf_size;\n\n\n\n    if (AV_RB24(ptr) == 0xEFBBBF)\n\n        ptr += 3; /* skip UTF-8 BOM */\n\n\n\n    while (ptr < ptr_end) {\n\n        while (jss_whitespace(*ptr))\n\n            ptr++;\n\n        if (*ptr != '#' && *ptr != '\\n') {\n\n            if (timed_line(ptr))\n\n                return AVPROBE_SCORE_EXTENSION + 1;\n\n            return 0;\n\n        }\n\n        ptr += strcspn(ptr, \"\\n\") + 1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 8803}
{"project": "qemu", "commit_id": "7d553f27fce284805d7f94603932045ee3bbb979", "target": 0, "func": "static void usbredir_do_attach(void *opaque)\n\n{\n\n    USBRedirDevice *dev = opaque;\n\n\n\n    /* In order to work properly with XHCI controllers we need these caps */\n\n    if ((dev->dev.port->speedmask & USB_SPEED_MASK_SUPER) && !(\n\n        usbredirparser_peer_has_cap(dev->parser,\n\n                                    usb_redir_cap_ep_info_max_packet_size) &&\n\n        usbredirparser_peer_has_cap(dev->parser,\n\n                                    usb_redir_cap_32bits_bulk_length) &&\n\n        usbredirparser_peer_has_cap(dev->parser,\n\n                                    usb_redir_cap_64bits_ids))) {\n\n        ERROR(\"usb-redir-host lacks capabilities needed for use with XHCI\\n\");\n\n        usbredir_reject_device(dev);\n\n        return;\n\n    }\n\n\n\n    if (usb_device_attach(&dev->dev) != 0) {\n\n        WARNING(\"rejecting device due to speed mismatch\\n\");\n\n        usbredir_reject_device(dev);\n\n    }\n\n}\n", "idx": 8838}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "uint64_t helper_fctidz (uint64_t arg)\n\n{\n\n    CPU_DoubleU farg;\n\n    farg.ll = arg;\n\n\n\n    if (unlikely(float64_is_signaling_nan(farg.d))) {\n\n        /* sNaN conversion */\n\n        farg.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXSNAN | POWERPC_EXCP_FP_VXCVI);\n\n    } else if (unlikely(float64_is_nan(farg.d) || float64_is_infinity(farg.d))) {\n\n        /* qNan / infinity conversion */\n\n        farg.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXCVI);\n\n    } else {\n\n        farg.ll = float64_to_int64_round_to_zero(farg.d, &env->fp_status);\n\n    }\n\n    return farg.ll;\n\n}\n", "idx": 8853}
{"project": "FFmpeg", "commit_id": "484b1cdd5303771447e15d0067a2034b0c17fdc8", "target": 0, "func": "static int ljpeg_decode_rgb_scan(MJpegDecodeContext *s, int predictor, int point_transform){\n\n    int i, mb_x, mb_y;\n\n    uint16_t (*buffer)[4];\n\n    int left[3], top[3], topleft[3];\n\n    const int linesize= s->linesize[0];\n\n    const int mask= (1<<s->bits)-1;\n\n\n\n    av_fast_malloc(&s->ljpeg_buffer, &s->ljpeg_buffer_size, (unsigned)s->mb_width * 4 * sizeof(s->ljpeg_buffer[0][0]));\n\n    buffer= s->ljpeg_buffer;\n\n\n\n    for(i=0; i<3; i++){\n\n        buffer[0][i]= 1 << (s->bits + point_transform - 1);\n\n    }\n\n    for(mb_y = 0; mb_y < s->mb_height; mb_y++) {\n\n        const int modified_predictor= mb_y ? predictor : 1;\n\n        uint8_t *ptr = s->picture.data[0] + (linesize * mb_y);\n\n\n\n        if (s->interlaced && s->bottom_field)\n\n            ptr += linesize >> 1;\n\n\n\n        for(i=0; i<3; i++){\n\n            top[i]= left[i]= topleft[i]= buffer[0][i];\n\n        }\n\n        for(mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n            if (s->restart_interval && !s->restart_count)\n\n                s->restart_count = s->restart_interval;\n\n\n\n            for(i=0;i<3;i++) {\n\n                int pred;\n\n\n\n                topleft[i]= top[i];\n\n                top[i]= buffer[mb_x][i];\n\n\n\n                PREDICT(pred, topleft[i], top[i], left[i], modified_predictor);\n\n\n\n                left[i]=\n\n                buffer[mb_x][i]= mask & (pred + (mjpeg_decode_dc(s, s->dc_index[i]) << point_transform));\n\n            }\n\n\n\n            if (s->restart_interval && !--s->restart_count) {\n\n                align_get_bits(&s->gb);\n\n                skip_bits(&s->gb, 16); /* skip RSTn */\n\n            }\n\n        }\n\n\n\n        if(s->rct){\n\n            for(mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n                ptr[3*mb_x+1] = buffer[mb_x][0] - ((buffer[mb_x][1] + buffer[mb_x][2] - 0x200)>>2);\n\n                ptr[3*mb_x+0] = buffer[mb_x][1] + ptr[3*mb_x+1];\n\n                ptr[3*mb_x+2] = buffer[mb_x][2] + ptr[3*mb_x+1];\n\n            }\n\n        }else if(s->pegasus_rct){\n\n            for(mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n                ptr[3*mb_x+1] = buffer[mb_x][0] - ((buffer[mb_x][1] + buffer[mb_x][2])>>2);\n\n                ptr[3*mb_x+0] = buffer[mb_x][1] + ptr[3*mb_x+1];\n\n                ptr[3*mb_x+2] = buffer[mb_x][2] + ptr[3*mb_x+1];\n\n            }\n\n        }else{\n\n            for(mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n                ptr[3*mb_x+0] = buffer[mb_x][2];\n\n                ptr[3*mb_x+1] = buffer[mb_x][1];\n\n                ptr[3*mb_x+2] = buffer[mb_x][0];\n\n            }\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 8930}
{"project": "qemu", "commit_id": "f6977f15561973d4a67b6aa46da88aa678c505dd", "target": 1, "func": "static int qcow2_write_snapshots(BlockDriverState *bs)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    QCowSnapshot *sn;\n\n    QCowSnapshotHeader h;\n\n    QCowSnapshotExtraData extra;\n\n    int i, name_size, id_str_size, snapshots_size;\n\n    struct {\n\n        uint32_t nb_snapshots;\n\n        uint64_t snapshots_offset;\n\n    } QEMU_PACKED header_data;\n\n    int64_t offset, snapshots_offset;\n\n    int ret;\n\n\n\n    /* compute the size of the snapshots */\n\n    offset = 0;\n\n    for(i = 0; i < s->nb_snapshots; i++) {\n\n        sn = s->snapshots + i;\n\n        offset = align_offset(offset, 8);\n\n        offset += sizeof(h);\n\n        offset += sizeof(extra);\n\n        offset += strlen(sn->id_str);\n\n        offset += strlen(sn->name);\n\n    }\n\n    snapshots_size = offset;\n\n\n\n    /* Allocate space for the new snapshot list */\n\n    snapshots_offset = qcow2_alloc_clusters(bs, snapshots_size);\n\n    bdrv_flush(bs->file);\n\n    offset = snapshots_offset;\n\n    if (offset < 0) {\n\n        return offset;\n\n    }\n\n\n\n    /* Write all snapshots to the new list */\n\n    for(i = 0; i < s->nb_snapshots; i++) {\n\n        sn = s->snapshots + i;\n\n        memset(&h, 0, sizeof(h));\n\n        h.l1_table_offset = cpu_to_be64(sn->l1_table_offset);\n\n        h.l1_size = cpu_to_be32(sn->l1_size);\n\n        /* If it doesn't fit in 32 bit, older implementations should treat it\n\n         * as a disk-only snapshot rather than truncate the VM state */\n\n        if (sn->vm_state_size <= 0xffffffff) {\n\n            h.vm_state_size = cpu_to_be32(sn->vm_state_size);\n\n        }\n\n        h.date_sec = cpu_to_be32(sn->date_sec);\n\n        h.date_nsec = cpu_to_be32(sn->date_nsec);\n\n        h.vm_clock_nsec = cpu_to_be64(sn->vm_clock_nsec);\n\n        h.extra_data_size = cpu_to_be32(sizeof(extra));\n\n\n\n        memset(&extra, 0, sizeof(extra));\n\n        extra.vm_state_size_large = cpu_to_be64(sn->vm_state_size);\n\n        extra.disk_size = cpu_to_be64(sn->disk_size);\n\n\n\n        id_str_size = strlen(sn->id_str);\n\n        name_size = strlen(sn->name);\n\n        h.id_str_size = cpu_to_be16(id_str_size);\n\n        h.name_size = cpu_to_be16(name_size);\n\n        offset = align_offset(offset, 8);\n\n\n\n        ret = bdrv_pwrite(bs->file, offset, &h, sizeof(h));\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n        offset += sizeof(h);\n\n\n\n        ret = bdrv_pwrite(bs->file, offset, &extra, sizeof(extra));\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n        offset += sizeof(extra);\n\n\n\n        ret = bdrv_pwrite(bs->file, offset, sn->id_str, id_str_size);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n        offset += id_str_size;\n\n\n\n        ret = bdrv_pwrite(bs->file, offset, sn->name, name_size);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n        offset += name_size;\n\n    }\n\n\n\n    /*\n\n     * Update the header to point to the new snapshot table. This requires the\n\n     * new table and its refcounts to be stable on disk.\n\n     */\n\n    ret = bdrv_flush(bs);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    QEMU_BUILD_BUG_ON(offsetof(QCowHeader, snapshots_offset) !=\n\n        offsetof(QCowHeader, nb_snapshots) + sizeof(header_data.nb_snapshots));\n\n\n\n    header_data.nb_snapshots        = cpu_to_be32(s->nb_snapshots);\n\n    header_data.snapshots_offset    = cpu_to_be64(snapshots_offset);\n\n\n\n    ret = bdrv_pwrite_sync(bs->file, offsetof(QCowHeader, nb_snapshots),\n\n                           &header_data, sizeof(header_data));\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    /* free the old snapshot table */\n\n    qcow2_free_clusters(bs, s->snapshots_offset, s->snapshots_size);\n\n    s->snapshots_offset = snapshots_offset;\n\n    s->snapshots_size = snapshots_size;\n\n    return 0;\n\n\n\nfail:\n\n    return ret;\n\n}\n", "idx": 9082}
{"project": "FFmpeg", "commit_id": "57623cba1301ee7874687dd7e04c611051638e9d", "target": 0, "func": "static int vp8_lossy_decode_frame(AVCodecContext *avctx, AVFrame *p,\n\n                                  int *got_frame, uint8_t *data_start,\n\n                                  unsigned int data_size)\n\n{\n\n    WebPContext *s = avctx->priv_data;\n\n    AVPacket pkt;\n\n    int ret;\n\n\n\n    if (!s->initialized) {\n\n        ff_vp8_decode_init(avctx);\n\n        s->initialized = 1;\n\n        avctx->get_format = webp_get_format;\n\n    }\n\n    s->lossless = 0;\n\n\n\n    if (data_size > INT_MAX) {\n\n        av_log(avctx, AV_LOG_ERROR, \"unsupported chunk size\\n\");\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    av_init_packet(&pkt);\n\n    pkt.data = data_start;\n\n    pkt.size = data_size;\n\n\n\n    ret = ff_vp8_decode_frame(avctx, p, got_frame, &pkt);\n\n    if (s->has_alpha) {\n\n        ret = vp8_lossy_decode_alpha(avctx, p, s->alpha_data,\n\n                                     s->alpha_data_size);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n    return ret;\n\n}\n", "idx": 9130}
{"project": "FFmpeg", "commit_id": "1c495b0bf690995c45f79f4f19500921e14ec78a", "target": 1, "func": "static void sd_1d97_float(float *p, int i0, int i1)\n\n{\n\n    int i;\n\n\n\n    if (i1 <= i0 + 1) {\n\n        if (i0 == 1)\n\n            p[1] *= F_LFTG_X;\n\n        else\n\n            p[0] *= F_LFTG_K;\n\n        return;\n\n    }\n\n\n\n    extend97_float(p, i0, i1);\n\n    i0++; i1++;\n\n\n\n    for (i = i0/2 - 2; i < i1/2 + 1; i++)\n\n        p[2*i+1] -= 1.586134 * (p[2*i] + p[2*i+2]);\n\n    for (i = i0/2 - 1; i < i1/2 + 1; i++)\n\n        p[2*i] -= 0.052980 * (p[2*i-1] + p[2*i+1]);\n\n    for (i = i0/2 - 1; i < i1/2; i++)\n\n        p[2*i+1] += 0.882911 * (p[2*i] + p[2*i+2]);\n\n    for (i = i0/2; i < i1/2; i++)\n\n        p[2*i] += 0.443506 * (p[2*i-1] + p[2*i+1]);\n\n}\n", "idx": 9192}
{"project": "qemu", "commit_id": "9d8f818cdee83e726a5dd14b645738ec632d2577", "target": 0, "func": "int nbd_client_co_pdiscard(BlockDriverState *bs, int64_t offset, int bytes)\n\n{\n\n    NBDClientSession *client = nbd_get_client_session(bs);\n\n    NBDRequest request = {\n\n        .type = NBD_CMD_TRIM,\n\n        .from = offset,\n\n        .len = bytes,\n\n    };\n\n\n\n    assert(!(client->info.flags & NBD_FLAG_READ_ONLY));\n\n    if (!(client->info.flags & NBD_FLAG_SEND_TRIM)) {\n\n        return 0;\n\n    }\n\n\n\n    return nbd_co_request(bs, &request, NULL);\n\n}\n", "idx": 9207}
{"project": "FFmpeg", "commit_id": "8c50704ebf1777bee76772c4835d9760b3721057", "target": 1, "func": "static av_always_inline int vorbis_residue_decode_internal(vorbis_context *vc,\n\n                                                           vorbis_residue *vr,\n\n                                                           unsigned ch,\n\n                                                           uint8_t *do_not_decode,\n\n                                                           float *vec,\n\n                                                           unsigned vlen,\n\n                                                           unsigned ch_left,\n\n                                                           int vr_type)\n\n{\n\n    GetBitContext *gb = &vc->gb;\n\n    unsigned c_p_c        = vc->codebooks[vr->classbook].dimensions;\n\n    uint8_t *classifs = vr->classifs;\n\n    unsigned pass, ch_used, i, j, k, l;\n\n    unsigned max_output = (ch - 1) * vlen;\n\n    int ptns_to_read = vr->ptns_to_read;\n\n    int libvorbis_bug = 0;\n\n\n\n    if (vr_type == 2) {\n\n        for (j = 1; j < ch; ++j)\n\n            do_not_decode[0] &= do_not_decode[j];  // FIXME - clobbering input\n\n        if (do_not_decode[0])\n\n            return 0;\n\n        ch_used = 1;\n\n        max_output += vr->end / ch;\n\n    } else {\n\n        ch_used = ch;\n\n        max_output += vr->end;\n\n    }\n\n\n\n    if (max_output > ch_left * vlen) {\n\n        if (max_output <= ch_left * vlen + vr->partition_size*ch_used/ch) {\n\n            ptns_to_read--;\n\n            libvorbis_bug = 1;\n\n        } else {\n\n            av_log(vc->avctx, AV_LOG_ERROR, \"Insufficient output buffer\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n\n\n    av_dlog(NULL, \" residue type 0/1/2 decode begin, ch: %d  cpc %d  \\n\", ch, c_p_c);\n\n\n\n    for (pass = 0; pass <= vr->maxpass; ++pass) { // FIXME OPTIMIZE?\n\n        int voffset, partition_count, j_times_ptns_to_read;\n\n\n\n        voffset = vr->begin;\n\n        for (partition_count = 0; partition_count < ptns_to_read;) {  // SPEC        error\n\n            if (!pass) {\n\n                int ret;\n\n                if ((ret = setup_classifs(vc, vr, do_not_decode, ch_used, partition_count)) < 0)\n\n                    return ret;\n\n            }\n\n            for (i = 0; (i < c_p_c) && (partition_count < ptns_to_read); ++i) {\n\n                for (j_times_ptns_to_read = 0, j = 0; j < ch_used; ++j) {\n\n                    unsigned voffs;\n\n\n\n                    if (!do_not_decode[j]) {\n\n                        unsigned vqclass = classifs[j_times_ptns_to_read + partition_count];\n\n                        int vqbook  = vr->books[vqclass][pass];\n\n\n\n                        if (vqbook >= 0 && vc->codebooks[vqbook].codevectors) {\n\n                            unsigned coffs;\n\n                            unsigned dim  = vc->codebooks[vqbook].dimensions;\n\n                            unsigned step = FASTDIV(vr->partition_size << 1, dim << 1);\n\n                            vorbis_codebook codebook = vc->codebooks[vqbook];\n\n\n\n                            if (vr_type == 0) {\n\n\n\n                                voffs = voffset+j*vlen;\n\n                                for (k = 0; k < step; ++k) {\n\n                                    coffs = get_vlc2(gb, codebook.vlc.table, codebook.nb_bits, 3) * dim;\n\n                                    for (l = 0; l < dim; ++l)\n\n                                        vec[voffs + k + l * step] += codebook.codevectors[coffs + l];\n\n                                }\n\n                            } else if (vr_type == 1) {\n\n                                voffs = voffset + j * vlen;\n\n                                for (k = 0; k < step; ++k) {\n\n                                    coffs = get_vlc2(gb, codebook.vlc.table, codebook.nb_bits, 3) * dim;\n\n                                    for (l = 0; l < dim; ++l, ++voffs) {\n\n                                        vec[voffs]+=codebook.codevectors[coffs+l];\n\n\n\n                                        av_dlog(NULL, \" pass %d offs: %d curr: %f change: %f cv offs.: %d  \\n\",\n\n                                                pass, voffs, vec[voffs], codebook.codevectors[coffs+l], coffs);\n\n                                    }\n\n                                }\n\n                            } else if (vr_type == 2 && ch == 2 && (voffset & 1) == 0 && (dim & 1) == 0) { // most frequent case optimized\n\n                                voffs = voffset >> 1;\n\n\n\n                                if (dim == 2) {\n\n                                    for (k = 0; k < step; ++k) {\n\n                                        coffs = get_vlc2(gb, codebook.vlc.table, codebook.nb_bits, 3) * 2;\n\n                                        vec[voffs + k       ] += codebook.codevectors[coffs    ];\n\n                                        vec[voffs + k + vlen] += codebook.codevectors[coffs + 1];\n\n                                    }\n\n                                } else if (dim == 4) {\n\n                                    for (k = 0; k < step; ++k, voffs += 2) {\n\n                                        coffs = get_vlc2(gb, codebook.vlc.table, codebook.nb_bits, 3) * 4;\n\n                                        vec[voffs           ] += codebook.codevectors[coffs    ];\n\n                                        vec[voffs + 1       ] += codebook.codevectors[coffs + 2];\n\n                                        vec[voffs + vlen    ] += codebook.codevectors[coffs + 1];\n\n                                        vec[voffs + vlen + 1] += codebook.codevectors[coffs + 3];\n\n                                    }\n\n                                } else\n\n                                for (k = 0; k < step; ++k) {\n\n                                    coffs = get_vlc2(gb, codebook.vlc.table, codebook.nb_bits, 3) * dim;\n\n                                    for (l = 0; l < dim; l += 2, voffs++) {\n\n                                        vec[voffs       ] += codebook.codevectors[coffs + l    ];\n\n                                        vec[voffs + vlen] += codebook.codevectors[coffs + l + 1];\n\n\n\n                                        av_dlog(NULL, \" pass %d offs: %d curr: %f change: %f cv offs.: %d+%d  \\n\",\n\n                                                pass, voffset / ch + (voffs % ch) * vlen,\n\n                                                vec[voffset / ch + (voffs % ch) * vlen],\n\n                                                codebook.codevectors[coffs + l], coffs, l);\n\n                                    }\n\n                                }\n\n\n\n                            } else if (vr_type == 2) {\n\n                                unsigned voffs_div = FASTDIV(voffset << 1, ch <<1);\n\n                                unsigned voffs_mod = voffset - voffs_div * ch;\n\n\n\n                                for (k = 0; k < step; ++k) {\n\n                                    coffs = get_vlc2(gb, codebook.vlc.table, codebook.nb_bits, 3) * dim;\n\n                                    for (l = 0; l < dim; ++l) {\n\n                                        vec[voffs_div + voffs_mod * vlen] +=\n\n                                            codebook.codevectors[coffs + l];\n\n\n\n                                        av_dlog(NULL, \" pass %d offs: %d curr: %f change: %f cv offs.: %d+%d  \\n\",\n\n                                                pass, voffs_div + voffs_mod * vlen,\n\n                                                vec[voffs_div + voffs_mod * vlen],\n\n                                                codebook.codevectors[coffs + l], coffs, l);\n\n\n\n                                        if (++voffs_mod == ch) {\n\n                                            voffs_div++;\n\n                                            voffs_mod = 0;\n\n                                        }\n\n                                    }\n\n                                }\n\n                            }\n\n                        }\n\n                    }\n\n                    j_times_ptns_to_read += ptns_to_read;\n\n                }\n\n                ++partition_count;\n\n                voffset += vr->partition_size;\n\n            }\n\n        }\n\n        if (libvorbis_bug && !pass) {\n\n            for (j = 0; j < ch_used; ++j) {\n\n                if (!do_not_decode[j]) {\n\n                    get_vlc2(&vc->gb, vc->codebooks[vr->classbook].vlc.table,\n\n                                vc->codebooks[vr->classbook].nb_bits, 3);\n\n                }\n\n            }\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 9229}
{"project": "FFmpeg", "commit_id": "4381bddc9f93da34a44e683bdc4c05c6f061244e", "target": 0, "func": "static void ff_dlog_link(void *ctx, AVFilterLink *link, int end)\n\n{\n\n    if (link->type == AVMEDIA_TYPE_VIDEO) {\n\n        av_dlog(ctx,\n\n                \"link[%p s:%dx%d fmt:%-16s %-16s->%-16s]%s\",\n\n                link, link->w, link->h,\n\n                av_pix_fmt_descriptors[link->format].name,\n\n                link->src ? link->src->filter->name : \"\",\n\n                link->dst ? link->dst->filter->name : \"\",\n\n                end ? \"\\n\" : \"\");\n\n    } else {\n\n        char buf[128];\n\n        av_get_channel_layout_string(buf, sizeof(buf), -1, link->channel_layout);\n\n\n\n        av_dlog(ctx,\n\n                \"link[%p r:%\"PRId64\" cl:%s fmt:%-16s %-16s->%-16s]%s\",\n\n                link, link->sample_rate, buf,\n\n                av_get_sample_fmt_name(link->format),\n\n                link->src ? link->src->filter->name : \"\",\n\n                link->dst ? link->dst->filter->name : \"\",\n\n                end ? \"\\n\" : \"\");\n\n    }\n\n}\n", "idx": 9327}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qmp_migrate_set_capabilities(MigrationCapabilityStatusList *params,\n\n                                  Error **errp)\n\n{\n\n    MigrationState *s = migrate_get_current();\n\n    MigrationCapabilityStatusList *cap;\n\n\n\n    if (s->state == MIG_STATE_ACTIVE || s->state == MIG_STATE_SETUP) {\n\n        error_set(errp, QERR_MIGRATION_ACTIVE);\n\n        return;\n\n    }\n\n\n\n    for (cap = params; cap; cap = cap->next) {\n\n        s->enabled_capabilities[cap->value->capability] = cap->value->state;\n\n    }\n\n}\n", "idx": 9334}
{"project": "qemu", "commit_id": "635db18f68ded6abec11cd4cf64ebc15c1c6b190", "target": 1, "func": "void qmp_qmp_capabilities(Error **errp)\n\n{\n\n    cur_mon->qmp.in_command_mode = true;\n\n}\n", "idx": 9346}
{"project": "qemu", "commit_id": "f41152bd9d01ab327c19a3828bb7896d67cf0752", "target": 1, "func": "static void lm32_uclinux_init(QEMUMachineInitArgs *args)\n{\n    const char *cpu_model = args->cpu_model;\n    const char *kernel_filename = args->kernel_filename;\n    const char *kernel_cmdline = args->kernel_cmdline;\n    const char *initrd_filename = args->initrd_filename;\n    LM32CPU *cpu;\n    CPULM32State *env;\n    DriveInfo *dinfo;\n    MemoryRegion *address_space_mem =  get_system_memory();\n    MemoryRegion *phys_ram = g_new(MemoryRegion, 1);\n    qemu_irq *cpu_irq, irq[32];\n    HWSetup *hw;\n    ResetInfo *reset_info;\n    int i;\n    /* memory map */\n    hwaddr flash_base   = 0x04000000;\n    size_t flash_sector_size        = 256 * 1024;\n    size_t flash_size               = 32 * 1024 * 1024;\n    hwaddr ram_base     = 0x08000000;\n    size_t ram_size                 = 64 * 1024 * 1024;\n    hwaddr uart0_base   = 0x80000000;\n    hwaddr timer0_base  = 0x80002000;\n    hwaddr timer1_base  = 0x80010000;\n    hwaddr timer2_base  = 0x80012000;\n    int uart0_irq                   = 0;\n    int timer0_irq                  = 1;\n    int timer1_irq                  = 20;\n    int timer2_irq                  = 21;\n    hwaddr hwsetup_base = 0x0bffe000;\n    hwaddr cmdline_base = 0x0bfff000;\n    hwaddr initrd_base  = 0x08400000;\n    size_t initrd_max               = 0x01000000;\n    reset_info = g_malloc0(sizeof(ResetInfo));\n    if (cpu_model == NULL) {\n        cpu_model = \"lm32-full\";\n    cpu = cpu_lm32_init(cpu_model);\n    env = &cpu->env;\n    reset_info->cpu = cpu;\n    reset_info->flash_base = flash_base;\n    memory_region_init_ram(phys_ram, NULL, \"lm32_uclinux.sdram\", ram_size);\n    vmstate_register_ram_global(phys_ram);\n    memory_region_add_subregion(address_space_mem, ram_base, phys_ram);\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n    /* Spansion S29NS128P */\n    pflash_cfi02_register(flash_base, NULL, \"lm32_uclinux.flash\", flash_size,\n                          dinfo ? dinfo->bdrv : NULL, flash_sector_size,\n                          flash_size / flash_sector_size, 1, 2,\n                          0x01, 0x7e, 0x43, 0x00, 0x555, 0x2aa, 1);\n    /* create irq lines */\n    cpu_irq = qemu_allocate_irqs(cpu_irq_handler, env, 1);\n    env->pic_state = lm32_pic_init(*cpu_irq);\n    for (i = 0; i < 32; i++) {\n        irq[i] = qdev_get_gpio_in(env->pic_state, i);\n    sysbus_create_simple(\"lm32-uart\", uart0_base, irq[uart0_irq]);\n    sysbus_create_simple(\"lm32-timer\", timer0_base, irq[timer0_irq]);\n    sysbus_create_simple(\"lm32-timer\", timer1_base, irq[timer1_irq]);\n    sysbus_create_simple(\"lm32-timer\", timer2_base, irq[timer2_irq]);\n    /* make sure juart isn't the first chardev */\n    env->juart_state = lm32_juart_init();\n    reset_info->bootstrap_pc = flash_base;\n    if (kernel_filename) {\n        uint64_t entry;\n        int kernel_size;\n        kernel_size = load_elf(kernel_filename, NULL, NULL, &entry, NULL, NULL,\n                               1, ELF_MACHINE, 0);\n        reset_info->bootstrap_pc = entry;\n        if (kernel_size < 0) {\n            kernel_size = load_image_targphys(kernel_filename, ram_base,\n                                              ram_size);\n            reset_info->bootstrap_pc = ram_base;\n        if (kernel_size < 0) {\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n                    kernel_filename);\n    /* generate a rom with the hardware description */\n    hw = hwsetup_init();\n    hwsetup_add_cpu(hw, \"LM32\", 75000000);\n    hwsetup_add_flash(hw, \"flash\", flash_base, flash_size);\n    hwsetup_add_ddr_sdram(hw, \"ddr_sdram\", ram_base, ram_size);\n    hwsetup_add_timer(hw, \"timer0\", timer0_base, timer0_irq);\n    hwsetup_add_timer(hw, \"timer1_dev_only\", timer1_base, timer1_irq);\n    hwsetup_add_timer(hw, \"timer2_dev_only\", timer2_base, timer2_irq);\n    hwsetup_add_uart(hw, \"uart\", uart0_base, uart0_irq);\n    hwsetup_add_trailer(hw);\n    hwsetup_create_rom(hw, hwsetup_base);\n    hwsetup_free(hw);\n    reset_info->hwsetup_base = hwsetup_base;\n    if (kernel_cmdline && strlen(kernel_cmdline)) {\n        pstrcpy_targphys(\"cmdline\", cmdline_base, TARGET_PAGE_SIZE,\n                kernel_cmdline);\n        reset_info->cmdline_base = cmdline_base;\n    if (initrd_filename) {\n        size_t initrd_size;\n        initrd_size = load_image_targphys(initrd_filename, initrd_base,\n                initrd_max);\n        reset_info->initrd_base = initrd_base;\n        reset_info->initrd_size = initrd_size;\n    qemu_register_reset(main_cpu_reset, reset_info);", "idx": 9400}
{"project": "qemu", "commit_id": "ebfe27c593e5b222aa2a1fc545b447be3d995faa", "target": 1, "func": "static void disas_thumb_insn(CPUARMState *env, DisasContext *s)\n\n{\n\n    uint32_t val, insn, op, rm, rn, rd, shift, cond;\n\n    int32_t offset;\n\n    int i;\n\n    TCGv_i32 tmp;\n\n    TCGv_i32 tmp2;\n\n    TCGv_i32 addr;\n\n\n\n    if (s->condexec_mask) {\n\n        cond = s->condexec_cond;\n\n        if (cond != 0x0e) {     /* Skip conditional when condition is AL. */\n\n          s->condlabel = gen_new_label();\n\n          arm_gen_test_cc(cond ^ 1, s->condlabel);\n\n          s->condjmp = 1;\n\n        }\n\n    }\n\n\n\n    insn = arm_lduw_code(env, s->pc, s->sctlr_b);\n\n    s->pc += 2;\n\n\n\n    switch (insn >> 12) {\n\n    case 0: case 1:\n\n\n\n        rd = insn & 7;\n\n        op = (insn >> 11) & 3;\n\n        if (op == 3) {\n\n            /* add/subtract */\n\n            rn = (insn >> 3) & 7;\n\n            tmp = load_reg(s, rn);\n\n            if (insn & (1 << 10)) {\n\n                /* immediate */\n\n                tmp2 = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(tmp2, (insn >> 6) & 7);\n\n            } else {\n\n                /* reg */\n\n                rm = (insn >> 6) & 7;\n\n                tmp2 = load_reg(s, rm);\n\n            }\n\n            if (insn & (1 << 9)) {\n\n                if (s->condexec_mask)\n\n                    tcg_gen_sub_i32(tmp, tmp, tmp2);\n\n                else\n\n                    gen_sub_CC(tmp, tmp, tmp2);\n\n            } else {\n\n                if (s->condexec_mask)\n\n                    tcg_gen_add_i32(tmp, tmp, tmp2);\n\n                else\n\n                    gen_add_CC(tmp, tmp, tmp2);\n\n            }\n\n            tcg_temp_free_i32(tmp2);\n\n            store_reg(s, rd, tmp);\n\n        } else {\n\n            /* shift immediate */\n\n            rm = (insn >> 3) & 7;\n\n            shift = (insn >> 6) & 0x1f;\n\n            tmp = load_reg(s, rm);\n\n            gen_arm_shift_im(tmp, op, shift, s->condexec_mask == 0);\n\n            if (!s->condexec_mask)\n\n                gen_logic_CC(tmp);\n\n            store_reg(s, rd, tmp);\n\n        }\n\n        break;\n\n    case 2: case 3:\n\n        /* arithmetic large immediate */\n\n        op = (insn >> 11) & 3;\n\n        rd = (insn >> 8) & 0x7;\n\n        if (op == 0) { /* mov */\n\n            tmp = tcg_temp_new_i32();\n\n            tcg_gen_movi_i32(tmp, insn & 0xff);\n\n            if (!s->condexec_mask)\n\n                gen_logic_CC(tmp);\n\n            store_reg(s, rd, tmp);\n\n        } else {\n\n            tmp = load_reg(s, rd);\n\n            tmp2 = tcg_temp_new_i32();\n\n            tcg_gen_movi_i32(tmp2, insn & 0xff);\n\n            switch (op) {\n\n            case 1: /* cmp */\n\n                gen_sub_CC(tmp, tmp, tmp2);\n\n                tcg_temp_free_i32(tmp);\n\n                tcg_temp_free_i32(tmp2);\n\n                break;\n\n            case 2: /* add */\n\n                if (s->condexec_mask)\n\n                    tcg_gen_add_i32(tmp, tmp, tmp2);\n\n                else\n\n                    gen_add_CC(tmp, tmp, tmp2);\n\n                tcg_temp_free_i32(tmp2);\n\n                store_reg(s, rd, tmp);\n\n                break;\n\n            case 3: /* sub */\n\n                if (s->condexec_mask)\n\n                    tcg_gen_sub_i32(tmp, tmp, tmp2);\n\n                else\n\n                    gen_sub_CC(tmp, tmp, tmp2);\n\n                tcg_temp_free_i32(tmp2);\n\n                store_reg(s, rd, tmp);\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n    case 4:\n\n        if (insn & (1 << 11)) {\n\n            rd = (insn >> 8) & 7;\n\n            /* load pc-relative.  Bit 1 of PC is ignored.  */\n\n            val = s->pc + 2 + ((insn & 0xff) * 4);\n\n            val &= ~(uint32_t)2;\n\n            addr = tcg_temp_new_i32();\n\n            tcg_gen_movi_i32(addr, val);\n\n            tmp = tcg_temp_new_i32();\n\n            gen_aa32_ld32u_iss(s, tmp, addr, get_mem_index(s),\n\n                               rd | ISSIs16Bit);\n\n            tcg_temp_free_i32(addr);\n\n            store_reg(s, rd, tmp);\n\n            break;\n\n        }\n\n        if (insn & (1 << 10)) {\n\n            /* data processing extended or blx */\n\n            rd = (insn & 7) | ((insn >> 4) & 8);\n\n            rm = (insn >> 3) & 0xf;\n\n            op = (insn >> 8) & 3;\n\n            switch (op) {\n\n            case 0: /* add */\n\n                tmp = load_reg(s, rd);\n\n                tmp2 = load_reg(s, rm);\n\n                tcg_gen_add_i32(tmp, tmp, tmp2);\n\n                tcg_temp_free_i32(tmp2);\n\n                store_reg(s, rd, tmp);\n\n                break;\n\n            case 1: /* cmp */\n\n                tmp = load_reg(s, rd);\n\n                tmp2 = load_reg(s, rm);\n\n                gen_sub_CC(tmp, tmp, tmp2);\n\n                tcg_temp_free_i32(tmp2);\n\n                tcg_temp_free_i32(tmp);\n\n                break;\n\n            case 2: /* mov/cpy */\n\n                tmp = load_reg(s, rm);\n\n                store_reg(s, rd, tmp);\n\n                break;\n\n            case 3:/* branch [and link] exchange thumb register */\n\n                tmp = load_reg(s, rm);\n\n                if (insn & (1 << 7)) {\n\n                    ARCH(5);\n\n                    val = (uint32_t)s->pc | 1;\n\n                    tmp2 = tcg_temp_new_i32();\n\n                    tcg_gen_movi_i32(tmp2, val);\n\n                    store_reg(s, 14, tmp2);\n\n                    gen_bx(s, tmp);\n\n                } else {\n\n                    /* Only BX works as exception-return, not BLX */\n\n                    gen_bx_excret(s, tmp);\n\n                }\n\n                break;\n\n            }\n\n            break;\n\n        }\n\n\n\n        /* data processing register */\n\n        rd = insn & 7;\n\n        rm = (insn >> 3) & 7;\n\n        op = (insn >> 6) & 0xf;\n\n        if (op == 2 || op == 3 || op == 4 || op == 7) {\n\n            /* the shift/rotate ops want the operands backwards */\n\n            val = rm;\n\n            rm = rd;\n\n            rd = val;\n\n            val = 1;\n\n        } else {\n\n            val = 0;\n\n        }\n\n\n\n        if (op == 9) { /* neg */\n\n            tmp = tcg_temp_new_i32();\n\n            tcg_gen_movi_i32(tmp, 0);\n\n        } else if (op != 0xf) { /* mvn doesn't read its first operand */\n\n            tmp = load_reg(s, rd);\n\n        } else {\n\n            TCGV_UNUSED_I32(tmp);\n\n        }\n\n\n\n        tmp2 = load_reg(s, rm);\n\n        switch (op) {\n\n        case 0x0: /* and */\n\n            tcg_gen_and_i32(tmp, tmp, tmp2);\n\n            if (!s->condexec_mask)\n\n                gen_logic_CC(tmp);\n\n            break;\n\n        case 0x1: /* eor */\n\n            tcg_gen_xor_i32(tmp, tmp, tmp2);\n\n            if (!s->condexec_mask)\n\n                gen_logic_CC(tmp);\n\n            break;\n\n        case 0x2: /* lsl */\n\n            if (s->condexec_mask) {\n\n                gen_shl(tmp2, tmp2, tmp);\n\n            } else {\n\n                gen_helper_shl_cc(tmp2, cpu_env, tmp2, tmp);\n\n                gen_logic_CC(tmp2);\n\n            }\n\n            break;\n\n        case 0x3: /* lsr */\n\n            if (s->condexec_mask) {\n\n                gen_shr(tmp2, tmp2, tmp);\n\n            } else {\n\n                gen_helper_shr_cc(tmp2, cpu_env, tmp2, tmp);\n\n                gen_logic_CC(tmp2);\n\n            }\n\n            break;\n\n        case 0x4: /* asr */\n\n            if (s->condexec_mask) {\n\n                gen_sar(tmp2, tmp2, tmp);\n\n            } else {\n\n                gen_helper_sar_cc(tmp2, cpu_env, tmp2, tmp);\n\n                gen_logic_CC(tmp2);\n\n            }\n\n            break;\n\n        case 0x5: /* adc */\n\n            if (s->condexec_mask) {\n\n                gen_adc(tmp, tmp2);\n\n            } else {\n\n                gen_adc_CC(tmp, tmp, tmp2);\n\n            }\n\n            break;\n\n        case 0x6: /* sbc */\n\n            if (s->condexec_mask) {\n\n                gen_sub_carry(tmp, tmp, tmp2);\n\n            } else {\n\n                gen_sbc_CC(tmp, tmp, tmp2);\n\n            }\n\n            break;\n\n        case 0x7: /* ror */\n\n            if (s->condexec_mask) {\n\n                tcg_gen_andi_i32(tmp, tmp, 0x1f);\n\n                tcg_gen_rotr_i32(tmp2, tmp2, tmp);\n\n            } else {\n\n                gen_helper_ror_cc(tmp2, cpu_env, tmp2, tmp);\n\n                gen_logic_CC(tmp2);\n\n            }\n\n            break;\n\n        case 0x8: /* tst */\n\n            tcg_gen_and_i32(tmp, tmp, tmp2);\n\n            gen_logic_CC(tmp);\n\n            rd = 16;\n\n            break;\n\n        case 0x9: /* neg */\n\n            if (s->condexec_mask)\n\n                tcg_gen_neg_i32(tmp, tmp2);\n\n            else\n\n                gen_sub_CC(tmp, tmp, tmp2);\n\n            break;\n\n        case 0xa: /* cmp */\n\n            gen_sub_CC(tmp, tmp, tmp2);\n\n            rd = 16;\n\n            break;\n\n        case 0xb: /* cmn */\n\n            gen_add_CC(tmp, tmp, tmp2);\n\n            rd = 16;\n\n            break;\n\n        case 0xc: /* orr */\n\n            tcg_gen_or_i32(tmp, tmp, tmp2);\n\n            if (!s->condexec_mask)\n\n                gen_logic_CC(tmp);\n\n            break;\n\n        case 0xd: /* mul */\n\n            tcg_gen_mul_i32(tmp, tmp, tmp2);\n\n            if (!s->condexec_mask)\n\n                gen_logic_CC(tmp);\n\n            break;\n\n        case 0xe: /* bic */\n\n            tcg_gen_andc_i32(tmp, tmp, tmp2);\n\n            if (!s->condexec_mask)\n\n                gen_logic_CC(tmp);\n\n            break;\n\n        case 0xf: /* mvn */\n\n            tcg_gen_not_i32(tmp2, tmp2);\n\n            if (!s->condexec_mask)\n\n                gen_logic_CC(tmp2);\n\n            val = 1;\n\n            rm = rd;\n\n            break;\n\n        }\n\n        if (rd != 16) {\n\n            if (val) {\n\n                store_reg(s, rm, tmp2);\n\n                if (op != 0xf)\n\n                    tcg_temp_free_i32(tmp);\n\n            } else {\n\n                store_reg(s, rd, tmp);\n\n                tcg_temp_free_i32(tmp2);\n\n            }\n\n        } else {\n\n            tcg_temp_free_i32(tmp);\n\n            tcg_temp_free_i32(tmp2);\n\n        }\n\n        break;\n\n\n\n    case 5:\n\n        /* load/store register offset.  */\n\n        rd = insn & 7;\n\n        rn = (insn >> 3) & 7;\n\n        rm = (insn >> 6) & 7;\n\n        op = (insn >> 9) & 7;\n\n        addr = load_reg(s, rn);\n\n        tmp = load_reg(s, rm);\n\n        tcg_gen_add_i32(addr, addr, tmp);\n\n        tcg_temp_free_i32(tmp);\n\n\n\n        if (op < 3) { /* store */\n\n            tmp = load_reg(s, rd);\n\n        } else {\n\n            tmp = tcg_temp_new_i32();\n\n        }\n\n\n\n        switch (op) {\n\n        case 0: /* str */\n\n            gen_aa32_st32_iss(s, tmp, addr, get_mem_index(s), rd | ISSIs16Bit);\n\n            break;\n\n        case 1: /* strh */\n\n            gen_aa32_st16_iss(s, tmp, addr, get_mem_index(s), rd | ISSIs16Bit);\n\n            break;\n\n        case 2: /* strb */\n\n            gen_aa32_st8_iss(s, tmp, addr, get_mem_index(s), rd | ISSIs16Bit);\n\n            break;\n\n        case 3: /* ldrsb */\n\n            gen_aa32_ld8s_iss(s, tmp, addr, get_mem_index(s), rd | ISSIs16Bit);\n\n            break;\n\n        case 4: /* ldr */\n\n            gen_aa32_ld32u_iss(s, tmp, addr, get_mem_index(s), rd | ISSIs16Bit);\n\n            break;\n\n        case 5: /* ldrh */\n\n            gen_aa32_ld16u_iss(s, tmp, addr, get_mem_index(s), rd | ISSIs16Bit);\n\n            break;\n\n        case 6: /* ldrb */\n\n            gen_aa32_ld8u_iss(s, tmp, addr, get_mem_index(s), rd | ISSIs16Bit);\n\n            break;\n\n        case 7: /* ldrsh */\n\n            gen_aa32_ld16s_iss(s, tmp, addr, get_mem_index(s), rd | ISSIs16Bit);\n\n            break;\n\n        }\n\n        if (op >= 3) { /* load */\n\n            store_reg(s, rd, tmp);\n\n        } else {\n\n            tcg_temp_free_i32(tmp);\n\n        }\n\n        tcg_temp_free_i32(addr);\n\n        break;\n\n\n\n    case 6:\n\n        /* load/store word immediate offset */\n\n        rd = insn & 7;\n\n        rn = (insn >> 3) & 7;\n\n        addr = load_reg(s, rn);\n\n        val = (insn >> 4) & 0x7c;\n\n        tcg_gen_addi_i32(addr, addr, val);\n\n\n\n        if (insn & (1 << 11)) {\n\n            /* load */\n\n            tmp = tcg_temp_new_i32();\n\n            gen_aa32_ld32u(s, tmp, addr, get_mem_index(s));\n\n            store_reg(s, rd, tmp);\n\n        } else {\n\n            /* store */\n\n            tmp = load_reg(s, rd);\n\n            gen_aa32_st32(s, tmp, addr, get_mem_index(s));\n\n            tcg_temp_free_i32(tmp);\n\n        }\n\n        tcg_temp_free_i32(addr);\n\n        break;\n\n\n\n    case 7:\n\n        /* load/store byte immediate offset */\n\n        rd = insn & 7;\n\n        rn = (insn >> 3) & 7;\n\n        addr = load_reg(s, rn);\n\n        val = (insn >> 6) & 0x1f;\n\n        tcg_gen_addi_i32(addr, addr, val);\n\n\n\n        if (insn & (1 << 11)) {\n\n            /* load */\n\n            tmp = tcg_temp_new_i32();\n\n            gen_aa32_ld8u_iss(s, tmp, addr, get_mem_index(s), rd | ISSIs16Bit);\n\n            store_reg(s, rd, tmp);\n\n        } else {\n\n            /* store */\n\n            tmp = load_reg(s, rd);\n\n            gen_aa32_st8_iss(s, tmp, addr, get_mem_index(s), rd | ISSIs16Bit);\n\n            tcg_temp_free_i32(tmp);\n\n        }\n\n        tcg_temp_free_i32(addr);\n\n        break;\n\n\n\n    case 8:\n\n        /* load/store halfword immediate offset */\n\n        rd = insn & 7;\n\n        rn = (insn >> 3) & 7;\n\n        addr = load_reg(s, rn);\n\n        val = (insn >> 5) & 0x3e;\n\n        tcg_gen_addi_i32(addr, addr, val);\n\n\n\n        if (insn & (1 << 11)) {\n\n            /* load */\n\n            tmp = tcg_temp_new_i32();\n\n            gen_aa32_ld16u_iss(s, tmp, addr, get_mem_index(s), rd | ISSIs16Bit);\n\n            store_reg(s, rd, tmp);\n\n        } else {\n\n            /* store */\n\n            tmp = load_reg(s, rd);\n\n            gen_aa32_st16_iss(s, tmp, addr, get_mem_index(s), rd | ISSIs16Bit);\n\n            tcg_temp_free_i32(tmp);\n\n        }\n\n        tcg_temp_free_i32(addr);\n\n        break;\n\n\n\n    case 9:\n\n        /* load/store from stack */\n\n        rd = (insn >> 8) & 7;\n\n        addr = load_reg(s, 13);\n\n        val = (insn & 0xff) * 4;\n\n        tcg_gen_addi_i32(addr, addr, val);\n\n\n\n        if (insn & (1 << 11)) {\n\n            /* load */\n\n            tmp = tcg_temp_new_i32();\n\n            gen_aa32_ld32u_iss(s, tmp, addr, get_mem_index(s), rd | ISSIs16Bit);\n\n            store_reg(s, rd, tmp);\n\n        } else {\n\n            /* store */\n\n            tmp = load_reg(s, rd);\n\n            gen_aa32_st32_iss(s, tmp, addr, get_mem_index(s), rd | ISSIs16Bit);\n\n            tcg_temp_free_i32(tmp);\n\n        }\n\n        tcg_temp_free_i32(addr);\n\n        break;\n\n\n\n    case 10:\n\n        /* add to high reg */\n\n        rd = (insn >> 8) & 7;\n\n        if (insn & (1 << 11)) {\n\n            /* SP */\n\n            tmp = load_reg(s, 13);\n\n        } else {\n\n            /* PC. bit 1 is ignored.  */\n\n            tmp = tcg_temp_new_i32();\n\n            tcg_gen_movi_i32(tmp, (s->pc + 2) & ~(uint32_t)2);\n\n        }\n\n        val = (insn & 0xff) * 4;\n\n        tcg_gen_addi_i32(tmp, tmp, val);\n\n        store_reg(s, rd, tmp);\n\n        break;\n\n\n\n    case 11:\n\n        /* misc */\n\n        op = (insn >> 8) & 0xf;\n\n        switch (op) {\n\n        case 0:\n\n            /* adjust stack pointer */\n\n            tmp = load_reg(s, 13);\n\n            val = (insn & 0x7f) * 4;\n\n            if (insn & (1 << 7))\n\n                val = -(int32_t)val;\n\n            tcg_gen_addi_i32(tmp, tmp, val);\n\n            store_reg(s, 13, tmp);\n\n            break;\n\n\n\n        case 2: /* sign/zero extend.  */\n\n            ARCH(6);\n\n            rd = insn & 7;\n\n            rm = (insn >> 3) & 7;\n\n            tmp = load_reg(s, rm);\n\n            switch ((insn >> 6) & 3) {\n\n            case 0: gen_sxth(tmp); break;\n\n            case 1: gen_sxtb(tmp); break;\n\n            case 2: gen_uxth(tmp); break;\n\n            case 3: gen_uxtb(tmp); break;\n\n            }\n\n            store_reg(s, rd, tmp);\n\n            break;\n\n        case 4: case 5: case 0xc: case 0xd:\n\n            /* push/pop */\n\n            addr = load_reg(s, 13);\n\n            if (insn & (1 << 8))\n\n                offset = 4;\n\n            else\n\n                offset = 0;\n\n            for (i = 0; i < 8; i++) {\n\n                if (insn & (1 << i))\n\n                    offset += 4;\n\n            }\n\n            if ((insn & (1 << 11)) == 0) {\n\n                tcg_gen_addi_i32(addr, addr, -offset);\n\n            }\n\n            for (i = 0; i < 8; i++) {\n\n                if (insn & (1 << i)) {\n\n                    if (insn & (1 << 11)) {\n\n                        /* pop */\n\n                        tmp = tcg_temp_new_i32();\n\n                        gen_aa32_ld32u(s, tmp, addr, get_mem_index(s));\n\n                        store_reg(s, i, tmp);\n\n                    } else {\n\n                        /* push */\n\n                        tmp = load_reg(s, i);\n\n                        gen_aa32_st32(s, tmp, addr, get_mem_index(s));\n\n                        tcg_temp_free_i32(tmp);\n\n                    }\n\n                    /* advance to the next address.  */\n\n                    tcg_gen_addi_i32(addr, addr, 4);\n\n                }\n\n            }\n\n            TCGV_UNUSED_I32(tmp);\n\n            if (insn & (1 << 8)) {\n\n                if (insn & (1 << 11)) {\n\n                    /* pop pc */\n\n                    tmp = tcg_temp_new_i32();\n\n                    gen_aa32_ld32u(s, tmp, addr, get_mem_index(s));\n\n                    /* don't set the pc until the rest of the instruction\n\n                       has completed */\n\n                } else {\n\n                    /* push lr */\n\n                    tmp = load_reg(s, 14);\n\n                    gen_aa32_st32(s, tmp, addr, get_mem_index(s));\n\n                    tcg_temp_free_i32(tmp);\n\n                }\n\n                tcg_gen_addi_i32(addr, addr, 4);\n\n            }\n\n            if ((insn & (1 << 11)) == 0) {\n\n                tcg_gen_addi_i32(addr, addr, -offset);\n\n            }\n\n            /* write back the new stack pointer */\n\n            store_reg(s, 13, addr);\n\n            /* set the new PC value */\n\n            if ((insn & 0x0900) == 0x0900) {\n\n                store_reg_from_load(s, 15, tmp);\n\n            }\n\n            break;\n\n\n\n        case 1: case 3: case 9: case 11: /* czb */\n\n            rm = insn & 7;\n\n            tmp = load_reg(s, rm);\n\n            s->condlabel = gen_new_label();\n\n            s->condjmp = 1;\n\n            if (insn & (1 << 11))\n\n                tcg_gen_brcondi_i32(TCG_COND_EQ, tmp, 0, s->condlabel);\n\n            else\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, tmp, 0, s->condlabel);\n\n            tcg_temp_free_i32(tmp);\n\n            offset = ((insn & 0xf8) >> 2) | (insn & 0x200) >> 3;\n\n            val = (uint32_t)s->pc + 2;\n\n            val += offset;\n\n            gen_jmp(s, val);\n\n            break;\n\n\n\n        case 15: /* IT, nop-hint.  */\n\n            if ((insn & 0xf) == 0) {\n\n                gen_nop_hint(s, (insn >> 4) & 0xf);\n\n                break;\n\n            }\n\n            /* If Then.  */\n\n            s->condexec_cond = (insn >> 4) & 0xe;\n\n            s->condexec_mask = insn & 0x1f;\n\n            /* No actual code generated for this insn, just setup state.  */\n\n            break;\n\n\n\n        case 0xe: /* bkpt */\n\n        {\n\n            int imm8 = extract32(insn, 0, 8);\n\n            ARCH(5);\n\n            gen_exception_insn(s, 2, EXCP_BKPT, syn_aa32_bkpt(imm8, true),\n\n                               default_exception_el(s));\n\n            break;\n\n        }\n\n\n\n        case 0xa: /* rev, and hlt */\n\n        {\n\n            int op1 = extract32(insn, 6, 2);\n\n\n\n            if (op1 == 2) {\n\n                /* HLT */\n\n                int imm6 = extract32(insn, 0, 6);\n\n\n\n                gen_hlt(s, imm6);\n\n                break;\n\n            }\n\n\n\n            /* Otherwise this is rev */\n\n            ARCH(6);\n\n            rn = (insn >> 3) & 0x7;\n\n            rd = insn & 0x7;\n\n            tmp = load_reg(s, rn);\n\n            switch (op1) {\n\n            case 0: tcg_gen_bswap32_i32(tmp, tmp); break;\n\n            case 1: gen_rev16(tmp); break;\n\n            case 3: gen_revsh(tmp); break;\n\n            default:\n\n                g_assert_not_reached();\n\n            }\n\n            store_reg(s, rd, tmp);\n\n            break;\n\n        }\n\n\n\n        case 6:\n\n            switch ((insn >> 5) & 7) {\n\n            case 2:\n\n                /* setend */\n\n                ARCH(6);\n\n                if (((insn >> 3) & 1) != !!(s->be_data == MO_BE)) {\n\n                    gen_helper_setend(cpu_env);\n\n                    s->is_jmp = DISAS_UPDATE;\n\n                }\n\n                break;\n\n            case 3:\n\n                /* cps */\n\n                ARCH(6);\n\n                if (IS_USER(s)) {\n\n                    break;\n\n                }\n\n                if (arm_dc_feature(s, ARM_FEATURE_M)) {\n\n                    tmp = tcg_const_i32((insn & (1 << 4)) != 0);\n\n                    /* FAULTMASK */\n\n                    if (insn & 1) {\n\n                        addr = tcg_const_i32(19);\n\n                        gen_helper_v7m_msr(cpu_env, addr, tmp);\n\n                        tcg_temp_free_i32(addr);\n\n                    }\n\n                    /* PRIMASK */\n\n                    if (insn & 2) {\n\n                        addr = tcg_const_i32(16);\n\n                        gen_helper_v7m_msr(cpu_env, addr, tmp);\n\n                        tcg_temp_free_i32(addr);\n\n                    }\n\n                    tcg_temp_free_i32(tmp);\n\n                    gen_lookup_tb(s);\n\n                } else {\n\n                    if (insn & (1 << 4)) {\n\n                        shift = CPSR_A | CPSR_I | CPSR_F;\n\n                    } else {\n\n                        shift = 0;\n\n                    }\n\n                    gen_set_psr_im(s, ((insn & 7) << 6), 0, shift);\n\n                }\n\n                break;\n\n            default:\n\n                goto undef;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            goto undef;\n\n        }\n\n        break;\n\n\n\n    case 12:\n\n    {\n\n        /* load/store multiple */\n\n        TCGv_i32 loaded_var;\n\n        TCGV_UNUSED_I32(loaded_var);\n\n        rn = (insn >> 8) & 0x7;\n\n        addr = load_reg(s, rn);\n\n        for (i = 0; i < 8; i++) {\n\n            if (insn & (1 << i)) {\n\n                if (insn & (1 << 11)) {\n\n                    /* load */\n\n                    tmp = tcg_temp_new_i32();\n\n                    gen_aa32_ld32u(s, tmp, addr, get_mem_index(s));\n\n                    if (i == rn) {\n\n                        loaded_var = tmp;\n\n                    } else {\n\n                        store_reg(s, i, tmp);\n\n                    }\n\n                } else {\n\n                    /* store */\n\n                    tmp = load_reg(s, i);\n\n                    gen_aa32_st32(s, tmp, addr, get_mem_index(s));\n\n                    tcg_temp_free_i32(tmp);\n\n                }\n\n                /* advance to the next address */\n\n                tcg_gen_addi_i32(addr, addr, 4);\n\n            }\n\n        }\n\n        if ((insn & (1 << rn)) == 0) {\n\n            /* base reg not in list: base register writeback */\n\n            store_reg(s, rn, addr);\n\n        } else {\n\n            /* base reg in list: if load, complete it now */\n\n            if (insn & (1 << 11)) {\n\n                store_reg(s, rn, loaded_var);\n\n            }\n\n            tcg_temp_free_i32(addr);\n\n        }\n\n        break;\n\n    }\n\n    case 13:\n\n        /* conditional branch or swi */\n\n        cond = (insn >> 8) & 0xf;\n\n        if (cond == 0xe)\n\n            goto undef;\n\n\n\n        if (cond == 0xf) {\n\n            /* swi */\n\n            gen_set_pc_im(s, s->pc);\n\n            s->svc_imm = extract32(insn, 0, 8);\n\n            s->is_jmp = DISAS_SWI;\n\n            break;\n\n        }\n\n        /* generate a conditional jump to next instruction */\n\n        s->condlabel = gen_new_label();\n\n        arm_gen_test_cc(cond ^ 1, s->condlabel);\n\n        s->condjmp = 1;\n\n\n\n        /* jump to the offset */\n\n        val = (uint32_t)s->pc + 2;\n\n        offset = ((int32_t)insn << 24) >> 24;\n\n        val += offset << 1;\n\n        gen_jmp(s, val);\n\n        break;\n\n\n\n    case 14:\n\n        if (insn & (1 << 11)) {\n\n            if (disas_thumb2_insn(env, s, insn))\n\n              goto undef32;\n\n            break;\n\n        }\n\n        /* unconditional branch */\n\n        val = (uint32_t)s->pc;\n\n        offset = ((int32_t)insn << 21) >> 21;\n\n        val += (offset << 1) + 2;\n\n        gen_jmp(s, val);\n\n        break;\n\n\n\n    case 15:\n\n        if (disas_thumb2_insn(env, s, insn))\n\n            goto undef32;\n\n        break;\n\n    }\n\n    return;\n\nundef32:\n\n    gen_exception_insn(s, 4, EXCP_UDEF, syn_uncategorized(),\n\n                       default_exception_el(s));\n\n    return;\n\nillegal_op:\n\nundef:\n\n    gen_exception_insn(s, 2, EXCP_UDEF, syn_uncategorized(),\n\n                       default_exception_el(s));\n\n}\n", "idx": 9458}
{"project": "qemu", "commit_id": "c1d4096b0f033d0a52c542f0948403783c3682e9", "target": 1, "func": "static int iscsi_open(BlockDriverState *bs, QDict *options, int flags,\n                      Error **errp)\n{\n    IscsiLun *iscsilun = bs->opaque;\n    struct iscsi_context *iscsi = NULL;\n    struct iscsi_url *iscsi_url = NULL;\n    struct scsi_task *task = NULL;\n    struct scsi_inquiry_standard *inq = NULL;\n    struct scsi_inquiry_supported_pages *inq_vpd;\n    char *initiator_name = NULL;\n    QemuOpts *opts;\n    Error *local_err = NULL;\n    const char *filename;\n    int i, ret;\n    if ((BDRV_SECTOR_SIZE % 512) != 0) {\n        error_setg(errp, \"iSCSI: Invalid BDRV_SECTOR_SIZE. \"\n                   \"BDRV_SECTOR_SIZE(%lld) is not a multiple \"\n                   \"of 512\", BDRV_SECTOR_SIZE);\n        return -EINVAL;\n    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);\n    qemu_opts_absorb_qdict(opts, options, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        ret = -EINVAL;\n    filename = qemu_opt_get(opts, \"filename\");\n    iscsi_url = iscsi_parse_full_url(iscsi, filename);\n    if (iscsi_url == NULL) {\n        error_setg(errp, \"Failed to parse URL : %s\", filename);\n        ret = -EINVAL;\n    memset(iscsilun, 0, sizeof(IscsiLun));\n    initiator_name = parse_initiator_name(iscsi_url->target);\n    iscsi = iscsi_create_context(initiator_name);\n    if (iscsi == NULL) {\n        error_setg(errp, \"iSCSI: Failed to create iSCSI context.\");\n        ret = -ENOMEM;\n    if (iscsi_set_targetname(iscsi, iscsi_url->target)) {\n        error_setg(errp, \"iSCSI: Failed to set target name.\");\n        ret = -EINVAL;\n    if (iscsi_url->user != NULL) {\n        ret = iscsi_set_initiator_username_pwd(iscsi, iscsi_url->user,\n                                              iscsi_url->passwd);\n        if (ret != 0) {\n            error_setg(errp, \"Failed to set initiator username and password\");\n            ret = -EINVAL;\n    /* check if we got CHAP username/password via the options */\n    parse_chap(iscsi, iscsi_url->target, &local_err);\n    if (local_err != NULL) {\n        error_propagate(errp, local_err);\n        ret = -EINVAL;\n    if (iscsi_set_session_type(iscsi, ISCSI_SESSION_NORMAL) != 0) {\n        error_setg(errp, \"iSCSI: Failed to set session type to normal.\");\n        ret = -EINVAL;\n    iscsi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_NONE_CRC32C);\n    /* check if we got HEADER_DIGEST via the options */\n    parse_header_digest(iscsi, iscsi_url->target, &local_err);\n    if (local_err != NULL) {\n        error_propagate(errp, local_err);\n        ret = -EINVAL;\n    if (iscsi_full_connect_sync(iscsi, iscsi_url->portal, iscsi_url->lun) != 0) {\n        error_setg(errp, \"iSCSI: Failed to connect to LUN : %s\",\n            iscsi_get_error(iscsi));\n        ret = -EINVAL;\n    iscsilun->iscsi = iscsi;\n    iscsilun->aio_context = bdrv_get_aio_context(bs);\n    iscsilun->lun   = iscsi_url->lun;\n    iscsilun->has_write_same = true;\n    task = iscsi_do_inquiry(iscsilun->iscsi, iscsilun->lun, 0, 0,\n                            (void **) &inq, errp);\n    if (task == NULL) {\n        ret = -EINVAL;\n    iscsilun->type = inq->periperal_device_type;\n    scsi_free_scsi_task(task);\n    task = NULL;\n    iscsi_readcapacity_sync(iscsilun, &local_err);\n    if (local_err != NULL) {\n        error_propagate(errp, local_err);\n        ret = -EINVAL;\n    bs->total_sectors = sector_lun2qemu(iscsilun->num_blocks, iscsilun);\n    bs->request_alignment = iscsilun->block_size;\n    /* We don't have any emulation for devices other than disks and CD-ROMs, so\n     * this must be sg ioctl compatible. We force it to be sg, otherwise qemu\n     * will try to read from the device to guess the image format.\n     */\n    if (iscsilun->type != TYPE_DISK && iscsilun->type != TYPE_ROM) {\n        bs->sg = 1;\n    task = iscsi_do_inquiry(iscsilun->iscsi, iscsilun->lun, 1,\n                            SCSI_INQUIRY_PAGECODE_SUPPORTED_VPD_PAGES,\n                            (void **) &inq_vpd, errp);\n    if (task == NULL) {\n        ret = -EINVAL;\n    for (i = 0; i < inq_vpd->num_pages; i++) {\n        struct scsi_task *inq_task;\n        struct scsi_inquiry_logical_block_provisioning *inq_lbp;\n        struct scsi_inquiry_block_limits *inq_bl;\n        switch (inq_vpd->pages[i]) {\n        case SCSI_INQUIRY_PAGECODE_LOGICAL_BLOCK_PROVISIONING:\n            inq_task = iscsi_do_inquiry(iscsilun->iscsi, iscsilun->lun, 1,\n                                        SCSI_INQUIRY_PAGECODE_LOGICAL_BLOCK_PROVISIONING,\n                                        (void **) &inq_lbp, errp);\n            if (inq_task == NULL) {\n                ret = -EINVAL;\n            memcpy(&iscsilun->lbp, inq_lbp,\n                   sizeof(struct scsi_inquiry_logical_block_provisioning));\n            scsi_free_scsi_task(inq_task);\n            break;\n        case SCSI_INQUIRY_PAGECODE_BLOCK_LIMITS:\n            inq_task = iscsi_do_inquiry(iscsilun->iscsi, iscsilun->lun, 1,\n                                    SCSI_INQUIRY_PAGECODE_BLOCK_LIMITS,\n                                    (void **) &inq_bl, errp);\n            if (inq_task == NULL) {\n                ret = -EINVAL;\n            memcpy(&iscsilun->bl, inq_bl,\n                   sizeof(struct scsi_inquiry_block_limits));\n            scsi_free_scsi_task(inq_task);\n            break;\n        default:\n            break;\n    scsi_free_scsi_task(task);\n    task = NULL;\n    iscsi_attach_aio_context(bs, iscsilun->aio_context);\n    /* Guess the internal cluster (page) size of the iscsi target by the means\n     * of opt_unmap_gran. Transfer the unmap granularity only if it has a\n     * reasonable size */\n    if (iscsilun->bl.opt_unmap_gran * iscsilun->block_size >= 4 * 1024 &&\n        iscsilun->bl.opt_unmap_gran * iscsilun->block_size <= 16 * 1024 * 1024) {\n        iscsilun->cluster_sectors = (iscsilun->bl.opt_unmap_gran *\n                                     iscsilun->block_size) >> BDRV_SECTOR_BITS;\n        if (iscsilun->lbprz && !(bs->open_flags & BDRV_O_NOCACHE)) {\n            iscsilun->allocationmap = iscsi_allocationmap_init(iscsilun);\n            if (iscsilun->allocationmap == NULL) {\n                ret = -ENOMEM;\nout:\n    qemu_opts_del(opts);\n    g_free(initiator_name);\n    if (iscsi_url != NULL) {\n        iscsi_destroy_url(iscsi_url);\n    if (task != NULL) {\n        scsi_free_scsi_task(task);\n    if (ret) {\n        if (iscsi != NULL) {\n            iscsi_destroy_context(iscsi);\n        memset(iscsilun, 0, sizeof(IscsiLun));\n    return ret;", "idx": 9460}
{"project": "FFmpeg", "commit_id": "0ce3a0f9d9523a9bcad4c6d451ca5bbd7a4f420d", "target": 1, "func": "static void restore_median(uint8_t *src, int step, int stride,\n\n                           int width, int height, int slices, int rmode)\n\n{\n\n    int i, j, slice;\n\n    int A, B, C;\n\n    uint8_t *bsrc;\n\n    int slice_start, slice_height;\n\n    const int cmask = ~rmode;\n\n\n\n    for (slice = 0; slice < slices; slice++) {\n\n        slice_start  = ((slice * height) / slices) & cmask;\n\n        slice_height = ((((slice + 1) * height) / slices) & cmask) -\n\n                       slice_start;\n\n\n\n\n\n        bsrc = src + slice_start * stride;\n\n\n\n        // first line - left neighbour prediction\n\n        bsrc[0] += 0x80;\n\n        A = bsrc[0];\n\n        for (i = step; i < width * step; i += step) {\n\n            bsrc[i] += A;\n\n            A        = bsrc[i];\n\n        }\n\n        bsrc += stride;\n\n        if (slice_height == 1)\n\n\n        // second line - first element has top prediction, the rest uses median\n\n        C        = bsrc[-stride];\n\n        bsrc[0] += C;\n\n        A        = bsrc[0];\n\n        for (i = step; i < width * step; i += step) {\n\n            B        = bsrc[i - stride];\n\n            bsrc[i] += mid_pred(A, B, (uint8_t)(A + B - C));\n\n            C        = B;\n\n            A        = bsrc[i];\n\n        }\n\n        bsrc += stride;\n\n        // the rest of lines use continuous median prediction\n\n        for (j = 2; j < slice_height; j++) {\n\n            for (i = 0; i < width * step; i += step) {\n\n                B        = bsrc[i - stride];\n\n                bsrc[i] += mid_pred(A, B, (uint8_t)(A + B - C));\n\n                C        = B;\n\n                A        = bsrc[i];\n\n            }\n\n            bsrc += stride;\n\n        }\n\n    }\n\n}", "idx": 9466}
{"project": "FFmpeg", "commit_id": "d9d9fd9446eb722fd288f56d905f0dfde661af8f", "target": 1, "func": "int ff_mpeg_er_init(MpegEncContext *s)\n\n{\n\n    ERContext *er = &s->er;\n\n    int mb_array_size = s->mb_height * s->mb_stride;\n\n    int i;\n\n\n\n    er->avctx       = s->avctx;\n\n\n\n    er->mb_index2xy = s->mb_index2xy;\n\n    er->mb_num      = s->mb_num;\n\n    er->mb_width    = s->mb_width;\n\n    er->mb_height   = s->mb_height;\n\n    er->mb_stride   = s->mb_stride;\n\n    er->b8_stride   = s->b8_stride;\n\n\n\n    er->er_temp_buffer     = av_malloc(s->mb_height * s->mb_stride);\n\n    er->error_status_table = av_mallocz(mb_array_size);\n\n    if (!er->er_temp_buffer || !er->error_status_table)\n\n        goto fail;\n\n\n\n    er->mbskip_table  = s->mbskip_table;\n\n    er->mbintra_table = s->mbintra_table;\n\n\n\n    for (i = 0; i < FF_ARRAY_ELEMS(s->dc_val); i++)\n\n        er->dc_val[i] = s->dc_val[i];\n\n\n\n    er->decode_mb = mpeg_er_decode_mb;\n\n    er->opaque    = s;\n\n\n\n    return 0;\n\nfail:\n\n    av_freep(&er->er_temp_buffer);\n\n    av_freep(&er->error_status_table);\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 9483}
{"project": "FFmpeg", "commit_id": "4f00519d9508e07aac58a00a9b514dae8ad95723", "target": 1, "func": "int vc1_decode_entry_point(AVCodecContext *avctx, VC1Context *v, GetBitContext *gb)\n\n{\n\n    int i;\n\n\n\n    av_log(avctx, AV_LOG_DEBUG, \"Entry point: %08X\\n\", show_bits_long(gb, 32));\n\n    v->broken_link = get_bits1(gb);\n\n    v->closed_entry = get_bits1(gb);\n\n    v->panscanflag = get_bits1(gb);\n\n    v->refdist_flag = get_bits1(gb);\n\n    v->s.loop_filter = get_bits1(gb);\n\n    v->fastuvmc = get_bits1(gb);\n\n    v->extended_mv = get_bits1(gb);\n\n    v->dquant = get_bits(gb, 2);\n\n    v->vstransform = get_bits1(gb);\n\n    v->overlap = get_bits1(gb);\n\n    v->quantizer_mode = get_bits(gb, 2);\n\n\n\n    if(v->hrd_param_flag){\n\n        for(i = 0; i < v->hrd_num_leaky_buckets; i++) {\n\n            skip_bits(gb, 8); //hrd_full[n]\n\n        }\n\n    }\n\n\n\n    if(get_bits1(gb)){\n\n        avctx->coded_width = (get_bits(gb, 12)+1)<<1;\n\n        avctx->coded_height = (get_bits(gb, 12)+1)<<1;\n\n    }\n\n    if(v->extended_mv)\n\n        v->extended_dmv = get_bits1(gb);\n\n    if((v->range_mapy_flag = get_bits1(gb))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Luma scaling is not supported, expect wrong picture\\n\");\n\n        v->range_mapy = get_bits(gb, 3);\n\n    }\n\n    if((v->range_mapuv_flag = get_bits1(gb))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Chroma scaling is not supported, expect wrong picture\\n\");\n\n        v->range_mapuv = get_bits(gb, 3);\n\n    }\n\n\n\n    av_log(avctx, AV_LOG_DEBUG, \"Entry point info:\\n\"\n\n        \"BrokenLink=%i, ClosedEntry=%i, PanscanFlag=%i\\n\"\n\n        \"RefDist=%i, Postproc=%i, FastUVMC=%i, ExtMV=%i\\n\"\n\n        \"DQuant=%i, VSTransform=%i, Overlap=%i, Qmode=%i\\n\",\n\n        v->broken_link, v->closed_entry, v->panscanflag, v->refdist_flag, v->s.loop_filter,\n\n        v->fastuvmc, v->extended_mv, v->dquant, v->vstransform, v->overlap, v->quantizer_mode);\n\n\n\n    return 0;\n\n}\n", "idx": 9515}
{"project": "FFmpeg", "commit_id": "c3ab0004ae4dffc32494ae84dd15cfaa909a7884", "target": 1, "func": "static inline void RENAME(bgr24ToUV_half)(uint8_t *dstU, uint8_t *dstV, const uint8_t *src1, const uint8_t *src2, int width, uint32_t *unused)\n\n{\n\n    int i;\n\n    for (i=0; i<width; i++) {\n\n        int b= src1[6*i + 0] + src1[6*i + 3];\n\n        int g= src1[6*i + 1] + src1[6*i + 4];\n\n        int r= src1[6*i + 2] + src1[6*i + 5];\n\n\n\n        dstU[i]= (RU*r + GU*g + BU*b + (257<<RGB2YUV_SHIFT))>>(RGB2YUV_SHIFT+1);\n\n        dstV[i]= (RV*r + GV*g + BV*b + (257<<RGB2YUV_SHIFT))>>(RGB2YUV_SHIFT+1);\n\n    }\n\n    assert(src1 == src2);\n\n}\n", "idx": 9522}
{"project": "qemu", "commit_id": "55e00a19b6dc8f20e5688866451bb4a60e649459", "target": 0, "func": "static void armv7m_nvic_class_init(ObjectClass *klass, void *data)\n\n{\n\n    NVICClass *nc = NVIC_CLASS(klass);\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    SysBusDeviceClass *sdc = SYS_BUS_DEVICE_CLASS(klass);\n\n\n\n    nc->parent_reset = dc->reset;\n\n    nc->parent_init = sdc->init;\n\n    sdc->init = armv7m_nvic_init;\n\n    dc->vmsd  = &vmstate_nvic;\n\n    dc->reset = armv7m_nvic_reset;\n\n    dc->props = armv7m_nvic_properties;\n\n}\n", "idx": 9579}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t intel_hda_mmio_readw(void *opaque, target_phys_addr_t addr)\n\n{\n\n    IntelHDAState *d = opaque;\n\n    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);\n\n\n\n    return intel_hda_reg_read(d, reg, 0xffff);\n\n}\n", "idx": 9585}
{"project": "qemu", "commit_id": "210b580b106fa798149e28aa13c66b325a43204e", "target": 0, "func": "static void rtas_ibm_read_pci_config(sPAPREnvironment *spapr,\n\n                                     uint32_t token, uint32_t nargs,\n\n                                     target_ulong args,\n\n                                     uint32_t nret, target_ulong rets)\n\n{\n\n    uint64_t buid;\n\n    uint32_t size, addr;\n\n\n\n    if ((nargs != 4) || (nret != 2)) {\n\n        rtas_st(rets, 0, -1);\n\n        return;\n\n    }\n\n\n\n    buid = ((uint64_t)rtas_ld(args, 1) << 32) | rtas_ld(args, 2);\n\n    size = rtas_ld(args, 3);\n\n    addr = rtas_ld(args, 0);\n\n\n\n    finish_read_pci_config(spapr, buid, addr, size, rets);\n\n}\n", "idx": 9586}
{"project": "FFmpeg", "commit_id": "2e7744a6a265604600f86a85c6961dbf5df9ecdd", "target": 1, "func": "static int subviewer_decode_frame(AVCodecContext *avctx,\n\n                                  void *data, int *got_sub_ptr, AVPacket *avpkt)\n\n{\n\n    char c;\n\n    AVSubtitle *sub = data;\n\n    const char *ptr = avpkt->data;\n\n    AVBPrint buf;\n\n\n\n    /* To be removed later */\n\n    if (sscanf(ptr, \"%*u:%*u:%*u.%*u,%*u:%*u:%*u.%*u%c\", &c) == 1) {\n\n        av_log(avctx, AV_LOG_ERROR, \"AVPacket is not clean (contains timing \"\n\n               \"information). You need to upgrade your libavformat or \"\n\n               \"sanitize your packet.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    av_bprint_init(&buf, 0, AV_BPRINT_SIZE_UNLIMITED);\n\n    // note: no need to rescale pts & duration since they are in the same\n\n    // timebase as ASS (1/100)\n\n    if (ptr && avpkt->size > 0 && !subviewer_event_to_ass(&buf, ptr))\n\n        ff_ass_add_rect(sub, buf.str, avpkt->pts, avpkt->duration, 0);\n\n    *got_sub_ptr = sub->num_rects > 0;\n\n    av_bprint_finalize(&buf, NULL);\n\n    return avpkt->size;\n\n}\n", "idx": 9649}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "void bdrv_aio_cancel_async(BlockAIOCB *acb)\n\n{\n\n    if (acb->aiocb_info->cancel_async) {\n\n        acb->aiocb_info->cancel_async(acb);\n\n    }\n\n}\n", "idx": 9743}
{"project": "qemu", "commit_id": "9dfef5aae422d479d8e561889da05cf31d850d5c", "target": 0, "func": "static void *spapr_create_fdt_skel(const char *cpu_model,\n\n                                   target_phys_addr_t initrd_base,\n\n                                   target_phys_addr_t initrd_size,\n\n                                   const char *boot_device,\n\n                                   const char *kernel_cmdline,\n\n                                   long hash_shift)\n\n{\n\n    void *fdt;\n\n    CPUState *env;\n\n    uint64_t mem_reg_property[] = { 0, cpu_to_be64(ram_size) };\n\n    uint32_t start_prop = cpu_to_be32(initrd_base);\n\n    uint32_t end_prop = cpu_to_be32(initrd_base + initrd_size);\n\n    uint32_t pft_size_prop[] = {0, cpu_to_be32(hash_shift)};\n\n    char hypertas_prop[] = \"hcall-pft\\0hcall-term\\0hcall-dabr\\0hcall-interrupt\"\n\n        \"\\0hcall-tce\\0hcall-vio\\0hcall-splpar\";\n\n    uint32_t interrupt_server_ranges_prop[] = {0, cpu_to_be32(smp_cpus)};\n\n    int i;\n\n    char *modelname;\n\n\n\n#define _FDT(exp) \\\n\n    do { \\\n\n        int ret = (exp);                                           \\\n\n        if (ret < 0) {                                             \\\n\n            fprintf(stderr, \"qemu: error creating device tree: %s: %s\\n\", \\\n\n                    #exp, fdt_strerror(ret));                      \\\n\n            exit(1);                                               \\\n\n        }                                                          \\\n\n    } while (0)\n\n\n\n    fdt = g_malloc0(FDT_MAX_SIZE);\n\n    _FDT((fdt_create(fdt, FDT_MAX_SIZE)));\n\n\n\n    _FDT((fdt_finish_reservemap(fdt)));\n\n\n\n    /* Root node */\n\n    _FDT((fdt_begin_node(fdt, \"\")));\n\n    _FDT((fdt_property_string(fdt, \"device_type\", \"chrp\")));\n\n    _FDT((fdt_property_string(fdt, \"model\", \"IBM pSeries (emulated by qemu)\")));\n\n\n\n    _FDT((fdt_property_cell(fdt, \"#address-cells\", 0x2)));\n\n    _FDT((fdt_property_cell(fdt, \"#size-cells\", 0x2)));\n\n\n\n    /* /chosen */\n\n    _FDT((fdt_begin_node(fdt, \"chosen\")));\n\n\n\n    _FDT((fdt_property_string(fdt, \"bootargs\", kernel_cmdline)));\n\n    _FDT((fdt_property(fdt, \"linux,initrd-start\",\n\n                       &start_prop, sizeof(start_prop))));\n\n    _FDT((fdt_property(fdt, \"linux,initrd-end\",\n\n                       &end_prop, sizeof(end_prop))));\n\n    _FDT((fdt_property_string(fdt, \"qemu,boot-device\", boot_device)));\n\n\n\n    _FDT((fdt_end_node(fdt)));\n\n\n\n    /* memory node */\n\n    _FDT((fdt_begin_node(fdt, \"memory@0\")));\n\n\n\n    _FDT((fdt_property_string(fdt, \"device_type\", \"memory\")));\n\n    _FDT((fdt_property(fdt, \"reg\",\n\n                       mem_reg_property, sizeof(mem_reg_property))));\n\n\n\n    _FDT((fdt_end_node(fdt)));\n\n\n\n    /* cpus */\n\n    _FDT((fdt_begin_node(fdt, \"cpus\")));\n\n\n\n    _FDT((fdt_property_cell(fdt, \"#address-cells\", 0x1)));\n\n    _FDT((fdt_property_cell(fdt, \"#size-cells\", 0x0)));\n\n\n\n    modelname = g_strdup(cpu_model);\n\n\n\n    for (i = 0; i < strlen(modelname); i++) {\n\n        modelname[i] = toupper(modelname[i]);\n\n    }\n\n\n\n    for (env = first_cpu; env != NULL; env = env->next_cpu) {\n\n        int index = env->cpu_index;\n\n        uint32_t gserver_prop[] = {cpu_to_be32(index), 0}; /* HACK! */\n\n        char *nodename;\n\n        uint32_t segs[] = {cpu_to_be32(28), cpu_to_be32(40),\n\n                           0xffffffff, 0xffffffff};\n\n        uint32_t tbfreq = kvm_enabled() ? kvmppc_get_tbfreq() : TIMEBASE_FREQ;\n\n        uint32_t cpufreq = kvm_enabled() ? kvmppc_get_clockfreq() : 1000000000;\n\n\n\n        if (asprintf(&nodename, \"%s@%x\", modelname, index) < 0) {\n\n            fprintf(stderr, \"Allocation failure\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        _FDT((fdt_begin_node(fdt, nodename)));\n\n\n\n        free(nodename);\n\n\n\n        _FDT((fdt_property_cell(fdt, \"reg\", index)));\n\n        _FDT((fdt_property_string(fdt, \"device_type\", \"cpu\")));\n\n\n\n        _FDT((fdt_property_cell(fdt, \"cpu-version\", env->spr[SPR_PVR])));\n\n        _FDT((fdt_property_cell(fdt, \"dcache-block-size\",\n\n                                env->dcache_line_size)));\n\n        _FDT((fdt_property_cell(fdt, \"icache-block-size\",\n\n                                env->icache_line_size)));\n\n        _FDT((fdt_property_cell(fdt, \"timebase-frequency\", tbfreq)));\n\n        _FDT((fdt_property_cell(fdt, \"clock-frequency\", cpufreq)));\n\n        _FDT((fdt_property_cell(fdt, \"ibm,slb-size\", env->slb_nr)));\n\n        _FDT((fdt_property(fdt, \"ibm,pft-size\",\n\n                           pft_size_prop, sizeof(pft_size_prop))));\n\n        _FDT((fdt_property_string(fdt, \"status\", \"okay\")));\n\n        _FDT((fdt_property(fdt, \"64-bit\", NULL, 0)));\n\n        _FDT((fdt_property_cell(fdt, \"ibm,ppc-interrupt-server#s\", index)));\n\n        _FDT((fdt_property(fdt, \"ibm,ppc-interrupt-gserver#s\",\n\n                           gserver_prop, sizeof(gserver_prop))));\n\n\n\n        if (env->mmu_model & POWERPC_MMU_1TSEG) {\n\n            _FDT((fdt_property(fdt, \"ibm,processor-segment-sizes\",\n\n                               segs, sizeof(segs))));\n\n        }\n\n\n\n        _FDT((fdt_end_node(fdt)));\n\n    }\n\n\n\n    g_free(modelname);\n\n\n\n    _FDT((fdt_end_node(fdt)));\n\n\n\n    /* RTAS */\n\n    _FDT((fdt_begin_node(fdt, \"rtas\")));\n\n\n\n    _FDT((fdt_property(fdt, \"ibm,hypertas-functions\", hypertas_prop,\n\n                       sizeof(hypertas_prop))));\n\n\n\n    _FDT((fdt_end_node(fdt)));\n\n\n\n    /* interrupt controller */\n\n    _FDT((fdt_begin_node(fdt, \"interrupt-controller@0\")));\n\n\n\n    _FDT((fdt_property_string(fdt, \"device_type\",\n\n                              \"PowerPC-External-Interrupt-Presentation\")));\n\n    _FDT((fdt_property_string(fdt, \"compatible\", \"IBM,ppc-xicp\")));\n\n    _FDT((fdt_property_cell(fdt, \"reg\", 0)));\n\n    _FDT((fdt_property(fdt, \"interrupt-controller\", NULL, 0)));\n\n    _FDT((fdt_property(fdt, \"ibm,interrupt-server-ranges\",\n\n                       interrupt_server_ranges_prop,\n\n                       sizeof(interrupt_server_ranges_prop))));\n\n    _FDT((fdt_property_cell(fdt, \"#interrupt-cells\", 2)));\n\n    _FDT((fdt_property_cell(fdt, \"linux,phandle\", PHANDLE_XICP)));\n\n    _FDT((fdt_property_cell(fdt, \"phandle\", PHANDLE_XICP)));\n\n\n\n    _FDT((fdt_end_node(fdt)));\n\n\n\n    /* vdevice */\n\n    _FDT((fdt_begin_node(fdt, \"vdevice\")));\n\n\n\n    _FDT((fdt_property_string(fdt, \"device_type\", \"vdevice\")));\n\n    _FDT((fdt_property_string(fdt, \"compatible\", \"IBM,vdevice\")));\n\n    _FDT((fdt_property_cell(fdt, \"#address-cells\", 0x1)));\n\n    _FDT((fdt_property_cell(fdt, \"#size-cells\", 0x0)));\n\n    _FDT((fdt_property_cell(fdt, \"#interrupt-cells\", 0x2)));\n\n    _FDT((fdt_property(fdt, \"interrupt-controller\", NULL, 0)));\n\n\n\n    _FDT((fdt_end_node(fdt)));\n\n\n\n    _FDT((fdt_end_node(fdt))); /* close root node */\n\n    _FDT((fdt_finish(fdt)));\n\n\n\n    return fdt;\n\n}\n", "idx": 9756}
{"project": "FFmpeg", "commit_id": "cc13bc8c4f0f4afa30d0b94c3f3a369ccd2aaf0b", "target": 0, "func": "static int decode_extradata_ps(const uint8_t *data, int size, H264ParamSets *ps,\n\n                               int is_avc, void *logctx)\n\n{\n\n    H2645Packet pkt = { 0 };\n\n    int i, ret = 0;\n\n\n\n    ret = ff_h2645_packet_split(&pkt, data, size, logctx, is_avc, 2, AV_CODEC_ID_H264);\n\n    if (ret < 0) {\n\n        ret = 0;\n\n        goto fail;\n\n    }\n\n\n\n    for (i = 0; i < pkt.nb_nals; i++) {\n\n        H2645NAL *nal = &pkt.nals[i];\n\n        switch (nal->type) {\n\n        case H264_NAL_SPS:\n\n            ret = ff_h264_decode_seq_parameter_set(&nal->gb, logctx, ps, 0);\n\n            if (ret < 0)\n\n                goto fail;\n\n            break;\n\n        case H264_NAL_PPS:\n\n            ret = ff_h264_decode_picture_parameter_set(&nal->gb, logctx, ps,\n\n                                                       nal->size_bits);\n\n            if (ret < 0)\n\n                goto fail;\n\n            break;\n\n        default:\n\n            av_log(logctx, AV_LOG_VERBOSE, \"Ignoring NAL type %d in extradata\\n\",\n\n                   nal->type);\n\n            break;\n\n        }\n\n    }\n\n\n\nfail:\n\n    ff_h2645_packet_uninit(&pkt);\n\n    return ret;\n\n}\n", "idx": 9759}
{"project": "qemu", "commit_id": "c834cba90521576224c30b15ebb4d6aeab7b42c4", "target": 1, "func": "int qcow2_get_cluster_offset(BlockDriverState *bs, uint64_t offset,\n\n                             unsigned int *bytes, uint64_t *cluster_offset)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    unsigned int l2_index;\n\n    uint64_t l1_index, l2_offset, *l2_table;\n\n    int l1_bits, c;\n\n    unsigned int offset_in_cluster, nb_clusters;\n\n    uint64_t bytes_available, bytes_needed;\n\n    int ret;\n\n\n\n    offset_in_cluster = offset_into_cluster(s, offset);\n\n    bytes_needed = (uint64_t) *bytes + offset_in_cluster;\n\n\n\n    l1_bits = s->l2_bits + s->cluster_bits;\n\n\n\n    /* compute how many bytes there are between the start of the cluster\n\n     * containing offset and the end of the l1 entry */\n\n    bytes_available = (1ULL << l1_bits) - (offset & ((1ULL << l1_bits) - 1))\n\n                    + offset_in_cluster;\n\n\n\n    if (bytes_needed > bytes_available) {\n\n        bytes_needed = bytes_available;\n\n    }\n\n    assert(bytes_needed <= INT_MAX);\n\n\n\n    *cluster_offset = 0;\n\n\n\n    /* seek to the l2 offset in the l1 table */\n\n\n\n    l1_index = offset >> l1_bits;\n\n    if (l1_index >= s->l1_size) {\n\n        ret = QCOW2_CLUSTER_UNALLOCATED;\n\n        goto out;\n\n    }\n\n\n\n    l2_offset = s->l1_table[l1_index] & L1E_OFFSET_MASK;\n\n    if (!l2_offset) {\n\n        ret = QCOW2_CLUSTER_UNALLOCATED;\n\n        goto out;\n\n    }\n\n\n\n    if (offset_into_cluster(s, l2_offset)) {\n\n        qcow2_signal_corruption(bs, true, -1, -1, \"L2 table offset %#\" PRIx64\n\n                                \" unaligned (L1 index: %#\" PRIx64 \")\",\n\n                                l2_offset, l1_index);\n\n        return -EIO;\n\n    }\n\n\n\n    /* load the l2 table in memory */\n\n\n\n    ret = l2_load(bs, l2_offset, &l2_table);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* find the cluster offset for the given disk offset */\n\n\n\n    l2_index = (offset >> s->cluster_bits) & (s->l2_size - 1);\n\n    *cluster_offset = be64_to_cpu(l2_table[l2_index]);\n\n\n\n    /* nb_needed <= INT_MAX, thus nb_clusters <= INT_MAX, too */\n\n    nb_clusters = size_to_clusters(s, bytes_needed);\n\n\n\n    ret = qcow2_get_cluster_type(*cluster_offset);\n\n    switch (ret) {\n\n    case QCOW2_CLUSTER_COMPRESSED:\n\n        /* Compressed clusters can only be processed one by one */\n\n        c = 1;\n\n        *cluster_offset &= L2E_COMPRESSED_OFFSET_SIZE_MASK;\n\n        break;\n\n    case QCOW2_CLUSTER_ZERO:\n\n        if (s->qcow_version < 3) {\n\n            qcow2_signal_corruption(bs, true, -1, -1, \"Zero cluster entry found\"\n\n                                    \" in pre-v3 image (L2 offset: %#\" PRIx64\n\n                                    \", L2 index: %#x)\", l2_offset, l2_index);\n\n            ret = -EIO;\n\n            goto fail;\n\n        }\n\n        c = count_contiguous_clusters_by_type(nb_clusters, &l2_table[l2_index],\n\n                                              QCOW2_CLUSTER_ZERO);\n\n        *cluster_offset = 0;\n\n        break;\n\n    case QCOW2_CLUSTER_UNALLOCATED:\n\n        /* how many empty clusters ? */\n\n        c = count_contiguous_clusters_by_type(nb_clusters, &l2_table[l2_index],\n\n                                              QCOW2_CLUSTER_UNALLOCATED);\n\n        *cluster_offset = 0;\n\n        break;\n\n    case QCOW2_CLUSTER_NORMAL:\n\n        /* how many allocated clusters ? */\n\n        c = count_contiguous_clusters(nb_clusters, s->cluster_size,\n\n                &l2_table[l2_index], QCOW_OFLAG_ZERO);\n\n        *cluster_offset &= L2E_OFFSET_MASK;\n\n        if (offset_into_cluster(s, *cluster_offset)) {\n\n            qcow2_signal_corruption(bs, true, -1, -1, \"Data cluster offset %#\"\n\n                                    PRIx64 \" unaligned (L2 offset: %#\" PRIx64\n\n                                    \", L2 index: %#x)\", *cluster_offset,\n\n                                    l2_offset, l2_index);\n\n            ret = -EIO;\n\n            goto fail;\n\n        }\n\n        break;\n\n    default:\n\n        abort();\n\n    }\n\n\n\n    qcow2_cache_put(bs, s->l2_table_cache, (void**) &l2_table);\n\n\n\n    bytes_available = (c * s->cluster_size);\n\n\n\nout:\n\n    if (bytes_available > bytes_needed) {\n\n        bytes_available = bytes_needed;\n\n    }\n\n\n\n    *bytes = bytes_available - offset_in_cluster;\n\n\n\n    return ret;\n\n\n\nfail:\n\n    qcow2_cache_put(bs, s->l2_table_cache, (void **)&l2_table);\n\n    return ret;\n\n}\n", "idx": 9765}
{"project": "FFmpeg", "commit_id": "22522d9c2c69624fe4d81d61ee65a56610f22f1d", "target": 1, "func": "int ff_qsv_decode_init(AVCodecContext *avctx, QSVContext *q, mfxSession session)\n\n{\n\n    mfxVideoParam param = { { 0 } };\n\n    int ret;\n\n\n\n    q->async_fifo = av_fifo_alloc((1 + q->async_depth) *\n\n                                  (sizeof(mfxSyncPoint) + sizeof(QSVFrame*)));\n\n    if (!q->async_fifo)\n\n        return AVERROR(ENOMEM);\n\n\n\n    ret = qsv_init_session(avctx, q, session);\n\n    if (ret < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error initializing an MFX session\\n\");\n\n        return ret;\n\n    }\n\n\n\n\n\n    ret = ff_qsv_codec_id_to_mfx(avctx->codec_id);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    param.mfx.CodecId      = ret;\n\n    param.mfx.CodecProfile = avctx->profile;\n\n    param.mfx.CodecLevel   = avctx->level;\n\n\n\n    param.mfx.FrameInfo.BitDepthLuma   = 8;\n\n    param.mfx.FrameInfo.BitDepthChroma = 8;\n\n    param.mfx.FrameInfo.Shift          = 0;\n\n    param.mfx.FrameInfo.FourCC         = MFX_FOURCC_NV12;\n\n    param.mfx.FrameInfo.Width          = avctx->coded_width;\n\n    param.mfx.FrameInfo.Height         = avctx->coded_height;\n\n    param.mfx.FrameInfo.ChromaFormat   = MFX_CHROMAFORMAT_YUV420;\n\n\n\n    param.IOPattern   = q->iopattern;\n\n    param.AsyncDepth  = q->async_depth;\n\n    param.ExtParam    = q->ext_buffers;\n\n    param.NumExtParam = q->nb_ext_buffers;\n\n\n\n    ret = MFXVideoDECODE_Init(q->session, &param);\n\n    if (ret < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error initializing the MFX video decoder\\n\");\n\n        return ff_qsv_error(ret);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 9774}
{"project": "qemu", "commit_id": "fc9c0a9c4b2c07cf2b8683f2617af584f14c93e7", "target": 1, "func": "void block_job_sleep_ns(BlockJob *job, QEMUClockType type, int64_t ns)\n\n{\n\n    assert(job->busy);\n\n\n\n    /* Check cancellation *before* setting busy = false, too!  */\n\n    if (block_job_is_cancelled(job)) {\n\n        return;\n\n    }\n\n\n\n    job->busy = false;\n\n    if (!block_job_should_pause(job)) {\n\n        co_aio_sleep_ns(blk_get_aio_context(job->blk), type, ns);\n\n    }\n\n    /* The job can be paused while sleeping, so check this again */\n\n    if (block_job_should_pause(job)) {\n\n        qemu_coroutine_yield();\n\n    }\n\n    job->busy = true;\n\n}\n", "idx": 9780}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static int ohci_service_td(OHCIState *ohci, struct ohci_ed *ed)\n\n{\n\n    int dir;\n\n    size_t len = 0;\n\n#ifdef DEBUG_PACKET\n\n    const char *str = NULL;\n\n#endif\n\n    int pid;\n\n    int ret;\n\n    int i;\n\n    USBDevice *dev;\n\n    struct ohci_td td;\n\n    uint32_t addr;\n\n    int flag_r;\n\n    int completion;\n\n\n\n    addr = ed->head & OHCI_DPTR_MASK;\n\n    /* See if this TD has already been submitted to the device.  */\n\n    completion = (addr == ohci->async_td);\n\n    if (completion && !ohci->async_complete) {\n\n#ifdef DEBUG_PACKET\n\n        DPRINTF(\"Skipping async TD\\n\");\n\n#endif\n\n        return 1;\n\n    }\n\n    if (!ohci_read_td(ohci, addr, &td)) {\n\n        fprintf(stderr, \"usb-ohci: TD read error at %x\\n\", addr);\n\n        return 0;\n\n    }\n\n\n\n    dir = OHCI_BM(ed->flags, ED_D);\n\n    switch (dir) {\n\n    case OHCI_TD_DIR_OUT:\n\n    case OHCI_TD_DIR_IN:\n\n        /* Same value.  */\n\n        break;\n\n    default:\n\n        dir = OHCI_BM(td.flags, TD_DP);\n\n        break;\n\n    }\n\n\n\n    switch (dir) {\n\n    case OHCI_TD_DIR_IN:\n\n#ifdef DEBUG_PACKET\n\n        str = \"in\";\n\n#endif\n\n        pid = USB_TOKEN_IN;\n\n        break;\n\n    case OHCI_TD_DIR_OUT:\n\n#ifdef DEBUG_PACKET\n\n        str = \"out\";\n\n#endif\n\n        pid = USB_TOKEN_OUT;\n\n        break;\n\n    case OHCI_TD_DIR_SETUP:\n\n#ifdef DEBUG_PACKET\n\n        str = \"setup\";\n\n#endif\n\n        pid = USB_TOKEN_SETUP;\n\n        break;\n\n    default:\n\n        fprintf(stderr, \"usb-ohci: Bad direction\\n\");\n\n        return 1;\n\n    }\n\n    if (td.cbp && td.be) {\n\n        if ((td.cbp & 0xfffff000) != (td.be & 0xfffff000)) {\n\n            len = (td.be & 0xfff) + 0x1001 - (td.cbp & 0xfff);\n\n        } else {\n\n            len = (td.be - td.cbp) + 1;\n\n        }\n\n\n\n        if (len && dir != OHCI_TD_DIR_IN && !completion) {\n\n            ohci_copy_td(ohci, &td, ohci->usb_buf, len, 0);\n\n        }\n\n    }\n\n\n\n    flag_r = (td.flags & OHCI_TD_R) != 0;\n\n#ifdef DEBUG_PACKET\n\n    DPRINTF(\" TD @ 0x%.8x %\" PRId64 \" bytes %s r=%d cbp=0x%.8x be=0x%.8x\\n\",\n\n            addr, (int64_t)len, str, flag_r, td.cbp, td.be);\n\n\n\n    if (len > 0 && dir != OHCI_TD_DIR_IN) {\n\n        DPRINTF(\"  data:\");\n\n        for (i = 0; i < len; i++)\n\n            printf(\" %.2x\", ohci->usb_buf[i]);\n\n        DPRINTF(\"\\n\");\n\n    }\n\n#endif\n\n    if (completion) {\n\n        ret = ohci->usb_packet.len;\n\n        ohci->async_td = 0;\n\n        ohci->async_complete = 0;\n\n    } else {\n\n        ret = USB_RET_NODEV;\n\n        for (i = 0; i < ohci->num_ports; i++) {\n\n            dev = ohci->rhport[i].port.dev;\n\n            if ((ohci->rhport[i].ctrl & OHCI_PORT_PES) == 0)\n\n                continue;\n\n\n\n            if (ohci->async_td) {\n\n                /* ??? The hardware should allow one active packet per\n\n                   endpoint.  We only allow one active packet per controller.\n\n                   This should be sufficient as long as devices respond in a\n\n                   timely manner.\n\n                 */\n\n#ifdef DEBUG_PACKET\n\n                DPRINTF(\"Too many pending packets\\n\");\n\n#endif\n\n                return 1;\n\n            }\n\n            ohci->usb_packet.pid = pid;\n\n            ohci->usb_packet.devaddr = OHCI_BM(ed->flags, ED_FA);\n\n            ohci->usb_packet.devep = OHCI_BM(ed->flags, ED_EN);\n\n            ohci->usb_packet.data = ohci->usb_buf;\n\n            ohci->usb_packet.len = len;\n\n            ret = usb_handle_packet(dev, &ohci->usb_packet);\n\n            if (ret != USB_RET_NODEV)\n\n                break;\n\n        }\n\n#ifdef DEBUG_PACKET\n\n        DPRINTF(\"ret=%d\\n\", ret);\n\n#endif\n\n        if (ret == USB_RET_ASYNC) {\n\n            ohci->async_td = addr;\n\n            return 1;\n\n        }\n\n    }\n\n    if (ret >= 0) {\n\n        if (dir == OHCI_TD_DIR_IN) {\n\n            ohci_copy_td(ohci, &td, ohci->usb_buf, ret, 1);\n\n#ifdef DEBUG_PACKET\n\n            DPRINTF(\"  data:\");\n\n            for (i = 0; i < ret; i++)\n\n                printf(\" %.2x\", ohci->usb_buf[i]);\n\n            DPRINTF(\"\\n\");\n\n#endif\n\n        } else {\n\n            ret = len;\n\n        }\n\n    }\n\n\n\n    /* Writeback */\n\n    if (ret == len || (dir == OHCI_TD_DIR_IN && ret >= 0 && flag_r)) {\n\n        /* Transmission succeeded.  */\n\n        if (ret == len) {\n\n            td.cbp = 0;\n\n        } else {\n\n            td.cbp += ret;\n\n            if ((td.cbp & 0xfff) + ret > 0xfff) {\n\n                td.cbp &= 0xfff;\n\n                td.cbp |= td.be & ~0xfff;\n\n            }\n\n        }\n\n        td.flags |= OHCI_TD_T1;\n\n        td.flags ^= OHCI_TD_T0;\n\n        OHCI_SET_BM(td.flags, TD_CC, OHCI_CC_NOERROR);\n\n        OHCI_SET_BM(td.flags, TD_EC, 0);\n\n\n\n        ed->head &= ~OHCI_ED_C;\n\n        if (td.flags & OHCI_TD_T0)\n\n            ed->head |= OHCI_ED_C;\n\n    } else {\n\n        if (ret >= 0) {\n\n            DPRINTF(\"usb-ohci: Underrun\\n\");\n\n            OHCI_SET_BM(td.flags, TD_CC, OHCI_CC_DATAUNDERRUN);\n\n        } else {\n\n            switch (ret) {\n\n            case USB_RET_NODEV:\n\n                OHCI_SET_BM(td.flags, TD_CC, OHCI_CC_DEVICENOTRESPONDING);\n\n            case USB_RET_NAK:\n\n                DPRINTF(\"usb-ohci: got NAK\\n\");\n\n                return 1;\n\n            case USB_RET_STALL:\n\n                DPRINTF(\"usb-ohci: got STALL\\n\");\n\n                OHCI_SET_BM(td.flags, TD_CC, OHCI_CC_STALL);\n\n                break;\n\n            case USB_RET_BABBLE:\n\n                DPRINTF(\"usb-ohci: got BABBLE\\n\");\n\n                OHCI_SET_BM(td.flags, TD_CC, OHCI_CC_DATAOVERRUN);\n\n                break;\n\n            default:\n\n                fprintf(stderr, \"usb-ohci: Bad device response %d\\n\", ret);\n\n                OHCI_SET_BM(td.flags, TD_CC, OHCI_CC_UNDEXPETEDPID);\n\n                OHCI_SET_BM(td.flags, TD_EC, 3);\n\n                break;\n\n            }\n\n        }\n\n        ed->head |= OHCI_ED_H;\n\n    }\n\n\n\n    /* Retire this TD */\n\n    ed->head &= ~OHCI_DPTR_MASK;\n\n    ed->head |= td.next & OHCI_DPTR_MASK;\n\n    td.next = ohci->done;\n\n    ohci->done = addr;\n\n    i = OHCI_BM(td.flags, TD_DI);\n\n    if (i < ohci->done_count)\n\n        ohci->done_count = i;\n\n    ohci_put_td(ohci, addr, &td);\n\n    return OHCI_BM(td.flags, TD_CC) != OHCI_CC_NOERROR;\n\n}\n", "idx": 9890}
{"project": "qemu", "commit_id": "8daea510951dd309a44cea8de415c685c43851cf", "target": 1, "func": "void qdev_prop_set_drive(DeviceState *dev, const char *name,\n\n                         BlockBackend *value, Error **errp)\n\n{\n\n    object_property_set_str(OBJECT(dev), value ? blk_name(value) : \"\",\n\n                            name, errp);\n\n}\n", "idx": 9893}
{"project": "FFmpeg", "commit_id": "b6db385922b79939b0dc124d53ddb4824afac040", "target": 0, "func": "static int mmap_start(AVFormatContext *ctx)\n\n{\n\n    struct video_data *s = ctx->priv_data;\n\n    enum v4l2_buf_type type;\n\n    int i, res;\n\n\n\n    for (i = 0; i < s->buffers; i++) {\n\n        struct v4l2_buffer buf;\n\n\n\n        memset(&buf, 0, sizeof(struct v4l2_buffer));\n\n        buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\n        buf.memory = V4L2_MEMORY_MMAP;\n\n        buf.index  = i;\n\n\n\n        res = ioctl(s->fd, VIDIOC_QBUF, &buf);\n\n        if (res < 0) {\n\n            av_log(ctx, AV_LOG_ERROR, \"ioctl(VIDIOC_QBUF): %s\\n\",\n\n                   strerror(errno));\n\n\n\n            return AVERROR(errno);\n\n        }\n\n    }\n\n\n\n    type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\n    res = ioctl(s->fd, VIDIOC_STREAMON, &type);\n\n    if (res < 0) {\n\n        av_log(ctx, AV_LOG_ERROR, \"ioctl(VIDIOC_STREAMON): %s\\n\",\n\n               strerror(errno));\n\n\n\n        return AVERROR(errno);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 9919}
{"project": "qemu", "commit_id": "acf6e5f0962c4be670d4a93ede77423512521876", "target": 0, "func": "static coroutine_fn int sd_co_pdiscard(BlockDriverState *bs, int64_t offset,\n\n                                      int count)\n\n{\n\n    SheepdogAIOCB acb;\n\n    BDRVSheepdogState *s = bs->opaque;\n\n    QEMUIOVector discard_iov;\n\n    struct iovec iov;\n\n    uint32_t zero = 0;\n\n\n\n    if (!s->discard_supported) {\n\n        return 0;\n\n    }\n\n\n\n    memset(&discard_iov, 0, sizeof(discard_iov));\n\n    memset(&iov, 0, sizeof(iov));\n\n    iov.iov_base = &zero;\n\n    iov.iov_len = sizeof(zero);\n\n    discard_iov.iov = &iov;\n\n    discard_iov.niov = 1;\n\n    if (!QEMU_IS_ALIGNED(offset | count, BDRV_SECTOR_SIZE)) {\n\n        return -ENOTSUP;\n\n    }\n\n    sd_aio_setup(&acb, s, &discard_iov, offset >> BDRV_SECTOR_BITS,\n\n                 count >> BDRV_SECTOR_BITS, AIOCB_DISCARD_OBJ);\n\n\n\nretry:\n\n    if (check_overlapping_aiocb(s, &acb)) {\n\n        qemu_co_queue_wait(&s->overlapping_queue);\n\n        goto retry;\n\n    }\n\n\n\n    sd_co_rw_vector(&acb);\n\n\n\n    QLIST_REMOVE(&acb, aiocb_siblings);\n\n    qemu_co_queue_restart_all(&s->overlapping_queue);\n\n    return acb.ret;\n\n}\n", "idx": 10004}
{"project": "qemu", "commit_id": "393a98924eb00df76231384b86652e1d5f964d67", "target": 0, "func": "uint32_t msix_bar_size(PCIDevice *dev)\n\n{\n\n    return (dev->cap_present & QEMU_PCI_CAP_MSIX) ?\n\n        dev->msix_bar_size : 0;\n\n}\n", "idx": 10020}
{"project": "qemu", "commit_id": "e5b8b0d4ba29fe1268ba049519a1b0cf8552a21a", "target": 0, "func": "static bool e1000_has_rxbufs(E1000State *s, size_t total_size)\n\n{\n\n    int bufs;\n\n    /* Fast-path short packets */\n\n    if (total_size <= s->rxbuf_size) {\n\n        return s->mac_reg[RDH] != s->mac_reg[RDT] || !s->check_rxov;\n\n    }\n\n    if (s->mac_reg[RDH] < s->mac_reg[RDT]) {\n\n        bufs = s->mac_reg[RDT] - s->mac_reg[RDH];\n\n    } else if (s->mac_reg[RDH] > s->mac_reg[RDT] || !s->check_rxov) {\n\n        bufs = s->mac_reg[RDLEN] /  sizeof(struct e1000_rx_desc) +\n\n            s->mac_reg[RDT] - s->mac_reg[RDH];\n\n    } else {\n\n        return false;\n\n    }\n\n    return total_size <= bufs * s->rxbuf_size;\n\n}\n", "idx": 10077}
{"project": "qemu", "commit_id": "d2cb36af2b0040d421b347e6e4e803e07220f78d", "target": 0, "func": "static coroutine_fn int qcow2_co_pwrite_zeroes(BlockDriverState *bs,\n\n    int64_t offset, int count, BdrvRequestFlags flags)\n\n{\n\n    int ret;\n\n    BDRVQcow2State *s = bs->opaque;\n\n\n\n    uint32_t head = offset % s->cluster_size;\n\n    uint32_t tail = (offset + count) % s->cluster_size;\n\n\n\n    trace_qcow2_pwrite_zeroes_start_req(qemu_coroutine_self(), offset, count);\n\n    if (offset + count == bs->total_sectors * BDRV_SECTOR_SIZE) {\n\n        tail = 0;\n\n    }\n\n\n\n    if (head || tail) {\n\n        int64_t cl_start = (offset - head) >> BDRV_SECTOR_BITS;\n\n        uint64_t off;\n\n        unsigned int nr;\n\n\n\n        assert(head + count <= s->cluster_size);\n\n\n\n        /* check whether remainder of cluster already reads as zero */\n\n        if (!(is_zero_sectors(bs, cl_start,\n\n                              DIV_ROUND_UP(head, BDRV_SECTOR_SIZE)) &&\n\n              is_zero_sectors(bs, (offset + count) >> BDRV_SECTOR_BITS,\n\n                              DIV_ROUND_UP(-tail & (s->cluster_size - 1),\n\n                                           BDRV_SECTOR_SIZE)))) {\n\n            return -ENOTSUP;\n\n        }\n\n\n\n        qemu_co_mutex_lock(&s->lock);\n\n        /* We can have new write after previous check */\n\n        offset = cl_start << BDRV_SECTOR_BITS;\n\n        count = s->cluster_size;\n\n        nr = s->cluster_size;\n\n        ret = qcow2_get_cluster_offset(bs, offset, &nr, &off);\n\n        if (ret != QCOW2_CLUSTER_UNALLOCATED &&\n\n            ret != QCOW2_CLUSTER_ZERO_PLAIN &&\n\n            ret != QCOW2_CLUSTER_ZERO_ALLOC) {\n\n            qemu_co_mutex_unlock(&s->lock);\n\n            return -ENOTSUP;\n\n        }\n\n    } else {\n\n        qemu_co_mutex_lock(&s->lock);\n\n    }\n\n\n\n    trace_qcow2_pwrite_zeroes(qemu_coroutine_self(), offset, count);\n\n\n\n    /* Whatever is left can use real zero clusters */\n\n    ret = qcow2_zero_clusters(bs, offset, count >> BDRV_SECTOR_BITS, flags);\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    return ret;\n\n}\n", "idx": 10136}
{"project": "qemu", "commit_id": "2e6fc7eb1a4af1b127df5f07b8bb28af891946fa", "target": 0, "func": "static int coroutine_fn raw_co_preadv(BlockDriverState *bs, uint64_t offset,\n\n                                      uint64_t bytes, QEMUIOVector *qiov,\n\n                                      int flags)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n\n\n    if (offset > UINT64_MAX - s->offset) {\n\n        return -EINVAL;\n\n    }\n\n    offset += s->offset;\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);\n\n    return bdrv_co_preadv(bs->file, offset, bytes, qiov, flags);\n\n}\n", "idx": 10193}
{"project": "qemu", "commit_id": "28c5af54c661e73e5596918fa67a22b5e87c2022", "target": 0, "func": "static void ppc_prep_init (int ram_size, int vga_ram_size, const char *boot_device,\n\n                           DisplayState *ds, const char **fd_filename,\n\n                           int snapshot, const char *kernel_filename,\n\n                           const char *kernel_cmdline,\n\n                           const char *initrd_filename,\n\n                           const char *cpu_model)\n\n{\n\n    CPUState *env, *envs[MAX_CPUS];\n\n    char buf[1024];\n\n    nvram_t nvram;\n\n    m48t59_t *m48t59;\n\n    int PPC_io_memory;\n\n    int linux_boot, i, nb_nics1, bios_size;\n\n    unsigned long bios_offset;\n\n    uint32_t kernel_base, kernel_size, initrd_base, initrd_size;\n\n    PCIBus *pci_bus;\n\n    qemu_irq *i8259;\n\n    int ppc_boot_device = boot_device[0];\n\n\n\n    sysctrl = qemu_mallocz(sizeof(sysctrl_t));\n\n    if (sysctrl == NULL)\n\n        return;\n\n\n\n    linux_boot = (kernel_filename != NULL);\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL)\n\n        cpu_model = \"default\";\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        env = cpu_init(cpu_model);\n\n        if (!env) {\n\n            fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        /* Set time-base frequency to 100 Mhz */\n\n        cpu_ppc_tb_init(env, 100UL * 1000UL * 1000UL);\n\n        qemu_register_reset(&cpu_ppc_reset, env);\n\n        register_savevm(\"cpu\", 0, 3, cpu_save, cpu_load, env);\n\n        envs[i] = env;\n\n    }\n\n\n\n    /* allocate RAM */\n\n    cpu_register_physical_memory(0, ram_size, IO_MEM_RAM);\n\n\n\n    /* allocate and load BIOS */\n\n    bios_offset = ram_size + vga_ram_size;\n\n    if (bios_name == NULL)\n\n        bios_name = BIOS_FILENAME;\n\n    snprintf(buf, sizeof(buf), \"%s/%s\", bios_dir, bios_name);\n\n    bios_size = load_image(buf, phys_ram_base + bios_offset);\n\n    if (bios_size < 0 || bios_size > BIOS_SIZE) {\n\n        cpu_abort(env, \"qemu: could not load PPC PREP bios '%s'\\n\", buf);\n\n        exit(1);\n\n    }\n\n    if (env->nip < 0xFFF80000 && bios_size < 0x00100000) {\n\n        cpu_abort(env, \"PowerPC 601 / 620 / 970 need a 1MB BIOS\\n\");\n\n    }\n\n    bios_size = (bios_size + 0xfff) & ~0xfff;\n\n    cpu_register_physical_memory((uint32_t)(-bios_size),\n\n                                 bios_size, bios_offset | IO_MEM_ROM);\n\n\n\n    if (linux_boot) {\n\n        kernel_base = KERNEL_LOAD_ADDR;\n\n        /* now we can load the kernel */\n\n        kernel_size = load_image(kernel_filename, phys_ram_base + kernel_base);\n\n        if (kernel_size < 0) {\n\n            cpu_abort(env, \"qemu: could not load kernel '%s'\\n\",\n\n                      kernel_filename);\n\n            exit(1);\n\n        }\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            initrd_base = INITRD_LOAD_ADDR;\n\n            initrd_size = load_image(initrd_filename,\n\n                                     phys_ram_base + initrd_base);\n\n            if (initrd_size < 0) {\n\n                cpu_abort(env, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                          initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n        ppc_boot_device = 'm';\n\n    } else {\n\n        kernel_base = 0;\n\n        kernel_size = 0;\n\n        initrd_base = 0;\n\n        initrd_size = 0;\n\n    }\n\n\n\n    isa_mem_base = 0xc0000000;\n\n    if (PPC_INPUT(env) != PPC_FLAGS_INPUT_6xx) {\n\n        cpu_abort(env, \"Only 6xx bus is supported on PREP machine\\n\");\n\n        exit(1);\n\n    }\n\n    i8259 = i8259_init(first_cpu->irq_inputs[PPC6xx_INPUT_INT]);\n\n    pci_bus = pci_prep_init(i8259);\n\n    //    pci_bus = i440fx_init();\n\n    /* Register 8 MB of ISA IO space (needed for non-contiguous map) */\n\n    PPC_io_memory = cpu_register_io_memory(0, PPC_prep_io_read,\n\n                                           PPC_prep_io_write, sysctrl);\n\n    cpu_register_physical_memory(0x80000000, 0x00800000, PPC_io_memory);\n\n\n\n    /* init basic PC hardware */\n\n    pci_vga_init(pci_bus, ds, phys_ram_base + ram_size, ram_size,\n\n                 vga_ram_size, 0, 0);\n\n    //    openpic = openpic_init(0x00000000, 0xF0000000, 1);\n\n    //    pit = pit_init(0x40, i8259[0]);\n\n    rtc_init(0x70, i8259[8]);\n\n\n\n    serial_init(0x3f8, i8259[4], serial_hds[0]);\n\n    nb_nics1 = nb_nics;\n\n    if (nb_nics1 > NE2000_NB_MAX)\n\n        nb_nics1 = NE2000_NB_MAX;\n\n    for(i = 0; i < nb_nics1; i++) {\n\n        if (nd_table[i].model == NULL\n\n            || strcmp(nd_table[i].model, \"ne2k_isa\") == 0) {\n\n            isa_ne2000_init(ne2000_io[i], i8259[ne2000_irq[i]], &nd_table[i]);\n\n        } else {\n\n            pci_nic_init(pci_bus, &nd_table[i], -1);\n\n        }\n\n    }\n\n\n\n    for(i = 0; i < 2; i++) {\n\n        isa_ide_init(ide_iobase[i], ide_iobase2[i], i8259[ide_irq[i]],\n\n                     bs_table[2 * i], bs_table[2 * i + 1]);\n\n    }\n\n    i8042_init(i8259[1], i8259[12], 0x60);\n\n    DMA_init(1);\n\n    //    AUD_init();\n\n    //    SB16_init();\n\n\n\n    fdctrl_init(i8259[6], 2, 0, 0x3f0, fd_table);\n\n\n\n    /* Register speaker port */\n\n    register_ioport_read(0x61, 1, 1, speaker_ioport_read, NULL);\n\n    register_ioport_write(0x61, 1, 1, speaker_ioport_write, NULL);\n\n    /* Register fake IO ports for PREP */\n\n    sysctrl->reset_irq = first_cpu->irq_inputs[PPC6xx_INPUT_HRESET];\n\n    register_ioport_read(0x398, 2, 1, &PREP_io_read, sysctrl);\n\n    register_ioport_write(0x398, 2, 1, &PREP_io_write, sysctrl);\n\n    /* System control ports */\n\n    register_ioport_read(0x0092, 0x01, 1, &PREP_io_800_readb, sysctrl);\n\n    register_ioport_write(0x0092, 0x01, 1, &PREP_io_800_writeb, sysctrl);\n\n    register_ioport_read(0x0800, 0x52, 1, &PREP_io_800_readb, sysctrl);\n\n    register_ioport_write(0x0800, 0x52, 1, &PREP_io_800_writeb, sysctrl);\n\n    /* PCI intack location */\n\n    PPC_io_memory = cpu_register_io_memory(0, PPC_intack_read,\n\n                                           PPC_intack_write, NULL);\n\n    cpu_register_physical_memory(0xBFFFFFF0, 0x4, PPC_io_memory);\n\n    /* PowerPC control and status register group */\n\n#if 0\n\n    PPC_io_memory = cpu_register_io_memory(0, PPC_XCSR_read, PPC_XCSR_write,\n\n                                           NULL);\n\n    cpu_register_physical_memory(0xFEFF0000, 0x1000, PPC_io_memory);\n\n#endif\n\n\n\n    if (usb_enabled) {\n\n        usb_ohci_init_pci(pci_bus, 3, -1);\n\n    }\n\n\n\n    m48t59 = m48t59_init(i8259[8], 0, 0x0074, NVRAM_SIZE, 59);\n\n    if (m48t59 == NULL)\n\n        return;\n\n    sysctrl->nvram = m48t59;\n\n\n\n    /* Initialise NVRAM */\n\n    nvram.opaque = m48t59;\n\n    nvram.read_fn = &m48t59_read;\n\n    nvram.write_fn = &m48t59_write;\n\n    PPC_NVRAM_set_params(&nvram, NVRAM_SIZE, \"PREP\", ram_size, ppc_boot_device,\n\n                         kernel_base, kernel_size,\n\n                         kernel_cmdline,\n\n                         initrd_base, initrd_size,\n\n                         /* XXX: need an option to load a NVRAM image */\n\n                         0,\n\n                         graphic_width, graphic_height, graphic_depth);\n\n\n\n    /* Special port to get debug messages from Open-Firmware */\n\n    register_ioport_write(0x0F00, 4, 1, &PPC_debug_write, NULL);\n\n}\n", "idx": 10240}
{"project": "qemu", "commit_id": "7dfbfc7927c1f7ab9f6910768ed6d966645b5866", "target": 0, "func": "int vnc_display_disable_login(DisplayState *ds)\n\n{\n\n    VncDisplay *vs = ds ? (VncDisplay *)ds->opaque : vnc_display;\n\n\n\n    if (!vs) {\n\n        return -1;\n\n    }\n\n\n\n    if (vs->password) {\n\n        g_free(vs->password);\n\n    }\n\n\n\n    vs->password = NULL;\n\n    vs->auth = VNC_AUTH_VNC;\n\n\n\n    return 0;\n\n}\n", "idx": 10288}
{"project": "qemu", "commit_id": "b02ef3d92b19ad304a84433d3817f0903296ebc7", "target": 0, "func": "static void read_storage_element0_info(SCLPDevice *sclp, SCCB *sccb)\n\n{\n\n    int i, assigned;\n\n    int subincrement_id = SCLP_STARTING_SUBINCREMENT_ID;\n\n    ReadStorageElementInfo *storage_info = (ReadStorageElementInfo *) sccb;\n\n    sclpMemoryHotplugDev *mhd = get_sclp_memory_hotplug_dev();\n\n\n\n    assert(mhd);\n\n\n\n    if ((ram_size >> mhd->increment_size) >= 0x10000) {\n\n        sccb->h.response_code = cpu_to_be16(SCLP_RC_SCCB_BOUNDARY_VIOLATION);\n\n        return;\n\n    }\n\n\n\n    /* Return information regarding core memory */\n\n    storage_info->max_id = cpu_to_be16(mhd->standby_mem_size ? 1 : 0);\n\n    assigned = ram_size >> mhd->increment_size;\n\n    storage_info->assigned = cpu_to_be16(assigned);\n\n\n\n    for (i = 0; i < assigned; i++) {\n\n        storage_info->entries[i] = cpu_to_be32(subincrement_id);\n\n        subincrement_id += SCLP_INCREMENT_UNIT;\n\n    }\n\n    sccb->h.response_code = cpu_to_be16(SCLP_RC_NORMAL_READ_COMPLETION);\n\n}\n", "idx": 10293}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(addme)\n\n{\n\n    T1 = T0;\n\n    T0 += xer_ca + (-1);\n\n    if (T1 != 0)\n\n        xer_ca = 1;\n\n    RETURN();\n\n}\n", "idx": 10389}
{"project": "FFmpeg", "commit_id": "655b6dcb34b25d591e15ede17673ea6cb8074711", "target": 0, "func": "static void update_stream_timings(AVFormatContext *ic)\n\n{\n\n    int64_t start_time, start_time1, start_time_text, end_time, end_time1;\n\n    int64_t duration, duration1, filesize;\n\n    int i;\n\n    AVStream *st;\n\n    AVProgram *p;\n\n\n\n    start_time = INT64_MAX;\n\n    start_time_text = INT64_MAX;\n\n    end_time   = INT64_MIN;\n\n    duration   = INT64_MIN;\n\n    for (i = 0; i < ic->nb_streams; i++) {\n\n        st = ic->streams[i];\n\n        if (st->start_time != AV_NOPTS_VALUE && st->time_base.den) {\n\n            start_time1 = av_rescale_q(st->start_time, st->time_base,\n\n                                       AV_TIME_BASE_Q);\n\n            if (st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE || st->codec->codec_type == AVMEDIA_TYPE_DATA) {\n\n                if (start_time1 < start_time_text)\n\n                    start_time_text = start_time1;\n\n            } else\n\n                start_time = FFMIN(start_time, start_time1);\n\n            end_time1   = AV_NOPTS_VALUE;\n\n            if (st->duration != AV_NOPTS_VALUE) {\n\n                end_time1 = start_time1 +\n\n                            av_rescale_q(st->duration, st->time_base,\n\n                                         AV_TIME_BASE_Q);\n\n                end_time = FFMAX(end_time, end_time1);\n\n            }\n\n            for (p = NULL; (p = av_find_program_from_stream(ic, p, i)); ) {\n\n                if (p->start_time == AV_NOPTS_VALUE || p->start_time > start_time1)\n\n                    p->start_time = start_time1;\n\n                if (p->end_time < end_time1)\n\n                    p->end_time = end_time1;\n\n            }\n\n        }\n\n        if (st->duration != AV_NOPTS_VALUE) {\n\n            duration1 = av_rescale_q(st->duration, st->time_base,\n\n                                     AV_TIME_BASE_Q);\n\n            duration  = FFMAX(duration, duration1);\n\n        }\n\n    }\n\n    if (start_time == INT64_MAX || (start_time > start_time_text && start_time - start_time_text < AV_TIME_BASE))\n\n        start_time = start_time_text;\n\n    else if (start_time > start_time_text)\n\n        av_log(ic, AV_LOG_VERBOSE, \"Ignoring outlier non primary stream starttime %f\\n\", start_time_text / (float)AV_TIME_BASE);\n\n\n\n    if (start_time != INT64_MAX) {\n\n        ic->start_time = start_time;\n\n        if (end_time != INT64_MIN) {\n\n            if (ic->nb_programs) {\n\n                for (i = 0; i < ic->nb_programs; i++) {\n\n                    p = ic->programs[i];\n\n                    if (p->start_time != AV_NOPTS_VALUE && p->end_time > p->start_time)\n\n                        duration = FFMAX(duration, p->end_time - p->start_time);\n\n                }\n\n            } else\n\n                duration = FFMAX(duration, end_time - start_time);\n\n        }\n\n    }\n\n    if (duration != INT64_MIN && duration > 0 && ic->duration == AV_NOPTS_VALUE) {\n\n        ic->duration = duration;\n\n    }\n\n    if (ic->pb && (filesize = avio_size(ic->pb)) > 0 && ic->duration != AV_NOPTS_VALUE) {\n\n        /* compute the bitrate */\n\n        double bitrate = (double) filesize * 8.0 * AV_TIME_BASE /\n\n                         (double) ic->duration;\n\n        if (bitrate >= 0 && (!AV_HAVE_INCOMPATIBLE_LIBAV_ABI || bitrate <= INT_MAX))\n\n            ic->bit_rate = bitrate;\n\n    }\n\n}\n", "idx": 10399}
{"project": "qemu", "commit_id": "f76f665547f4a954a2c83552a88816fc2a316be0", "target": 1, "func": "static int virtio_balloon_init_pci(PCIDevice *pci_dev)\n\n{\n\n    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);\n\n    VirtIODevice *vdev;\n\n\n\n    vdev = virtio_balloon_init(&pci_dev->qdev);\n\n\n\n\n    virtio_init_pci(proxy, vdev);\n\n    return 0;\n", "idx": 10422}
{"project": "qemu", "commit_id": "fa0cfdf24a75f3e6aa6c8b6efcbebd09e7f054aa", "target": 0, "func": "static void vnc_disconnect_finish(VncState *vs)\n\n{\n\n    if (vs->input.buffer) qemu_free(vs->input.buffer);\n\n    if (vs->output.buffer) qemu_free(vs->output.buffer);\n\n#ifdef CONFIG_VNC_TLS\n\n    vnc_tls_client_cleanup(vs);\n\n#endif /* CONFIG_VNC_TLS */\n\n#ifdef CONFIG_VNC_SASL\n\n    vnc_sasl_client_cleanup(vs);\n\n#endif /* CONFIG_VNC_SASL */\n\n    audio_del(vs);\n\n\n\n    VncState *p, *parent = NULL;\n\n    for (p = vs->vd->clients; p != NULL; p = p->next) {\n\n        if (p == vs) {\n\n            if (parent)\n\n                parent->next = p->next;\n\n            else\n\n                vs->vd->clients = p->next;\n\n            break;\n\n        }\n\n        parent = p;\n\n    }\n\n    if (!vs->vd->clients)\n\n        dcl->idle = 1;\n\n\n\n    vnc_remove_timer(vs->vd);\n\n    qemu_free(vs);\n\n}\n", "idx": 10494}
{"project": "qemu", "commit_id": "28143b409f698210d85165ca518235ac7e7c5ac5", "target": 0, "func": "int kvm_has_xcrs(void)\n\n{\n\n    return kvm_state->xcrs;\n\n}\n", "idx": 10575}
{"project": "qemu", "commit_id": "249127d0dfeb2cf5e24d9353b6d54c91c1666ddc", "target": 1, "func": "static void spapr_cpu_core_realize_child(Object *child, Error **errp)\n\n{\n\n    Error *local_err = NULL;\n\n    sPAPRMachineState *spapr = SPAPR_MACHINE(qdev_get_machine());\n\n    CPUState *cs = CPU(child);\n\n    PowerPCCPU *cpu = POWERPC_CPU(cs);\n\n    Object *obj;\n\n\n\n    obj = object_new(spapr->icp_type);\n\n    object_property_add_child(OBJECT(cpu), \"icp\", obj, NULL);\n\n    object_property_add_const_link(obj, \"xics\", OBJECT(spapr), &error_abort);\n\n    object_property_set_bool(obj, true, \"realized\", &local_err);\n\n    if (local_err) {\n\n        goto error;\n\n    }\n\n\n\n    object_property_set_bool(child, true, \"realized\", &local_err);\n\n    if (local_err) {\n\n        goto error;\n\n    }\n\n\n\n    spapr_cpu_init(spapr, cpu, &local_err);\n\n    if (local_err) {\n\n        goto error;\n\n    }\n\n\n\n    xics_cpu_setup(XICS_FABRIC(spapr), cpu, ICP(obj));\n\n    return;\n\n\n\nerror:\n\n    object_unparent(obj);\n\n    error_propagate(errp, local_err);\n\n}\n", "idx": 10599}
{"project": "qemu", "commit_id": "90527d2a8bb08ca5b4774eacfdd6b8fe9671c077", "target": 1, "func": "static int get_real_id(const char *devpath, const char *idname, uint16_t *val)\n\n{\n\n    FILE *f;\n\n    char name[128];\n\n    long id;\n\n\n\n    snprintf(name, sizeof(name), \"%s%s\", devpath, idname);\n\n    f = fopen(name, \"r\");\n\n    if (f == NULL) {\n\n        error_report(\"%s: %s: %m\", __func__, name);\n\n        return -1;\n\n    }\n\n    if (fscanf(f, \"%li\\n\", &id) == 1) {\n\n        *val = id;\n\n    } else {\n\n\n        return -1;\n\n    }\n\n\n\n\n    return 0;\n\n}", "idx": 10611}
{"project": "FFmpeg", "commit_id": "4b7ef5a1e6fa622fc85741c9c1ca11c798cda9cb", "target": 0, "func": "static int parse_keyframes_index(AVFormatContext *s, AVIOContext *ioc, AVStream *vstream, int64_t max_pos) {\n\n    unsigned int timeslen = 0, fileposlen = 0, i;\n\n    char str_val[256];\n\n    int64_t *times = NULL;\n\n    int64_t *filepositions = NULL;\n\n    int ret = AVERROR(ENOSYS);\n\n    int64_t initial_pos = avio_tell(ioc);\n\n    AVDictionaryEntry *creator = av_dict_get(s->metadata, \"metadatacreator\",\n\n                                             NULL, 0);\n\n\n\n    if (creator && !strcmp(creator->value, \"MEGA\")) {\n\n        /* Files with this metadatacreator tag seem to have filepositions\n\n         * pointing at the 4 trailer bytes of the previous packet,\n\n         * which isn't the norm (nor what we expect here, nor what\n\n         * jwplayer + lighttpd expect, nor what flvtool2 produces).\n\n         * Just ignore the index in this case, instead of risking trying\n\n         * to adjust it to something that might or might not work. */\n\n        return 0;\n\n    }\n\n\n\n    if(vstream->nb_index_entries>0){\n\n        av_log(s, AV_LOG_WARNING, \"Skiping duplicate index\\n\");\n\n        return 0;\n\n    }\n\n\n\n    while (avio_tell(ioc) < max_pos - 2 && amf_get_string(ioc, str_val, sizeof(str_val)) > 0) {\n\n        int64_t** current_array;\n\n        unsigned int arraylen;\n\n\n\n        // Expect array object in context\n\n        if (avio_r8(ioc) != AMF_DATA_TYPE_ARRAY)\n\n            break;\n\n\n\n        arraylen = avio_rb32(ioc);\n\n        if(arraylen>>28)\n\n            break;\n\n\n\n        if       (!strcmp(KEYFRAMES_TIMESTAMP_TAG , str_val) && !times){\n\n            current_array= &times;\n\n            timeslen= arraylen;\n\n        }else if (!strcmp(KEYFRAMES_BYTEOFFSET_TAG, str_val) && !filepositions){\n\n            current_array= &filepositions;\n\n            fileposlen= arraylen;\n\n        }else // unexpected metatag inside keyframes, will not use such metadata for indexing\n\n            break;\n\n\n\n        if (!(*current_array = av_mallocz(sizeof(**current_array) * arraylen))) {\n\n            ret = AVERROR(ENOMEM);\n\n            goto finish;\n\n        }\n\n\n\n        for (i = 0; i < arraylen && avio_tell(ioc) < max_pos - 1; i++) {\n\n            if (avio_r8(ioc) != AMF_DATA_TYPE_NUMBER)\n\n                goto finish;\n\n            current_array[0][i] = av_int2dbl(avio_rb64(ioc));\n\n        }\n\n        if (times && filepositions) {\n\n            // All done, exiting at a position allowing amf_parse_object\n\n            // to finish parsing the object\n\n            ret = 0;\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (timeslen == fileposlen) {\n\n         for(i = 0; i < timeslen; i++)\n\n             av_add_index_entry(vstream, filepositions[i], times[i]*1000, 0, 0, AVINDEX_KEYFRAME);\n\n    } else\n\n        av_log(s, AV_LOG_WARNING, \"Invalid keyframes object, skipping.\\n\");\n\n\n\nfinish:\n\n    av_freep(&times);\n\n    av_freep(&filepositions);\n\n    avio_seek(ioc, initial_pos, SEEK_SET);\n\n    return ret;\n\n}\n", "idx": 10622}
{"project": "FFmpeg", "commit_id": "48df6a241532f0702fc4fd10ddcbfac435e4027c", "target": 1, "func": "static void iv_Decode_Chunk(Indeo3DecodeContext *s,\n\n        uint8_t *cur, uint8_t *ref, int width, int height,\n\n        const uint8_t *buf1, int cb_offset, const uint8_t *hdr,\n\n        const uint8_t *buf2, int min_width_160)\n\n{\n\n    uint8_t bit_buf;\n\n    unsigned int bit_pos, lv, lv1, lv2;\n\n    int *width_tbl, width_tbl_arr[10];\n\n    const signed char *ref_vectors;\n\n    uint8_t *cur_frm_pos, *ref_frm_pos, *cp, *cp2;\n\n\n    uint32_t *cur_lp, *ref_lp;\n\n    const uint32_t *correction_lp[2], *correctionloworder_lp[2], *correctionhighorder_lp[2];\n\n    uint8_t *correction_type_sp[2];\n\n    struct ustr strip_tbl[20], *strip;\n\n    int i, j, k, lp1, lp2, flag1, cmd, blks_width, blks_height, region_160_width,\n\n        rle_v1, rle_v2, rle_v3;\n\n    unsigned short res;\n\n\n\n    bit_buf = 0;\n\n    ref_vectors = NULL;\n\n\n\n    width_tbl = width_tbl_arr + 1;\n\n    i = (width < 0 ? width + 3 : width)/4;\n\n    for(j = -1; j < 8; j++)\n\n        width_tbl[j] = i * j;\n\n\n\n    strip = strip_tbl;\n\n\n\n    for(region_160_width = 0; region_160_width < (width - min_width_160); region_160_width += min_width_160);\n\n\n\n    strip->ypos = strip->xpos = 0;\n\n    for(strip->width = min_width_160; width > strip->width; strip->width *= 2);\n\n    strip->height = height;\n\n    strip->split_direction = 0;\n\n    strip->split_flag = 0;\n\n    strip->usl7 = 0;\n\n\n\n    bit_pos = 0;\n\n\n\n    rle_v1 = rle_v2 = rle_v3 = 0;\n\n\n\n    while(strip >= strip_tbl) {\n\n        if(bit_pos <= 0) {\n\n            bit_pos = 8;\n\n            bit_buf = *buf1++;\n\n        }\n\n\n\n        bit_pos -= 2;\n\n        cmd = (bit_buf >> bit_pos) & 0x03;\n\n\n\n        if(cmd == 0) {\n\n            strip++;\n\n            if(strip >= strip_tbl + FF_ARRAY_ELEMS(strip_tbl)) {\n\n                av_log(s->avctx, AV_LOG_WARNING, \"out of range strip\\n\");\n\n                break;\n\n            }\n\n            memcpy(strip, strip-1, sizeof(*strip));\n\n            strip->split_flag = 1;\n\n            strip->split_direction = 0;\n\n            strip->height = (strip->height > 8 ? ((strip->height+8)>>4)<<3 : 4);\n\n            continue;\n\n        } else if(cmd == 1) {\n\n            strip++;\n\n            if(strip >= strip_tbl + FF_ARRAY_ELEMS(strip_tbl)) {\n\n                av_log(s->avctx, AV_LOG_WARNING, \"out of range strip\\n\");\n\n                break;\n\n            }\n\n            memcpy(strip, strip-1, sizeof(*strip));\n\n            strip->split_flag = 1;\n\n            strip->split_direction = 1;\n\n            strip->width = (strip->width > 8 ? ((strip->width+8)>>4)<<3 : 4);\n\n            continue;\n\n        } else if(cmd == 2) {\n\n            if(strip->usl7 == 0) {\n\n                strip->usl7 = 1;\n\n                ref_vectors = NULL;\n\n                continue;\n\n            }\n\n        } else if(cmd == 3) {\n\n            if(strip->usl7 == 0) {\n\n                strip->usl7 = 1;\n\n                ref_vectors = (const signed char*)buf2 + (*buf1 * 2);\n\n                buf1++;\n\n                continue;\n\n            }\n\n        }\n\n\n\n        cur_frm_pos = cur + width * strip->ypos + strip->xpos;\n\n\n\n        if((blks_width = strip->width) < 0)\n\n            blks_width += 3;\n\n        blks_width >>= 2;\n\n        blks_height = strip->height;\n\n\n\n        if(ref_vectors != NULL) {\n\n            ref_frm_pos = ref + (ref_vectors[0] + strip->ypos) * width +\n\n                ref_vectors[1] + strip->xpos;\n\n        } else\n\n            ref_frm_pos = cur_frm_pos - width_tbl[4];\n\n\n\n        if(cmd == 2) {\n\n            if(bit_pos <= 0) {\n\n                bit_pos = 8;\n\n                bit_buf = *buf1++;\n\n            }\n\n\n\n            bit_pos -= 2;\n\n            cmd = (bit_buf >> bit_pos) & 0x03;\n\n\n\n            if(cmd == 0 || ref_vectors != NULL) {\n\n                for(lp1 = 0; lp1 < blks_width; lp1++) {\n\n                    for(i = 0, j = 0; i < blks_height; i++, j += width_tbl[1])\n\n                        ((uint32_t *)cur_frm_pos)[j] = ((uint32_t *)ref_frm_pos)[j];\n\n                    cur_frm_pos += 4;\n\n                    ref_frm_pos += 4;\n\n                }\n\n            } else if(cmd != 1)\n\n                return;\n\n        } else {\n\n            k = *buf1 >> 4;\n\n            j = *buf1 & 0x0f;\n\n            buf1++;\n\n            lv = j + cb_offset;\n\n\n\n            if((lv - 8) <= 7 && (k == 0 || k == 3 || k == 10)) {\n\n                cp2 = s->ModPred + ((lv - 8) << 7);\n\n                cp = ref_frm_pos;\n\n                for(i = 0; i < blks_width << 2; i++) {\n\n                    int v = *cp >> 1;\n\n                    *(cp++) = cp2[v];\n\n                }\n\n            }\n\n\n\n            if(k == 1 || k == 4) {\n\n                lv = (hdr[j] & 0xf) + cb_offset;\n\n                correction_type_sp[0] = s->corrector_type + (lv << 8);\n\n                correction_lp[0] = correction + (lv << 8);\n\n                lv = (hdr[j] >> 4) + cb_offset;\n\n                correction_lp[1] = correction + (lv << 8);\n\n                correction_type_sp[1] = s->corrector_type + (lv << 8);\n\n            } else {\n\n                correctionloworder_lp[0] = correctionloworder_lp[1] = correctionloworder + (lv << 8);\n\n                correctionhighorder_lp[0] = correctionhighorder_lp[1] = correctionhighorder + (lv << 8);\n\n                correction_type_sp[0] = correction_type_sp[1] = s->corrector_type + (lv << 8);\n\n                correction_lp[0] = correction_lp[1] = correction + (lv << 8);\n\n            }\n\n\n\n            switch(k) {\n\n            case 1:\n\n            case 0:                    /********** CASE 0 **********/\n\n                for( ; blks_height > 0; blks_height -= 4) {\n\n                    for(lp1 = 0; lp1 < blks_width; lp1++) {\n\n                        for(lp2 = 0; lp2 < 4; ) {\n\n                            k = *buf1++;\n\n                            cur_lp = ((uint32_t *)cur_frm_pos) + width_tbl[lp2];\n\n                            ref_lp = ((uint32_t *)ref_frm_pos) + width_tbl[lp2];\n\n                            if ((uint8_t *)cur_lp >= cur_end-3)\n\n                                break;\n\n\n\n                            switch(correction_type_sp[0][k]) {\n\n                            case 0:\n\n                                *cur_lp = av_le2ne32(((av_le2ne32(*ref_lp) >> 1) + correction_lp[lp2 & 0x01][k]) << 1);\n\n                                lp2++;\n\n                                break;\n\n                            case 1:\n\n                                res = ((av_le2ne16(((unsigned short *)(ref_lp))[0]) >> 1) + correction_lp[lp2 & 0x01][*buf1]) << 1;\n\n                                ((unsigned short *)cur_lp)[0] = av_le2ne16(res);\n\n                                res = ((av_le2ne16(((unsigned short *)(ref_lp))[1]) >> 1) + correction_lp[lp2 & 0x01][k]) << 1;\n\n                                ((unsigned short *)cur_lp)[1] = av_le2ne16(res);\n\n                                buf1++;\n\n                                lp2++;\n\n                                break;\n\n                            case 2:\n\n                                if(lp2 == 0) {\n\n                                    for(i = 0, j = 0; i < 2; i++, j += width_tbl[1])\n\n                                        cur_lp[j] = ref_lp[j];\n\n                                    lp2 += 2;\n\n                                }\n\n                                break;\n\n                            case 3:\n\n                                if(lp2 < 2) {\n\n                                    for(i = 0, j = 0; i < (3 - lp2); i++, j += width_tbl[1])\n\n                                        cur_lp[j] = ref_lp[j];\n\n                                    lp2 = 3;\n\n                                }\n\n                                break;\n\n                            case 8:\n\n                                if(lp2 == 0) {\n\n                                    RLE_V3_CHECK(buf1,rle_v1,rle_v2,rle_v3)\n\n\n\n                                    if(rle_v1 == 1 || ref_vectors != NULL) {\n\n                                        for(i = 0, j = 0; i < 4; i++, j += width_tbl[1])\n\n                                            cur_lp[j] = ref_lp[j];\n\n                                    }\n\n\n\n                                    RLE_V2_CHECK(buf1,rle_v2, rle_v3,lp2)\n\n                                    break;\n\n                                } else {\n\n                                    rle_v1 = 1;\n\n                                    rle_v2 = *buf1 - 1;\n\n                                }\n\n                            case 5:\n\n                                LP2_CHECK(buf1,rle_v3,lp2)\n\n                            case 4:\n\n                                for(i = 0, j = 0; i < (4 - lp2); i++, j += width_tbl[1])\n\n                                    cur_lp[j] = ref_lp[j];\n\n                                lp2 = 4;\n\n                                break;\n\n\n\n                            case 7:\n\n                                if(rle_v3 != 0)\n\n                                    rle_v3 = 0;\n\n                                else {\n\n                                    buf1--;\n\n                                    rle_v3 = 1;\n\n                                }\n\n                            case 6:\n\n                                if(ref_vectors != NULL) {\n\n                                    for(i = 0, j = 0; i < 4; i++, j += width_tbl[1])\n\n                                        cur_lp[j] = ref_lp[j];\n\n                                }\n\n                                lp2 = 4;\n\n                                break;\n\n\n\n                            case 9:\n\n                                lv1 = *buf1++;\n\n                                lv = (lv1 & 0x7F) << 1;\n\n                                lv += (lv << 8);\n\n                                lv += (lv << 16);\n\n                                for(i = 0, j = 0; i < 4; i++, j += width_tbl[1])\n\n                                    cur_lp[j] = lv;\n\n\n\n                                LV1_CHECK(buf1,rle_v3,lv1,lp2)\n\n                                break;\n\n                            default:\n\n                                return;\n\n                            }\n\n                        }\n\n\n\n                        cur_frm_pos += 4;\n\n                        ref_frm_pos += 4;\n\n                    }\n\n\n\n                    cur_frm_pos += ((width - blks_width) * 4);\n\n                    ref_frm_pos += ((width - blks_width) * 4);\n\n                }\n\n                break;\n\n\n\n            case 4:\n\n            case 3:                    /********** CASE 3 **********/\n\n                if(ref_vectors != NULL)\n\n                    return;\n\n                flag1 = 1;\n\n\n\n                for( ; blks_height > 0; blks_height -= 8) {\n\n                    for(lp1 = 0; lp1 < blks_width; lp1++) {\n\n                        for(lp2 = 0; lp2 < 4; ) {\n\n                            k = *buf1++;\n\n\n\n                            cur_lp = ((uint32_t *)cur_frm_pos) + width_tbl[lp2 * 2];\n\n                            ref_lp = ((uint32_t *)cur_frm_pos) + width_tbl[(lp2 * 2) - 1];\n\n\n\n                            switch(correction_type_sp[lp2 & 0x01][k]) {\n\n                            case 0:\n\n                                cur_lp[width_tbl[1]] = av_le2ne32(((av_le2ne32(*ref_lp) >> 1) + correction_lp[lp2 & 0x01][k]) << 1);\n\n                                if(lp2 > 0 || flag1 == 0 || strip->ypos != 0)\n\n                                    cur_lp[0] = ((cur_lp[-width_tbl[1]] >> 1) + (cur_lp[width_tbl[1]] >> 1)) & 0xFEFEFEFE;\n\n                                else\n\n                                    cur_lp[0] = av_le2ne32(((av_le2ne32(*ref_lp) >> 1) + correction_lp[lp2 & 0x01][k]) << 1);\n\n                                lp2++;\n\n                                break;\n\n\n\n                            case 1:\n\n                                res = ((av_le2ne16(((unsigned short *)ref_lp)[0]) >> 1) + correction_lp[lp2 & 0x01][*buf1]) << 1;\n\n                                ((unsigned short *)cur_lp)[width_tbl[2]] = av_le2ne16(res);\n\n                                res = ((av_le2ne16(((unsigned short *)ref_lp)[1]) >> 1) + correction_lp[lp2 & 0x01][k]) << 1;\n\n                                ((unsigned short *)cur_lp)[width_tbl[2]+1] = av_le2ne16(res);\n\n\n\n                                if(lp2 > 0 || flag1 == 0 || strip->ypos != 0)\n\n                                    cur_lp[0] = ((cur_lp[-width_tbl[1]] >> 1) + (cur_lp[width_tbl[1]] >> 1)) & 0xFEFEFEFE;\n\n                                else\n\n                                    cur_lp[0] = cur_lp[width_tbl[1]];\n\n                                buf1++;\n\n                                lp2++;\n\n                                break;\n\n\n\n                            case 2:\n\n                                if(lp2 == 0) {\n\n                                    for(i = 0, j = 0; i < 4; i++, j += width_tbl[1])\n\n                                        cur_lp[j] = *ref_lp;\n\n                                    lp2 += 2;\n\n                                }\n\n                                break;\n\n\n\n                            case 3:\n\n                                if(lp2 < 2) {\n\n                                    for(i = 0, j = 0; i < 6 - (lp2 * 2); i++, j += width_tbl[1])\n\n                                        cur_lp[j] = *ref_lp;\n\n                                    lp2 = 3;\n\n                                }\n\n                                break;\n\n\n\n                            case 6:\n\n                                lp2 = 4;\n\n                                break;\n\n\n\n                            case 7:\n\n                                if(rle_v3 != 0)\n\n                                    rle_v3 = 0;\n\n                                else {\n\n                                    buf1--;\n\n                                    rle_v3 = 1;\n\n                                }\n\n                                lp2 = 4;\n\n                                break;\n\n\n\n                            case 8:\n\n                                if(lp2 == 0) {\n\n                                    RLE_V3_CHECK(buf1,rle_v1,rle_v2,rle_v3)\n\n\n\n                                    if(rle_v1 == 1) {\n\n                                        for(i = 0, j = 0; i < 8; i++, j += width_tbl[1])\n\n                                            cur_lp[j] = ref_lp[j];\n\n                                    }\n\n\n\n                                    RLE_V2_CHECK(buf1,rle_v2, rle_v3,lp2)\n\n                                    break;\n\n                                } else {\n\n                                    rle_v2 = (*buf1) - 1;\n\n                                    rle_v1 = 1;\n\n                                }\n\n                            case 5:\n\n                                LP2_CHECK(buf1,rle_v3,lp2)\n\n                            case 4:\n\n                                for(i = 0, j = 0; i < 8 - (lp2 * 2); i++, j += width_tbl[1])\n\n                                    cur_lp[j] = *ref_lp;\n\n                                lp2 = 4;\n\n                                break;\n\n\n\n                            case 9:\n\n                                av_log(s->avctx, AV_LOG_ERROR, \"UNTESTED.\\n\");\n\n                                lv1 = *buf1++;\n\n                                lv = (lv1 & 0x7F) << 1;\n\n                                lv += (lv << 8);\n\n                                lv += (lv << 16);\n\n\n\n                                for(i = 0, j = 0; i < 4; i++, j += width_tbl[1])\n\n                                    cur_lp[j] = lv;\n\n\n\n                                LV1_CHECK(buf1,rle_v3,lv1,lp2)\n\n                                break;\n\n\n\n                            default:\n\n                                return;\n\n                            }\n\n                        }\n\n\n\n                        cur_frm_pos += 4;\n\n                    }\n\n\n\n                    cur_frm_pos += (((width * 2) - blks_width) * 4);\n\n                    flag1 = 0;\n\n                }\n\n                break;\n\n\n\n            case 10:                    /********** CASE 10 **********/\n\n                if(ref_vectors == NULL) {\n\n                    flag1 = 1;\n\n\n\n                    for( ; blks_height > 0; blks_height -= 8) {\n\n                        for(lp1 = 0; lp1 < blks_width; lp1 += 2) {\n\n                            for(lp2 = 0; lp2 < 4; ) {\n\n                                k = *buf1++;\n\n                                cur_lp = ((uint32_t *)cur_frm_pos) + width_tbl[lp2 * 2];\n\n                                ref_lp = ((uint32_t *)cur_frm_pos) + width_tbl[(lp2 * 2) - 1];\n\n                                lv1 = ref_lp[0];\n\n                                lv2 = ref_lp[1];\n\n                                if(lp2 == 0 && flag1 != 0) {\n\n#if HAVE_BIGENDIAN\n\n                                    lv1 = lv1 & 0xFF00FF00;\n\n                                    lv1 = (lv1 >> 8) | lv1;\n\n                                    lv2 = lv2 & 0xFF00FF00;\n\n                                    lv2 = (lv2 >> 8) | lv2;\n\n#else\n\n                                    lv1 = lv1 & 0x00FF00FF;\n\n                                    lv1 = (lv1 << 8) | lv1;\n\n                                    lv2 = lv2 & 0x00FF00FF;\n\n                                    lv2 = (lv2 << 8) | lv2;\n\n#endif\n\n                                }\n\n\n\n                                switch(correction_type_sp[lp2 & 0x01][k]) {\n\n                                case 0:\n\n                                    cur_lp[width_tbl[1]] = av_le2ne32(((av_le2ne32(lv1) >> 1) + correctionloworder_lp[lp2 & 0x01][k]) << 1);\n\n                                    cur_lp[width_tbl[1]+1] = av_le2ne32(((av_le2ne32(lv2) >> 1) + correctionhighorder_lp[lp2 & 0x01][k]) << 1);\n\n                                    if(lp2 > 0 || strip->ypos != 0 || flag1 == 0) {\n\n                                        cur_lp[0] = ((cur_lp[-width_tbl[1]] >> 1) + (cur_lp[width_tbl[1]] >> 1)) & 0xFEFEFEFE;\n\n                                        cur_lp[1] = ((cur_lp[-width_tbl[1]+1] >> 1) + (cur_lp[width_tbl[1]+1] >> 1)) & 0xFEFEFEFE;\n\n                                    } else {\n\n                                        cur_lp[0] = cur_lp[width_tbl[1]];\n\n                                        cur_lp[1] = cur_lp[width_tbl[1]+1];\n\n                                    }\n\n                                    lp2++;\n\n                                    break;\n\n\n\n                                case 1:\n\n                                    cur_lp[width_tbl[1]] = av_le2ne32(((av_le2ne32(lv1) >> 1) + correctionloworder_lp[lp2 & 0x01][*buf1]) << 1);\n\n                                    cur_lp[width_tbl[1]+1] = av_le2ne32(((av_le2ne32(lv2) >> 1) + correctionloworder_lp[lp2 & 0x01][k]) << 1);\n\n                                    if(lp2 > 0 || strip->ypos != 0 || flag1 == 0) {\n\n                                        cur_lp[0] = ((cur_lp[-width_tbl[1]] >> 1) + (cur_lp[width_tbl[1]] >> 1)) & 0xFEFEFEFE;\n\n                                        cur_lp[1] = ((cur_lp[-width_tbl[1]+1] >> 1) + (cur_lp[width_tbl[1]+1] >> 1)) & 0xFEFEFEFE;\n\n                                    } else {\n\n                                        cur_lp[0] = cur_lp[width_tbl[1]];\n\n                                        cur_lp[1] = cur_lp[width_tbl[1]+1];\n\n                                    }\n\n                                    buf1++;\n\n                                    lp2++;\n\n                                    break;\n\n\n\n                                case 2:\n\n                                    if(lp2 == 0) {\n\n                                        if(flag1 != 0) {\n\n                                            for(i = 0, j = width_tbl[1]; i < 3; i++, j += width_tbl[1]) {\n\n                                                cur_lp[j] = lv1;\n\n                                                cur_lp[j+1] = lv2;\n\n                                            }\n\n                                            cur_lp[0] = ((cur_lp[-width_tbl[1]] >> 1) + (cur_lp[width_tbl[1]] >> 1)) & 0xFEFEFEFE;\n\n                                            cur_lp[1] = ((cur_lp[-width_tbl[1]+1] >> 1) + (cur_lp[width_tbl[1]+1] >> 1)) & 0xFEFEFEFE;\n\n                                        } else {\n\n                                            for(i = 0, j = 0; i < 4; i++, j += width_tbl[1]) {\n\n                                                cur_lp[j] = lv1;\n\n                                                cur_lp[j+1] = lv2;\n\n                                            }\n\n                                        }\n\n                                        lp2 += 2;\n\n                                    }\n\n                                    break;\n\n\n\n                                case 3:\n\n                                    if(lp2 < 2) {\n\n                                        if(lp2 == 0 && flag1 != 0) {\n\n                                            for(i = 0, j = width_tbl[1]; i < 5; i++, j += width_tbl[1]) {\n\n                                                cur_lp[j] = lv1;\n\n                                                cur_lp[j+1] = lv2;\n\n                                            }\n\n                                            cur_lp[0] = ((cur_lp[-width_tbl[1]] >> 1) + (cur_lp[width_tbl[1]] >> 1)) & 0xFEFEFEFE;\n\n                                            cur_lp[1] = ((cur_lp[-width_tbl[1]+1] >> 1) + (cur_lp[width_tbl[1]+1] >> 1)) & 0xFEFEFEFE;\n\n                                        } else {\n\n                                            for(i = 0, j = 0; i < 6 - (lp2 * 2); i++, j += width_tbl[1]) {\n\n                                                cur_lp[j] = lv1;\n\n                                                cur_lp[j+1] = lv2;\n\n                                            }\n\n                                        }\n\n                                        lp2 = 3;\n\n                                    }\n\n                                    break;\n\n\n\n                                case 8:\n\n                                    if(lp2 == 0) {\n\n                                        RLE_V3_CHECK(buf1,rle_v1,rle_v2,rle_v3)\n\n                                        if(rle_v1 == 1) {\n\n                                            if(flag1 != 0) {\n\n                                                for(i = 0, j = width_tbl[1]; i < 7; i++, j += width_tbl[1]) {\n\n                                                    cur_lp[j] = lv1;\n\n                                                    cur_lp[j+1] = lv2;\n\n                                                }\n\n                                                cur_lp[0] = ((cur_lp[-width_tbl[1]] >> 1) + (cur_lp[width_tbl[1]] >> 1)) & 0xFEFEFEFE;\n\n                                                cur_lp[1] = ((cur_lp[-width_tbl[1]+1] >> 1) + (cur_lp[width_tbl[1]+1] >> 1)) & 0xFEFEFEFE;\n\n                                            } else {\n\n                                                for(i = 0, j = 0; i < 8; i++, j += width_tbl[1]) {\n\n                                                    cur_lp[j] = lv1;\n\n                                                    cur_lp[j+1] = lv2;\n\n                                                }\n\n                                            }\n\n                                        }\n\n                                        RLE_V2_CHECK(buf1,rle_v2, rle_v3,lp2)\n\n                                        break;\n\n                                    } else {\n\n                                        rle_v1 = 1;\n\n                                        rle_v2 = (*buf1) - 1;\n\n                                    }\n\n                                case 5:\n\n                                    LP2_CHECK(buf1,rle_v3,lp2)\n\n                                case 4:\n\n                                    if(lp2 == 0 && flag1 != 0) {\n\n                                        for(i = 0, j = width_tbl[1]; i < 7; i++, j += width_tbl[1]) {\n\n                                            cur_lp[j] = lv1;\n\n                                            cur_lp[j+1] = lv2;\n\n                                        }\n\n                                        cur_lp[0] = ((cur_lp[-width_tbl[1]] >> 1) + (cur_lp[width_tbl[1]] >> 1)) & 0xFEFEFEFE;\n\n                                        cur_lp[1] = ((cur_lp[-width_tbl[1]+1] >> 1) + (cur_lp[width_tbl[1]+1] >> 1)) & 0xFEFEFEFE;\n\n                                    } else {\n\n                                        for(i = 0, j = 0; i < 8 - (lp2 * 2); i++, j += width_tbl[1]) {\n\n                                            cur_lp[j] = lv1;\n\n                                            cur_lp[j+1] = lv2;\n\n                                        }\n\n                                    }\n\n                                    lp2 = 4;\n\n                                    break;\n\n\n\n                                case 6:\n\n                                    lp2 = 4;\n\n                                    break;\n\n\n\n                                case 7:\n\n                                    if(lp2 == 0) {\n\n                                        if(rle_v3 != 0)\n\n                                            rle_v3 = 0;\n\n                                        else {\n\n                                            buf1--;\n\n                                            rle_v3 = 1;\n\n                                        }\n\n                                        lp2 = 4;\n\n                                    }\n\n                                    break;\n\n\n\n                                case 9:\n\n                                    av_log(s->avctx, AV_LOG_ERROR, \"UNTESTED.\\n\");\n\n                                    lv1 = *buf1;\n\n                                    lv = (lv1 & 0x7F) << 1;\n\n                                    lv += (lv << 8);\n\n                                    lv += (lv << 16);\n\n                                    for(i = 0, j = 0; i < 8; i++, j += width_tbl[1])\n\n                                        cur_lp[j] = lv;\n\n                                    LV1_CHECK(buf1,rle_v3,lv1,lp2)\n\n                                    break;\n\n\n\n                                default:\n\n                                    return;\n\n                                }\n\n                            }\n\n\n\n                            cur_frm_pos += 8;\n\n                        }\n\n\n\n                        cur_frm_pos += (((width * 2) - blks_width) * 4);\n\n                        flag1 = 0;\n\n                    }\n\n                } else {\n\n                    for( ; blks_height > 0; blks_height -= 8) {\n\n                        for(lp1 = 0; lp1 < blks_width; lp1 += 2) {\n\n                            for(lp2 = 0; lp2 < 4; ) {\n\n                                k = *buf1++;\n\n                                cur_lp = ((uint32_t *)cur_frm_pos) + width_tbl[lp2 * 2];\n\n                                ref_lp = ((uint32_t *)ref_frm_pos) + width_tbl[lp2 * 2];\n\n\n\n                                switch(correction_type_sp[lp2 & 0x01][k]) {\n\n                                case 0:\n\n                                    lv1 = correctionloworder_lp[lp2 & 0x01][k];\n\n                                    lv2 = correctionhighorder_lp[lp2 & 0x01][k];\n\n                                    cur_lp[0] = av_le2ne32(((av_le2ne32(ref_lp[0]) >> 1) + lv1) << 1);\n\n                                    cur_lp[1] = av_le2ne32(((av_le2ne32(ref_lp[1]) >> 1) + lv2) << 1);\n\n                                    cur_lp[width_tbl[1]] = av_le2ne32(((av_le2ne32(ref_lp[width_tbl[1]]) >> 1) + lv1) << 1);\n\n                                    cur_lp[width_tbl[1]+1] = av_le2ne32(((av_le2ne32(ref_lp[width_tbl[1]+1]) >> 1) + lv2) << 1);\n\n                                    lp2++;\n\n                                    break;\n\n\n\n                                case 1:\n\n                                    lv1 = correctionloworder_lp[lp2 & 0x01][*buf1++];\n\n                                    lv2 = correctionloworder_lp[lp2 & 0x01][k];\n\n                                    cur_lp[0] = av_le2ne32(((av_le2ne32(ref_lp[0]) >> 1) + lv1) << 1);\n\n                                    cur_lp[1] = av_le2ne32(((av_le2ne32(ref_lp[1]) >> 1) + lv2) << 1);\n\n                                    cur_lp[width_tbl[1]] = av_le2ne32(((av_le2ne32(ref_lp[width_tbl[1]]) >> 1) + lv1) << 1);\n\n                                    cur_lp[width_tbl[1]+1] = av_le2ne32(((av_le2ne32(ref_lp[width_tbl[1]+1]) >> 1) + lv2) << 1);\n\n                                    lp2++;\n\n                                    break;\n\n\n\n                                case 2:\n\n                                    if(lp2 == 0) {\n\n                                        for(i = 0, j = 0; i < 4; i++, j += width_tbl[1]) {\n\n                                            cur_lp[j] = ref_lp[j];\n\n                                            cur_lp[j+1] = ref_lp[j+1];\n\n                                        }\n\n                                        lp2 += 2;\n\n                                    }\n\n                                    break;\n\n\n\n                                case 3:\n\n                                    if(lp2 < 2) {\n\n                                        for(i = 0, j = 0; i < 6 - (lp2 * 2); i++, j += width_tbl[1]) {\n\n                                            cur_lp[j] = ref_lp[j];\n\n                                            cur_lp[j+1] = ref_lp[j+1];\n\n                                        }\n\n                                        lp2 = 3;\n\n                                    }\n\n                                    break;\n\n\n\n                                case 8:\n\n                                    if(lp2 == 0) {\n\n                                        RLE_V3_CHECK(buf1,rle_v1,rle_v2,rle_v3)\n\n                                        for(i = 0, j = 0; i < 8; i++, j += width_tbl[1]) {\n\n                                            ((uint32_t *)cur_frm_pos)[j] = ((uint32_t *)ref_frm_pos)[j];\n\n                                            ((uint32_t *)cur_frm_pos)[j+1] = ((uint32_t *)ref_frm_pos)[j+1];\n\n                                        }\n\n                                        RLE_V2_CHECK(buf1,rle_v2, rle_v3,lp2)\n\n                                        break;\n\n                                    } else {\n\n                                        rle_v1 = 1;\n\n                                        rle_v2 = (*buf1) - 1;\n\n                                    }\n\n                                case 5:\n\n                                case 7:\n\n                                    LP2_CHECK(buf1,rle_v3,lp2)\n\n                                case 6:\n\n                                case 4:\n\n                                    for(i = 0, j = 0; i < 8 - (lp2 * 2); i++, j += width_tbl[1]) {\n\n                                        cur_lp[j] = ref_lp[j];\n\n                                        cur_lp[j+1] = ref_lp[j+1];\n\n                                    }\n\n                                    lp2 = 4;\n\n                                    break;\n\n\n\n                                case 9:\n\n                                    av_log(s->avctx, AV_LOG_ERROR, \"UNTESTED.\\n\");\n\n                                    lv1 = *buf1;\n\n                                    lv = (lv1 & 0x7F) << 1;\n\n                                    lv += (lv << 8);\n\n                                    lv += (lv << 16);\n\n                                    for(i = 0, j = 0; i < 8; i++, j += width_tbl[1])\n\n                                        ((uint32_t *)cur_frm_pos)[j] = ((uint32_t *)cur_frm_pos)[j+1] = lv;\n\n                                    LV1_CHECK(buf1,rle_v3,lv1,lp2)\n\n                                    break;\n\n\n\n                                default:\n\n                                    return;\n\n                                }\n\n                            }\n\n\n\n                            cur_frm_pos += 8;\n\n                            ref_frm_pos += 8;\n\n                        }\n\n\n\n                        cur_frm_pos += (((width * 2) - blks_width) * 4);\n\n                        ref_frm_pos += (((width * 2) - blks_width) * 4);\n\n                    }\n\n                }\n\n                break;\n\n\n\n            case 11:                    /********** CASE 11 **********/\n\n                if(ref_vectors == NULL)\n\n                    return;\n\n\n\n                for( ; blks_height > 0; blks_height -= 8) {\n\n                    for(lp1 = 0; lp1 < blks_width; lp1++) {\n\n                        for(lp2 = 0; lp2 < 4; ) {\n\n                            k = *buf1++;\n\n                            cur_lp = ((uint32_t *)cur_frm_pos) + width_tbl[lp2 * 2];\n\n                            ref_lp = ((uint32_t *)ref_frm_pos) + width_tbl[lp2 * 2];\n\n\n\n                            switch(correction_type_sp[lp2 & 0x01][k]) {\n\n                            case 0:\n\n                                cur_lp[0] = av_le2ne32(((av_le2ne32(*ref_lp) >> 1) + correction_lp[lp2 & 0x01][k]) << 1);\n\n                                cur_lp[width_tbl[1]] = av_le2ne32(((av_le2ne32(ref_lp[width_tbl[1]]) >> 1) + correction_lp[lp2 & 0x01][k]) << 1);\n\n                                lp2++;\n\n                                break;\n\n\n\n                            case 1:\n\n                                lv1 = (unsigned short)(correction_lp[lp2 & 0x01][*buf1++]);\n\n                                lv2 = (unsigned short)(correction_lp[lp2 & 0x01][k]);\n\n                                res = (unsigned short)(((av_le2ne16(((unsigned short *)ref_lp)[0]) >> 1) + lv1) << 1);\n\n                                ((unsigned short *)cur_lp)[0] = av_le2ne16(res);\n\n                                res = (unsigned short)(((av_le2ne16(((unsigned short *)ref_lp)[1]) >> 1) + lv2) << 1);\n\n                                ((unsigned short *)cur_lp)[1] = av_le2ne16(res);\n\n                                res = (unsigned short)(((av_le2ne16(((unsigned short *)ref_lp)[width_tbl[2]]) >> 1) + lv1) << 1);\n\n                                ((unsigned short *)cur_lp)[width_tbl[2]] = av_le2ne16(res);\n\n                                res = (unsigned short)(((av_le2ne16(((unsigned short *)ref_lp)[width_tbl[2]+1]) >> 1) + lv2) << 1);\n\n                                ((unsigned short *)cur_lp)[width_tbl[2]+1] = av_le2ne16(res);\n\n                                lp2++;\n\n                                break;\n\n\n\n                            case 2:\n\n                                if(lp2 == 0) {\n\n                                    for(i = 0, j = 0; i < 4; i++, j += width_tbl[1])\n\n                                        cur_lp[j] = ref_lp[j];\n\n                                    lp2 += 2;\n\n                                }\n\n                                break;\n\n\n\n                            case 3:\n\n                                if(lp2 < 2) {\n\n                                    for(i = 0, j = 0; i < 6 - (lp2 * 2); i++, j += width_tbl[1])\n\n                                        cur_lp[j] = ref_lp[j];\n\n                                    lp2 = 3;\n\n                                }\n\n                                break;\n\n\n\n                            case 8:\n\n                                if(lp2 == 0) {\n\n                                    RLE_V3_CHECK(buf1,rle_v1,rle_v2,rle_v3)\n\n\n\n                                    for(i = 0, j = 0; i < 8; i++, j += width_tbl[1])\n\n                                        cur_lp[j] = ref_lp[j];\n\n\n\n                                    RLE_V2_CHECK(buf1,rle_v2, rle_v3,lp2)\n\n                                    break;\n\n                                } else {\n\n                                    rle_v1 = 1;\n\n                                    rle_v2 = (*buf1) - 1;\n\n                                }\n\n                            case 5:\n\n                            case 7:\n\n                                LP2_CHECK(buf1,rle_v3,lp2)\n\n                            case 4:\n\n                            case 6:\n\n                                for(i = 0, j = 0; i < 8 - (lp2 * 2); i++, j += width_tbl[1])\n\n                                    cur_lp[j] = ref_lp[j];\n\n                                lp2 = 4;\n\n                                break;\n\n\n\n                            case 9:\n\n                                av_log(s->avctx, AV_LOG_ERROR, \"UNTESTED.\\n\");\n\n                                lv1 = *buf1++;\n\n                                lv = (lv1 & 0x7F) << 1;\n\n                                lv += (lv << 8);\n\n                                lv += (lv << 16);\n\n                                for(i = 0, j = 0; i < 4; i++, j += width_tbl[1])\n\n                                    cur_lp[j] = lv;\n\n                                LV1_CHECK(buf1,rle_v3,lv1,lp2)\n\n                                break;\n\n\n\n                            default:\n\n                                return;\n\n                            }\n\n                        }\n\n\n\n                        cur_frm_pos += 4;\n\n                        ref_frm_pos += 4;\n\n                    }\n\n\n\n                    cur_frm_pos += (((width * 2) - blks_width) * 4);\n\n                    ref_frm_pos += (((width * 2) - blks_width) * 4);\n\n                }\n\n                break;\n\n\n\n            default:\n\n                return;\n\n            }\n\n        }\n\n\n\n        for( ; strip >= strip_tbl; strip--) {\n\n            if(strip->split_flag != 0) {\n\n                strip->split_flag = 0;\n\n                strip->usl7 = (strip-1)->usl7;\n\n\n\n                if(strip->split_direction) {\n\n                    strip->xpos += strip->width;\n\n                    strip->width = (strip-1)->width - strip->width;\n\n                    if(region_160_width <= strip->xpos && width < strip->width + strip->xpos)\n\n                        strip->width = width - strip->xpos;\n\n                } else {\n\n                    strip->ypos += strip->height;\n\n                    strip->height = (strip-1)->height - strip->height;\n\n                }\n\n                break;\n\n            }\n\n        }\n\n    }\n\n}", "idx": 10662}
{"project": "qemu", "commit_id": "2a7e6857cd3178d705a49c4adde2f3af26ed3ae1", "target": 0, "func": "static VncBasicInfoList *qmp_query_server_entry(QIOChannelSocket *ioc,\n\n                                                bool websocket,\n\n                                                VncBasicInfoList *prev)\n\n{\n\n    VncBasicInfoList *list;\n\n    VncBasicInfo *info;\n\n    Error *err = NULL;\n\n    SocketAddress *addr;\n\n\n\n    addr = qio_channel_socket_get_local_address(ioc, &err);\n\n    if (!addr) {\n\n        error_free(err);\n\n        return prev;\n\n    }\n\n\n\n    info = g_new0(VncBasicInfo, 1);\n\n    vnc_init_basic_info(addr, info, &err);\n\n    qapi_free_SocketAddress(addr);\n\n    if (err) {\n\n        qapi_free_VncBasicInfo(info);\n\n        error_free(err);\n\n        return prev;\n\n    }\n\n    info->websocket = websocket;\n\n\n\n    list = g_new0(VncBasicInfoList, 1);\n\n    list->value = info;\n\n    list->next = prev;\n\n    return list;\n\n}\n", "idx": 10722}
{"project": "qemu", "commit_id": "d861b05ea30e6ac177de9b679da96194ebe21afc", "target": 1, "func": "static NetSocketState *net_socket_fd_init_dgram(VLANState *vlan, int fd, \n\n                                          int is_connected)\n\n{\n\n    struct sockaddr_in saddr;\n\n    int newfd;\n\n    socklen_t saddr_len;\n\n    NetSocketState *s;\n\n\n\n    /* fd passed: multicast: \"learn\" dgram_dst address from bound address and save it\n\n     * Because this may be \"shared\" socket from a \"master\" process, datagrams would be recv() \n\n     * by ONLY ONE process: we must \"clone\" this dgram socket --jjo\n\n     */\n\n\n\n    if (is_connected) {\n\n\tif (getsockname(fd, (struct sockaddr *) &saddr, &saddr_len) == 0) {\n\n\t    /* must be bound */\n\n\t    if (saddr.sin_addr.s_addr==0) {\n\n\t\tfprintf(stderr, \"qemu: error: init_dgram: fd=%d unbound, cannot setup multicast dst addr\\n\",\n\n\t\t\tfd);\n\n\t\treturn NULL;\n\n\t    }\n\n\t    /* clone dgram socket */\n\n\t    newfd = net_socket_mcast_create(&saddr);\n\n\t    if (newfd < 0) {\n\n\t\t/* error already reported by net_socket_mcast_create() */\n\n\t\tclose(fd);\n\n\t\treturn NULL;\n\n\t    }\n\n\t    /* clone newfd to fd, close newfd */\n\n\t    dup2(newfd, fd);\n\n\t    close(newfd);\n\n\t\n\n\t} else {\n\n\t    fprintf(stderr, \"qemu: error: init_dgram: fd=%d failed getsockname(): %s\\n\",\n\n\t\t    fd, strerror(errno));\n\n\t    return NULL;\n\n\t}\n\n    }\n\n\n\n    s = qemu_mallocz(sizeof(NetSocketState));\n\n    if (!s)\n\n        return NULL;\n\n    s->fd = fd;\n\n\n\n    s->vc = qemu_new_vlan_client(vlan, net_socket_receive_dgram, s);\n\n    qemu_set_fd_handler(s->fd, net_socket_send_dgram, NULL, s);\n\n\n\n    /* mcast: save bound address as dst */\n\n    if (is_connected) s->dgram_dst=saddr;\n\n\n\n    snprintf(s->vc->info_str, sizeof(s->vc->info_str),\n\n\t    \"socket: fd=%d (%s mcast=%s:%d)\", \n\n\t    fd, is_connected? \"cloned\" : \"\",\n\n\t    inet_ntoa(saddr.sin_addr), ntohs(saddr.sin_port));\n\n    return s;\n\n}\n", "idx": 10729}
{"project": "FFmpeg", "commit_id": "d31dbec3742e488156621b9ca21069f8c05aabf0", "target": 0, "func": "static int init_duplicate_context(MpegEncContext *s, MpegEncContext *base){\n\n    int i;\n\n\n\n    // edge emu needs blocksize + filter length - 1 (=17x17 for halfpel / 21x21 for h264)\n\n    CHECKED_ALLOCZ(s->allocated_edge_emu_buffer, (s->width+64)*2*21*2); //(width + edge + align)*interlaced*MBsize*tolerance\n\n    s->edge_emu_buffer= s->allocated_edge_emu_buffer + (s->width+64)*2*21;\n\n\n\n     //FIXME should be linesize instead of s->width*2 but that is not known before get_buffer()\n\n    CHECKED_ALLOCZ(s->me.scratchpad,  (s->width+64)*4*16*2*sizeof(uint8_t))\n\n    s->me.temp=         s->me.scratchpad;\n\n    s->rd_scratchpad=   s->me.scratchpad;\n\n    s->b_scratchpad=    s->me.scratchpad;\n\n    s->obmc_scratchpad= s->me.scratchpad + 16;\n\n    if (s->encoding) {\n\n        CHECKED_ALLOCZ(s->me.map      , ME_MAP_SIZE*sizeof(uint32_t))\n\n        CHECKED_ALLOCZ(s->me.score_map, ME_MAP_SIZE*sizeof(uint32_t))\n\n        if(s->avctx->noise_reduction){\n\n            CHECKED_ALLOCZ(s->dct_error_sum, 2 * 64 * sizeof(int))\n\n        }\n\n    }\n\n    CHECKED_ALLOCZ(s->blocks, 64*12*2 * sizeof(DCTELEM))\n\n    s->block= s->blocks[0];\n\n\n\n    for(i=0;i<12;i++){\n\n        s->pblocks[i] = &s->block[i];\n\n    }\n\n    return 0;\n\nfail:\n\n    return -1; //free() through MPV_common_end()\n\n}\n", "idx": 10751}
{"project": "qemu", "commit_id": "46c5874e9cd752ed8ded31af03472edd8fc3efc1", "target": 0, "func": "static void rtas_ibm_set_eeh_option(PowerPCCPU *cpu,\n\n                                    sPAPREnvironment *spapr,\n\n                                    uint32_t token, uint32_t nargs,\n\n                                    target_ulong args, uint32_t nret,\n\n                                    target_ulong rets)\n\n{\n\n    sPAPRPHBState *sphb;\n\n    sPAPRPHBClass *spc;\n\n    uint32_t addr, option;\n\n    uint64_t buid;\n\n    int ret;\n\n\n\n    if ((nargs != 4) || (nret != 1)) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    buid = ((uint64_t)rtas_ld(args, 1) << 32) | rtas_ld(args, 2);\n\n    addr = rtas_ld(args, 0);\n\n    option = rtas_ld(args, 3);\n\n\n\n    sphb = find_phb(spapr, buid);\n\n    if (!sphb) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    spc = SPAPR_PCI_HOST_BRIDGE_GET_CLASS(sphb);\n\n    if (!spc->eeh_set_option) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    ret = spc->eeh_set_option(sphb, addr, option);\n\n    rtas_st(rets, 0, ret);\n\n    return;\n\n\n\nparam_error_exit:\n\n    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n}\n", "idx": 10889}
{"project": "qemu", "commit_id": "9d40cd8a68cfc7606f4548cc9e812bab15c6dc28", "target": 0, "func": "static bool nvic_user_access_ok(NVICState *s, hwaddr offset)\n\n{\n\n    /* Return true if unprivileged access to this register is permitted. */\n\n    switch (offset) {\n\n    case 0xf00: /* STIR: accessible only if CCR.USERSETMPEND permits */\n\n        return s->cpu->env.v7m.ccr & R_V7M_CCR_USERSETMPEND_MASK;\n\n    default:\n\n        /* All other user accesses cause a BusFault unconditionally */\n\n        return false;\n\n    }\n\n}\n", "idx": 10897}
{"project": "FFmpeg", "commit_id": "5ad4335c2233d5a6d9487d2d56387b7484aecded", "target": 0, "func": "void inter_predict(VP8Context *s, uint8_t *dst[3], VP8Macroblock *mb,\n\n                   int mb_x, int mb_y)\n\n{\n\n    int x_off = mb_x << 4, y_off = mb_y << 4;\n\n    int width = 16*s->mb_width, height = 16*s->mb_height;\n\n    AVFrame *ref = s->framep[mb->ref_frame];\n\n    VP56mv *bmv = mb->bmv;\n\n\n\n    switch (mb->partitioning) {\n\n    case VP8_SPLITMVMODE_NONE:\n\n        vp8_mc_part(s, dst, ref, x_off, y_off,\n\n                    0, 0, 16, 16, width, height, &mb->mv);\n\n        break;\n\n    case VP8_SPLITMVMODE_4x4: {\n\n        int x, y;\n\n        VP56mv uvmv;\n\n\n\n        /* Y */\n\n        for (y = 0; y < 4; y++) {\n\n            for (x = 0; x < 4; x++) {\n\n                vp8_mc(s, 1, dst[0] + 4*y*s->linesize + x*4,\n\n                       ref->data[0], &bmv[4*y + x],\n\n                       4*x + x_off, 4*y + y_off, 4, 4,\n\n                       width, height, s->linesize,\n\n                       s->put_pixels_tab[2]);\n\n            }\n\n        }\n\n\n\n        /* U/V */\n\n        x_off >>= 1; y_off >>= 1; width >>= 1; height >>= 1;\n\n        for (y = 0; y < 2; y++) {\n\n            for (x = 0; x < 2; x++) {\n\n                uvmv.x = mb->bmv[ 2*y    * 4 + 2*x  ].x +\n\n                         mb->bmv[ 2*y    * 4 + 2*x+1].x +\n\n                         mb->bmv[(2*y+1) * 4 + 2*x  ].x +\n\n                         mb->bmv[(2*y+1) * 4 + 2*x+1].x;\n\n                uvmv.y = mb->bmv[ 2*y    * 4 + 2*x  ].y +\n\n                         mb->bmv[ 2*y    * 4 + 2*x+1].y +\n\n                         mb->bmv[(2*y+1) * 4 + 2*x  ].y +\n\n                         mb->bmv[(2*y+1) * 4 + 2*x+1].y;\n\n                uvmv.x = (uvmv.x + 2 + (uvmv.x >> (INT_BIT-1))) >> 2;\n\n                uvmv.y = (uvmv.y + 2 + (uvmv.y >> (INT_BIT-1))) >> 2;\n\n                if (s->profile == 3) {\n\n                    uvmv.x &= ~7;\n\n                    uvmv.y &= ~7;\n\n                }\n\n                vp8_mc(s, 0, dst[1] + 4*y*s->uvlinesize + x*4,\n\n                       ref->data[1], &uvmv,\n\n                       4*x + x_off, 4*y + y_off, 4, 4,\n\n                       width, height, s->uvlinesize,\n\n                       s->put_pixels_tab[2]);\n\n                vp8_mc(s, 0, dst[2] + 4*y*s->uvlinesize + x*4,\n\n                       ref->data[2], &uvmv,\n\n                       4*x + x_off, 4*y + y_off, 4, 4,\n\n                       width, height, s->uvlinesize,\n\n                       s->put_pixels_tab[2]);\n\n            }\n\n        }\n\n        break;\n\n    }\n\n    case VP8_SPLITMVMODE_16x8:\n\n        vp8_mc_part(s, dst, ref, x_off, y_off,\n\n                    0, 0, 16, 8, width, height, &bmv[0]);\n\n        vp8_mc_part(s, dst, ref, x_off, y_off,\n\n                    0, 8, 16, 8, width, height, &bmv[1]);\n\n        break;\n\n    case VP8_SPLITMVMODE_8x16:\n\n        vp8_mc_part(s, dst, ref, x_off, y_off,\n\n                    0, 0, 8, 16, width, height, &bmv[0]);\n\n        vp8_mc_part(s, dst, ref, x_off, y_off,\n\n                    8, 0, 8, 16, width, height, &bmv[1]);\n\n        break;\n\n    case VP8_SPLITMVMODE_8x8:\n\n        vp8_mc_part(s, dst, ref, x_off, y_off,\n\n                    0, 0, 8, 8, width, height, &bmv[0]);\n\n        vp8_mc_part(s, dst, ref, x_off, y_off,\n\n                    8, 0, 8, 8, width, height, &bmv[1]);\n\n        vp8_mc_part(s, dst, ref, x_off, y_off,\n\n                    0, 8, 8, 8, width, height, &bmv[2]);\n\n        vp8_mc_part(s, dst, ref, x_off, y_off,\n\n                    8, 8, 8, 8, width, height, &bmv[3]);\n\n        break;\n\n    }\n\n}\n", "idx": 10928}
{"project": "qemu", "commit_id": "c572f23a3e7180dbeab5e86583e43ea2afed6271", "target": 1, "func": "static void v9fs_lcreate(void *opaque)\n\n{\n\n    int32_t dfid, flags, mode;\n\n    gid_t gid;\n\n    ssize_t err = 0;\n\n    ssize_t offset = 7;\n\n    V9fsString name;\n\n    V9fsFidState *fidp;\n\n    struct stat stbuf;\n\n    V9fsQID qid;\n\n    int32_t iounit;\n\n    V9fsPDU *pdu = opaque;\n\n\n\n    pdu_unmarshal(pdu, offset, \"dsddd\", &dfid, &name, &flags,\n\n                  &mode, &gid);\n\n\n\n\n    fidp = get_fid(pdu, dfid);\n\n    if (fidp == NULL) {\n\n        err = -ENOENT;\n\n        goto out_nofid;\n\n    }\n\n\n\n    flags = get_dotl_openflags(pdu->s, flags);\n\n    err = v9fs_co_open2(pdu, fidp, &name, gid,\n\n                        flags | O_CREAT, mode, &stbuf);\n\n    if (err < 0) {\n\n        goto out;\n\n    }\n\n    fidp->fid_type = P9_FID_FILE;\n\n    fidp->open_flags = flags;\n\n    if (flags & O_EXCL) {\n\n        /*\n\n         * We let the host file system do O_EXCL check\n\n         * We should not reclaim such fd\n\n         */\n\n        fidp->flags |= FID_NON_RECLAIMABLE;\n\n    }\n\n    iounit =  get_iounit(pdu, &fidp->path);\n\n    stat_to_qid(&stbuf, &qid);\n\n    offset += pdu_marshal(pdu, offset, \"Qd\", &qid, iounit);\n\n    err = offset;\n\nout:\n\n    put_fid(pdu, fidp);\n\nout_nofid:\n\n    trace_v9fs_lcreate_return(pdu->tag, pdu->id,\n\n                              qid.type, qid.version, qid.path, iounit);\n\n    complete_pdu(pdu->s, pdu, err);\n\n    v9fs_string_free(&name);\n\n}", "idx": 11055}
{"project": "qemu", "commit_id": "a01672d3968cf91208666d371784110bfde9d4f8", "target": 1, "func": "int kvm_init(void)\n\n{\n\n    static const char upgrade_note[] =\n\n        \"Please upgrade to at least kernel 2.6.29 or recent kvm-kmod\\n\"\n\n        \"(see http://sourceforge.net/projects/kvm).\\n\";\n\n    KVMState *s;\n\n    const KVMCapabilityInfo *missing_cap;\n\n    int ret;\n\n    int i;\n\n\n\n    s = g_malloc0(sizeof(KVMState));\n\n\n\n#ifdef KVM_CAP_SET_GUEST_DEBUG\n\n    QTAILQ_INIT(&s->kvm_sw_breakpoints);\n\n#endif\n\n    for (i = 0; i < ARRAY_SIZE(s->slots); i++) {\n\n        s->slots[i].slot = i;\n\n    }\n\n    s->vmfd = -1;\n\n    s->fd = qemu_open(\"/dev/kvm\", O_RDWR);\n\n    if (s->fd == -1) {\n\n        fprintf(stderr, \"Could not access KVM kernel module: %m\\n\");\n\n        ret = -errno;\n\n        goto err;\n\n    }\n\n\n\n    ret = kvm_ioctl(s, KVM_GET_API_VERSION, 0);\n\n    if (ret < KVM_API_VERSION) {\n\n        if (ret > 0) {\n\n            ret = -EINVAL;\n\n        }\n\n        fprintf(stderr, \"kvm version too old\\n\");\n\n        goto err;\n\n    }\n\n\n\n    if (ret > KVM_API_VERSION) {\n\n        ret = -EINVAL;\n\n        fprintf(stderr, \"kvm version not supported\\n\");\n\n        goto err;\n\n    }\n\n\n\n    s->vmfd = kvm_ioctl(s, KVM_CREATE_VM, 0);\n\n    if (s->vmfd < 0) {\n\n#ifdef TARGET_S390X\n\n        fprintf(stderr, \"Please add the 'switch_amode' kernel parameter to \"\n\n                        \"your host kernel command line\\n\");\n\n#endif\n\n        ret = s->vmfd;\n\n        goto err;\n\n    }\n\n\n\n    missing_cap = kvm_check_extension_list(s, kvm_required_capabilites);\n\n    if (!missing_cap) {\n\n        missing_cap =\n\n            kvm_check_extension_list(s, kvm_arch_required_capabilities);\n\n    }\n\n    if (missing_cap) {\n\n        ret = -EINVAL;\n\n        fprintf(stderr, \"kvm does not support %s\\n%s\",\n\n                missing_cap->name, upgrade_note);\n\n        goto err;\n\n    }\n\n\n\n    s->coalesced_mmio = kvm_check_extension(s, KVM_CAP_COALESCED_MMIO);\n\n\n\n    s->broken_set_mem_region = 1;\n\n    ret = kvm_check_extension(s, KVM_CAP_JOIN_MEMORY_REGIONS_WORKS);\n\n    if (ret > 0) {\n\n        s->broken_set_mem_region = 0;\n\n    }\n\n\n\n#ifdef KVM_CAP_VCPU_EVENTS\n\n    s->vcpu_events = kvm_check_extension(s, KVM_CAP_VCPU_EVENTS);\n\n#endif\n\n\n\n    s->robust_singlestep =\n\n        kvm_check_extension(s, KVM_CAP_X86_ROBUST_SINGLESTEP);\n\n\n\n#ifdef KVM_CAP_DEBUGREGS\n\n    s->debugregs = kvm_check_extension(s, KVM_CAP_DEBUGREGS);\n\n#endif\n\n\n\n#ifdef KVM_CAP_XSAVE\n\n    s->xsave = kvm_check_extension(s, KVM_CAP_XSAVE);\n\n#endif\n\n\n\n#ifdef KVM_CAP_XCRS\n\n    s->xcrs = kvm_check_extension(s, KVM_CAP_XCRS);\n\n#endif\n\n\n\n    ret = kvm_arch_init(s);\n\n    if (ret < 0) {\n\n        goto err;\n\n    }\n\n\n\n    kvm_state = s;\n\n    cpu_register_phys_memory_client(&kvm_cpu_phys_memory_client);\n\n\n\n    s->many_ioeventfds = kvm_check_many_ioeventfds();\n\n\n\n    cpu_interrupt_handler = kvm_handle_interrupt;\n\n\n\n    return 0;\n\n\n\nerr:\n\n    if (s) {\n\n        if (s->vmfd >= 0) {\n\n            close(s->vmfd);\n\n        }\n\n        if (s->fd != -1) {\n\n            close(s->fd);\n\n        }\n\n    }\n\n    g_free(s);\n\n\n\n    return ret;\n\n}\n", "idx": 11075}
{"project": "FFmpeg", "commit_id": "b76d853697a8b558e597ed4a6fc5a088b6c602c7", "target": 0, "func": "av_cold int avcodec_close(AVCodecContext *avctx)\n\n{\n\n    int ret = ff_lock_avcodec(avctx);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (avcodec_is_open(avctx)) {\n\n        FramePool *pool = avctx->internal->pool;\n\n        int i;\n\n        if (HAVE_THREADS && avctx->internal->frame_thread_encoder && avctx->thread_count > 1) {\n\n            ff_unlock_avcodec();\n\n            ff_frame_thread_encoder_free(avctx);\n\n            ff_lock_avcodec(avctx);\n\n        }\n\n        if (HAVE_THREADS && avctx->thread_opaque)\n\n            ff_thread_free(avctx);\n\n        if (avctx->codec && avctx->codec->close)\n\n            avctx->codec->close(avctx);\n\n        avctx->coded_frame = NULL;\n\n        avctx->internal->byte_buffer_size = 0;\n\n        av_freep(&avctx->internal->byte_buffer);\n\n        if (!avctx->refcounted_frames)\n\n            av_frame_unref(&avctx->internal->to_free);\n\n        for (i = 0; i < FF_ARRAY_ELEMS(pool->pools); i++)\n\n            av_buffer_pool_uninit(&pool->pools[i]);\n\n        av_freep(&avctx->internal->pool);\n\n        av_freep(&avctx->internal);\n\n    }\n\n\n\n    if (avctx->priv_data && avctx->codec && avctx->codec->priv_class)\n\n        av_opt_free(avctx->priv_data);\n\n    av_opt_free(avctx);\n\n    av_freep(&avctx->priv_data);\n\n    if (av_codec_is_encoder(avctx->codec))\n\n        av_freep(&avctx->extradata);\n\n    avctx->codec = NULL;\n\n    avctx->active_thread_type = 0;\n\n\n\n    ff_unlock_avcodec();\n\n    return 0;\n\n}\n", "idx": 11158}
{"project": "qemu", "commit_id": "e0e2d644096c79a71099b176d08f465f6803a8b1", "target": 1, "func": "static void virtio_device_free_virtqueues(VirtIODevice *vdev)\n\n{\n\n    int i;\n\n    if (!vdev->vq) {\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < VIRTIO_QUEUE_MAX; i++) {\n\n        VRingMemoryRegionCaches *caches;\n\n        if (vdev->vq[i].vring.num == 0) {\n\n            break;\n\n        }\n\n        caches = atomic_read(&vdev->vq[i].vring.caches);\n\n        atomic_set(&vdev->vq[i].vring.caches, NULL);\n\n        virtio_free_region_cache(caches);\n\n    }\n\n    g_free(vdev->vq);\n\n}\n", "idx": 11160}
{"project": "FFmpeg", "commit_id": "c2fa6bb0e8703a7a6aa10e11f9ab36094416d83f", "target": 1, "func": "static void mpeg_decode_picture_coding_extension(Mpeg1Context *s1)\n\n{\n\n    MpegEncContext *s = &s1->mpeg_enc_ctx;\n\n\n\n    s->full_pel[0]       = s->full_pel[1] = 0;\n\n    s->mpeg_f_code[0][0] = get_bits(&s->gb, 4);\n\n    s->mpeg_f_code[0][1] = get_bits(&s->gb, 4);\n\n    s->mpeg_f_code[1][0] = get_bits(&s->gb, 4);\n\n    s->mpeg_f_code[1][1] = get_bits(&s->gb, 4);\n\n    if (!s->pict_type && s1->mpeg_enc_ctx_allocated) {\n\n        av_log(s->avctx, AV_LOG_ERROR,\n\n               \"Missing picture start code, guessing missing values\\n\");\n\n        if (s->mpeg_f_code[1][0] == 15 && s->mpeg_f_code[1][1] == 15) {\n\n            if (s->mpeg_f_code[0][0] == 15 && s->mpeg_f_code[0][1] == 15)\n\n                s->pict_type = AV_PICTURE_TYPE_I;\n\n            else\n\n                s->pict_type = AV_PICTURE_TYPE_P;\n\n        } else\n\n            s->pict_type = AV_PICTURE_TYPE_B;\n\n        s->current_picture.f->pict_type = s->pict_type;\n\n        s->current_picture.f->key_frame = s->pict_type == AV_PICTURE_TYPE_I;\n\n    }\n\n    s->intra_dc_precision         = get_bits(&s->gb, 2);\n\n    s->picture_structure          = get_bits(&s->gb, 2);\n\n    s->top_field_first            = get_bits1(&s->gb);\n\n    s->frame_pred_frame_dct       = get_bits1(&s->gb);\n\n    s->concealment_motion_vectors = get_bits1(&s->gb);\n\n    s->q_scale_type               = get_bits1(&s->gb);\n\n    s->intra_vlc_format           = get_bits1(&s->gb);\n\n    s->alternate_scan             = get_bits1(&s->gb);\n\n    s->repeat_first_field         = get_bits1(&s->gb);\n\n    s->chroma_420_type            = get_bits1(&s->gb);\n\n    s->progressive_frame          = get_bits1(&s->gb);\n\n\n\n    if (s->progressive_sequence && !s->progressive_frame) {\n\n        s->progressive_frame = 1;\n\n        av_log(s->avctx, AV_LOG_ERROR,\n\n               \"interlaced frame in progressive sequence, ignoring\\n\");\n\n    }\n\n\n\n    if (s->picture_structure == 0 ||\n\n        (s->progressive_frame && s->picture_structure != PICT_FRAME)) {\n\n        av_log(s->avctx, AV_LOG_ERROR,\n\n               \"picture_structure %d invalid, ignoring\\n\",\n\n               s->picture_structure);\n\n        s->picture_structure = PICT_FRAME;\n\n    }\n\n\n\n    if (s->progressive_sequence && !s->frame_pred_frame_dct)\n\n        av_log(s->avctx, AV_LOG_WARNING, \"invalid frame_pred_frame_dct\\n\");\n\n\n\n    if (s->picture_structure == PICT_FRAME) {\n\n        s->first_field = 0;\n\n        s->v_edge_pos  = 16 * s->mb_height;\n\n    } else {\n\n        s->first_field ^= 1;\n\n        s->v_edge_pos   = 8 * s->mb_height;\n\n        memset(s->mbskip_table, 0, s->mb_stride * s->mb_height);\n\n    }\n\n\n\n    if (s->alternate_scan) {\n\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_alternate_vertical_scan);\n\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_alternate_vertical_scan);\n\n    } else {\n\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_zigzag_direct);\n\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_zigzag_direct);\n\n    }\n\n\n\n    /* composite display not parsed */\n\n    ff_dlog(s->avctx, \"intra_dc_precision=%d\\n\", s->intra_dc_precision);\n\n    ff_dlog(s->avctx, \"picture_structure=%d\\n\", s->picture_structure);\n\n    ff_dlog(s->avctx, \"top field first=%d\\n\", s->top_field_first);\n\n    ff_dlog(s->avctx, \"repeat first field=%d\\n\", s->repeat_first_field);\n\n    ff_dlog(s->avctx, \"conceal=%d\\n\", s->concealment_motion_vectors);\n\n    ff_dlog(s->avctx, \"intra_vlc_format=%d\\n\", s->intra_vlc_format);\n\n    ff_dlog(s->avctx, \"alternate_scan=%d\\n\", s->alternate_scan);\n\n    ff_dlog(s->avctx, \"frame_pred_frame_dct=%d\\n\", s->frame_pred_frame_dct);\n\n    ff_dlog(s->avctx, \"progressive_frame=%d\\n\", s->progressive_frame);\n\n}\n", "idx": 11194}
{"project": "qemu", "commit_id": "97a2ae34537882df34810d538ab1f51085499d2c", "target": 1, "func": "static int coroutine_fn raw_co_write_zeroes(\n\n    BlockDriverState *bs, int64_t sector_num,\n\n    int nb_sectors, BdrvRequestFlags flags)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n\n\n    if (!(flags & BDRV_REQ_MAY_UNMAP)) {\n\n        return -ENOTSUP;\n\n    }\n\n    if (!s->discard_zeroes) {\n\n        return -ENOTSUP;\n\n    }\n\n    return paio_submit_co(bs, s->fd, sector_num, NULL, nb_sectors,\n\n                          QEMU_AIO_DISCARD);\n\n}\n", "idx": 11254}
{"project": "qemu", "commit_id": "f7736b91c40a617e93505e32dcbd2cb56aad8a23", "target": 0, "func": "static int dma_buf_prepare(BMDMAState *bm, int is_write)\n\n{\n\n    IDEState *s = bmdma_active_if(bm);\n\n    struct {\n\n        uint32_t addr;\n\n        uint32_t size;\n\n    } prd;\n\n    int l, len;\n\n\n\n    qemu_sglist_init(&s->sg, s->nsector / (TARGET_PAGE_SIZE/512) + 1);\n\n    s->io_buffer_size = 0;\n\n    for(;;) {\n\n        if (bm->cur_prd_len == 0) {\n\n            /* end of table (with a fail safe of one page) */\n\n            if (bm->cur_prd_last ||\n\n                (bm->cur_addr - bm->addr) >= 4096)\n\n                return s->io_buffer_size != 0;\n\n            cpu_physical_memory_read(bm->cur_addr, (uint8_t *)&prd, 8);\n\n            bm->cur_addr += 8;\n\n            prd.addr = le32_to_cpu(prd.addr);\n\n            prd.size = le32_to_cpu(prd.size);\n\n            len = prd.size & 0xfffe;\n\n            if (len == 0)\n\n                len = 0x10000;\n\n            bm->cur_prd_len = len;\n\n            bm->cur_prd_addr = prd.addr;\n\n            bm->cur_prd_last = (prd.size & 0x80000000);\n\n        }\n\n        l = bm->cur_prd_len;\n\n        if (l > 0) {\n\n            qemu_sglist_add(&s->sg, bm->cur_prd_addr, l);\n\n            bm->cur_prd_addr += l;\n\n            bm->cur_prd_len -= l;\n\n            s->io_buffer_size += l;\n\n        }\n\n    }\n\n    return 1;\n\n}\n", "idx": 11263}
{"project": "qemu", "commit_id": "1294ca797c6bee39d4dbc3e92010873ce4047e0e", "target": 0, "func": "static int usb_host_claim_interfaces(USBHostDevice *s, int configuration)\n\n{\n\n    USBDevice *udev = USB_DEVICE(s);\n\n    struct libusb_config_descriptor *conf;\n\n    int rc, i;\n\n\n\n    for (i = 0; i < USB_MAX_INTERFACES; i++) {\n\n        udev->altsetting[i] = 0;\n\n    }\n\n    udev->ninterfaces   = 0;\n\n    udev->configuration = 0;\n\n\n\n    if (configuration == 0) {\n\n        /* address state - ignore */\n\n        return USB_RET_SUCCESS;\n\n    }\n\n\n\n    usb_host_detach_kernel(s);\n\n\n\n    rc = libusb_get_active_config_descriptor(s->dev, &conf);\n\n    if (rc != 0) {\n\n        return USB_RET_STALL;\n\n    }\n\n\n\n    for (i = 0; i < conf->bNumInterfaces; i++) {\n\n        trace_usb_host_claim_interface(s->bus_num, s->addr, configuration, i);\n\n        rc = libusb_claim_interface(s->dh, i);\n\n        usb_host_libusb_error(\"libusb_claim_interface\", rc);\n\n        if (rc != 0) {\n\n            return USB_RET_STALL;\n\n        }\n\n        s->ifs[i].claimed = true;\n\n    }\n\n\n\n    udev->ninterfaces   = conf->bNumInterfaces;\n\n    udev->configuration = configuration;\n\n\n\n    libusb_free_config_descriptor(conf);\n\n    return USB_RET_SUCCESS;\n\n}\n", "idx": 11264}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "static void term_completion(void)\n\n{\n\n    int len, i, j, max_width, nb_cols;\n\n    char *cmdline;\n\n\n\n    nb_completions = 0;\n\n    \n\n    cmdline = qemu_malloc(term_cmd_buf_index + 1);\n\n    if (!cmdline)\n\n        return;\n\n    memcpy(cmdline, term_cmd_buf, term_cmd_buf_index);\n\n    cmdline[term_cmd_buf_index] = '\\0';\n\n    find_completion(cmdline);\n\n    qemu_free(cmdline);\n\n\n\n    /* no completion found */\n\n    if (nb_completions <= 0)\n\n        return;\n\n    if (nb_completions == 1) {\n\n        len = strlen(completions[0]);\n\n        for(i = completion_index; i < len; i++) {\n\n            term_insert_char(completions[0][i]);\n\n        }\n\n        /* extra space for next argument. XXX: make it more generic */\n\n        if (len > 0 && completions[0][len - 1] != '/')\n\n            term_insert_char(' ');\n\n    } else {\n\n        term_printf(\"\\n\");\n\n        max_width = 0;\n\n        for(i = 0; i < nb_completions; i++) {\n\n            len = strlen(completions[i]);\n\n            if (len > max_width)\n\n                max_width = len;\n\n        }\n\n        max_width += 2;\n\n        if (max_width < 10)\n\n            max_width = 10;\n\n        else if (max_width > 80)\n\n            max_width = 80;\n\n        nb_cols = 80 / max_width;\n\n        j = 0;\n\n        for(i = 0; i < nb_completions; i++) {\n\n            term_printf(\"%-*s\", max_width, completions[i]);\n\n            if (++j == nb_cols || i == (nb_completions - 1)) {\n\n                term_printf(\"\\n\");\n\n                j = 0;\n\n            }\n\n        }\n\n        term_show_prompt2();\n\n    }\n\n}\n", "idx": 11270}
{"project": "FFmpeg", "commit_id": "295a7c0238e84b0ffa8f21ed938d45f51f54a4cd", "target": 1, "func": "static int decode_i2_frame(FourXContext *f, const uint8_t *buf, int length){\n\n    int x, y, x2, y2;\n\n    const int width= f->avctx->width;\n\n    const int height= f->avctx->height;\n\n    uint16_t *dst= (uint16_t*)f->current_picture.data[0];\n\n    const int stride= f->current_picture.linesize[0]>>1;\n\n\n\n    for(y=0; y<height; y+=16){\n\n        for(x=0; x<width; x+=16){\n\n            unsigned int color[4], bits;\n\n            memset(color, 0, sizeof(color));\n\n//warning following is purely guessed ...\n\n            color[0]= bytestream_get_le16(&buf);\n\n            color[1]= bytestream_get_le16(&buf);\n\n\n\n            if(color[0]&0x8000) av_log(NULL, AV_LOG_ERROR, \"unk bit 1\\n\");\n\n            if(color[1]&0x8000) av_log(NULL, AV_LOG_ERROR, \"unk bit 2\\n\");\n\n\n\n            color[2]= mix(color[0], color[1]);\n\n            color[3]= mix(color[1], color[0]);\n\n\n\n            bits= bytestream_get_le32(&buf);\n\n            for(y2=0; y2<16; y2++){\n\n                for(x2=0; x2<16; x2++){\n\n                    int index= 2*(x2>>2) + 8*(y2>>2);\n\n                    dst[y2*stride+x2]= color[(bits>>index)&3];\n\n                }\n\n            }\n\n            dst+=16;\n\n        }\n\n        dst += 16 * stride - x;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 11293}
{"project": "qemu", "commit_id": "7d99f4c1b5d12de7644a5bd8c3d46bff05c9ca7c", "target": 1, "func": "static int scsi_get_configuration(SCSIDiskState *s, uint8_t *outbuf)\n\n{\n\n    int current;\n\n\n\n    if (s->qdev.type != TYPE_ROM) {\n\n        return -1;\n\n    }\n\n    current = media_is_dvd(s) ? MMC_PROFILE_DVD_ROM : MMC_PROFILE_CD_ROM;\n\n    memset(outbuf, 0, 40);\n\n    stl_be_p(&outbuf[0], 36); /* Bytes after the data length field */\n\n    stw_be_p(&outbuf[6], current);\n\n    /* outbuf[8] - outbuf[19]: Feature 0 - Profile list */\n\n    outbuf[10] = 0x03; /* persistent, current */\n\n    outbuf[11] = 8; /* two profiles */\n\n    stw_be_p(&outbuf[12], MMC_PROFILE_DVD_ROM);\n\n    outbuf[14] = (current == MMC_PROFILE_DVD_ROM);\n\n    stw_be_p(&outbuf[16], MMC_PROFILE_CD_ROM);\n\n    outbuf[18] = (current == MMC_PROFILE_CD_ROM);\n\n    /* outbuf[20] - outbuf[31]: Feature 1 - Core feature */\n\n    stw_be_p(&outbuf[20], 1);\n\n    outbuf[22] = 0x08 | 0x03; /* version 2, persistent, current */\n\n    outbuf[23] = 8;\n\n    stl_be_p(&outbuf[24], 1); /* SCSI */\n\n    outbuf[28] = 1; /* DBE = 1, mandatory */\n\n    /* outbuf[32] - outbuf[39]: Feature 3 - Removable media feature */\n\n    stw_be_p(&outbuf[32], 3);\n\n    outbuf[34] = 0x08 | 0x03; /* version 2, persistent, current */\n\n    outbuf[35] = 4;\n\n    outbuf[36] = 0x39; /* tray, load=1, eject=1, unlocked at powerup, lock=1 */\n\n    /* TODO: Random readable, CD read, DVD read, drive serial number,\n\n       power management */\n\n    return 40;\n\n}\n", "idx": 11343}
{"project": "qemu", "commit_id": "27463101f15bee17d2f46642c48a7373bc6c595e", "target": 1, "func": "int qemu_eventfd(int *fds)\n\n{\n\n#if defined(SYS_eventfd)\n\n    int ret;\n\n\n\n    ret = syscall(SYS_eventfd, 0);\n\n    if (ret >= 0) {\n\n        fds[0] = fds[1] = ret;\n\n        return 0;\n\n    } else if (!(ret == -1 && errno == ENOSYS))\n\n        return ret;\n\n#endif\n\n\n\n    return pipe(fds);\n\n}\n", "idx": 11373}
{"project": "FFmpeg", "commit_id": "0422af7e49dbd3ac1d552edcd7972e266e0202a4", "target": 0, "func": "static void opt_input_file(const char *filename)\n\n{\n\n    AVFormatContext *ic;\n\n    AVFormatParameters params, *ap = &params;\n\n    AVInputFormat *file_iformat = NULL;\n\n    int err, i, ret, rfps, rfps_base;\n\n    int64_t timestamp;\n\n\n\n    if (last_asked_format) {\n\n        if (!(file_iformat = av_find_input_format(last_asked_format))) {\n\n            fprintf(stderr, \"Unknown input format: '%s'\\n\", last_asked_format);\n\n            ffmpeg_exit(1);\n\n        }\n\n        last_asked_format = NULL;\n\n    }\n\n\n\n    if (!strcmp(filename, \"-\"))\n\n        filename = \"pipe:\";\n\n\n\n    using_stdin |= !strncmp(filename, \"pipe:\", 5) ||\n\n                    !strcmp(filename, \"/dev/stdin\");\n\n\n\n    /* get default parameters from command line */\n\n    ic = avformat_alloc_context();\n\n    if (!ic) {\n\n        print_error(filename, AVERROR(ENOMEM));\n\n        ffmpeg_exit(1);\n\n    }\n\n\n\n    memset(ap, 0, sizeof(*ap));\n\n    ap->prealloced_context = 1;\n\n    ap->sample_rate = audio_sample_rate;\n\n    ap->channels = audio_channels;\n\n    ap->time_base.den = frame_rate.num;\n\n    ap->time_base.num = frame_rate.den;\n\n    ap->width = frame_width;\n\n    ap->height = frame_height;\n\n    ap->pix_fmt = frame_pix_fmt;\n\n   // ap->sample_fmt = audio_sample_fmt; //FIXME:not implemented in libavformat\n\n    ap->channel = video_channel;\n\n    ap->standard = video_standard;\n\n\n\n    set_context_opts(ic, avformat_opts, AV_OPT_FLAG_DECODING_PARAM, NULL);\n\n\n\n    ic->video_codec_id   =\n\n        find_codec_or_die(video_codec_name   , AVMEDIA_TYPE_VIDEO   , 0,\n\n                          avcodec_opts[AVMEDIA_TYPE_VIDEO   ]->strict_std_compliance);\n\n    ic->audio_codec_id   =\n\n        find_codec_or_die(audio_codec_name   , AVMEDIA_TYPE_AUDIO   , 0,\n\n                          avcodec_opts[AVMEDIA_TYPE_AUDIO   ]->strict_std_compliance);\n\n    ic->subtitle_codec_id=\n\n        find_codec_or_die(subtitle_codec_name, AVMEDIA_TYPE_SUBTITLE, 0,\n\n                          avcodec_opts[AVMEDIA_TYPE_SUBTITLE]->strict_std_compliance);\n\n    ic->flags |= AVFMT_FLAG_NONBLOCK;\n\n\n\n    if(pgmyuv_compatibility_hack)\n\n        ic->video_codec_id= CODEC_ID_PGMYUV;\n\n\n\n    /* open the input file with generic libav function */\n\n    err = av_open_input_file(&ic, filename, file_iformat, 0, ap);\n\n    if (err < 0) {\n\n        print_error(filename, err);\n\n        ffmpeg_exit(1);\n\n    }\n\n    if(opt_programid) {\n\n        int i, j;\n\n        int found=0;\n\n        for(i=0; i<ic->nb_streams; i++){\n\n            ic->streams[i]->discard= AVDISCARD_ALL;\n\n        }\n\n        for(i=0; i<ic->nb_programs; i++){\n\n            AVProgram *p= ic->programs[i];\n\n            if(p->id != opt_programid){\n\n                p->discard = AVDISCARD_ALL;\n\n            }else{\n\n                found=1;\n\n                for(j=0; j<p->nb_stream_indexes; j++){\n\n                    ic->streams[p->stream_index[j]]->discard= AVDISCARD_DEFAULT;\n\n                }\n\n            }\n\n        }\n\n        if(!found){\n\n            fprintf(stderr, \"Specified program id not found\\n\");\n\n            ffmpeg_exit(1);\n\n        }\n\n        opt_programid=0;\n\n    }\n\n\n\n    ic->loop_input = loop_input;\n\n\n\n    /* If not enough info to get the stream parameters, we decode the\n\n       first frames to get it. (used in mpeg case for example) */\n\n    ret = av_find_stream_info(ic);\n\n    if (ret < 0 && verbose >= 0) {\n\n        fprintf(stderr, \"%s: could not find codec parameters\\n\", filename);\n\n        av_close_input_file(ic);\n\n        ffmpeg_exit(1);\n\n    }\n\n\n\n    timestamp = start_time;\n\n    /* add the stream start time */\n\n    if (ic->start_time != AV_NOPTS_VALUE)\n\n        timestamp += ic->start_time;\n\n\n\n    /* if seeking requested, we execute it */\n\n    if (start_time != 0) {\n\n        ret = av_seek_frame(ic, -1, timestamp, AVSEEK_FLAG_BACKWARD);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"%s: could not seek to position %0.3f\\n\",\n\n                    filename, (double)timestamp / AV_TIME_BASE);\n\n        }\n\n        /* reset seek info */\n\n        start_time = 0;\n\n    }\n\n\n\n    /* update the current parameters so that they match the one of the input stream */\n\n    for(i=0;i<ic->nb_streams;i++) {\n\n        AVStream *st = ic->streams[i];\n\n        AVCodecContext *dec = st->codec;\n\n        avcodec_thread_init(dec, thread_count);\n\n        input_codecs = grow_array(input_codecs, sizeof(*input_codecs), &nb_input_codecs, nb_input_codecs + 1);\n\n        switch (dec->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            input_codecs[nb_input_codecs-1] = avcodec_find_decoder_by_name(audio_codec_name);\n\n            set_context_opts(dec, avcodec_opts[AVMEDIA_TYPE_AUDIO], AV_OPT_FLAG_AUDIO_PARAM | AV_OPT_FLAG_DECODING_PARAM, input_codecs[nb_input_codecs-1]);\n\n            //fprintf(stderr, \"\\nInput Audio channels: %d\", dec->channels);\n\n            channel_layout    = dec->channel_layout;\n\n            audio_channels    = dec->channels;\n\n            audio_sample_rate = dec->sample_rate;\n\n            audio_sample_fmt  = dec->sample_fmt;\n\n            if(audio_disable)\n\n                st->discard= AVDISCARD_ALL;\n\n            /* Note that av_find_stream_info can add more streams, and we\n\n             * currently have no chance of setting up lowres decoding\n\n             * early enough for them. */\n\n            if (dec->lowres)\n\n                audio_sample_rate >>= dec->lowres;\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            input_codecs[nb_input_codecs-1] = avcodec_find_decoder_by_name(video_codec_name);\n\n            set_context_opts(dec, avcodec_opts[AVMEDIA_TYPE_VIDEO], AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM, input_codecs[nb_input_codecs-1]);\n\n            frame_height = dec->height;\n\n            frame_width  = dec->width;\n\n            if(ic->streams[i]->sample_aspect_ratio.num)\n\n                frame_aspect_ratio=av_q2d(ic->streams[i]->sample_aspect_ratio);\n\n            else\n\n                frame_aspect_ratio=av_q2d(dec->sample_aspect_ratio);\n\n            frame_aspect_ratio *= (float) dec->width / dec->height;\n\n            frame_pix_fmt = dec->pix_fmt;\n\n            rfps      = ic->streams[i]->r_frame_rate.num;\n\n            rfps_base = ic->streams[i]->r_frame_rate.den;\n\n            if (dec->lowres) {\n\n                dec->flags |= CODEC_FLAG_EMU_EDGE;\n\n                frame_height >>= dec->lowres;\n\n                frame_width  >>= dec->lowres;\n\n            }\n\n            if(me_threshold)\n\n                dec->debug |= FF_DEBUG_MV;\n\n\n\n            if (dec->time_base.den != rfps*dec->ticks_per_frame || dec->time_base.num != rfps_base) {\n\n\n\n                if (verbose >= 0)\n\n                    fprintf(stderr,\"\\nSeems stream %d codec frame rate differs from container frame rate: %2.2f (%d/%d) -> %2.2f (%d/%d)\\n\",\n\n                            i, (float)dec->time_base.den / dec->time_base.num, dec->time_base.den, dec->time_base.num,\n\n\n\n                    (float)rfps / rfps_base, rfps, rfps_base);\n\n            }\n\n            /* update the current frame rate to match the stream frame rate */\n\n            frame_rate.num = rfps;\n\n            frame_rate.den = rfps_base;\n\n\n\n            if(video_disable)\n\n                st->discard= AVDISCARD_ALL;\n\n            else if(video_discard)\n\n                st->discard= video_discard;\n\n            break;\n\n        case AVMEDIA_TYPE_DATA:\n\n            break;\n\n        case AVMEDIA_TYPE_SUBTITLE:\n\n            input_codecs[nb_input_codecs-1] = avcodec_find_decoder_by_name(subtitle_codec_name);\n\n            if(subtitle_disable)\n\n                st->discard = AVDISCARD_ALL;\n\n            break;\n\n        case AVMEDIA_TYPE_ATTACHMENT:\n\n        case AVMEDIA_TYPE_UNKNOWN:\n\n            break;\n\n        default:\n\n            abort();\n\n        }\n\n    }\n\n\n\n    input_files[nb_input_files] = ic;\n\n    input_files_ts_offset[nb_input_files] = input_ts_offset - (copy_ts ? 0 : timestamp);\n\n    /* dump the file content */\n\n    if (verbose >= 0)\n\n        dump_format(ic, nb_input_files, filename, 0);\n\n\n\n    nb_input_files++;\n\n\n\n    video_channel = 0;\n\n\n\n    av_freep(&video_codec_name);\n\n    av_freep(&audio_codec_name);\n\n    av_freep(&subtitle_codec_name);\n\n}\n", "idx": 11388}
{"project": "qemu", "commit_id": "3718d8ab65f68de2acccbe6a315907805f54e3cc", "target": 0, "func": "void block_job_completed(BlockJob *job, int ret)\n\n{\n\n    BlockDriverState *bs = job->bs;\n\n\n\n    assert(bs->job == job);\n\n    job->cb(job->opaque, ret);\n\n    bs->job = NULL;\n\n    g_free(job);\n\n    bdrv_set_in_use(bs, 0);\n\n}\n", "idx": 11414}
{"project": "qemu", "commit_id": "07caea315a85ebfe90851f9c2e4ef3fdd24117b5", "target": 1, "func": "static void mpc8544ds_init(ram_addr_t ram_size,\n\n                         const char *boot_device,\n\n                         const char *kernel_filename,\n\n                         const char *kernel_cmdline,\n\n                         const char *initrd_filename,\n\n                         const char *cpu_model)\n\n{\n\n    PCIBus *pci_bus;\n\n    CPUState *env;\n\n    uint64_t elf_entry;\n\n    uint64_t elf_lowaddr;\n\n    target_phys_addr_t entry=0;\n\n    target_phys_addr_t loadaddr=UIMAGE_LOAD_BASE;\n\n    target_long kernel_size=0;\n\n    target_ulong dt_base=DTB_LOAD_BASE;\n\n    target_ulong initrd_base=INITRD_LOAD_BASE;\n\n    target_long initrd_size=0;\n\n    void *fdt;\n\n    int i=0;\n\n    unsigned int pci_irq_nrs[4] = {1, 2, 3, 4};\n\n    qemu_irq *irqs, *mpic, *pci_irqs;\n\n    SerialState * serial[2];\n\n\n\n    /* Setup CPU */\n\n    env = cpu_ppc_init(\"e500v2_v30\");\n\n    if (!env) {\n\n        fprintf(stderr, \"Unable to initialize CPU!\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* Fixup Memory size on a alignment boundary */\n\n    ram_size &= ~(RAM_SIZES_ALIGN - 1);\n\n\n\n    /* Register Memory */\n\n    cpu_register_physical_memory(0, ram_size, qemu_ram_alloc(ram_size));\n\n\n\n    /* MPIC */\n\n    irqs = qemu_mallocz(sizeof(qemu_irq) * OPENPIC_OUTPUT_NB);\n\n    irqs[OPENPIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPCE500_INPUT_INT];\n\n    irqs[OPENPIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPCE500_INPUT_CINT];\n\n    mpic = mpic_init(MPC8544_MPIC_REGS_BASE, 1, &irqs, NULL);\n\n\n\n    /* Serial */\n\n    if (serial_hds[0])\n\n        serial[0] = serial_mm_init(MPC8544_SERIAL0_REGS_BASE,\n\n                               0, mpic[12+26], 399193,\n\n                        serial_hds[0], 1);\n\n\n\n    if (serial_hds[1])\n\n        serial[0] = serial_mm_init(MPC8544_SERIAL1_REGS_BASE,\n\n                        0, mpic[12+26], 399193,\n\n                        serial_hds[0], 1);\n\n\n\n    /* PCI */\n\n    pci_irqs = qemu_malloc(sizeof(qemu_irq) * 4);\n\n    pci_irqs[0] = mpic[pci_irq_nrs[0]];\n\n    pci_irqs[1] = mpic[pci_irq_nrs[1]];\n\n    pci_irqs[2] = mpic[pci_irq_nrs[2]];\n\n    pci_irqs[3] = mpic[pci_irq_nrs[3]];\n\n    pci_bus = ppce500_pci_init(pci_irqs, MPC8544_PCI_REGS_BASE);\n\n    if (!pci_bus)\n\n        printf(\"couldn't create PCI controller!\\n\");\n\n\n\n    isa_mmio_init(MPC8544_PCI_IO, MPC8544_PCI_IOLEN);\n\n\n\n    if (pci_bus) {\n\n        /* Register network interfaces. */\n\n        for (i = 0; i < nb_nics; i++) {\n\n            pci_nic_init(&nd_table[i], \"virtio\", NULL);\n\n        }\n\n    }\n\n\n\n    /* Load kernel. */\n\n    if (kernel_filename) {\n\n        kernel_size = load_uimage(kernel_filename, &entry, &loadaddr, NULL);\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_elf(kernel_filename, 0, &elf_entry, &elf_lowaddr,\n\n                                   NULL, 1, ELF_MACHINE, 0);\n\n            entry = elf_entry;\n\n            loadaddr = elf_lowaddr;\n\n        }\n\n        /* XXX try again as binary */\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* Load initrd. */\n\n    if (initrd_filename) {\n\n        initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                          ram_size - initrd_base);\n\n\n\n        if (initrd_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                    initrd_filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* If we're loading a kernel directly, we must load the device tree too. */\n\n    if (kernel_filename) {\n\n        fdt = mpc8544_load_device_tree(dt_base, ram_size,\n\n                                      initrd_base, initrd_size, kernel_cmdline);\n\n        if (fdt == NULL) {\n\n            fprintf(stderr, \"couldn't load device tree\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        /* Set initial guest state. */\n\n        env->gpr[1] = (16<<20) - 8;\n\n        env->gpr[3] = dt_base;\n\n        env->nip = entry;\n\n        /* XXX we currently depend on KVM to create some initial TLB entries. */\n\n    }\n\n\n\n    if (kvm_enabled())\n\n        kvmppc_init();\n\n\n\n    return;\n\n}\n", "idx": 11517}
{"project": "qemu", "commit_id": "2436b61a6b386d712a1813b036921443bd1c5c39", "target": 0, "func": "void helper_sysexit(void)\n\n{\n\n    int cpl;\n\n\n\n    cpl = env->hflags & HF_CPL_MASK;\n\n    if (env->sysenter_cs == 0 || cpl != 0) {\n\n        raise_exception_err(EXCP0D_GPF, 0);\n\n    }\n\n    cpu_x86_set_cpl(env, 3);\n\n    cpu_x86_load_seg_cache(env, R_CS, ((env->sysenter_cs + 16) & 0xfffc) | 3,\n\n                           0, 0xffffffff,\n\n                           DESC_G_MASK | DESC_B_MASK | DESC_P_MASK |\n\n                           DESC_S_MASK | (3 << DESC_DPL_SHIFT) |\n\n                           DESC_CS_MASK | DESC_R_MASK | DESC_A_MASK);\n\n    cpu_x86_load_seg_cache(env, R_SS, ((env->sysenter_cs + 24) & 0xfffc) | 3,\n\n                           0, 0xffffffff,\n\n                           DESC_G_MASK | DESC_B_MASK | DESC_P_MASK |\n\n                           DESC_S_MASK | (3 << DESC_DPL_SHIFT) |\n\n                           DESC_W_MASK | DESC_A_MASK);\n\n    ESP = ECX;\n\n    EIP = EDX;\n\n#ifdef USE_KQEMU\n\n    if (kqemu_is_ok(env)) {\n\n        env->exception_index = -1;\n\n        cpu_loop_exit();\n\n    }\n\n#endif\n\n}\n", "idx": 11595}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_nabs(DisasContext *ctx)\n\n{\n\n    int l1 = gen_new_label();\n\n    int l2 = gen_new_label();\n\n    tcg_gen_brcondi_tl(TCG_COND_GT, cpu_gpr[rA(ctx->opcode)], 0, l1);\n\n    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);\n\n    tcg_gen_br(l2);\n\n    gen_set_label(l1);\n\n    tcg_gen_neg_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);\n\n    gen_set_label(l2);\n\n    if (unlikely(Rc(ctx->opcode) != 0))\n\n        gen_set_Rc0(ctx, cpu_gpr[rD(ctx->opcode)]);\n\n}\n", "idx": 11616}
{"project": "qemu", "commit_id": "d66b969b0d9c8eefdcbff4b48535b0fe1501d139", "target": 0, "func": "static void vtd_iotlb_page_invalidate(IntelIOMMUState *s, uint16_t domain_id,\n\n                                      hwaddr addr, uint8_t am)\n\n{\n\n    VTDIOTLBPageInvInfo info;\n\n\n\n    assert(am <= VTD_MAMV);\n\n    info.domain_id = domain_id;\n\n    info.gfn = addr >> VTD_PAGE_SHIFT_4K;\n\n    info.mask = ~((1 << am) - 1);\n\n    g_hash_table_foreach_remove(s->iotlb, vtd_hash_remove_by_page, &info);\n\n}\n", "idx": 11628}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int targa_encode_init(AVCodecContext *avctx)\n\n{\n\n    avctx->coded_frame = av_frame_alloc();\n\n    if (!avctx->coded_frame)\n\n        return AVERROR(ENOMEM);\n\n\n\n    avctx->coded_frame->key_frame = 1;\n\n    avctx->coded_frame->pict_type = AV_PICTURE_TYPE_I;\n\n\n\n    return 0;\n\n}\n", "idx": 11688}
{"project": "qemu", "commit_id": "f65ed4c1529f29a7d62d6733eaa50bed24a4b2ed", "target": 1, "func": "void vga_init(VGAState *s)\n\n{\n\n    int vga_io_memory;\n\n\n\n    register_savevm(\"vga\", 0, 2, vga_save, vga_load, s);\n\n\n\n    register_ioport_write(0x3c0, 16, 1, vga_ioport_write, s);\n\n\n\n    register_ioport_write(0x3b4, 2, 1, vga_ioport_write, s);\n\n    register_ioport_write(0x3d4, 2, 1, vga_ioport_write, s);\n\n    register_ioport_write(0x3ba, 1, 1, vga_ioport_write, s);\n\n    register_ioport_write(0x3da, 1, 1, vga_ioport_write, s);\n\n\n\n    register_ioport_read(0x3c0, 16, 1, vga_ioport_read, s);\n\n\n\n    register_ioport_read(0x3b4, 2, 1, vga_ioport_read, s);\n\n    register_ioport_read(0x3d4, 2, 1, vga_ioport_read, s);\n\n    register_ioport_read(0x3ba, 1, 1, vga_ioport_read, s);\n\n    register_ioport_read(0x3da, 1, 1, vga_ioport_read, s);\n\n    s->bank_offset = 0;\n\n\n\n#ifdef CONFIG_BOCHS_VBE\n\n    s->vbe_regs[VBE_DISPI_INDEX_ID] = VBE_DISPI_ID0;\n\n    s->vbe_bank_mask = ((s->vram_size >> 16) - 1);\n\n#if defined (TARGET_I386)\n\n    register_ioport_read(0x1ce, 1, 2, vbe_ioport_read_index, s);\n\n    register_ioport_read(0x1cf, 1, 2, vbe_ioport_read_data, s);\n\n\n\n    register_ioport_write(0x1ce, 1, 2, vbe_ioport_write_index, s);\n\n    register_ioport_write(0x1cf, 1, 2, vbe_ioport_write_data, s);\n\n\n\n    /* old Bochs IO ports */\n\n    register_ioport_read(0xff80, 1, 2, vbe_ioport_read_index, s);\n\n    register_ioport_read(0xff81, 1, 2, vbe_ioport_read_data, s);\n\n\n\n    register_ioport_write(0xff80, 1, 2, vbe_ioport_write_index, s);\n\n    register_ioport_write(0xff81, 1, 2, vbe_ioport_write_data, s);\n\n#else\n\n    register_ioport_read(0x1ce, 1, 2, vbe_ioport_read_index, s);\n\n    register_ioport_read(0x1d0, 1, 2, vbe_ioport_read_data, s);\n\n\n\n    register_ioport_write(0x1ce, 1, 2, vbe_ioport_write_index, s);\n\n    register_ioport_write(0x1d0, 1, 2, vbe_ioport_write_data, s);\n\n#endif\n\n#endif /* CONFIG_BOCHS_VBE */\n\n\n\n    vga_io_memory = cpu_register_io_memory(0, vga_mem_read, vga_mem_write, s);\n\n    cpu_register_physical_memory(isa_mem_base + 0x000a0000, 0x20000,\n\n                                 vga_io_memory);\n\n\n}", "idx": 11735}
{"project": "FFmpeg", "commit_id": "e48ded8551172b58a78f30303a81dfce125344e0", "target": 0, "func": "static av_cold int asink_init(AVFilterContext *ctx, void *opaque)\n\n{\n\n    BufferSinkContext *buf = ctx->priv;\n\n    AVABufferSinkParams *params = opaque;\n\n\n\n    if (params && params->sample_fmts) {\n\n        buf->sample_fmts = ff_copy_int_list(params->sample_fmts);\n\n        if (!buf->sample_fmts)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n    if (params && params->sample_rates) {\n\n        buf->sample_rates = ff_copy_int_list(params->sample_rates);\n\n        if (!buf->sample_rates)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n    if (params && (params->channel_layouts || params->channel_counts)) {\n\n        if (params->all_channel_counts) {\n\n            av_log(ctx, AV_LOG_ERROR,\n\n                   \"Conflicting all_channel_counts and list in parameters\\n\");\n\n            return AVERROR(EINVAL);\n\n        }\n\n        buf->channel_layouts = concat_channels_lists(params->channel_layouts,\n\n                                                     params->channel_counts);\n\n        if (!buf->channel_layouts)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n    if (params)\n\n        buf->all_channel_counts = params->all_channel_counts;\n\n    return common_init(ctx);\n\n}\n", "idx": 11895}
{"project": "qemu", "commit_id": "03f4995781a64e106e6f73864a1e9c4163dac53b", "target": 0, "func": "static MemoryRegionSection *phys_page_find(PhysPageEntry lp, hwaddr index,\n\n                                           Node *nodes, MemoryRegionSection *sections)\n\n{\n\n    PhysPageEntry *p;\n\n    int i;\n\n\n\n    for (i = P_L2_LEVELS - 1; i >= 0 && !lp.is_leaf; i--) {\n\n        if (lp.ptr == PHYS_MAP_NODE_NIL) {\n\n            return &sections[PHYS_SECTION_UNASSIGNED];\n\n        }\n\n        p = nodes[lp.ptr];\n\n        lp = p[(index >> (i * L2_BITS)) & (L2_SIZE - 1)];\n\n    }\n\n    return &sections[lp.ptr];\n\n}\n", "idx": 11945}
{"project": "FFmpeg", "commit_id": "8f3a9603538b8633fb873fcee7ffcec72e849c42", "target": 0, "func": "int configure_filtergraph(FilterGraph *fg)\n\n{\n\n    AVFilterInOut *inputs, *outputs, *cur;\n\n    int ret, i, simple = !fg->graph_desc;\n\n    const char *graph_desc = simple ? fg->outputs[0]->ost->avfilter :\n\n                                      fg->graph_desc;\n\n\n\n    avfilter_graph_free(&fg->graph);\n\n    if (!(fg->graph = avfilter_graph_alloc()))\n\n        return AVERROR(ENOMEM);\n\n\n\n    if (simple) {\n\n        OutputStream *ost = fg->outputs[0]->ost;\n\n        char args[512];\n\n        AVDictionaryEntry *e = NULL;\n\n\n\n        args[0] = 0;\n\n        while ((e = av_dict_get(ost->sws_dict, \"\", e,\n\n                                AV_DICT_IGNORE_SUFFIX))) {\n\n            av_strlcatf(args, sizeof(args), \"%s=%s:\", e->key, e->value);\n\n        }\n\n        if (strlen(args))\n\n            args[strlen(args)-1] = 0;\n\n        fg->graph->scale_sws_opts = av_strdup(args);\n\n\n\n        args[0] = 0;\n\n        while ((e = av_dict_get(ost->swr_opts, \"\", e,\n\n                                AV_DICT_IGNORE_SUFFIX))) {\n\n            av_strlcatf(args, sizeof(args), \"%s=%s:\", e->key, e->value);\n\n        }\n\n        if (strlen(args))\n\n            args[strlen(args)-1] = 0;\n\n        av_opt_set(fg->graph, \"aresample_swr_opts\", args, 0);\n\n\n\n        args[0] = '\\0';\n\n        while ((e = av_dict_get(fg->outputs[0]->ost->resample_opts, \"\", e,\n\n                                AV_DICT_IGNORE_SUFFIX))) {\n\n            av_strlcatf(args, sizeof(args), \"%s=%s:\", e->key, e->value);\n\n        }\n\n        if (strlen(args))\n\n            args[strlen(args) - 1] = '\\0';\n\n        fg->graph->resample_lavr_opts = av_strdup(args);\n\n\n\n        e = av_dict_get(ost->encoder_opts, \"threads\", NULL, 0);\n\n        if (e)\n\n            av_opt_set(fg->graph, \"threads\", e->value, 0);\n\n    }\n\n\n\n    if ((ret = avfilter_graph_parse2(fg->graph, graph_desc, &inputs, &outputs)) < 0)\n\n        return ret;\n\n\n\n    if (simple && (!inputs || inputs->next || !outputs || outputs->next)) {\n\n        const char *num_inputs;\n\n        const char *num_outputs;\n\n        if (!outputs) {\n\n            num_outputs = \"0\";\n\n        } else if (outputs->next) {\n\n            num_outputs = \">1\";\n\n        } else {\n\n            num_outputs = \"1\";\n\n        }\n\n        if (!inputs) {\n\n            num_inputs = \"0\";\n\n        } else if (inputs->next) {\n\n            num_inputs = \">1\";\n\n        } else {\n\n            num_inputs = \"1\";\n\n        }\n\n        av_log(NULL, AV_LOG_ERROR, \"Simple filtergraph '%s' was expected \"\n\n               \"to have exactly 1 input and 1 output.\"\n\n               \" However, it had %s input(s) and %s output(s).\"\n\n               \" Please adjust, or use a complex filtergraph (-filter_complex) instead.\\n\",\n\n               graph_desc, num_inputs, num_outputs);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    for (cur = inputs, i = 0; cur; cur = cur->next, i++)\n\n        if ((ret = configure_input_filter(fg, fg->inputs[i], cur)) < 0) {\n\n            avfilter_inout_free(&inputs);\n\n            avfilter_inout_free(&outputs);\n\n            return ret;\n\n        }\n\n    avfilter_inout_free(&inputs);\n\n\n\n    for (cur = outputs, i = 0; cur; cur = cur->next, i++)\n\n        configure_output_filter(fg, fg->outputs[i], cur);\n\n    avfilter_inout_free(&outputs);\n\n\n\n    if ((ret = avfilter_graph_config(fg->graph, NULL)) < 0)\n\n        return ret;\n\n\n\n    fg->reconfiguration = 1;\n\n\n\n    for (i = 0; i < fg->nb_outputs; i++) {\n\n        OutputStream *ost = fg->outputs[i]->ost;\n\n        if (!ost->enc) {\n\n            /* identical to the same check in ffmpeg.c, needed because\n\n               complex filter graphs are initialized earlier */\n\n            av_log(NULL, AV_LOG_ERROR, \"Encoder (codec %s) not found for output stream #%d:%d\\n\",\n\n                     avcodec_get_name(ost->st->codec->codec_id), ost->file_index, ost->index);\n\n            return AVERROR(EINVAL);\n\n        }\n\n        if (ost &&\n\n            ost->enc->type == AVMEDIA_TYPE_AUDIO &&\n\n            !(ost->enc->capabilities & AV_CODEC_CAP_VARIABLE_FRAME_SIZE))\n\n            av_buffersink_set_frame_size(ost->filter->filter,\n\n                                         ost->enc_ctx->frame_size);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 12006}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void lance_mem_write(void *opaque, target_phys_addr_t addr,\n\n                            uint64_t val, unsigned size)\n\n{\n\n    SysBusPCNetState *d = opaque;\n\n\n\n    trace_lance_mem_writew(addr, val & 0xffff);\n\n    pcnet_ioport_writew(&d->state, addr, val & 0xffff);\n\n}\n", "idx": 12053}
{"project": "FFmpeg", "commit_id": "8a0d446ad618ff89e2e212beb7e6ebee125a85a4", "target": 1, "func": "static int siff_read_packet(AVFormatContext *s, AVPacket *pkt)\n\n{\n\n    SIFFContext *c = s->priv_data;\n\n    int size;\n\n\n\n    if (c->has_video){\n\n        if (c->cur_frame >= c->frames)\n\n            return AVERROR_EOF;\n\n        if (c->curstrm == -1){\n\n            c->pktsize = avio_rl32(s->pb) - 4;\n\n            c->flags = avio_rl16(s->pb);\n\n            c->gmcsize = (c->flags & VB_HAS_GMC) ? 4 : 0;\n\n            if (c->gmcsize)\n\n                avio_read(s->pb, c->gmc, c->gmcsize);\n\n            c->sndsize = (c->flags & VB_HAS_AUDIO) ? avio_rl32(s->pb): 0;\n\n            c->curstrm = !!(c->flags & VB_HAS_AUDIO);\n\n        }\n\n\n\n        if (!c->curstrm){\n\n            size = c->pktsize - c->sndsize - c->gmcsize - 2;\n\n            size = ffio_limit(s->pb, size);\n\n            if(size < 0 || c->pktsize < c->sndsize)\n\n                return AVERROR_INVALIDDATA;\n\n            if (av_new_packet(pkt, size + c->gmcsize + 2) < 0)\n\n                return AVERROR(ENOMEM);\n\n            AV_WL16(pkt->data, c->flags);\n\n            if (c->gmcsize)\n\n                memcpy(pkt->data + 2, c->gmc, c->gmcsize);\n\n            avio_read(s->pb, pkt->data + 2 + c->gmcsize, size);\n\n            pkt->stream_index = 0;\n\n            c->curstrm = -1;\n\n        }else{\n\n            if ((size = av_get_packet(s->pb, pkt, c->sndsize - 4)) < 0)\n\n                return AVERROR(EIO);\n\n            pkt->stream_index = 1;\n\n            pkt->duration     = size;\n\n            c->curstrm = 0;\n\n        }\n\n        if(!c->cur_frame || c->curstrm)\n\n            pkt->flags |= AV_PKT_FLAG_KEY;\n\n        if (c->curstrm == -1)\n\n            c->cur_frame++;\n\n    }else{\n\n        size = av_get_packet(s->pb, pkt, c->block_align);\n\n        if(!size)\n\n            return AVERROR_EOF;\n\n        if(size < 0)\n\n            return AVERROR(EIO);\n\n        pkt->duration = size;\n\n    }\n\n    return pkt->size;\n\n}\n", "idx": 12068}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "void helper_fcmpo (uint64_t arg1, uint64_t arg2, uint32_t crfD)\n\n{\n\n    CPU_DoubleU farg1, farg2;\n\n    uint32_t ret = 0;\n\n    farg1.ll = arg1;\n\n    farg2.ll = arg2;\n\n\n\n    if (unlikely(float64_is_nan(farg1.d) ||\n\n                 float64_is_nan(farg2.d))) {\n\n        ret = 0x01UL;\n\n    } else if (float64_lt(farg1.d, farg2.d, &env->fp_status)) {\n\n        ret = 0x08UL;\n\n    } else if (!float64_le(farg1.d, farg2.d, &env->fp_status)) {\n\n        ret = 0x04UL;\n\n    } else {\n\n        ret = 0x02UL;\n\n    }\n\n\n\n    env->fpscr &= ~(0x0F << FPSCR_FPRF);\n\n    env->fpscr |= ret << FPSCR_FPRF;\n\n    env->crf[crfD] = ret;\n\n    if (unlikely (ret == 0x01UL)) {\n\n        if (float64_is_signaling_nan(farg1.d) ||\n\n            float64_is_signaling_nan(farg2.d)) {\n\n            /* sNaN comparison */\n\n            fload_invalid_op_excp(POWERPC_EXCP_FP_VXSNAN |\n\n                                  POWERPC_EXCP_FP_VXVC);\n\n        } else {\n\n            /* qNaN comparison */\n\n            fload_invalid_op_excp(POWERPC_EXCP_FP_VXVC);\n\n        }\n\n    }\n\n}\n", "idx": 12121}
{"project": "qemu", "commit_id": "8b0ee8c576a6f3e107c80f70f6dacb2964feb4a7", "target": 0, "func": "static inline abi_long host_to_target_stat64(void *cpu_env,\n\n                                             abi_ulong target_addr,\n\n                                             struct stat *host_st)\n\n{\n\n#ifdef TARGET_ARM\n\n    if (((CPUARMState *)cpu_env)->eabi) {\n\n        struct target_eabi_stat64 *target_st;\n\n\n\n        if (!lock_user_struct(VERIFY_WRITE, target_st, target_addr, 0))\n\n            return -TARGET_EFAULT;\n\n        memset(target_st, 0, sizeof(struct target_eabi_stat64));\n\n        __put_user(host_st->st_dev, &target_st->st_dev);\n\n        __put_user(host_st->st_ino, &target_st->st_ino);\n\n#ifdef TARGET_STAT64_HAS_BROKEN_ST_INO\n\n        __put_user(host_st->st_ino, &target_st->__st_ino);\n\n#endif\n\n        __put_user(host_st->st_mode, &target_st->st_mode);\n\n        __put_user(host_st->st_nlink, &target_st->st_nlink);\n\n        __put_user(host_st->st_uid, &target_st->st_uid);\n\n        __put_user(host_st->st_gid, &target_st->st_gid);\n\n        __put_user(host_st->st_rdev, &target_st->st_rdev);\n\n        __put_user(host_st->st_size, &target_st->st_size);\n\n        __put_user(host_st->st_blksize, &target_st->st_blksize);\n\n        __put_user(host_st->st_blocks, &target_st->st_blocks);\n\n        __put_user(host_st->st_atime, &target_st->target_st_atime);\n\n        __put_user(host_st->st_mtime, &target_st->target_st_mtime);\n\n        __put_user(host_st->st_ctime, &target_st->target_st_ctime);\n\n        unlock_user_struct(target_st, target_addr, 1);\n\n    } else\n\n#endif\n\n    {\n\n#if TARGET_LONG_BITS == 64\n\n        struct target_stat *target_st;\n\n#else\n\n        struct target_stat64 *target_st;\n\n#endif\n\n\n\n        if (!lock_user_struct(VERIFY_WRITE, target_st, target_addr, 0))\n\n            return -TARGET_EFAULT;\n\n        memset(target_st, 0, sizeof(*target_st));\n\n        __put_user(host_st->st_dev, &target_st->st_dev);\n\n        __put_user(host_st->st_ino, &target_st->st_ino);\n\n#ifdef TARGET_STAT64_HAS_BROKEN_ST_INO\n\n        __put_user(host_st->st_ino, &target_st->__st_ino);\n\n#endif\n\n        __put_user(host_st->st_mode, &target_st->st_mode);\n\n        __put_user(host_st->st_nlink, &target_st->st_nlink);\n\n        __put_user(host_st->st_uid, &target_st->st_uid);\n\n        __put_user(host_st->st_gid, &target_st->st_gid);\n\n        __put_user(host_st->st_rdev, &target_st->st_rdev);\n\n        /* XXX: better use of kernel struct */\n\n        __put_user(host_st->st_size, &target_st->st_size);\n\n        __put_user(host_st->st_blksize, &target_st->st_blksize);\n\n        __put_user(host_st->st_blocks, &target_st->st_blocks);\n\n        __put_user(host_st->st_atime, &target_st->target_st_atime);\n\n        __put_user(host_st->st_mtime, &target_st->target_st_mtime);\n\n        __put_user(host_st->st_ctime, &target_st->target_st_ctime);\n\n        unlock_user_struct(target_st, target_addr, 1);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 12148}
{"project": "qemu", "commit_id": "56c119e52ca229869912b22a5bec283487b0cf9b", "target": 1, "func": "void xen_map_cache_init(void)\n\n{\n\n    unsigned long size;\n\n    struct rlimit rlimit_as;\n\n\n\n    mapcache = g_malloc0(sizeof (MapCache));\n\n\n\n    QTAILQ_INIT(&mapcache->locked_entries);\n\n    mapcache->last_address_index = -1;\n\n\n\n    getrlimit(RLIMIT_AS, &rlimit_as);\n\n    if (rlimit_as.rlim_max < MCACHE_MAX_SIZE) {\n\n        rlimit_as.rlim_cur = rlimit_as.rlim_max;\n\n    } else {\n\n        rlimit_as.rlim_cur = MCACHE_MAX_SIZE;\n\n    }\n\n\n\n    setrlimit(RLIMIT_AS, &rlimit_as);\n\n    mapcache->max_mcache_size = rlimit_as.rlim_cur;\n\n\n\n    mapcache->nr_buckets =\n\n        (((mapcache->max_mcache_size >> XC_PAGE_SHIFT) +\n\n          (1UL << (MCACHE_BUCKET_SHIFT - XC_PAGE_SHIFT)) - 1) >>\n\n         (MCACHE_BUCKET_SHIFT - XC_PAGE_SHIFT));\n\n\n\n    size = mapcache->nr_buckets * sizeof (MapCacheEntry);\n\n    size = (size + XC_PAGE_SIZE - 1) & ~(XC_PAGE_SIZE - 1);\n\n    DPRINTF(\"%s, nr_buckets = %lx size %lu\\n\", __func__,\n\n            mapcache->nr_buckets, size);\n\n    mapcache->entry = g_malloc0(size);\n\n}\n", "idx": 12194}
{"project": "FFmpeg", "commit_id": "f5cf0ea93a55f43b553aa7d6698936e48c6a94df", "target": 1, "func": "static int asf_parse_packet(AVFormatContext *s, AVIOContext *pb, AVPacket *pkt)\n\n{\n\n    ASFContext *asf   = s->priv_data;\n\n    ASFStream *asf_st = 0;\n\n    for (;;) {\n\n        int ret;\n\n        if (url_feof(pb))\n\n            return AVERROR_EOF;\n\n\n\n        if (asf->packet_size_left < FRAME_HEADER_SIZE) {\n\n            int ret = asf->packet_size_left + asf->packet_padsize;\n\n\n\n            assert(ret >= 0);\n\n            /* fail safe */\n\n            avio_skip(pb, ret);\n\n\n\n            asf->packet_pos = avio_tell(pb);\n\n            if (asf->data_object_size != (uint64_t)-1 &&\n\n                (asf->packet_pos - asf->data_object_offset >= asf->data_object_size))\n\n                return AVERROR_EOF;  /* Do not exceed the size of the data object */\n\n            return 1;\n\n        }\n\n        if (asf->packet_time_start == 0) {\n\n            if (asf_read_frame_header(s, pb) < 0) {\n\n                asf->packet_time_start = asf->packet_segments = 0;\n\n                continue;\n\n            }\n\n            if (asf->stream_index < 0 ||\n\n                s->streams[asf->stream_index]->discard >= AVDISCARD_ALL ||\n\n                (!asf->packet_key_frame &&\n\n                 (s->streams[asf->stream_index]->discard >= AVDISCARD_NONKEY || asf->streams[s->streams[asf->stream_index]->id].skip_to_key))) {\n\n                asf->packet_time_start = 0;\n\n                /* unhandled packet (should not happen) */\n\n                avio_skip(pb, asf->packet_frag_size);\n\n                asf->packet_size_left -= asf->packet_frag_size;\n\n                if (asf->stream_index < 0)\n\n                    av_log(s, AV_LOG_ERROR, \"ff asf skip %d (unknown stream)\\n\",\n\n                           asf->packet_frag_size);\n\n                continue;\n\n            }\n\n            asf->asf_st = &asf->streams[s->streams[asf->stream_index]->id];\n\n            asf->asf_st->skip_to_key = 0;\n\n        }\n\n        asf_st = asf->asf_st;\n\n        av_assert0(asf_st);\n\n\n\n        if (asf->packet_replic_size == 1) {\n\n            // frag_offset is here used as the beginning timestamp\n\n            asf->packet_frag_timestamp = asf->packet_time_start;\n\n            asf->packet_time_start    += asf->packet_time_delta;\n\n            asf_st->packet_obj_size    = asf->packet_frag_size = avio_r8(pb);\n\n            asf->packet_size_left--;\n\n            asf->packet_multi_size--;\n\n            if (asf->packet_multi_size < asf_st->packet_obj_size) {\n\n                asf->packet_time_start = 0;\n\n                avio_skip(pb, asf->packet_multi_size);\n\n                asf->packet_size_left -= asf->packet_multi_size;\n\n                continue;\n\n            }\n\n            asf->packet_multi_size -= asf_st->packet_obj_size;\n\n        }\n\n\n\n        if (asf_st->pkt.size != asf_st->packet_obj_size ||\n\n            // FIXME is this condition sufficient?\n\n            asf_st->frag_offset + asf->packet_frag_size > asf_st->pkt.size) {\n\n            if (asf_st->pkt.data) {\n\n                av_log(s, AV_LOG_INFO,\n\n                       \"freeing incomplete packet size %d, new %d\\n\",\n\n                       asf_st->pkt.size, asf_st->packet_obj_size);\n\n                asf_st->frag_offset = 0;\n\n                av_free_packet(&asf_st->pkt);\n\n            }\n\n            /* new packet */\n\n            av_new_packet(&asf_st->pkt, asf_st->packet_obj_size);\n\n            asf_st->seq              = asf->packet_seq;\n\n            asf_st->pkt.dts          = asf->packet_frag_timestamp - asf->hdr.preroll;\n\n            asf_st->pkt.stream_index = asf->stream_index;\n\n            asf_st->pkt.pos          = asf_st->packet_pos = asf->packet_pos;\n\n\n\n\n            if (asf_st->pkt.data && asf_st->palette_changed) {\n\n                uint8_t *pal;\n\n                pal = av_packet_new_side_data(&asf_st->pkt, AV_PKT_DATA_PALETTE,\n\n                                              AVPALETTE_SIZE);\n\n                if (!pal) {\n\n                    av_log(s, AV_LOG_ERROR, \"Cannot append palette to packet\\n\");\n\n                } else {\n\n                    memcpy(pal, asf_st->palette, AVPALETTE_SIZE);\n\n                    asf_st->palette_changed = 0;\n\n                }\n\n            }\n\n            av_dlog(asf, \"new packet: stream:%d key:%d packet_key:%d audio:%d size:%d\\n\",\n\n                    asf->stream_index, asf->packet_key_frame,\n\n                    asf_st->pkt.flags & AV_PKT_FLAG_KEY,\n\n                    s->streams[asf->stream_index]->codec->codec_type == AVMEDIA_TYPE_AUDIO,\n\n                    asf_st->packet_obj_size);\n\n            if (s->streams[asf->stream_index]->codec->codec_type == AVMEDIA_TYPE_AUDIO)\n\n                asf->packet_key_frame = 1;\n\n            if (asf->packet_key_frame)\n\n                asf_st->pkt.flags |= AV_PKT_FLAG_KEY;\n\n        }\n\n\n\n        /* read data */\n\n        av_dlog(asf, \"READ PACKET s:%d  os:%d  o:%d,%d  l:%d   DATA:%p\\n\",\n\n                s->packet_size, asf_st->pkt.size, asf->packet_frag_offset,\n\n                asf_st->frag_offset, asf->packet_frag_size, asf_st->pkt.data);\n\n        asf->packet_size_left -= asf->packet_frag_size;\n\n        if (asf->packet_size_left < 0)\n\n            continue;\n\n\n\n        if (asf->packet_frag_offset >= asf_st->pkt.size ||\n\n            asf->packet_frag_size > asf_st->pkt.size - asf->packet_frag_offset) {\n\n            av_log(s, AV_LOG_ERROR,\n\n                   \"packet fragment position invalid %u,%u not in %u\\n\",\n\n                   asf->packet_frag_offset, asf->packet_frag_size,\n\n                   asf_st->pkt.size);\n\n            continue;\n\n        }\n\n\n\n        if (asf->packet_frag_offset != asf_st->frag_offset && !asf_st->pkt_clean) {\n\n            memset(asf_st->pkt.data + asf_st->frag_offset, 0, asf_st->pkt.size - asf_st->frag_offset);\n\n            asf_st->pkt_clean = 1;\n\n        }\n\n\n\n        ret = avio_read(pb, asf_st->pkt.data + asf->packet_frag_offset,\n\n                        asf->packet_frag_size);\n\n        if (ret != asf->packet_frag_size) {\n\n            if (ret < 0 || asf->packet_frag_offset + ret == 0)\n\n                return ret < 0 ? ret : AVERROR_EOF;\n\n\n\n            if (asf_st->ds_span > 1) {\n\n                // scrambling, we can either drop it completely or fill the remainder\n\n                // TODO: should we fill the whole packet instead of just the current\n\n                // fragment?\n\n                memset(asf_st->pkt.data + asf->packet_frag_offset + ret, 0,\n\n                       asf->packet_frag_size - ret);\n\n                ret = asf->packet_frag_size;\n\n            } else {\n\n                // no scrambling, so we can return partial packets\n\n                av_shrink_packet(&asf_st->pkt, asf->packet_frag_offset + ret);\n\n            }\n\n        }\n\n        if (s->key && s->keylen == 20)\n\n            ff_asfcrypt_dec(s->key, asf_st->pkt.data + asf->packet_frag_offset,\n\n                            ret);\n\n        asf_st->frag_offset += ret;\n\n        /* test if whole packet is read */\n\n        if (asf_st->frag_offset == asf_st->pkt.size) {\n\n            // workaround for macroshit radio DVR-MS files\n\n            if (s->streams[asf->stream_index]->codec->codec_id == AV_CODEC_ID_MPEG2VIDEO &&\n\n                asf_st->pkt.size > 100) {\n\n                int i;\n\n                for (i = 0; i < asf_st->pkt.size && !asf_st->pkt.data[i]; i++)\n\n                    ;\n\n                if (i == asf_st->pkt.size) {\n\n                    av_log(s, AV_LOG_DEBUG, \"discarding ms fart\\n\");\n\n                    asf_st->frag_offset = 0;\n\n                    av_free_packet(&asf_st->pkt);\n\n                    continue;\n\n                }\n\n            }\n\n\n\n            /* return packet */\n\n            if (asf_st->ds_span > 1) {\n\n                if (asf_st->pkt.size != asf_st->ds_packet_size * asf_st->ds_span) {\n\n                    av_log(s, AV_LOG_ERROR,\n\n                           \"pkt.size != ds_packet_size * ds_span (%d %d %d)\\n\",\n\n                           asf_st->pkt.size, asf_st->ds_packet_size,\n\n                           asf_st->ds_span);\n\n                } else {\n\n                    /* packet descrambling */\n\n                    AVBufferRef *buf = av_buffer_alloc(asf_st->pkt.size +\n\n                                                       FF_INPUT_BUFFER_PADDING_SIZE);\n\n                    if (buf) {\n\n                        uint8_t *newdata = buf->data;\n\n                        int offset = 0;\n\n                        memset(newdata + asf_st->pkt.size, 0,\n\n                               FF_INPUT_BUFFER_PADDING_SIZE);\n\n                        while (offset < asf_st->pkt.size) {\n\n                            int off = offset / asf_st->ds_chunk_size;\n\n                            int row = off / asf_st->ds_span;\n\n                            int col = off % asf_st->ds_span;\n\n                            int idx = row + col * asf_st->ds_packet_size / asf_st->ds_chunk_size;\n\n                            assert(offset + asf_st->ds_chunk_size <= asf_st->pkt.size);\n\n                            assert(idx + 1 <= asf_st->pkt.size / asf_st->ds_chunk_size);\n\n                            memcpy(newdata + offset,\n\n                                   asf_st->pkt.data + idx * asf_st->ds_chunk_size,\n\n                                   asf_st->ds_chunk_size);\n\n                            offset += asf_st->ds_chunk_size;\n\n                        }\n\n                        av_buffer_unref(&asf_st->pkt.buf);\n\n                        asf_st->pkt.buf  = buf;\n\n                        asf_st->pkt.data = buf->data;\n\n                    }\n\n                }\n\n            }\n\n            asf_st->frag_offset         = 0;\n\n            *pkt                        = asf_st->pkt;\n\n#if FF_API_DESTRUCT_PACKET\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n            asf_st->pkt.destruct        = NULL;\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n            asf_st->pkt.buf             = 0;\n\n            asf_st->pkt.size            = 0;\n\n            asf_st->pkt.data            = 0;\n\n            asf_st->pkt.side_data_elems = 0;\n\n            asf_st->pkt.side_data       = NULL;\n\n            break; // packet completed\n\n        }\n\n    }\n\n    return 0;\n\n}", "idx": 12212}
{"project": "FFmpeg", "commit_id": "3176217c60ca7828712985092d9102d331ea4f3d", "target": 0, "func": "static int fill_filter_caches(const H264Context *h, H264SliceContext *sl, int mb_type)\n\n{\n\n    const int mb_xy = sl->mb_xy;\n\n    int top_xy, left_xy[LEFT_MBS];\n\n    int top_type, left_type[LEFT_MBS];\n\n    uint8_t *nnz;\n\n    uint8_t *nnz_cache;\n\n\n\n    top_xy = mb_xy - (h->mb_stride << MB_FIELD(sl));\n\n\n\n    /* Wow, what a mess, why didn't they simplify the interlacing & intra\n\n     * stuff, I can't imagine that these complex rules are worth it. */\n\n\n\n    left_xy[LBOT] = left_xy[LTOP] = mb_xy - 1;\n\n    if (FRAME_MBAFF(h)) {\n\n        const int left_mb_field_flag = IS_INTERLACED(h->cur_pic.mb_type[mb_xy - 1]);\n\n        const int curr_mb_field_flag = IS_INTERLACED(mb_type);\n\n        if (sl->mb_y & 1) {\n\n            if (left_mb_field_flag != curr_mb_field_flag)\n\n                left_xy[LTOP] -= h->mb_stride;\n\n        } else {\n\n            if (curr_mb_field_flag)\n\n                top_xy += h->mb_stride &\n\n                          (((h->cur_pic.mb_type[top_xy] >> 7) & 1) - 1);\n\n            if (left_mb_field_flag != curr_mb_field_flag)\n\n                left_xy[LBOT] += h->mb_stride;\n\n        }\n\n    }\n\n\n\n    sl->top_mb_xy        = top_xy;\n\n    sl->left_mb_xy[LTOP] = left_xy[LTOP];\n\n    sl->left_mb_xy[LBOT] = left_xy[LBOT];\n\n    {\n\n        /* For sufficiently low qp, filtering wouldn't do anything.\n\n         * This is a conservative estimate: could also check beta_offset\n\n         * and more accurate chroma_qp. */\n\n        int qp_thresh = sl->qp_thresh; // FIXME strictly we should store qp_thresh for each mb of a slice\n\n        int qp        = h->cur_pic.qscale_table[mb_xy];\n\n        if (qp <= qp_thresh &&\n\n            (left_xy[LTOP] < 0 ||\n\n             ((qp + h->cur_pic.qscale_table[left_xy[LTOP]] + 1) >> 1) <= qp_thresh) &&\n\n            (top_xy < 0 ||\n\n             ((qp + h->cur_pic.qscale_table[top_xy] + 1) >> 1) <= qp_thresh)) {\n\n            if (!FRAME_MBAFF(h))\n\n                return 1;\n\n            if ((left_xy[LTOP] < 0 ||\n\n                 ((qp + h->cur_pic.qscale_table[left_xy[LBOT]] + 1) >> 1) <= qp_thresh) &&\n\n                (top_xy < h->mb_stride ||\n\n                 ((qp + h->cur_pic.qscale_table[top_xy - h->mb_stride] + 1) >> 1) <= qp_thresh))\n\n                return 1;\n\n        }\n\n    }\n\n\n\n    top_type        = h->cur_pic.mb_type[top_xy];\n\n    left_type[LTOP] = h->cur_pic.mb_type[left_xy[LTOP]];\n\n    left_type[LBOT] = h->cur_pic.mb_type[left_xy[LBOT]];\n\n    if (sl->deblocking_filter == 2) {\n\n        if (h->slice_table[top_xy] != sl->slice_num)\n\n            top_type = 0;\n\n        if (h->slice_table[left_xy[LBOT]] != sl->slice_num)\n\n            left_type[LTOP] = left_type[LBOT] = 0;\n\n    } else {\n\n        if (h->slice_table[top_xy] == 0xFFFF)\n\n            top_type = 0;\n\n        if (h->slice_table[left_xy[LBOT]] == 0xFFFF)\n\n            left_type[LTOP] = left_type[LBOT] = 0;\n\n    }\n\n    sl->top_type        = top_type;\n\n    sl->left_type[LTOP] = left_type[LTOP];\n\n    sl->left_type[LBOT] = left_type[LBOT];\n\n\n\n    if (IS_INTRA(mb_type))\n\n        return 0;\n\n\n\n    fill_filter_caches_inter(h, sl, mb_type, top_xy, left_xy,\n\n                             top_type, left_type, mb_xy, 0);\n\n    if (sl->list_count == 2)\n\n        fill_filter_caches_inter(h, sl, mb_type, top_xy, left_xy,\n\n                                 top_type, left_type, mb_xy, 1);\n\n\n\n    nnz       = h->non_zero_count[mb_xy];\n\n    nnz_cache = sl->non_zero_count_cache;\n\n    AV_COPY32(&nnz_cache[4 + 8 * 1], &nnz[0]);\n\n    AV_COPY32(&nnz_cache[4 + 8 * 2], &nnz[4]);\n\n    AV_COPY32(&nnz_cache[4 + 8 * 3], &nnz[8]);\n\n    AV_COPY32(&nnz_cache[4 + 8 * 4], &nnz[12]);\n\n    sl->cbp = h->cbp_table[mb_xy];\n\n\n\n    if (top_type) {\n\n        nnz = h->non_zero_count[top_xy];\n\n        AV_COPY32(&nnz_cache[4 + 8 * 0], &nnz[3 * 4]);\n\n    }\n\n\n\n    if (left_type[LTOP]) {\n\n        nnz = h->non_zero_count[left_xy[LTOP]];\n\n        nnz_cache[3 + 8 * 1] = nnz[3 + 0 * 4];\n\n        nnz_cache[3 + 8 * 2] = nnz[3 + 1 * 4];\n\n        nnz_cache[3 + 8 * 3] = nnz[3 + 2 * 4];\n\n        nnz_cache[3 + 8 * 4] = nnz[3 + 3 * 4];\n\n    }\n\n\n\n    /* CAVLC 8x8dct requires NNZ values for residual decoding that differ\n\n     * from what the loop filter needs */\n\n    if (!CABAC(h) && h->pps.transform_8x8_mode) {\n\n        if (IS_8x8DCT(top_type)) {\n\n            nnz_cache[4 + 8 * 0] =\n\n            nnz_cache[5 + 8 * 0] = (h->cbp_table[top_xy] & 0x4000) >> 12;\n\n            nnz_cache[6 + 8 * 0] =\n\n            nnz_cache[7 + 8 * 0] = (h->cbp_table[top_xy] & 0x8000) >> 12;\n\n        }\n\n        if (IS_8x8DCT(left_type[LTOP])) {\n\n            nnz_cache[3 + 8 * 1] =\n\n            nnz_cache[3 + 8 * 2] = (h->cbp_table[left_xy[LTOP]] & 0x2000) >> 12; // FIXME check MBAFF\n\n        }\n\n        if (IS_8x8DCT(left_type[LBOT])) {\n\n            nnz_cache[3 + 8 * 3] =\n\n            nnz_cache[3 + 8 * 4] = (h->cbp_table[left_xy[LBOT]] & 0x8000) >> 12; // FIXME check MBAFF\n\n        }\n\n\n\n        if (IS_8x8DCT(mb_type)) {\n\n            nnz_cache[scan8[0]] =\n\n            nnz_cache[scan8[1]] =\n\n            nnz_cache[scan8[2]] =\n\n            nnz_cache[scan8[3]] = (sl->cbp & 0x1000) >> 12;\n\n\n\n            nnz_cache[scan8[0 + 4]] =\n\n            nnz_cache[scan8[1 + 4]] =\n\n            nnz_cache[scan8[2 + 4]] =\n\n            nnz_cache[scan8[3 + 4]] = (sl->cbp & 0x2000) >> 12;\n\n\n\n            nnz_cache[scan8[0 + 8]] =\n\n            nnz_cache[scan8[1 + 8]] =\n\n            nnz_cache[scan8[2 + 8]] =\n\n            nnz_cache[scan8[3 + 8]] = (sl->cbp & 0x4000) >> 12;\n\n\n\n            nnz_cache[scan8[0 + 12]] =\n\n            nnz_cache[scan8[1 + 12]] =\n\n            nnz_cache[scan8[2 + 12]] =\n\n            nnz_cache[scan8[3 + 12]] = (sl->cbp & 0x8000) >> 12;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 12542}
{"project": "FFmpeg", "commit_id": "07d84a4e9f37a42a390418928cc086246f846e3f", "target": 0, "func": "static int MPA_encode_init(AVCodecContext *avctx)\n\n{\n\n    MpegAudioContext *s = avctx->priv_data;\n\n    int freq = avctx->sample_rate;\n\n    int bitrate = avctx->bit_rate;\n\n    int channels = avctx->channels;\n\n    int i, v, table;\n\n    float a;\n\n\n\n    if (channels > 2)\n\n        return -1;\n\n    bitrate = bitrate / 1000;\n\n    s->nb_channels = channels;\n\n    s->freq = freq;\n\n    s->bit_rate = bitrate * 1000;\n\n    avctx->frame_size = MPA_FRAME_SIZE;\n\n\n\n    /* encoding freq */\n\n    s->lsf = 0;\n\n    for(i=0;i<3;i++) {\n\n        if (mpa_freq_tab[i] == freq)\n\n            break;\n\n        if ((mpa_freq_tab[i] / 2) == freq) {\n\n            s->lsf = 1;\n\n            break;\n\n        }\n\n    }\n\n    if (i == 3){\n\n        av_log(avctx, AV_LOG_ERROR, \"Sampling rate %d is not allowed in mp2\\n\", freq);\n\n        return -1;\n\n    }\n\n    s->freq_index = i;\n\n\n\n    /* encoding bitrate & frequency */\n\n    for(i=0;i<15;i++) {\n\n        if (mpa_bitrate_tab[s->lsf][1][i] == bitrate)\n\n            break;\n\n    }\n\n    if (i == 15){\n\n        av_log(avctx, AV_LOG_ERROR, \"bitrate %d is not allowed in mp2\\n\", bitrate);\n\n        return -1;\n\n    }\n\n    s->bitrate_index = i;\n\n\n\n    /* compute total header size & pad bit */\n\n\n\n    a = (float)(bitrate * 1000 * MPA_FRAME_SIZE) / (freq * 8.0);\n\n    s->frame_size = ((int)a) * 8;\n\n\n\n    /* frame fractional size to compute padding */\n\n    s->frame_frac = 0;\n\n    s->frame_frac_incr = (int)((a - floor(a)) * 65536.0);\n\n\n\n    /* select the right allocation table */\n\n    table = l2_select_table(bitrate, s->nb_channels, freq, s->lsf);\n\n\n\n    /* number of used subbands */\n\n    s->sblimit = sblimit_table[table];\n\n    s->alloc_table = alloc_tables[table];\n\n\n\n#ifdef DEBUG\n\n    av_log(avctx, AV_LOG_DEBUG, \"%d kb/s, %d Hz, frame_size=%d bits, table=%d, padincr=%x\\n\",\n\n           bitrate, freq, s->frame_size, table, s->frame_frac_incr);\n\n#endif\n\n\n\n    for(i=0;i<s->nb_channels;i++)\n\n        s->samples_offset[i] = 0;\n\n\n\n    for(i=0;i<257;i++) {\n\n        int v;\n\n        v = mpa_enwindow[i];\n\n#if WFRAC_BITS != 16\n\n        v = (v + (1 << (16 - WFRAC_BITS - 1))) >> (16 - WFRAC_BITS);\n\n#endif\n\n        filter_bank[i] = v;\n\n        if ((i & 63) != 0)\n\n            v = -v;\n\n        if (i != 0)\n\n            filter_bank[512 - i] = v;\n\n    }\n\n\n\n    for(i=0;i<64;i++) {\n\n        v = (int)(pow(2.0, (3 - i) / 3.0) * (1 << 20));\n\n        if (v <= 0)\n\n            v = 1;\n\n        scale_factor_table[i] = v;\n\n#ifdef USE_FLOATS\n\n        scale_factor_inv_table[i] = pow(2.0, -(3 - i) / 3.0) / (float)(1 << 20);\n\n#else\n\n#define P 15\n\n        scale_factor_shift[i] = 21 - P - (i / 3);\n\n        scale_factor_mult[i] = (1 << P) * pow(2.0, (i % 3) / 3.0);\n\n#endif\n\n    }\n\n    for(i=0;i<128;i++) {\n\n        v = i - 64;\n\n        if (v <= -3)\n\n            v = 0;\n\n        else if (v < 0)\n\n            v = 1;\n\n        else if (v == 0)\n\n            v = 2;\n\n        else if (v < 3)\n\n            v = 3;\n\n        else\n\n            v = 4;\n\n        scale_diff_table[i] = v;\n\n    }\n\n\n\n    for(i=0;i<17;i++) {\n\n        v = quant_bits[i];\n\n        if (v < 0)\n\n            v = -v;\n\n        else\n\n            v = v * 3;\n\n        total_quant_bits[i] = 12 * v;\n\n    }\n\n\n\n    avctx->coded_frame= avcodec_alloc_frame();\n\n    avctx->coded_frame->key_frame= 1;\n\n\n\n    return 0;\n\n}\n", "idx": 12651}
{"project": "qemu", "commit_id": "c021db86a4968f456f6365eab158107c131df22e", "target": 0, "func": "static void lsi_execute_script(LSIState *s)\n\n{\n\n    uint32_t insn;\n\n    uint32_t addr, addr_high;\n\n    int opcode;\n\n    int insn_processed = 0;\n\n\n\n    s->istat1 |= LSI_ISTAT1_SRUN;\n\nagain:\n\n    insn_processed++;\n\n    insn = read_dword(s, s->dsp);\n\n    addr = read_dword(s, s->dsp + 4);\n\n    addr_high = 0;\n\n    DPRINTF(\"SCRIPTS dsp=%08x opcode %08x arg %08x\\n\", s->dsp, insn, addr);\n\n    s->dsps = addr;\n\n    s->dcmd = insn >> 24;\n\n    s->dsp += 8;\n\n    switch (insn >> 30) {\n\n    case 0: /* Block move.  */\n\n        if (s->sist1 & LSI_SIST1_STO) {\n\n            DPRINTF(\"Delayed select timeout\\n\");\n\n            lsi_stop_script(s);\n\n            break;\n\n        }\n\n        s->dbc = insn & 0xffffff;\n\n        s->rbc = s->dbc;\n\n        if (insn & (1 << 29)) {\n\n            /* Indirect addressing.  */\n\n            addr = read_dword(s, addr);\n\n        } else if (insn & (1 << 28)) {\n\n            uint32_t buf[2];\n\n            int32_t offset;\n\n            /* Table indirect addressing.  */\n\n            offset = sxt24(addr);\n\n            cpu_physical_memory_read(s->dsa + offset, (uint8_t *)buf, 8);\n\n            /* byte count is stored in bits 0:23 only */\n\n            s->dbc = cpu_to_le32(buf[0]) & 0xffffff;\n\n            s->rbc = s->dbc;\n\n            addr = cpu_to_le32(buf[1]);\n\n\n\n            /* 40-bit DMA, upper addr bits [39:32] stored in first DWORD of\n\n             * table, bits [31:24] */\n\n            if (lsi_dma_40bit(s))\n\n                addr_high = cpu_to_le32(buf[0]) >> 24;\n\n        }\n\n        if ((s->sstat1 & PHASE_MASK) != ((insn >> 24) & 7)) {\n\n            DPRINTF(\"Wrong phase got %d expected %d\\n\",\n\n                    s->sstat1 & PHASE_MASK, (insn >> 24) & 7);\n\n            lsi_script_scsi_interrupt(s, LSI_SIST0_MA, 0);\n\n            break;\n\n        }\n\n        s->dnad = addr;\n\n        s->dnad64 = addr_high;\n\n        /* ??? Set ESA.  */\n\n        s->ia = s->dsp - 8;\n\n        switch (s->sstat1 & 0x7) {\n\n        case PHASE_DO:\n\n            s->waiting = 2;\n\n            lsi_do_dma(s, 1);\n\n            if (s->waiting)\n\n                s->waiting = 3;\n\n            break;\n\n        case PHASE_DI:\n\n            s->waiting = 2;\n\n            s->current_dma_len = s->dbc;\n\n            lsi_do_dma(s, 0);\n\n            if (s->waiting)\n\n                s->waiting = 3;\n\n            break;\n\n        case PHASE_CMD:\n\n            lsi_do_command(s);\n\n            break;\n\n        case PHASE_ST:\n\n            lsi_do_status(s);\n\n            break;\n\n        case PHASE_MO:\n\n            lsi_do_msgout(s);\n\n            break;\n\n        case PHASE_MI:\n\n            lsi_do_msgin(s);\n\n            break;\n\n        default:\n\n            BADF(\"Unimplemented phase %d\\n\", s->sstat1 & PHASE_MASK);\n\n            exit(1);\n\n        }\n\n        s->dfifo = s->dbc & 0xff;\n\n        s->ctest5 = (s->ctest5 & 0xfc) | ((s->dbc >> 8) & 3);\n\n        s->sbc = s->dbc;\n\n        s->rbc -= s->dbc;\n\n        s->ua = addr + s->dbc;\n\n        break;\n\n\n\n    case 1: /* IO or Read/Write instruction.  */\n\n        opcode = (insn >> 27) & 7;\n\n        if (opcode < 5) {\n\n            uint32_t id;\n\n\n\n            if (insn & (1 << 25)) {\n\n                id = read_dword(s, s->dsa + sxt24(insn));\n\n            } else {\n\n                id = addr;\n\n            }\n\n            id = (id >> 16) & 0xf;\n\n            if (insn & (1 << 26)) {\n\n                addr = s->dsp + sxt24(addr);\n\n            }\n\n            s->dnad = addr;\n\n            switch (opcode) {\n\n            case 0: /* Select */\n\n                s->sdid = id;\n\n                if (s->current_dma_len && (s->ssid & 0xf) == id) {\n\n                    DPRINTF(\"Already reselected by target %d\\n\", id);\n\n                    break;\n\n                }\n\n                s->sstat0 |= LSI_SSTAT0_WOA;\n\n                s->scntl1 &= ~LSI_SCNTL1_IARB;\n\n                if (id >= LSI_MAX_DEVS || !s->scsi_dev[id]) {\n\n                    DPRINTF(\"Selected absent target %d\\n\", id);\n\n                    lsi_script_scsi_interrupt(s, 0, LSI_SIST1_STO);\n\n                    lsi_disconnect(s);\n\n                    break;\n\n                }\n\n                DPRINTF(\"Selected target %d%s\\n\",\n\n                        id, insn & (1 << 3) ? \" ATN\" : \"\");\n\n                /* ??? Linux drivers compain when this is set.  Maybe\n\n                   it only applies in low-level mode (unimplemented).\n\n                lsi_script_scsi_interrupt(s, LSI_SIST0_CMP, 0); */\n\n                s->current_dev = s->scsi_dev[id];\n\n                s->current_tag = id << 8;\n\n                s->scntl1 |= LSI_SCNTL1_CON;\n\n                if (insn & (1 << 3)) {\n\n                    s->socl |= LSI_SOCL_ATN;\n\n                }\n\n                lsi_set_phase(s, PHASE_MO);\n\n                break;\n\n            case 1: /* Disconnect */\n\n                DPRINTF(\"Wait Disconect\\n\");\n\n                s->scntl1 &= ~LSI_SCNTL1_CON;\n\n                break;\n\n            case 2: /* Wait Reselect */\n\n                lsi_wait_reselect(s);\n\n                break;\n\n            case 3: /* Set */\n\n                DPRINTF(\"Set%s%s%s%s\\n\",\n\n                        insn & (1 << 3) ? \" ATN\" : \"\",\n\n                        insn & (1 << 6) ? \" ACK\" : \"\",\n\n                        insn & (1 << 9) ? \" TM\" : \"\",\n\n                        insn & (1 << 10) ? \" CC\" : \"\");\n\n                if (insn & (1 << 3)) {\n\n                    s->socl |= LSI_SOCL_ATN;\n\n                    lsi_set_phase(s, PHASE_MO);\n\n                }\n\n                if (insn & (1 << 9)) {\n\n                    BADF(\"Target mode not implemented\\n\");\n\n                    exit(1);\n\n                }\n\n                if (insn & (1 << 10))\n\n                    s->carry = 1;\n\n                break;\n\n            case 4: /* Clear */\n\n                DPRINTF(\"Clear%s%s%s%s\\n\",\n\n                        insn & (1 << 3) ? \" ATN\" : \"\",\n\n                        insn & (1 << 6) ? \" ACK\" : \"\",\n\n                        insn & (1 << 9) ? \" TM\" : \"\",\n\n                        insn & (1 << 10) ? \" CC\" : \"\");\n\n                if (insn & (1 << 3)) {\n\n                    s->socl &= ~LSI_SOCL_ATN;\n\n                }\n\n                if (insn & (1 << 10))\n\n                    s->carry = 0;\n\n                break;\n\n            }\n\n        } else {\n\n            uint8_t op0;\n\n            uint8_t op1;\n\n            uint8_t data8;\n\n            int reg;\n\n            int operator;\n\n#ifdef DEBUG_LSI\n\n            static const char *opcode_names[3] =\n\n                {\"Write\", \"Read\", \"Read-Modify-Write\"};\n\n            static const char *operator_names[8] =\n\n                {\"MOV\", \"SHL\", \"OR\", \"XOR\", \"AND\", \"SHR\", \"ADD\", \"ADC\"};\n\n#endif\n\n\n\n            reg = ((insn >> 16) & 0x7f) | (insn & 0x80);\n\n            data8 = (insn >> 8) & 0xff;\n\n            opcode = (insn >> 27) & 7;\n\n            operator = (insn >> 24) & 7;\n\n            DPRINTF(\"%s reg 0x%x %s data8=0x%02x sfbr=0x%02x%s\\n\",\n\n                    opcode_names[opcode - 5], reg,\n\n                    operator_names[operator], data8, s->sfbr,\n\n                    (insn & (1 << 23)) ? \" SFBR\" : \"\");\n\n            op0 = op1 = 0;\n\n            switch (opcode) {\n\n            case 5: /* From SFBR */\n\n                op0 = s->sfbr;\n\n                op1 = data8;\n\n                break;\n\n            case 6: /* To SFBR */\n\n                if (operator)\n\n                    op0 = lsi_reg_readb(s, reg);\n\n                op1 = data8;\n\n                break;\n\n            case 7: /* Read-modify-write */\n\n                if (operator)\n\n                    op0 = lsi_reg_readb(s, reg);\n\n                if (insn & (1 << 23)) {\n\n                    op1 = s->sfbr;\n\n                } else {\n\n                    op1 = data8;\n\n                }\n\n                break;\n\n            }\n\n\n\n            switch (operator) {\n\n            case 0: /* move */\n\n                op0 = op1;\n\n                break;\n\n            case 1: /* Shift left */\n\n                op1 = op0 >> 7;\n\n                op0 = (op0 << 1) | s->carry;\n\n                s->carry = op1;\n\n                break;\n\n            case 2: /* OR */\n\n                op0 |= op1;\n\n                break;\n\n            case 3: /* XOR */\n\n                op0 ^= op1;\n\n                break;\n\n            case 4: /* AND */\n\n                op0 &= op1;\n\n                break;\n\n            case 5: /* SHR */\n\n                op1 = op0 & 1;\n\n                op0 = (op0 >> 1) | (s->carry << 7);\n\n                s->carry = op1;\n\n                break;\n\n            case 6: /* ADD */\n\n                op0 += op1;\n\n                s->carry = op0 < op1;\n\n                break;\n\n            case 7: /* ADC */\n\n                op0 += op1 + s->carry;\n\n                if (s->carry)\n\n                    s->carry = op0 <= op1;\n\n                else\n\n                    s->carry = op0 < op1;\n\n                break;\n\n            }\n\n\n\n            switch (opcode) {\n\n            case 5: /* From SFBR */\n\n            case 7: /* Read-modify-write */\n\n                lsi_reg_writeb(s, reg, op0);\n\n                break;\n\n            case 6: /* To SFBR */\n\n                s->sfbr = op0;\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 2: /* Transfer Control.  */\n\n        {\n\n            int cond;\n\n            int jmp;\n\n\n\n            if ((insn & 0x002e0000) == 0) {\n\n                DPRINTF(\"NOP\\n\");\n\n                break;\n\n            }\n\n            if (s->sist1 & LSI_SIST1_STO) {\n\n                DPRINTF(\"Delayed select timeout\\n\");\n\n                lsi_stop_script(s);\n\n                break;\n\n            }\n\n            cond = jmp = (insn & (1 << 19)) != 0;\n\n            if (cond == jmp && (insn & (1 << 21))) {\n\n                DPRINTF(\"Compare carry %d\\n\", s->carry == jmp);\n\n                cond = s->carry != 0;\n\n            }\n\n            if (cond == jmp && (insn & (1 << 17))) {\n\n                DPRINTF(\"Compare phase %d %c= %d\\n\",\n\n                        (s->sstat1 & PHASE_MASK),\n\n                        jmp ? '=' : '!',\n\n                        ((insn >> 24) & 7));\n\n                cond = (s->sstat1 & PHASE_MASK) == ((insn >> 24) & 7);\n\n            }\n\n            if (cond == jmp && (insn & (1 << 18))) {\n\n                uint8_t mask;\n\n\n\n                mask = (~insn >> 8) & 0xff;\n\n                DPRINTF(\"Compare data 0x%x & 0x%x %c= 0x%x\\n\",\n\n                        s->sfbr, mask, jmp ? '=' : '!', insn & mask);\n\n                cond = (s->sfbr & mask) == (insn & mask);\n\n            }\n\n            if (cond == jmp) {\n\n                if (insn & (1 << 23)) {\n\n                    /* Relative address.  */\n\n                    addr = s->dsp + sxt24(addr);\n\n                }\n\n                switch ((insn >> 27) & 7) {\n\n                case 0: /* Jump */\n\n                    DPRINTF(\"Jump to 0x%08x\\n\", addr);\n\n                    s->dsp = addr;\n\n                    break;\n\n                case 1: /* Call */\n\n                    DPRINTF(\"Call 0x%08x\\n\", addr);\n\n                    s->temp = s->dsp;\n\n                    s->dsp = addr;\n\n                    break;\n\n                case 2: /* Return */\n\n                    DPRINTF(\"Return to 0x%08x\\n\", s->temp);\n\n                    s->dsp = s->temp;\n\n                    break;\n\n                case 3: /* Interrupt */\n\n                    DPRINTF(\"Interrupt 0x%08x\\n\", s->dsps);\n\n                    if ((insn & (1 << 20)) != 0) {\n\n                        s->istat0 |= LSI_ISTAT0_INTF;\n\n                        lsi_update_irq(s);\n\n                    } else {\n\n                        lsi_script_dma_interrupt(s, LSI_DSTAT_SIR);\n\n                    }\n\n                    break;\n\n                default:\n\n                    DPRINTF(\"Illegal transfer control\\n\");\n\n                    lsi_script_dma_interrupt(s, LSI_DSTAT_IID);\n\n                    break;\n\n                }\n\n            } else {\n\n                DPRINTF(\"Control condition failed\\n\");\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 3:\n\n        if ((insn & (1 << 29)) == 0) {\n\n            /* Memory move.  */\n\n            uint32_t dest;\n\n            /* ??? The docs imply the destination address is loaded into\n\n               the TEMP register.  However the Linux drivers rely on\n\n               the value being presrved.  */\n\n            dest = read_dword(s, s->dsp);\n\n            s->dsp += 4;\n\n            lsi_memcpy(s, dest, addr, insn & 0xffffff);\n\n        } else {\n\n            uint8_t data[7];\n\n            int reg;\n\n            int n;\n\n            int i;\n\n\n\n            if (insn & (1 << 28)) {\n\n                addr = s->dsa + sxt24(addr);\n\n            }\n\n            n = (insn & 7);\n\n            reg = (insn >> 16) & 0xff;\n\n            if (insn & (1 << 24)) {\n\n                cpu_physical_memory_read(addr, data, n);\n\n                DPRINTF(\"Load reg 0x%x size %d addr 0x%08x = %08x\\n\", reg, n,\n\n                        addr, *(int *)data);\n\n                for (i = 0; i < n; i++) {\n\n                    lsi_reg_writeb(s, reg + i, data[i]);\n\n                }\n\n            } else {\n\n                DPRINTF(\"Store reg 0x%x size %d addr 0x%08x\\n\", reg, n, addr);\n\n                for (i = 0; i < n; i++) {\n\n                    data[i] = lsi_reg_readb(s, reg + i);\n\n                }\n\n                cpu_physical_memory_write(addr, data, n);\n\n            }\n\n        }\n\n    }\n\n    if (insn_processed > 10000 && !s->waiting) {\n\n        /* Some windows drivers make the device spin waiting for a memory\n\n           location to change.  If we have been executed a lot of code then\n\n           assume this is the case and force an unexpected device disconnect.\n\n           This is apparently sufficient to beat the drivers into submission.\n\n         */\n\n        if (!(s->sien0 & LSI_SIST0_UDC))\n\n            fprintf(stderr, \"inf. loop with UDC masked\\n\");\n\n        lsi_script_scsi_interrupt(s, LSI_SIST0_UDC, 0);\n\n        lsi_disconnect(s);\n\n    } else if (s->istat1 & LSI_ISTAT1_SRUN && !s->waiting) {\n\n        if (s->dcntl & LSI_DCNTL_SSM) {\n\n            lsi_script_dma_interrupt(s, LSI_DSTAT_SSI);\n\n        } else {\n\n            goto again;\n\n        }\n\n    }\n\n    DPRINTF(\"SCRIPTS execution stopped\\n\");\n\n}\n", "idx": 12664}
{"project": "qemu", "commit_id": "9be385980d37e8f4fd33f605f5fb1c3d144170a8", "target": 0, "func": "Aml *aml_arg(int pos)\n\n{\n\n    Aml *var;\n\n    uint8_t op = 0x68 /* ARG0 op */ + pos;\n\n\n\n    assert(pos <= 6);\n\n    var = aml_opcode(op);\n\n    return var;\n\n}\n", "idx": 12727}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "static int vnc_display_listen_addr(VncDisplay *vd,\n\n                                   SocketAddressLegacy *addr,\n\n                                   const char *name,\n\n                                   QIOChannelSocket ***lsock,\n\n                                   guint **lsock_tag,\n\n                                   size_t *nlsock,\n\n                                   Error **errp)\n\n{\n\n    QIODNSResolver *resolver = qio_dns_resolver_get_instance();\n\n    SocketAddressLegacy **rawaddrs = NULL;\n\n    size_t nrawaddrs = 0;\n\n    Error *listenerr = NULL;\n\n    bool listening = false;\n\n    size_t i;\n\n\n\n    if (qio_dns_resolver_lookup_sync(resolver, addr, &nrawaddrs,\n\n                                     &rawaddrs, errp) < 0) {\n\n        return -1;\n\n    }\n\n\n\n    for (i = 0; i < nrawaddrs; i++) {\n\n        QIOChannelSocket *sioc = qio_channel_socket_new();\n\n\n\n        qio_channel_set_name(QIO_CHANNEL(sioc), name);\n\n        if (qio_channel_socket_listen_sync(\n\n                sioc, rawaddrs[i], listenerr == NULL ? &listenerr : NULL) < 0) {\n\n            object_unref(OBJECT(sioc));\n\n            continue;\n\n        }\n\n        listening = true;\n\n        (*nlsock)++;\n\n        *lsock = g_renew(QIOChannelSocket *, *lsock, *nlsock);\n\n        *lsock_tag = g_renew(guint, *lsock_tag, *nlsock);\n\n\n\n        (*lsock)[*nlsock - 1] = sioc;\n\n        (*lsock_tag)[*nlsock - 1] = 0;\n\n    }\n\n\n\n    for (i = 0; i < nrawaddrs; i++) {\n\n        qapi_free_SocketAddressLegacy(rawaddrs[i]);\n\n    }\n\n    g_free(rawaddrs);\n\n\n\n    if (listenerr) {\n\n        if (!listening) {\n\n            error_propagate(errp, listenerr);\n\n            return -1;\n\n        } else {\n\n            error_free(listenerr);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i < *nlsock; i++) {\n\n        (*lsock_tag)[i] = qio_channel_add_watch(\n\n            QIO_CHANNEL((*lsock)[i]),\n\n            G_IO_IN, vnc_listen_io, vd, NULL);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 12745}
{"project": "qemu", "commit_id": "5c6c0e513600ba57c3e73b7151d3c0664438f7b5", "target": 1, "func": "static void lsi_do_dma(LSIState *s, int out)\n\n{\n\n    uint32_t count, id;\n\n    target_phys_addr_t addr;\n\n    SCSIDevice *dev;\n\n\n\n    assert(s->current);\n\n    if (!s->current->dma_len) {\n\n        /* Wait until data is available.  */\n\n        DPRINTF(\"DMA no data available\\n\");\n\n        return;\n\n    }\n\n\n\n    id = (s->current->tag >> 8) & 0xf;\n\n    dev = s->bus.devs[id];\n\n    if (!dev) {\n\n        lsi_bad_selection(s, id);\n\n        return;\n\n    }\n\n\n\n    count = s->dbc;\n\n    if (count > s->current->dma_len)\n\n        count = s->current->dma_len;\n\n\n\n    addr = s->dnad;\n\n    /* both 40 and Table Indirect 64-bit DMAs store upper bits in dnad64 */\n\n    if (lsi_dma_40bit(s) || lsi_dma_ti64bit(s))\n\n        addr |= ((uint64_t)s->dnad64 << 32);\n\n    else if (s->dbms)\n\n        addr |= ((uint64_t)s->dbms << 32);\n\n    else if (s->sbms)\n\n        addr |= ((uint64_t)s->sbms << 32);\n\n\n\n    DPRINTF(\"DMA addr=0x\" TARGET_FMT_plx \" len=%d\\n\", addr, count);\n\n    s->csbc += count;\n\n    s->dnad += count;\n\n    s->dbc -= count;\n\n\n\n    if (s->current->dma_buf == NULL) {\n\n        s->current->dma_buf = dev->info->get_buf(dev, s->current->tag);\n\n    }\n\n\n\n    /* ??? Set SFBR to first data byte.  */\n\n    if (out) {\n\n        cpu_physical_memory_read(addr, s->current->dma_buf, count);\n\n    } else {\n\n        cpu_physical_memory_write(addr, s->current->dma_buf, count);\n\n    }\n\n    s->current->dma_len -= count;\n\n    if (s->current->dma_len == 0) {\n\n        s->current->dma_buf = NULL;\n\n        if (out) {\n\n            /* Write the data.  */\n\n            dev->info->write_data(dev, s->current->tag);\n\n        } else {\n\n            /* Request any remaining data.  */\n\n            dev->info->read_data(dev, s->current->tag);\n\n        }\n\n    } else {\n\n        s->current->dma_buf += count;\n\n        lsi_resume_script(s);\n\n    }\n\n}\n", "idx": 12796}
{"project": "qemu", "commit_id": "eb7b5c35117bfb90dcfa881a0e3b23368c73fba6", "target": 1, "func": "static void iothread_instance_finalize(Object *obj)\n\n{\n\n    IOThread *iothread = IOTHREAD(obj);\n\n\n\n    iothread_stop(obj, NULL);\n\n    qemu_cond_destroy(&iothread->init_done_cond);\n\n    qemu_mutex_destroy(&iothread->init_done_lock);\n\n\n\n\n    aio_context_unref(iothread->ctx);\n", "idx": 12801}
{"project": "FFmpeg", "commit_id": "22e49e6edead9c83696f20127988f659b952ce65", "target": 0, "func": "static int dds_decode(AVCodecContext *avctx, void *data,\n\n                      int *got_frame, AVPacket *avpkt)\n\n{\n\n    DDSContext *ctx = avctx->priv_data;\n\n    GetByteContext *gbc = &ctx->gbc;\n\n    AVFrame *frame = data;\n\n    int mipmap;\n\n    int ret;\n\n\n\n    ff_texturedsp_init(&ctx->texdsp);\n\n    bytestream2_init(gbc, avpkt->data, avpkt->size);\n\n\n\n    if (bytestream2_get_bytes_left(gbc) < 128) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Frame is too small (%d).\\n\",\n\n               bytestream2_get_bytes_left(gbc));\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (bytestream2_get_le32(gbc) != MKTAG('D', 'D', 'S', ' ') ||\n\n        bytestream2_get_le32(gbc) != 124) { // header size\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid DDS header.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    bytestream2_skip(gbc, 4); // flags\n\n\n\n    avctx->height = bytestream2_get_le32(gbc);\n\n    avctx->width  = bytestream2_get_le32(gbc);\n\n    ret = av_image_check_size(avctx->width, avctx->height, 0, avctx);\n\n    if (ret < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid image size %dx%d.\\n\",\n\n               avctx->width, avctx->height);\n\n        return ret;\n\n    }\n\n\n\n    /* Since codec is based on 4x4 blocks, size is aligned to 4. */\n\n    avctx->coded_width  = FFALIGN(avctx->width,  TEXTURE_BLOCK_W);\n\n    avctx->coded_height = FFALIGN(avctx->height, TEXTURE_BLOCK_H);\n\n\n\n    bytestream2_skip(gbc, 4); // pitch\n\n    bytestream2_skip(gbc, 4); // depth\n\n    mipmap = bytestream2_get_le32(gbc);\n\n    if (mipmap != 0)\n\n        av_log(avctx, AV_LOG_VERBOSE, \"Found %d mipmaps (ignored).\\n\", mipmap);\n\n\n\n    /* Extract pixel format information, considering additional elements\n\n     * in reserved1 and reserved2. */\n\n    ret = parse_pixel_format(avctx);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    ret = ff_get_buffer(avctx, frame, 0);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (ctx->compressed) {\n\n        int size = (avctx->coded_height / TEXTURE_BLOCK_H) *\n\n                   (avctx->coded_width / TEXTURE_BLOCK_W) * ctx->tex_ratio;\n\n        ctx->slice_count = av_clip(avctx->thread_count, 1,\n\n                                   avctx->coded_height / TEXTURE_BLOCK_H);\n\n\n\n        if (bytestream2_get_bytes_left(gbc) < size) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"Compressed Buffer is too small (%d < %d).\\n\",\n\n                   bytestream2_get_bytes_left(gbc), size);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        /* Use the decompress function on the texture, one block per thread. */\n\n        ctx->tex_data = gbc->buffer;\n\n        avctx->execute2(avctx, decompress_texture_thread, frame, NULL, ctx->slice_count);\n\n    } else {\n\n        int linesize = av_image_get_linesize(avctx->pix_fmt, frame->width, 0);\n\n\n\n        if (ctx->paletted) {\n\n            int i;\n\n            uint32_t *p = (uint32_t*) frame->data[1];\n\n\n\n            /* Use the first 1024 bytes as palette, then copy the rest. */\n\n            for (i = 0; i < 256; i++) {\n\n                uint32_t rgba = 0;\n\n                rgba |= bytestream2_get_byte(gbc) << 16;\n\n                rgba |= bytestream2_get_byte(gbc) << 8;\n\n                rgba |= bytestream2_get_byte(gbc) << 0;\n\n                rgba |= bytestream2_get_byte(gbc) << 24;\n\n                p[i] = rgba;\n\n            }\n\n\n\n            frame->palette_has_changed = 1;\n\n        }\n\n\n\n        if (bytestream2_get_bytes_left(gbc) < frame->height * linesize) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Buffer is too small (%d < %d).\\n\",\n\n                   bytestream2_get_bytes_left(gbc), frame->height * linesize);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        av_image_copy_plane(frame->data[0], frame->linesize[0],\n\n                            gbc->buffer, linesize,\n\n                            linesize, frame->height);\n\n    }\n\n\n\n    /* Run any post processing here if needed. */\n\n    if (avctx->pix_fmt == AV_PIX_FMT_BGRA ||\n\n        avctx->pix_fmt == AV_PIX_FMT_RGBA ||\n\n        avctx->pix_fmt == AV_PIX_FMT_YA8)\n\n        run_postproc(avctx, frame);\n\n\n\n    /* Frame is ready to be output. */\n\n    frame->pict_type = AV_PICTURE_TYPE_I;\n\n    frame->key_frame = 1;\n\n    *got_frame = 1;\n\n\n\n    return avpkt->size;\n\n}\n", "idx": 12862}
{"project": "qemu", "commit_id": "9bada8971173345ceb37ed1a47b00a01a4dd48cf", "target": 0, "func": "static QObject *parser_context_pop_token(JSONParserContext *ctxt)\n\n{\n\n    qobject_decref(ctxt->current);\n\n    assert(!g_queue_is_empty(ctxt->buf));\n\n    ctxt->current = g_queue_pop_head(ctxt->buf);\n\n    return ctxt->current;\n\n}\n", "idx": 12869}
{"project": "qemu", "commit_id": "d26d9e14c15837eba2b7447e8d15230bab8e0940", "target": 0, "func": "static void pc_fw_cfg_guest_info(PcGuestInfo *guest_info)\n\n{\n\n    PcRomPciInfo *info;\n\n    if (!guest_info->has_pci_info) {\n\n        return;\n\n    }\n\n\n\n    info = g_malloc(sizeof *info);\n\n    info->w32_min = cpu_to_le64(guest_info->pci_info.w32.begin);\n\n    info->w32_max = cpu_to_le64(guest_info->pci_info.w32.end);\n\n    info->w64_min = cpu_to_le64(guest_info->pci_info.w64.begin);\n\n    info->w64_max = cpu_to_le64(guest_info->pci_info.w64.end);\n\n    /* Pass PCI hole info to guest via a side channel.\n\n     * Required so guest PCI enumeration does the right thing. */\n\n    fw_cfg_add_file(guest_info->fw_cfg, \"etc/pci-info\", info, sizeof *info);\n\n}\n", "idx": 12871}
{"project": "qemu", "commit_id": "3a3b8502e6f0c8d30865c5f36d2c3ae4114000b5", "target": 1, "func": "int spapr_rtas_register(const char *name, spapr_rtas_fn fn)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < (rtas_next - rtas_table); i++) {\n\n        if (strcmp(name, rtas_table[i].name) == 0) {\n\n            fprintf(stderr, \"RTAS call \\\"%s\\\" registered twice\\n\", name);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    assert(rtas_next < (rtas_table + TOKEN_MAX));\n\n\n\n    rtas_next->name = name;\n\n    rtas_next->fn = fn;\n\n\n\n    return (rtas_next++ - rtas_table) + TOKEN_BASE;\n\n}\n", "idx": 12963}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t nvram_readw (void *opaque, target_phys_addr_t addr)\n\n{\n\n    M48t59State *NVRAM = opaque;\n\n    uint32_t retval;\n\n\n\n    retval = m48t59_read(NVRAM, addr) << 8;\n\n    retval |= m48t59_read(NVRAM, addr + 1);\n\n    return retval;\n\n}\n", "idx": 12999}
{"project": "qemu", "commit_id": "bdd03cdf5dc3176bc7169a1d5709303e9279fffb", "target": 0, "func": "static int raw_reopen_prepare(BDRVReopenState *state,\n\n                              BlockReopenQueue *queue, Error **errp)\n\n{\n\n    BDRVRawState *s;\n\n    BDRVRawReopenState *raw_s;\n\n    int ret = 0;\n\n    Error *local_err = NULL;\n\n\n\n    assert(state != NULL);\n\n    assert(state->bs != NULL);\n\n\n\n    s = state->bs->opaque;\n\n\n\n    state->opaque = g_new0(BDRVRawReopenState, 1);\n\n    raw_s = state->opaque;\n\n\n\n#ifdef CONFIG_LINUX_AIO\n\n    raw_s->use_aio = s->use_aio;\n\n\n\n    /* we can use s->aio_ctx instead of a copy, because the use_aio flag is\n\n     * valid in the 'false' condition even if aio_ctx is set, and raw_set_aio()\n\n     * won't override aio_ctx if aio_ctx is non-NULL */\n\n    if (raw_set_aio(&s->aio_ctx, &raw_s->use_aio, state->flags)) {\n\n        error_setg(errp, \"Could not set AIO state\");\n\n        return -1;\n\n    }\n\n#endif\n\n\n\n    if (s->type == FTYPE_FD || s->type == FTYPE_CD) {\n\n        raw_s->open_flags |= O_NONBLOCK;\n\n    }\n\n\n\n    raw_parse_flags(state->flags, &raw_s->open_flags);\n\n\n\n    raw_s->fd = -1;\n\n\n\n    int fcntl_flags = O_APPEND | O_NONBLOCK;\n\n#ifdef O_NOATIME\n\n    fcntl_flags |= O_NOATIME;\n\n#endif\n\n\n\n#ifdef O_ASYNC\n\n    /* Not all operating systems have O_ASYNC, and those that don't\n\n     * will not let us track the state into raw_s->open_flags (typically\n\n     * you achieve the same effect with an ioctl, for example I_SETSIG\n\n     * on Solaris). But we do not use O_ASYNC, so that's fine.\n\n     */\n\n    assert((s->open_flags & O_ASYNC) == 0);\n\n#endif\n\n\n\n    if ((raw_s->open_flags & ~fcntl_flags) == (s->open_flags & ~fcntl_flags)) {\n\n        /* dup the original fd */\n\n        /* TODO: use qemu fcntl wrapper */\n\n#ifdef F_DUPFD_CLOEXEC\n\n        raw_s->fd = fcntl(s->fd, F_DUPFD_CLOEXEC, 0);\n\n#else\n\n        raw_s->fd = dup(s->fd);\n\n        if (raw_s->fd != -1) {\n\n            qemu_set_cloexec(raw_s->fd);\n\n        }\n\n#endif\n\n        if (raw_s->fd >= 0) {\n\n            ret = fcntl_setfl(raw_s->fd, raw_s->open_flags);\n\n            if (ret) {\n\n                qemu_close(raw_s->fd);\n\n                raw_s->fd = -1;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* If we cannot use fcntl, or fcntl failed, fall back to qemu_open() */\n\n    if (raw_s->fd == -1) {\n\n        assert(!(raw_s->open_flags & O_CREAT));\n\n        raw_s->fd = qemu_open(state->bs->filename, raw_s->open_flags);\n\n        if (raw_s->fd == -1) {\n\n            error_setg_errno(errp, errno, \"Could not reopen file\");\n\n            ret = -1;\n\n        }\n\n    }\n\n\n\n    /* Fail already reopen_prepare() if we can't get a working O_DIRECT\n\n     * alignment with the new fd. */\n\n    if (raw_s->fd != -1) {\n\n        raw_probe_alignment(state->bs, raw_s->fd, &local_err);\n\n        if (local_err) {\n\n            qemu_close(raw_s->fd);\n\n            raw_s->fd = -1;\n\n            error_propagate(errp, local_err);\n\n            ret = -EINVAL;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 13017}
{"project": "qemu", "commit_id": "75e347d66ab81944b5b657d17cc90ef92af3f016", "target": 1, "func": "static int enable_write_target(BDRVVVFATState *s, Error **errp)\n\n{\n\n    BlockDriver *bdrv_qcow;\n\n    QEMUOptionParameter *options;\n\n    int ret;\n\n    int size = sector2cluster(s, s->sector_count);\n\n    s->used_clusters = calloc(size, 1);\n\n\n\n    array_init(&(s->commits), sizeof(commit_t));\n\n\n\n    s->qcow_filename = g_malloc(1024);\n\n    ret = get_tmp_filename(s->qcow_filename, 1024);\n\n    if (ret < 0) {\n\n        error_setg_errno(errp, -ret, \"can't create temporary file\");\n\n        goto err;\n\n    }\n\n\n\n    bdrv_qcow = bdrv_find_format(\"qcow\");\n\n    options = parse_option_parameters(\"\", bdrv_qcow->create_options, NULL);\n\n    set_option_parameter_int(options, BLOCK_OPT_SIZE, s->sector_count * 512);\n\n    set_option_parameter(options, BLOCK_OPT_BACKING_FILE, \"fat:\");\n\n\n\n    ret = bdrv_create(bdrv_qcow, s->qcow_filename, options, errp);\n\n\n    if (ret < 0) {\n\n        goto err;\n\n    }\n\n\n\n    s->qcow = NULL;\n\n    ret = bdrv_open(&s->qcow, s->qcow_filename, NULL, NULL,\n\n                    BDRV_O_RDWR | BDRV_O_CACHE_WB | BDRV_O_NO_FLUSH,\n\n                    bdrv_qcow, errp);\n\n    if (ret < 0) {\n\n        goto err;\n\n    }\n\n\n\n#ifndef _WIN32\n\n    unlink(s->qcow_filename);\n\n#endif\n\n\n\n    bdrv_set_backing_hd(s->bs, bdrv_new(\"\", &error_abort));\n\n    s->bs->backing_hd->drv = &vvfat_write_target;\n\n    s->bs->backing_hd->opaque = g_malloc(sizeof(void*));\n\n    *(void**)s->bs->backing_hd->opaque = s;\n\n\n\n    return 0;\n\n\n\nerr:\n\n    g_free(s->qcow_filename);\n\n    s->qcow_filename = NULL;\n\n    return ret;\n\n}", "idx": 13036}
{"project": "qemu", "commit_id": "412e0e81b17488e228b4f8451df6a4af26064bb4", "target": 0, "func": "static unsigned virtqueue_read_next_desc(VirtIODevice *vdev, VRingDesc *desc,\n\n                                         hwaddr desc_pa, unsigned int max)\n\n{\n\n    unsigned int next;\n\n\n\n    /* If this descriptor says it doesn't chain, we're done. */\n\n    if (!(desc->flags & VRING_DESC_F_NEXT)) {\n\n        return max;\n\n    }\n\n\n\n    /* Check they're not leading us off end of descriptors. */\n\n    next = desc->next;\n\n    /* Make sure compiler knows to grab that: we don't want it changing! */\n\n    smp_wmb();\n\n\n\n    if (next >= max) {\n\n        error_report(\"Desc next is %u\", next);\n\n        exit(1);\n\n    }\n\n\n\n    vring_desc_read(vdev, desc, desc_pa, next);\n\n    return next;\n\n}\n", "idx": 13046}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "void do_POWER_abso (void)\n\n{\n\n    if (T0 == INT32_MIN) {\n\n        T0 = INT32_MAX;\n\n        xer_ov = 1;\n\n        xer_so = 1;\n\n    } else {\n\n        T0 = -T0;\n\n        xer_ov = 0;\n\n    }\n\n}\n", "idx": 13091}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "void *qemu_try_blockalign0(BlockDriverState *bs, size_t size)\n\n{\n\n    void *mem = qemu_try_blockalign(bs, size);\n\n\n\n    if (mem) {\n\n        memset(mem, 0, size);\n\n    }\n\n\n\n    return mem;\n\n}\n", "idx": 13180}
{"project": "FFmpeg", "commit_id": "5a5c1b244281c3edcffca322b0c664ed620b1e24", "target": 1, "func": "static int decode_13(AVCodecContext *avctx, DxaDecContext *c, uint8_t* dst,\n\n                     int stride, uint8_t *src, uint8_t *ref)\n\n{\n\n    uint8_t *code, *data, *mv, *msk, *tmp, *tmp2;\n\n    int i, j, k;\n\n    int type, x, y, d, d2;\n\n    uint32_t mask;\n\n\n\n    code = src  + 12;\n\n    data = code + ((avctx->width * avctx->height) >> 4);\n\n    mv   = data + AV_RB32(src + 0);\n\n    msk  = mv   + AV_RB32(src + 4);\n\n\n\n    for(j = 0; j < avctx->height; j += 4){\n\n        for(i = 0; i < avctx->width; i += 4){\n\n            tmp  = dst + i;\n\n            tmp2 = ref + i;\n\n            type = *code++;\n\n            switch(type){\n\n            case 4: // motion compensation\n\n                x = (*mv) >> 4;    if(x & 8) x = 8 - x;\n\n                y = (*mv++) & 0xF; if(y & 8) y = 8 - y;\n\n                if (i < -x || avctx->width  - i - 4 < x ||\n\n                    j < -y || avctx->height - j - 4 < y) {\n\n                    av_log(avctx, AV_LOG_ERROR, \"MV %d %d out of bounds\\n\", x,y);\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n                tmp2 += x + y*stride;\n\n            case 0: // skip\n\n            case 5: // skip in method 12\n\n                for(y = 0; y < 4; y++){\n\n                    memcpy(tmp, tmp2, 4);\n\n                    tmp  += stride;\n\n                    tmp2 += stride;\n\n                }\n\n                break;\n\n            case 1:  // masked change\n\n            case 10: // masked change with only half of pixels changed\n\n            case 11: // cases 10-15 are for method 12 only\n\n            case 12:\n\n            case 13:\n\n            case 14:\n\n            case 15:\n\n                if(type == 1){\n\n                    mask = AV_RB16(msk);\n\n                    msk += 2;\n\n                }else{\n\n                    type -= 10;\n\n                    mask = ((msk[0] & 0xF0) << shift1[type]) | ((msk[0] & 0xF) << shift2[type]);\n\n                    msk++;\n\n                }\n\n                for(y = 0; y < 4; y++){\n\n                    for(x = 0; x < 4; x++){\n\n                        tmp[x] = (mask & 0x8000) ? *data++ : tmp2[x];\n\n                        mask <<= 1;\n\n                    }\n\n                    tmp  += stride;\n\n                    tmp2 += stride;\n\n                }\n\n                break;\n\n            case 2: // fill block\n\n                for(y = 0; y < 4; y++){\n\n                    memset(tmp, data[0], 4);\n\n                    tmp += stride;\n\n                }\n\n                data++;\n\n                break;\n\n            case 3: // raw block\n\n                for(y = 0; y < 4; y++){\n\n                    memcpy(tmp, data, 4);\n\n                    data += 4;\n\n                    tmp  += stride;\n\n                }\n\n                break;\n\n            case 8: // subblocks - method 13 only\n\n                mask = *msk++;\n\n                for(k = 0; k < 4; k++){\n\n                    d  = ((k & 1) << 1) + ((k & 2) * stride);\n\n                    d2 = ((k & 1) << 1) + ((k & 2) * stride);\n\n                    tmp2 = ref + i + d2;\n\n                    switch(mask & 0xC0){\n\n                    case 0x80: // motion compensation\n\n                        x = (*mv) >> 4;    if(x & 8) x = 8 - x;\n\n                        y = (*mv++) & 0xF; if(y & 8) y = 8 - y;\n\n                        if (i + 2*(k & 1) < -x || avctx->width  - i - 2*(k & 1) - 2 < x ||\n\n                            j +   (k & 2) < -y || avctx->height - j -   (k & 2) - 2 < y) {\n\n                            av_log(avctx, AV_LOG_ERROR, \"MV %d %d out of bounds\\n\", x,y);\n\n                            return AVERROR_INVALIDDATA;\n\n                        }\n\n                        tmp2 += x + y*stride;\n\n                    case 0x00: // skip\n\n                        tmp[d + 0         ] = tmp2[0];\n\n                        tmp[d + 1         ] = tmp2[1];\n\n                        tmp[d + 0 + stride] = tmp2[0 + stride];\n\n                        tmp[d + 1 + stride] = tmp2[1 + stride];\n\n                        break;\n\n                    case 0x40: // fill\n\n                        tmp[d + 0         ] = data[0];\n\n                        tmp[d + 1         ] = data[0];\n\n                        tmp[d + 0 + stride] = data[0];\n\n                        tmp[d + 1 + stride] = data[0];\n\n                        data++;\n\n                        break;\n\n                    case 0xC0: // raw\n\n                        tmp[d + 0         ] = *data++;\n\n                        tmp[d + 1         ] = *data++;\n\n                        tmp[d + 0 + stride] = *data++;\n\n                        tmp[d + 1 + stride] = *data++;\n\n                        break;\n\n                    }\n\n                    mask <<= 2;\n\n                }\n\n                break;\n\n            case 32: // vector quantization - 2 colors\n\n                mask = AV_RB16(msk);\n\n                msk += 2;\n\n                for(y = 0; y < 4; y++){\n\n                    for(x = 0; x < 4; x++){\n\n                        tmp[x] = data[mask & 1];\n\n                        mask >>= 1;\n\n                    }\n\n                    tmp  += stride;\n\n                    tmp2 += stride;\n\n                }\n\n                data += 2;\n\n                break;\n\n            case 33: // vector quantization - 3 or 4 colors\n\n            case 34:\n\n                mask = AV_RB32(msk);\n\n                msk += 4;\n\n                for(y = 0; y < 4; y++){\n\n                    for(x = 0; x < 4; x++){\n\n                        tmp[x] = data[mask & 3];\n\n                        mask >>= 2;\n\n                    }\n\n                    tmp  += stride;\n\n                    tmp2 += stride;\n\n                }\n\n                data += type - 30;\n\n                break;\n\n            default:\n\n                av_log(avctx, AV_LOG_ERROR, \"Unknown opcode %d\\n\", type);\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n        dst += stride * 4;\n\n        ref += stride * 4;\n\n    }\n\n    return 0;\n\n}\n", "idx": 13223}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qemu_put_buffer(QEMUFile *f, const uint8_t *buf, int size)\n\n{\n\n    int l;\n\n\n\n    if (f->last_error) {\n\n        return;\n\n    }\n\n\n\n    while (size > 0) {\n\n        l = IO_BUF_SIZE - f->buf_index;\n\n        if (l > size) {\n\n            l = size;\n\n        }\n\n        memcpy(f->buf + f->buf_index, buf, l);\n\n        f->bytes_xfer += l;\n\n        if (f->ops->writev_buffer) {\n\n            add_to_iovec(f, f->buf + f->buf_index, l);\n\n        }\n\n        f->buf_index += l;\n\n        if (f->buf_index == IO_BUF_SIZE) {\n\n            qemu_fflush(f);\n\n        }\n\n        if (qemu_file_get_error(f)) {\n\n            break;\n\n        }\n\n        buf += l;\n\n        size -= l;\n\n    }\n\n}\n", "idx": 13270}
{"project": "FFmpeg", "commit_id": "3aad94bf2b140cfba8ae69d018da05d4948ef37f", "target": 1, "func": "static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n                        AVPacket *avpkt)\n{\n    AVFrame *frame = data;\n    const uint8_t *buf = avpkt->data;\n    const uint8_t *buf_end = buf + avpkt->size;\n    KgvContext * const c = avctx->priv_data;\n    int offsets[8];\n    uint8_t *out, *prev;\n    int outcnt = 0, maxcnt;\n    int w, h, i, res;\n    if (avpkt->size < 2)\n    w = (buf[0] + 1) * 8;\n    h = (buf[1] + 1) * 8;\n    buf += 2;\n    if (w != avctx->width || h != avctx->height) {\n        av_freep(&c->frame_buffer);\n        av_freep(&c->last_frame_buffer);\n        if ((res = ff_set_dimensions(avctx, w, h)) < 0)\n            return res;\n    }\n    if (!c->frame_buffer) {\n        c->frame_buffer      = av_mallocz(avctx->width * avctx->height * 2);\n        c->last_frame_buffer = av_mallocz(avctx->width * avctx->height * 2);\n        if (!c->frame_buffer || !c->last_frame_buffer) {\n            decode_flush(avctx);\n            return AVERROR(ENOMEM);\n        }\n    }\n    maxcnt = w * h;\n    if ((res = ff_get_buffer(avctx, frame, 0)) < 0)\n        return res;\n    out  = (uint8_t*)c->frame_buffer;\n    prev = (uint8_t*)c->last_frame_buffer;\n    for (i = 0; i < 8; i++)\n        offsets[i] = -1;\n    while (outcnt < maxcnt && buf_end - 2 >= buf) {\n        int code = AV_RL16(buf);\n        buf += 2;\n        if (!(code & 0x8000)) {\n            AV_WN16A(&out[2 * outcnt], code); // rgb555 pixel coded directly\n            outcnt++;\n        } else {\n            int count;\n            if ((code & 0x6000) == 0x6000) {\n                // copy from previous frame\n                int oidx = (code >> 10) & 7;\n                int start;\n                count = (code & 0x3FF) + 3;\n                if (offsets[oidx] < 0) {\n                    if (buf_end - 3 < buf)\n                        break;\n                    offsets[oidx] = AV_RL24(buf);\n                    buf += 3;\n                }\n                start = (outcnt + offsets[oidx]) % maxcnt;\n                if (maxcnt - start < count || maxcnt - outcnt < count)\n                    break;\n                if (!prev) {\n                    av_log(avctx, AV_LOG_ERROR,\n                           \"Frame reference does not exist\\n\");\n                    break;\n                }\n                memcpy(out + 2 * outcnt, prev + 2 * start, 2 * count);\n            } else {\n                // copy from earlier in this frame\n                int offset = (code & 0x1FFF) + 1;\n                if (!(code & 0x6000)) {\n                    count = 2;\n                } else if ((code & 0x6000) == 0x2000) {\n                    count = 3;\n                } else {\n                    if (buf_end - 1 < buf)\n                        break;\n                    count = 4 + *buf++;\n                }\n                if (outcnt < offset || maxcnt - outcnt < count)\n                    break;\n                av_memcpy_backptr(out + 2 * outcnt, 2 * offset, 2 * count);\n            }\n            outcnt += count;\n        }\n    }\n    if (outcnt - maxcnt)\n        av_log(avctx, AV_LOG_DEBUG, \"frame finished with %d diff\\n\", outcnt - maxcnt);\n    av_image_copy_plane(frame->data[0], frame->linesize[0],\n                        (const uint8_t*)c->frame_buffer,  avctx->width * 2,\n                        avctx->width * 2, avctx->height);\n    FFSWAP(uint16_t *, c->frame_buffer, c->last_frame_buffer);\n    *got_frame = 1;\n    return avpkt->size;\n}", "idx": 13302}
{"project": "FFmpeg", "commit_id": "e9af732a1a4c28f81959f19d434c9be609cff22a", "target": 1, "func": "AVFilterBufferRef *avfilter_default_get_audio_buffer(AVFilterLink *link, int perms,\n\n                                                     int nb_samples)\n\n{\n\n    AVFilterBufferRef *samplesref = NULL;\n\n    int linesize[8];\n\n    uint8_t *data[8];\n\n    int nb_channels = av_get_channel_layout_nb_channels(link->channel_layout);\n\n\n\n    /* Calculate total buffer size, round to multiple of 16 to be SIMD friendly */\n\n    if (av_samples_alloc(data, linesize,\n\n                         nb_channels, nb_samples, link->format,\n\n                         16) < 0)\n\n        return NULL;\n\n\n\n    samplesref =\n\n        avfilter_get_audio_buffer_ref_from_arrays(data, linesize, perms,\n\n                                                  nb_samples, link->format,\n\n                                                  link->channel_layout, link->planar);\n\n    if (!samplesref) {\n\n        av_free(data[0]);\n\n        return NULL;\n\n    }\n\n\n\n    return samplesref;\n\n}\n", "idx": 13334}
{"project": "FFmpeg", "commit_id": "c89658008705d949c319df3fa6f400c481ad73e1", "target": 0, "func": "static int sdp_probe(AVProbeData *p1)\n\n{\n\n    const char *p = p1->buf, *p_end = p1->buf + p1->buf_size;\n\n\n\n    /* we look for a line beginning \"c=IN IP4\" */\n\n    while (p < p_end && *p != '\\0') {\n\n        if (p + sizeof(\"c=IN IP4\") - 1 < p_end && av_strstart(p, \"c=IN IP4\", NULL))\n\n            return AVPROBE_SCORE_MAX / 2;\n\n\n\n        while(p < p_end - 1 && *p != '\\n') p++;\n\n        if (++p >= p_end)\n\n            break;\n\n        if (*p == '\\r')\n\n            p++;\n\n    }\n\n    return 0;\n\n}\n", "idx": 13372}
{"project": "qemu", "commit_id": "8d2f850a5ab7579a852f23b28273940a47dfd7ff", "target": 0, "func": "uint32_t HELPER(mvcos)(CPUS390XState *env, uint64_t dest, uint64_t src,\n\n                       uint64_t len)\n\n{\n\n    const uint8_t psw_key = (env->psw.mask & PSW_MASK_KEY) >> PSW_SHIFT_KEY;\n\n    const uint8_t psw_as = (env->psw.mask & PSW_MASK_ASC) >> PSW_SHIFT_ASC;\n\n    const uint64_t r0 = env->regs[0];\n\n    const uintptr_t ra = GETPC();\n\n    CPUState *cs = CPU(s390_env_get_cpu(env));\n\n    uint8_t dest_key, dest_as, dest_k, dest_a;\n\n    uint8_t src_key, src_as, src_k, src_a;\n\n    uint64_t val;\n\n    int cc = 0;\n\n\n\n    HELPER_LOG(\"%s dest %\" PRIx64 \", src %\" PRIx64 \", len %\" PRIx64 \"\\n\",\n\n               __func__, dest, src, len);\n\n\n\n    if (!(env->psw.mask & PSW_MASK_DAT)) {\n\n        cpu_restore_state(cs, ra);\n\n        program_interrupt(env, PGM_SPECIAL_OP, 6);\n\n    }\n\n\n\n    /* OAC (operand access control) for the first operand -> dest */\n\n    val = (r0 & 0xffff0000ULL) >> 16;\n\n    dest_key = (val >> 12) & 0xf;\n\n    dest_as = (val >> 6) & 0x3;\n\n    dest_k = (val >> 1) & 0x1;\n\n    dest_a = val & 0x1;\n\n\n\n    /* OAC (operand access control) for the second operand -> src */\n\n    val = (r0 & 0x0000ffffULL);\n\n    src_key = (val >> 12) & 0xf;\n\n    src_as = (val >> 6) & 0x3;\n\n    src_k = (val >> 1) & 0x1;\n\n    src_a = val & 0x1;\n\n\n\n    if (!dest_k) {\n\n        dest_key = psw_key;\n\n    }\n\n    if (!src_k) {\n\n        src_key = psw_key;\n\n    }\n\n    if (!dest_a) {\n\n        dest_as = psw_as;\n\n    }\n\n    if (!src_a) {\n\n        src_as = psw_as;\n\n    }\n\n\n\n    if (dest_a && dest_as == AS_HOME && (env->psw.mask & PSW_MASK_PSTATE)) {\n\n        cpu_restore_state(cs, ra);\n\n        program_interrupt(env, PGM_SPECIAL_OP, 6);\n\n    }\n\n    if (!(env->cregs[0] & CR0_SECONDARY) &&\n\n        (dest_as == AS_SECONDARY || src_as == AS_SECONDARY)) {\n\n        cpu_restore_state(cs, ra);\n\n        program_interrupt(env, PGM_SPECIAL_OP, 6);\n\n    }\n\n    if (!psw_key_valid(env, dest_key) || !psw_key_valid(env, src_key)) {\n\n        cpu_restore_state(cs, ra);\n\n        program_interrupt(env, PGM_PRIVILEGED, 6);\n\n    }\n\n\n\n    len = wrap_length(env, len);\n\n    if (len > 4096) {\n\n        cc = 3;\n\n        len = 4096;\n\n    }\n\n\n\n    /* FIXME: AR-mode and proper problem state mode (using PSW keys) missing */\n\n    if (src_as == AS_ACCREG || dest_as == AS_ACCREG ||\n\n        (env->psw.mask & PSW_MASK_PSTATE)) {\n\n        qemu_log_mask(LOG_UNIMP, \"%s: AR-mode and PSTATE support missing\\n\",\n\n                      __func__);\n\n        cpu_restore_state(cs, ra);\n\n        program_interrupt(env, PGM_ADDRESSING, 6);\n\n    }\n\n\n\n    /* FIXME: a) LAP\n\n     *        b) Access using correct keys\n\n     *        c) AR-mode\n\n     */\n\n#ifdef CONFIG_USER_ONLY\n\n    /* psw keys are never valid in user mode, we will never reach this */\n\n    g_assert_not_reached();\n\n#else\n\n    fast_memmove_as(env, dest, src, len, dest_as, src_as, ra);\n\n#endif\n\n\n\n    return cc;\n\n}\n", "idx": 13373}
{"project": "qemu", "commit_id": "b08d0ea0446aa91f373c9df4254ba3bc4ee84098", "target": 0, "func": "static SCSIRequest *scsi_block_new_request(SCSIDevice *d, uint32_t tag,\n\n                                           uint32_t lun, uint8_t *buf,\n\n                                           void *hba_private)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);\n\n\n\n    switch (buf[0]) {\n\n    case READ_6:\n\n    case READ_10:\n\n    case READ_12:\n\n    case READ_16:\n\n    case VERIFY_10:\n\n    case VERIFY_12:\n\n    case VERIFY_16:\n\n    case WRITE_6:\n\n    case WRITE_10:\n\n    case WRITE_12:\n\n    case WRITE_16:\n\n    case WRITE_VERIFY_10:\n\n    case WRITE_VERIFY_12:\n\n    case WRITE_VERIFY_16:\n\n        /* If we are not using O_DIRECT, we might read stale data from the\n\n\t * host cache if writes were made using other commands than these\n\n\t * ones (such as WRITE SAME or EXTENDED COPY, etc.).  So, without\n\n\t * O_DIRECT everything must go through SG_IO.\n\n         */\n\n        if (bdrv_get_flags(s->qdev.conf.bs) & BDRV_O_NOCACHE) {\n\n            break;\n\n        }\n\n\n\n        /* MMC writing cannot be done via pread/pwrite, because it sometimes\n\n         * involves writing beyond the maximum LBA or to negative LBA (lead-in).\n\n         * And once you do these writes, reading from the block device is\n\n         * unreliable, too.  It is even possible that reads deliver random data\n\n         * from the host page cache (this is probably a Linux bug).\n\n         *\n\n         * We might use scsi_disk_reqops as long as no writing commands are\n\n         * seen, but performance usually isn't paramount on optical media.  So,\n\n         * just make scsi-block operate the same as scsi-generic for them.\n\n         */\n\n        if (s->qdev.type == TYPE_ROM) {\n\n            break;\n\n\t}\n\n        return scsi_req_alloc(&scsi_disk_reqops, &s->qdev, tag, lun,\n\n                              hba_private);\n\n    }\n\n\n\n    return scsi_req_alloc(&scsi_generic_req_ops, &s->qdev, tag, lun,\n\n                          hba_private);\n\n}\n", "idx": 13427}
{"project": "qemu", "commit_id": "eb513f82f04fab442cdef9db698dafc852275f7f", "target": 1, "func": "void helper_st_asi(CPUSPARCState *env, target_ulong addr, target_ulong val,\n\n                   int asi, int size)\n\n{\n\n#ifdef DEBUG_ASI\n\n    dump_asi(\"write\", addr, asi, size, val);\n\n#endif\n\n    if (asi < 0x80) {\n\n        helper_raise_exception(env, TT_PRIV_ACT);\n\n    }\n\n\n\n    helper_check_align(env, addr, size - 1);\n\n    addr = asi_address_mask(env, asi, addr);\n\n\n\n    /* Convert to little endian */\n\n    switch (asi) {\n\n    case 0x88: /* Primary LE */\n\n    case 0x89: /* Secondary LE */\n\n        switch (size) {\n\n        case 2:\n\n            val = bswap16(val);\n\n            break;\n\n        case 4:\n\n            val = bswap32(val);\n\n            break;\n\n        case 8:\n\n            val = bswap64(val);\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    default:\n\n        break;\n\n    }\n\n\n\n    switch (asi) {\n\n    case 0x80: /* Primary */\n\n    case 0x88: /* Primary LE */\n\n        {\n\n            switch (size) {\n\n            case 1:\n\n                stb_raw(addr, val);\n\n                break;\n\n            case 2:\n\n                stw_raw(addr, val);\n\n                break;\n\n            case 4:\n\n                stl_raw(addr, val);\n\n                break;\n\n            case 8:\n\n            default:\n\n                stq_raw(addr, val);\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n    case 0x81: /* Secondary */\n\n    case 0x89: /* Secondary LE */\n\n        /* XXX */\n\n        return;\n\n\n\n    case 0x82: /* Primary no-fault, RO */\n\n    case 0x83: /* Secondary no-fault, RO */\n\n    case 0x8a: /* Primary no-fault LE, RO */\n\n    case 0x8b: /* Secondary no-fault LE, RO */\n\n    default:\n\n        helper_raise_exception(env, TT_DATA_ACCESS);\n\n        return;\n\n    }\n\n}\n", "idx": 13467}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "int qemu_file_get_error(QEMUFile *f)\n\n{\n\n    return f->last_error;\n\n}\n", "idx": 13546}
{"project": "qemu", "commit_id": "59800ec8e52bcfa271fa61fb0aae19205ef1b7f1", "target": 0, "func": "uint64_t helper_fctidz(CPUPPCState *env, uint64_t arg)\n\n{\n\n    CPU_DoubleU farg;\n\n\n\n    farg.ll = arg;\n\n\n\n    if (unlikely(float64_is_signaling_nan(farg.d))) {\n\n        /* sNaN conversion */\n\n        farg.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN |\n\n                                        POWERPC_EXCP_FP_VXCVI);\n\n    } else if (unlikely(float64_is_quiet_nan(farg.d) ||\n\n                        float64_is_infinity(farg.d))) {\n\n        /* qNan / infinity conversion */\n\n        farg.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXCVI);\n\n    } else {\n\n        farg.ll = float64_to_int64_round_to_zero(farg.d, &env->fp_status);\n\n    }\n\n    return farg.ll;\n\n}\n", "idx": 13569}
{"project": "qemu", "commit_id": "45a50b1668822c23afc2a89f724654e176518bc4", "target": 0, "func": "static int load_multiboot(void *fw_cfg,\n\n                          FILE *f,\n\n                          const char *kernel_filename,\n\n                          const char *initrd_filename,\n\n                          const char *kernel_cmdline,\n\n                          uint8_t *header)\n\n{\n\n    int i, t, is_multiboot = 0;\n\n    uint32_t flags = 0;\n\n    uint32_t mh_entry_addr;\n\n    uint32_t mh_load_addr;\n\n    uint32_t mb_kernel_size;\n\n    uint32_t mmap_addr = MULTIBOOT_STRUCT_ADDR;\n\n    uint32_t mb_bootinfo = MULTIBOOT_STRUCT_ADDR + 0x500;\n\n    uint32_t mb_cmdline = mb_bootinfo + 0x200;\n\n    uint32_t mb_mod_end;\n\n\n\n    /* Ok, let's see if it is a multiboot image.\n\n       The header is 12x32bit long, so the latest entry may be 8192 - 48. */\n\n    for (i = 0; i < (8192 - 48); i += 4) {\n\n        if (ldl_p(header+i) == 0x1BADB002) {\n\n            uint32_t checksum = ldl_p(header+i+8);\n\n            flags = ldl_p(header+i+4);\n\n            checksum += flags;\n\n            checksum += (uint32_t)0x1BADB002;\n\n            if (!checksum) {\n\n                is_multiboot = 1;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (!is_multiboot)\n\n        return 0; /* no multiboot */\n\n\n\n#ifdef DEBUG_MULTIBOOT\n\n    fprintf(stderr, \"qemu: I believe we found a multiboot image!\\n\");\n\n#endif\n\n\n\n    if (flags & 0x00000004) { /* MULTIBOOT_HEADER_HAS_VBE */\n\n        fprintf(stderr, \"qemu: multiboot knows VBE. we don't.\\n\");\n\n    }\n\n    if (!(flags & 0x00010000)) { /* MULTIBOOT_HEADER_HAS_ADDR */\n\n        uint64_t elf_entry;\n\n        int kernel_size;\n\n        fclose(f);\n\n        kernel_size = load_elf(kernel_filename, 0, &elf_entry, NULL, NULL,\n\n                               0, ELF_MACHINE, 0);\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"Error while loading elf kernel\\n\");\n\n            exit(1);\n\n        }\n\n        mh_load_addr = mh_entry_addr = elf_entry;\n\n        mb_kernel_size = kernel_size;\n\n\n\n#ifdef DEBUG_MULTIBOOT\n\n        fprintf(stderr, \"qemu: loading multiboot-elf kernel (%#x bytes) with entry %#zx\\n\",\n\n                mb_kernel_size, (size_t)mh_entry_addr);\n\n#endif\n\n    } else {\n\n        /* Valid if mh_flags sets MULTIBOOT_HEADER_HAS_ADDR. */\n\n        uint32_t mh_header_addr = ldl_p(header+i+12);\n\n        mh_load_addr = ldl_p(header+i+16);\n\n#ifdef DEBUG_MULTIBOOT\n\n        uint32_t mh_load_end_addr = ldl_p(header+i+20);\n\n        uint32_t mh_bss_end_addr = ldl_p(header+i+24);\n\n#endif\n\n        uint32_t mb_kernel_text_offset = i - (mh_header_addr - mh_load_addr);\n\n\n\n        mh_entry_addr = ldl_p(header+i+28);\n\n        mb_kernel_size = get_file_size(f) - mb_kernel_text_offset;\n\n\n\n        /* Valid if mh_flags sets MULTIBOOT_HEADER_HAS_VBE.\n\n        uint32_t mh_mode_type = ldl_p(header+i+32);\n\n        uint32_t mh_width = ldl_p(header+i+36);\n\n        uint32_t mh_height = ldl_p(header+i+40);\n\n        uint32_t mh_depth = ldl_p(header+i+44); */\n\n\n\n#ifdef DEBUG_MULTIBOOT\n\n        fprintf(stderr, \"multiboot: mh_header_addr = %#x\\n\", mh_header_addr);\n\n        fprintf(stderr, \"multiboot: mh_load_addr = %#x\\n\", mh_load_addr);\n\n        fprintf(stderr, \"multiboot: mh_load_end_addr = %#x\\n\", mh_load_end_addr);\n\n        fprintf(stderr, \"multiboot: mh_bss_end_addr = %#x\\n\", mh_bss_end_addr);\n\n#endif\n\n\n\n        fseek(f, mb_kernel_text_offset, SEEK_SET);\n\n\n\n#ifdef DEBUG_MULTIBOOT\n\n        fprintf(stderr, \"qemu: loading multiboot kernel (%#x bytes) at %#x\\n\",\n\n                mb_kernel_size, mh_load_addr);\n\n#endif\n\n\n\n        if (!fread_targphys_ok(mh_load_addr, mb_kernel_size, f)) {\n\n            fprintf(stderr, \"qemu: read error on multiboot kernel '%s' (%#x)\\n\",\n\n                    kernel_filename, mb_kernel_size);\n\n            exit(1);\n\n        }\n\n        fclose(f);\n\n    }\n\n\n\n    /* blob size is only the kernel for now */\n\n    mb_mod_end = mh_load_addr + mb_kernel_size;\n\n\n\n    /* load modules */\n\n    stl_phys(mb_bootinfo + 20, 0x0); /* mods_count */\n\n    if (initrd_filename) {\n\n        uint32_t mb_mod_info = mb_bootinfo + 0x100;\n\n        uint32_t mb_mod_cmdline = mb_bootinfo + 0x300;\n\n        uint32_t mb_mod_start = mh_load_addr;\n\n        uint32_t mb_mod_length = mb_kernel_size;\n\n        char *next_initrd;\n\n        char *next_space;\n\n        int mb_mod_count = 0;\n\n\n\n        do {\n\n            next_initrd = strchr(initrd_filename, ',');\n\n            if (next_initrd)\n\n                *next_initrd = '\\0';\n\n            /* if a space comes after the module filename, treat everything\n\n               after that as parameters */\n\n            cpu_physical_memory_write(mb_mod_cmdline, (uint8_t*)initrd_filename,\n\n                                      strlen(initrd_filename) + 1);\n\n            stl_phys(mb_mod_info + 8, mb_mod_cmdline); /* string */\n\n            mb_mod_cmdline += strlen(initrd_filename) + 1;\n\n            if ((next_space = strchr(initrd_filename, ' ')))\n\n                *next_space = '\\0';\n\n#ifdef DEBUG_MULTIBOOT\n\n            printf(\"multiboot loading module: %s\\n\", initrd_filename);\n\n#endif\n\n            f = fopen(initrd_filename, \"rb\");\n\n            if (f) {\n\n                mb_mod_start = (mb_mod_start + mb_mod_length + (TARGET_PAGE_SIZE - 1))\n\n                             & (TARGET_PAGE_MASK);\n\n                mb_mod_length = get_file_size(f);\n\n                mb_mod_end = mb_mod_start + mb_mod_length;\n\n\n\n                if (!fread_targphys_ok(mb_mod_start, mb_mod_length, f)) {\n\n                    fprintf(stderr, \"qemu: read error on multiboot module '%s' (%#x)\\n\",\n\n                            initrd_filename, mb_mod_length);\n\n                    exit(1);\n\n                }\n\n\n\n                mb_mod_count++;\n\n                stl_phys(mb_mod_info + 0, mb_mod_start);\n\n                stl_phys(mb_mod_info + 4, mb_mod_start + mb_mod_length);\n\n#ifdef DEBUG_MULTIBOOT\n\n                printf(\"mod_start: %#x\\nmod_end:   %#x\\n\", mb_mod_start,\n\n                       mb_mod_start + mb_mod_length);\n\n#endif\n\n                stl_phys(mb_mod_info + 12, 0x0); /* reserved */\n\n            }\n\n            initrd_filename = next_initrd+1;\n\n            mb_mod_info += 16;\n\n        } while (next_initrd);\n\n        stl_phys(mb_bootinfo + 20, mb_mod_count); /* mods_count */\n\n        stl_phys(mb_bootinfo + 24, mb_bootinfo + 0x100); /* mods_addr */\n\n    }\n\n\n\n    /* Make sure we're getting kernel + modules back after reset */\n\n    option_rom_setup_reset(mh_load_addr, mb_mod_end - mh_load_addr);\n\n\n\n    /* Commandline support */\n\n    stl_phys(mb_bootinfo + 16, mb_cmdline);\n\n    t = strlen(kernel_filename);\n\n    cpu_physical_memory_write(mb_cmdline, (uint8_t*)kernel_filename, t);\n\n    mb_cmdline += t;\n\n    stb_phys(mb_cmdline++, ' ');\n\n    t = strlen(kernel_cmdline) + 1;\n\n    cpu_physical_memory_write(mb_cmdline, (uint8_t*)kernel_cmdline, t);\n\n\n\n    /* the kernel is where we want it to be now */\n\n\n\n#define MULTIBOOT_FLAGS_MEMORY (1 << 0)\n\n#define MULTIBOOT_FLAGS_BOOT_DEVICE (1 << 1)\n\n#define MULTIBOOT_FLAGS_CMDLINE (1 << 2)\n\n#define MULTIBOOT_FLAGS_MODULES (1 << 3)\n\n#define MULTIBOOT_FLAGS_MMAP (1 << 6)\n\n    stl_phys(mb_bootinfo, MULTIBOOT_FLAGS_MEMORY\n\n                        | MULTIBOOT_FLAGS_BOOT_DEVICE\n\n                        | MULTIBOOT_FLAGS_CMDLINE\n\n                        | MULTIBOOT_FLAGS_MODULES\n\n                        | MULTIBOOT_FLAGS_MMAP);\n\n    stl_phys(mb_bootinfo + 4, 640); /* mem_lower */\n\n    stl_phys(mb_bootinfo + 8, ram_size / 1024); /* mem_upper */\n\n    stl_phys(mb_bootinfo + 12, 0x8001ffff); /* XXX: use the -boot switch? */\n\n    stl_phys(mb_bootinfo + 48, mmap_addr); /* mmap_addr */\n\n\n\n#ifdef DEBUG_MULTIBOOT\n\n    fprintf(stderr, \"multiboot: mh_entry_addr = %#x\\n\", mh_entry_addr);\n\n#endif\n\n\n\n    /* Pass variables to option rom */\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, mh_entry_addr);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, mb_bootinfo);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, mmap_addr);\n\n\n\n    /* Make sure we're getting the config space back after reset */\n\n    option_rom_setup_reset(mb_bootinfo, 0x500);\n\n\n\n    option_rom[nb_option_roms] = \"multiboot.bin\";\n\n    nb_option_roms++;\n\n\n\n    return 1; /* yes, we are multiboot */\n\n}\n", "idx": 13595}
{"project": "FFmpeg", "commit_id": "87eebb3454ff0cd6af6ebf9e1d31bdfd1c3b601b", "target": 0, "func": "const uint8_t *ff_h264_decode_nal(H264Context *h, const uint8_t *src, int *dst_length, int *consumed, int length){\n\n    int i, si, di;\n\n    uint8_t *dst;\n\n    int bufidx;\n\n\n\n//    src[0]&0x80;                //forbidden bit\n\n    h->nal_ref_idc= src[0]>>5;\n\n    h->nal_unit_type= src[0]&0x1F;\n\n\n\n    src++; length--;\n\n\n\n#if HAVE_FAST_UNALIGNED\n\n# if HAVE_FAST_64BIT\n\n#   define RS 7\n\n    for(i=0; i+1<length; i+=9){\n\n        if(!((~AV_RN64A(src+i) & (AV_RN64A(src+i) - 0x0100010001000101ULL)) & 0x8000800080008080ULL))\n\n# else\n\n#   define RS 3\n\n    for(i=0; i+1<length; i+=5){\n\n        if(!((~AV_RN32A(src+i) & (AV_RN32A(src+i) - 0x01000101U)) & 0x80008080U))\n\n# endif\n\n            continue;\n\n        if(i>0 && !src[i]) i--;\n\n        while(src[i]) i++;\n\n#else\n\n#   define RS 0\n\n    for(i=0; i+1<length; i+=2){\n\n        if(src[i]) continue;\n\n        if(i>0 && src[i-1]==0) i--;\n\n#endif\n\n        if(i+2<length && src[i+1]==0 && src[i+2]<=3){\n\n            if(src[i+2]!=3){\n\n                /* startcode, so we must be past the end */\n\n                length=i;\n\n            }\n\n            break;\n\n        }\n\n        i-= RS;\n\n    }\n\n\n\n    if(i>=length-1){ //no escaped 0\n\n        *dst_length= length;\n\n        *consumed= length+1; //+1 for the header\n\n        return src;\n\n    }\n\n\n\n    bufidx = h->nal_unit_type == NAL_DPC ? 1 : 0; // use second escape buffer for inter data\n\n    av_fast_malloc(&h->rbsp_buffer[bufidx], &h->rbsp_buffer_size[bufidx], length+FF_INPUT_BUFFER_PADDING_SIZE);\n\n    dst= h->rbsp_buffer[bufidx];\n\n\n\n    if (dst == NULL){\n\n        return NULL;\n\n    }\n\n\n\n//printf(\"decoding esc\\n\");\n\n    memcpy(dst, src, i);\n\n    si=di=i;\n\n    while(si+2<length){\n\n        //remove escapes (very rare 1:2^22)\n\n        if(src[si+2]>3){\n\n            dst[di++]= src[si++];\n\n            dst[di++]= src[si++];\n\n        }else if(src[si]==0 && src[si+1]==0){\n\n            if(src[si+2]==3){ //escape\n\n                dst[di++]= 0;\n\n                dst[di++]= 0;\n\n                si+=3;\n\n                continue;\n\n            }else //next start code\n\n                goto nsc;\n\n        }\n\n\n\n        dst[di++]= src[si++];\n\n    }\n\n    while(si<length)\n\n        dst[di++]= src[si++];\n\nnsc:\n\n\n\n    memset(dst+di, 0, FF_INPUT_BUFFER_PADDING_SIZE);\n\n\n\n    *dst_length= di;\n\n    *consumed= si + 1;//+1 for the header\n\n//FIXME store exact number of bits in the getbitcontext (it is needed for decoding)\n\n    return dst;\n\n}\n", "idx": 13683}
{"project": "qemu", "commit_id": "94d81ae896810beafa60c85b88e991daa986e1fc", "target": 1, "func": "static void quit_handler(int sig)\n{\n    /* if we're frozen, don't exit unless we're absolutely forced to,\n     * because it's basically impossible for graceful exit to complete\n     * unless all log/pid files are on unfreezable filesystems. there's\n     * also a very likely chance killing the agent before unfreezing\n     * the filesystems is a mistake (or will be viewed as one later).\n     */\n    if (ga_is_frozen(ga_state)) {\n        return;\n    g_debug(\"received signal num %d, quitting\", sig);\n    if (g_main_loop_is_running(ga_state->main_loop)) {\n        g_main_loop_quit(ga_state->main_loop);", "idx": 13713}
{"project": "qemu", "commit_id": "61a5872fd66be718ad022102bf813d7e4e9324c5", "target": 1, "func": "static int tcp_close(MigrationState *s)\n\n{\n\n    DPRINTF(\"tcp_close\\n\");\n\n    if (s->fd != -1) {\n\n        close(s->fd);\n\n        s->fd = -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 13714}
{"project": "FFmpeg", "commit_id": "1dd488e9559bbe411c6933fd8ff02450a4b3be7e", "target": 0, "func": "static void hl_decode_mb(H264Context *h){\n\n    MpegEncContext * const s = &h->s;\n\n    const int mb_xy= h->mb_xy;\n\n    const int mb_type= s->current_picture.mb_type[mb_xy];\n\n    int is_complex = h->is_complex || IS_INTRA_PCM(mb_type) || s->qscale == 0;\n\n\n\n    if(ENABLE_H264_ENCODER && !s->decode)\n\n        return;\n\n\n\n    if (is_complex)\n\n        hl_decode_mb_complex(h);\n\n    else hl_decode_mb_simple(h);\n\n}\n", "idx": 13833}
{"project": "FFmpeg", "commit_id": "465e1dadbef7596a3eb87089a66bb4ecdc26d3c4", "target": 0, "func": "static void flush_buffer(ByteIOContext *s)\n\n{\n\n    if (s->buf_ptr > s->buffer) {\n\n        if (s->write_packet)\n\n            s->write_packet(s->opaque, s->buffer, s->buf_ptr - s->buffer);\n\n        if(s->checksum_ptr){\n\n            s->checksum= s->update_checksum(s->checksum, s->checksum_ptr, s->buf_ptr - s->checksum_ptr);\n\n            s->checksum_ptr= s->buffer;\n\n        }\n\n        s->pos += s->buf_ptr - s->buffer;\n\n    }\n\n    s->buf_ptr = s->buffer;\n\n}\n", "idx": 13893}
{"project": "FFmpeg", "commit_id": "679a315424e6ffaafd21ebf7a86108bd4e743793", "target": 1, "func": "static int daala_packet(AVFormatContext *s, int idx)\n\n{\n\n    int seg, duration = 1;\n\n    struct ogg *ogg = s->priv_data;\n\n    struct ogg_stream *os = ogg->streams + idx;\n\n\n\n    /*\n\n     * first packet handling: here we parse the duration of each packet in the\n\n     * first page and compare the total duration to the page granule to find the\n\n     * encoder delay and set the first timestamp\n\n     */\n\n\n\n    if ((!os->lastpts || os->lastpts == AV_NOPTS_VALUE) && !(os->flags & OGG_FLAG_EOS)) {\n\n        for (seg = os->segp; seg < os->nsegs; seg++)\n\n            if (os->segments[seg] < 255)\n\n                duration++;\n\n\n\n        os->lastpts = os->lastdts = daala_gptopts(s, idx, os->granule, NULL) - duration;\n\n        if(s->streams[idx]->start_time == AV_NOPTS_VALUE) {\n\n            s->streams[idx]->start_time = os->lastpts;\n\n            if (s->streams[idx]->duration)\n\n                s->streams[idx]->duration -= s->streams[idx]->start_time;\n\n        }\n\n    }\n\n\n\n    /* parse packet duration */\n\n    if (os->psize > 0)\n\n        os->pduration = 1;\n\n\n\n    return 0;\n\n}\n", "idx": 13914}
{"project": "qemu", "commit_id": "b2f56462d51a49c28d2a7b214b3ae8e8d3329f1f", "target": 0, "func": "static int coroutine_fn backup_do_cow(BlockDriverState *bs,\n\n                                      int64_t sector_num, int nb_sectors,\n\n                                      bool *error_is_read,\n\n                                      bool is_write_notifier)\n\n{\n\n    BackupBlockJob *job = (BackupBlockJob *)bs->job;\n\n    CowRequest cow_request;\n\n    struct iovec iov;\n\n    QEMUIOVector bounce_qiov;\n\n    void *bounce_buffer = NULL;\n\n    int ret = 0;\n\n    int64_t sectors_per_cluster = cluster_size_sectors(job);\n\n    int64_t start, end;\n\n    int n;\n\n\n\n    qemu_co_rwlock_rdlock(&job->flush_rwlock);\n\n\n\n    start = sector_num / sectors_per_cluster;\n\n    end = DIV_ROUND_UP(sector_num + nb_sectors, sectors_per_cluster);\n\n\n\n    trace_backup_do_cow_enter(job, start, sector_num, nb_sectors);\n\n\n\n    wait_for_overlapping_requests(job, start, end);\n\n    cow_request_begin(&cow_request, job, start, end);\n\n\n\n    for (; start < end; start++) {\n\n        if (hbitmap_get(job->bitmap, start)) {\n\n            trace_backup_do_cow_skip(job, start);\n\n            continue; /* already copied */\n\n        }\n\n\n\n        trace_backup_do_cow_process(job, start);\n\n\n\n        n = MIN(sectors_per_cluster,\n\n                job->common.len / BDRV_SECTOR_SIZE -\n\n                start * sectors_per_cluster);\n\n\n\n        if (!bounce_buffer) {\n\n            bounce_buffer = qemu_blockalign(bs, job->cluster_size);\n\n        }\n\n        iov.iov_base = bounce_buffer;\n\n        iov.iov_len = n * BDRV_SECTOR_SIZE;\n\n        qemu_iovec_init_external(&bounce_qiov, &iov, 1);\n\n\n\n        if (is_write_notifier) {\n\n            ret = bdrv_co_readv_no_serialising(bs,\n\n                                           start * sectors_per_cluster,\n\n                                           n, &bounce_qiov);\n\n        } else {\n\n            ret = bdrv_co_readv(bs, start * sectors_per_cluster, n,\n\n                                &bounce_qiov);\n\n        }\n\n        if (ret < 0) {\n\n            trace_backup_do_cow_read_fail(job, start, ret);\n\n            if (error_is_read) {\n\n                *error_is_read = true;\n\n            }\n\n            goto out;\n\n        }\n\n\n\n        if (buffer_is_zero(iov.iov_base, iov.iov_len)) {\n\n            ret = bdrv_co_write_zeroes(job->target,\n\n                                       start * sectors_per_cluster,\n\n                                       n, BDRV_REQ_MAY_UNMAP);\n\n        } else {\n\n            ret = bdrv_co_writev(job->target,\n\n                                 start * sectors_per_cluster, n,\n\n                                 &bounce_qiov);\n\n        }\n\n        if (ret < 0) {\n\n            trace_backup_do_cow_write_fail(job, start, ret);\n\n            if (error_is_read) {\n\n                *error_is_read = false;\n\n            }\n\n            goto out;\n\n        }\n\n\n\n        hbitmap_set(job->bitmap, start, 1);\n\n\n\n        /* Publish progress, guest I/O counts as progress too.  Note that the\n\n         * offset field is an opaque progress value, it is not a disk offset.\n\n         */\n\n        job->sectors_read += n;\n\n        job->common.offset += n * BDRV_SECTOR_SIZE;\n\n    }\n\n\n\nout:\n\n    if (bounce_buffer) {\n\n        qemu_vfree(bounce_buffer);\n\n    }\n\n\n\n    cow_request_end(&cow_request);\n\n\n\n    trace_backup_do_cow_return(job, sector_num, nb_sectors, ret);\n\n\n\n    qemu_co_rwlock_unlock(&job->flush_rwlock);\n\n\n\n    return ret;\n\n}\n", "idx": 14088}
{"project": "FFmpeg", "commit_id": "e8f814a907036e43f755f35e885bfadf94c4d63b", "target": 1, "func": "AVRational av_guess_frame_rate(AVFormatContext *format, AVStream *st, AVFrame *frame)\n\n{\n\n    AVRational fr = st->r_frame_rate;\n\n    AVRational codec_fr = st->codec->framerate;\n\n    AVRational   avg_fr = st->avg_frame_rate;\n\n\n\n    if (avg_fr.num > 0 && avg_fr.den > 0 && fr.num > 0 && fr.den > 0 &&\n\n        av_q2d(avg_fr) < 70 && av_q2d(fr) > 210) {\n\n        fr = avg_fr;\n\n    }\n\n\n\n\n\n    if (st->codec->ticks_per_frame > 1) {\n\n        if (   codec_fr.num > 0 && codec_fr.den > 0 && av_q2d(codec_fr) < av_q2d(fr)*0.7\n\n            && fabs(1.0 - av_q2d(av_div_q(avg_fr, fr))) > 0.1)\n\n            fr = codec_fr;\n\n    }\n\n\n\n    return fr;\n\n}\n", "idx": 14180}
{"project": "FFmpeg", "commit_id": "01ecb7172b684f1c4b3e748f95c5a9a494ca36ec", "target": 1, "func": "static void apply_mid_side_stereo(ChannelElement *cpe)\n\n{\n\n    int w, w2, g, i;\n\n    IndividualChannelStream *ics = &cpe->ch[0].ics;\n\n    if (!cpe->common_window)\n\n        return;\n\n    for (w = 0; w < ics->num_windows; w += ics->group_len[w]) {\n\n        for (w2 =  0; w2 < ics->group_len[w]; w2++) {\n\n            int start = (w+w2) * 128;\n\n            for (g = 0; g < ics->num_swb; g++) {\n\n                if (!cpe->ms_mask[w*16 + g]) {\n\n                    start += ics->swb_sizes[g];\n\n                    continue;\n\n                }\n\n                for (i = 0; i < ics->swb_sizes[g]; i++) {\n\n                    float L = (cpe->ch[0].coeffs[start+i] + cpe->ch[1].coeffs[start+i]) * 0.5f;\n\n                    float R = L - cpe->ch[1].coeffs[start+i];\n\n                    cpe->ch[0].coeffs[start+i] = L;\n\n                    cpe->ch[1].coeffs[start+i] = R;\n\n                }\n\n                start += ics->swb_sizes[g];\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 14192}
{"project": "qemu", "commit_id": "6fc76aa9adc1c8896a97059f12a1e5e6c1820c64", "target": 0, "func": "static int ppc_hash32_get_bat(CPUPPCState *env, struct mmu_ctx_hash32 *ctx,\n\n                              target_ulong virtual, int rwx)\n\n{\n\n    target_ulong *BATlt, *BATut;\n\n    target_ulong BEPIl, BEPIu, bl;\n\n    int i, valid, prot;\n\n    int ret = -1;\n\n\n\n    LOG_BATS(\"%s: %cBAT v \" TARGET_FMT_lx \"\\n\", __func__,\n\n             rwx == 2 ? 'I' : 'D', virtual);\n\n    if (rwx == 2) {\n\n        BATlt = env->IBAT[1];\n\n        BATut = env->IBAT[0];\n\n    } else {\n\n        BATlt = env->DBAT[1];\n\n        BATut = env->DBAT[0];\n\n    }\n\n    for (i = 0; i < env->nb_BATs; i++) {\n\n        target_ulong batu = BATut[i];\n\n        target_ulong batl = BATlt[i];\n\n\n\n        BEPIu = batu & BATU32_BEPIU;\n\n        BEPIl = batu & BATU32_BEPIL;\n\n        if (unlikely(env->mmu_model == POWERPC_MMU_601)) {\n\n            hash32_bat_601_size(env, &bl, &valid, batu, batl);\n\n            prot = hash32_bat_601_prot(env, batu, batl);\n\n        } else {\n\n            hash32_bat_size(env, &bl, &valid, batu, batl);\n\n            prot = hash32_bat_prot(env, batu, batl);\n\n        }\n\n        LOG_BATS(\"%s: %cBAT%d v \" TARGET_FMT_lx \" BATu \" TARGET_FMT_lx\n\n                 \" BATl \" TARGET_FMT_lx \"\\n\", __func__,\n\n                 type == ACCESS_CODE ? 'I' : 'D', i, virtual, batu, batl);\n\n        if ((virtual & BATU32_BEPIU) == BEPIu &&\n\n            ((virtual & BATU32_BEPIL) & ~bl) == BEPIl) {\n\n            /* BAT matches */\n\n            if (valid != 0) {\n\n                /* Get physical address */\n\n                ctx->raddr = (batl & BATL32_BRPNU) |\n\n                    ((virtual & BATU32_BEPIL & bl) | (batl & BATL32_BRPNL)) |\n\n                    (virtual & 0x0001F000);\n\n                /* Compute access rights */\n\n                ctx->prot = prot;\n\n                ret = ppc_hash32_check_prot(ctx->prot, rwx);\n\n                if (ret == 0) {\n\n                    LOG_BATS(\"BAT %d match: r \" TARGET_FMT_plx \" prot=%c%c\\n\",\n\n                             i, ctx->raddr, ctx->prot & PAGE_READ ? 'R' : '-',\n\n                             ctx->prot & PAGE_WRITE ? 'W' : '-');\n\n                }\n\n                break;\n\n            }\n\n        }\n\n    }\n\n    if (ret < 0) {\n\n#if defined(DEBUG_BATS)\n\n        if (qemu_log_enabled()) {\n\n            LOG_BATS(\"no BAT match for \" TARGET_FMT_lx \":\\n\", virtual);\n\n            for (i = 0; i < 4; i++) {\n\n                BATu = &BATut[i];\n\n                BATl = &BATlt[i];\n\n                BEPIu = *BATu & BATU32_BEPIU;\n\n                BEPIl = *BATu & BATU32_BEPIL;\n\n                bl = (*BATu & 0x00001FFC) << 15;\n\n                LOG_BATS(\"%s: %cBAT%d v \" TARGET_FMT_lx \" BATu \" TARGET_FMT_lx\n\n                         \" BATl \" TARGET_FMT_lx \"\\n\\t\" TARGET_FMT_lx \" \"\n\n                         TARGET_FMT_lx \" \" TARGET_FMT_lx \"\\n\",\n\n                         __func__, type == ACCESS_CODE ? 'I' : 'D', i, virtual,\n\n                         *BATu, *BATl, BEPIu, BEPIl, bl);\n\n            }\n\n        }\n\n#endif\n\n    }\n\n    /* No hit */\n\n    return ret;\n\n}\n", "idx": 14214}
{"project": "FFmpeg", "commit_id": "c9ff32215b433d505f251c1f212b1fa0a5e17b73", "target": 0, "func": "static int set_format(void *obj, const char *name, int fmt, int search_flags,\n\n                      enum AVOptionType type, const char *desc, int max)\n\n{\n\n    void *target_obj;\n\n    const AVOption *o = av_opt_find2(obj, name, NULL, 0,\n\n                                     search_flags, &target_obj);\n\n    if (!o || !target_obj)\n\n        return AVERROR_OPTION_NOT_FOUND;\n\n    if (o->type != type) {\n\n        av_log(obj, AV_LOG_ERROR,\n\n               \"The value set by option '%s' is not a %s format\", name, desc);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if (fmt < -1 || fmt > max) {\n\n        av_log(obj, AV_LOG_ERROR,\n\n               \"Value %d for parameter '%s' out of %s format range [-1 - %d]\\n\",\n\n               fmt, name, desc, max);\n\n        return AVERROR(ERANGE);\n\n    }\n\n    *(int *)(((uint8_t *)target_obj) + o->offset) = fmt;\n\n    return 0;\n\n}\n", "idx": 14240}
{"project": "qemu", "commit_id": "7bb6edb0e3dd78d74e0ac980cf6c0a07307f61bf", "target": 1, "func": "static int virtio_rng_device_exit(DeviceState *qdev)\n\n{\n\n    VirtIORNG *vrng = VIRTIO_RNG(qdev);\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(qdev);\n\n\n\n    timer_del(vrng->rate_limit_timer);\n\n    timer_free(vrng->rate_limit_timer);\n\n    unregister_savevm(qdev, \"virtio-rng\", vrng);\n\n    virtio_cleanup(vdev);\n\n    return 0;\n\n}\n", "idx": 14312}
{"project": "qemu", "commit_id": "baa61b9870dd7e0bb07e0ae61c6ec805db13f699", "target": 1, "func": "static void virtio_balloon_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);\n\n    dc->exit = virtio_balloon_device_exit;\n\n    dc->props = virtio_balloon_properties;\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n    vdc->init = virtio_balloon_device_init;\n\n    vdc->get_config = virtio_balloon_get_config;\n\n    vdc->set_config = virtio_balloon_set_config;\n\n    vdc->get_features = virtio_balloon_get_features;\n\n}\n", "idx": 14360}
{"project": "qemu", "commit_id": "1d5b8d770d1215b41ae32c881984b1d048b2f932", "target": 1, "func": "static KeyValue *copy_key_value(KeyValue *src)\n\n{\n\n    KeyValue *dst = g_new(KeyValue, 1);\n\n    memcpy(dst, src, sizeof(*src));\n\n\n\n\n\n\n    return dst;\n", "idx": 14367}
{"project": "qemu", "commit_id": "2399d4e7cec22ecf1c51062d2ebfd45220dbaace", "target": 0, "func": "static void gen_nop_hint(DisasContext *s, int val)\n\n{\n\n    switch (val) {\n\n    case 1: /* yield */\n\n        if (!parallel_cpus) {\n\n            gen_set_pc_im(s, s->pc);\n\n            s->base.is_jmp = DISAS_YIELD;\n\n        }\n\n        break;\n\n    case 3: /* wfi */\n\n        gen_set_pc_im(s, s->pc);\n\n        s->base.is_jmp = DISAS_WFI;\n\n        break;\n\n    case 2: /* wfe */\n\n        if (!parallel_cpus) {\n\n            gen_set_pc_im(s, s->pc);\n\n            s->base.is_jmp = DISAS_WFE;\n\n        }\n\n        break;\n\n    case 4: /* sev */\n\n    case 5: /* sevl */\n\n        /* TODO: Implement SEV, SEVL and WFE.  May help SMP performance.  */\n\n    default: /* nop */\n\n        break;\n\n    }\n\n}\n", "idx": 14396}
{"project": "FFmpeg", "commit_id": "8992029fc0a4dd9df16f8cb46cfb641c98fc9f6c", "target": 0, "func": "static int g729_parse(AVCodecParserContext *s1, AVCodecContext *avctx,\n\n                     const uint8_t **poutbuf, int *poutbuf_size,\n\n                     const uint8_t *buf, int buf_size)\n\n{\n\n    G729ParseContext *s = s1->priv_data;\n\n    ParseContext *pc = &s->pc;\n\n    int next;\n\n\n\n    if (!s->block_size) {\n\n        switch (avctx->codec_id) {\n\n        case AV_CODEC_ID_G729:\n\n            /* FIXME: replace this heuristic block_size with more precise estimate */\n\n            s->block_size = (avctx->bit_rate < 8000) ? G729D_6K4_BLOCK_SIZE : G729_8K_BLOCK_SIZE;\n\n            s->duration   = avctx->frame_size;\n\n            break;\n\n        default:\n\n            *poutbuf      = buf;\n\n            *poutbuf_size = buf_size;\n\n            av_log(avctx, AV_LOG_ERROR, \"Invalid codec_id\\n\");\n\n            return buf_size;\n\n        }\n\n    }\n\n\n\n    if (!s->remaining)\n\n        s->remaining = s->block_size;\n\n    if (s->remaining <= buf_size) {\n\n        next = s->remaining;\n\n        s->remaining = 0;\n\n    } else {\n\n        next = END_NOT_FOUND;\n\n        s->remaining -= buf_size;\n\n    }\n\n\n\n    if (ff_combine_frame(pc, next, &buf, &buf_size) < 0 || !buf_size) {\n\n        *poutbuf      = NULL;\n\n        *poutbuf_size = 0;\n\n        return buf_size;\n\n    }\n\n\n\n    s1->duration = s->duration;\n\n\n\n    *poutbuf      = buf;\n\n    *poutbuf_size = buf_size;\n\n    return next;\n\n}\n", "idx": 14509}
{"project": "FFmpeg", "commit_id": "57d77b3963ce1023eaf5ada8cba58b9379405cc8", "target": 0, "func": "int av_opencl_buffer_write_image(cl_mem dst_cl_buf, size_t cl_buffer_size, int dst_cl_offset,\n\n                                                    uint8_t **src_data, int *plane_size, int plane_num)\n\n{\n\n    int i, buffer_size = 0;\n\n    uint8_t *temp;\n\n    cl_int status;\n\n    void *mapped;\n\n    if ((unsigned int)plane_num > 8) {\n\n        return AVERROR(EINVAL);\n\n    }\n\n    for (i = 0;i < plane_num;i++) {\n\n        buffer_size += plane_size[i];\n\n    }\n\n    if (buffer_size > cl_buffer_size) {\n\n        av_log(&openclutils, AV_LOG_ERROR, \"Cannot write image to OpenCL buffer: buffer too small\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n    mapped = clEnqueueMapBuffer(gpu_env.command_queue, dst_cl_buf,\n\n                                      CL_TRUE,CL_MAP_WRITE, 0, buffer_size + dst_cl_offset,\n\n                                      0, NULL, NULL, &status);\n\n    if (status != CL_SUCCESS) {\n\n        av_log(&openclutils, AV_LOG_ERROR, \"Could not map OpenCL buffer: %s\\n\", opencl_errstr(status));\n\n        return AVERROR_EXTERNAL;\n\n    }\n\n    temp = mapped;\n\n    temp += dst_cl_offset;\n\n    for (i = 0; i < plane_num; i++) {\n\n        memcpy(temp, src_data[i], plane_size[i]);\n\n        temp += plane_size[i];\n\n    }\n\n    status = clEnqueueUnmapMemObject(gpu_env.command_queue, dst_cl_buf, mapped, 0, NULL, NULL);\n\n    if (status != CL_SUCCESS) {\n\n        av_log(&openclutils, AV_LOG_ERROR, \"Could not unmap OpenCL buffer: %s\\n\", opencl_errstr(status));\n\n        return AVERROR_EXTERNAL;\n\n    }\n\n    return 0;\n\n}\n", "idx": 14622}
{"project": "FFmpeg", "commit_id": "3518925a9127e368b6d0c7e8fd86510d34af40a1", "target": 1, "func": "static int mov_create_timecode_track(AVFormatContext *s, int index, int src_index, const char *tcstr)\n\n{\n\n    int ret;\n\n    MOVMuxContext *mov  = s->priv_data;\n\n    MOVTrack *track     = &mov->tracks[index];\n\n    AVStream *src_st    = s->streams[src_index];\n\n    AVTimecode tc;\n\n    AVPacket pkt    = {.stream_index = index, .flags = AV_PKT_FLAG_KEY, .size = 4};\n\n    AVRational rate = find_fps(s, src_st);\n\n\n\n    /* compute the frame number */\n\n    ret = av_timecode_init_from_string(&tc, rate, tcstr, s);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    /* tmcd track based on video stream */\n\n    track->mode      = mov->mode;\n\n    track->tag       = MKTAG('t','m','c','d');\n\n    track->src_track = src_index;\n\n    track->timescale = mov->tracks[src_index].timescale;\n\n    if (tc.flags & AV_TIMECODE_FLAG_DROPFRAME)\n\n        track->timecode_flags |= MOV_TIMECODE_FLAG_DROPFRAME;\n\n\n\n    /* set st to src_st for metadata access*/\n\n    track->st = src_st;\n\n\n\n    /* encode context: tmcd data stream */\n\n    track->enc = avcodec_alloc_context3(NULL);\n\n\n\n    track->enc->codec_type = AVMEDIA_TYPE_DATA;\n\n    track->enc->codec_tag  = track->tag;\n\n    track->enc->time_base  = av_inv_q(rate);\n\n\n\n    /* the tmcd track just contains one packet with the frame number */\n\n    pkt.data = av_malloc(pkt.size);\n\n\n\n    AV_WB32(pkt.data, tc.start);\n\n    ret = ff_mov_write_packet(s, &pkt);\n\n    av_free(pkt.data);\n\n    return ret;\n\n}", "idx": 14653}
{"project": "FFmpeg", "commit_id": "956472a3236cc8eaeba5147c55b51bde6005c898", "target": 1, "func": "static int rv40_decode_intra_types(RV34DecContext *r, GetBitContext *gb, int8_t *dst)\n\n{\n\n    MpegEncContext *s = &r->s;\n\n    int i, j, k, v;\n\n    int A, B, C;\n\n    int pattern;\n\n    int8_t *ptr;\n\n\n\n    for(i = 0; i < 4; i++, dst += r->intra_types_stride){\n\n        if(!i && s->first_slice_line){\n\n            pattern = get_vlc2(gb, aic_top_vlc.table, AIC_TOP_BITS, 1);\n\n            dst[0] = (pattern >> 2) & 2;\n\n            dst[1] = (pattern >> 1) & 2;\n\n            dst[2] =  pattern       & 2;\n\n            dst[3] = (pattern << 1) & 2;\n\n            continue;\n\n        }\n\n        ptr = dst;\n\n        for(j = 0; j < 4; j++){\n\n            /* Coefficients are read using VLC chosen by the prediction pattern\n\n             * The first one (used for retrieving a pair of coefficients) is\n\n             * constructed from the top, top right and left coefficients\n\n             * The second one (used for retrieving only one coefficient) is\n\n             * top + 10 * left.\n\n             */\n\n            A = ptr[-r->intra_types_stride + 1]; // it won't be used for the last coefficient in a row\n\n            B = ptr[-r->intra_types_stride];\n\n            C = ptr[-1];\n\n            pattern = A + (B << 4) + (C << 8);\n\n            for(k = 0; k < MODE2_PATTERNS_NUM; k++)\n\n                if(pattern == rv40_aic_table_index[k])\n\n                    break;\n\n            if(j < 3 && k < MODE2_PATTERNS_NUM){ //pattern is found, decoding 2 coefficients\n\n                v = get_vlc2(gb, aic_mode2_vlc[k].table, AIC_MODE2_BITS, 2);\n\n                *ptr++ = v/9;\n\n                *ptr++ = v%9;\n\n                j++;\n\n            }else{\n\n                if(B != -1 && C != -1)\n\n                    v = get_vlc2(gb, aic_mode1_vlc[B + C*10].table, AIC_MODE1_BITS, 1);\n\n                else{ // tricky decoding\n\n                    v = 0;\n\n                    switch(C){\n\n                    case -1: // code 0 -> 1, 1 -> 0\n\n                        if(B < 2)\n\n                            v = get_bits1(gb) ^ 1;\n\n                        break;\n\n                    case  0:\n\n                    case  2: // code 0 -> 2, 1 -> 0\n\n                        v = (get_bits1(gb) ^ 1) << 1;\n\n                        break;\n\n                    }\n\n                }\n\n                *ptr++ = v;\n\n            }\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 14657}
{"project": "qemu", "commit_id": "010ec6293409f10b88631c36145944b9c3277ce1", "target": 1, "func": "static void action_command(EEPRO100State *s)\n\n{\n\n    for (;;) {\n\n        bool bit_el;\n\n        bool bit_s;\n\n        bool bit_i;\n\n        bool bit_nc;\n\n        uint16_t ok_status = STATUS_OK;\n\n        s->cb_address = s->cu_base + s->cu_offset;\n\n        read_cb(s);\n\n        bit_el = ((s->tx.command & COMMAND_EL) != 0);\n\n        bit_s = ((s->tx.command & COMMAND_S) != 0);\n\n        bit_i = ((s->tx.command & COMMAND_I) != 0);\n\n        bit_nc = ((s->tx.command & COMMAND_NC) != 0);\n\n#if 0\n\n        bool bit_sf = ((s->tx.command & COMMAND_SF) != 0);\n\n#endif\n\n        s->cu_offset = s->tx.link;\n\n        TRACE(OTHER,\n\n              logout(\"val=(cu start), status=0x%04x, command=0x%04x, link=0x%08x\\n\",\n\n                     s->tx.status, s->tx.command, s->tx.link));\n\n        switch (s->tx.command & COMMAND_CMD) {\n\n        case CmdNOp:\n\n            /* Do nothing. */\n\n            break;\n\n        case CmdIASetup:\n\n            cpu_physical_memory_read(s->cb_address + 8, &s->conf.macaddr.a[0], 6);\n\n            TRACE(OTHER, logout(\"macaddr: %s\\n\", nic_dump(&s->conf.macaddr.a[0], 6)));\n\n            break;\n\n        case CmdConfigure:\n\n            cpu_physical_memory_read(s->cb_address + 8, &s->configuration[0],\n\n                                     sizeof(s->configuration));\n\n            TRACE(OTHER, logout(\"configuration: %s\\n\", nic_dump(&s->configuration[0], 16)));\n\n            break;\n\n        case CmdMulticastList:\n\n            set_multicast_list(s);\n\n            break;\n\n        case CmdTx:\n\n            if (bit_nc) {\n\n                missing(\"CmdTx: NC = 0\");\n\n                ok_status = 0;\n\n                break;\n\n            }\n\n            tx_command(s);\n\n            break;\n\n        case CmdTDR:\n\n            TRACE(OTHER, logout(\"load microcode\\n\"));\n\n            /* Starting with offset 8, the command contains\n\n             * 64 dwords microcode which we just ignore here. */\n\n            break;\n\n        case CmdDiagnose:\n\n            TRACE(OTHER, logout(\"diagnose\\n\"));\n\n            /* Make sure error flag is not set. */\n\n            s->tx.status = 0;\n\n            break;\n\n        default:\n\n            missing(\"undefined command\");\n\n            ok_status = 0;\n\n            break;\n\n        }\n\n        /* Write new status. */\n\n        stw_phys(s->cb_address, s->tx.status | ok_status | STATUS_C);\n\n        if (bit_i) {\n\n            /* CU completed action. */\n\n            eepro100_cx_interrupt(s);\n\n        }\n\n        if (bit_el) {\n\n            /* CU becomes idle. Terminate command loop. */\n\n            set_cu_state(s, cu_idle);\n\n            eepro100_cna_interrupt(s);\n\n            break;\n\n        } else if (bit_s) {\n\n            /* CU becomes suspended. Terminate command loop. */\n\n            set_cu_state(s, cu_suspended);\n\n            eepro100_cna_interrupt(s);\n\n            break;\n\n        } else {\n\n            /* More entries in list. */\n\n            TRACE(OTHER, logout(\"CU list with at least one more entry\\n\"));\n\n        }\n\n    }\n\n    TRACE(OTHER, logout(\"CU list empty\\n\"));\n\n    /* List is empty. Now CU is idle or suspended. */\n\n}\n", "idx": 14675}
{"project": "FFmpeg", "commit_id": "c8241e730f116f1c9cfc0b34110aa7f052e05332", "target": 0, "func": "static av_cold int vaapi_encode_h265_init(AVCodecContext *avctx)\n\n{\n\n    return ff_vaapi_encode_init(avctx, &vaapi_encode_type_h265);\n\n}\n", "idx": 14791}
{"project": "FFmpeg", "commit_id": "1acd7d594c15aa491729c837ad3519d3469e620a", "target": 0, "func": "static av_noinline void FUNC(hl_decode_mb)(H264Context *h)\n\n{\n\n    const int mb_x    = h->mb_x;\n\n    const int mb_y    = h->mb_y;\n\n    const int mb_xy   = h->mb_xy;\n\n    const int mb_type = h->cur_pic.f.mb_type[mb_xy];\n\n    uint8_t *dest_y, *dest_cb, *dest_cr;\n\n    int linesize, uvlinesize /*dct_offset*/;\n\n    int i, j;\n\n    int *block_offset = &h->block_offset[0];\n\n    const int transform_bypass = !SIMPLE && (h->qscale == 0 && h->sps.transform_bypass);\n\n    /* is_h264 should always be true if SVQ3 is disabled. */\n\n    const int is_h264 = !CONFIG_SVQ3_DECODER || SIMPLE || h->avctx->codec_id == AV_CODEC_ID_H264;\n\n    void (*idct_add)(uint8_t *dst, int16_t *block, int stride);\n\n    const int block_h   = 16 >> h->chroma_y_shift;\n\n    const int chroma422 = CHROMA422;\n\n\n\n    dest_y  = h->cur_pic.f.data[0] + ((mb_x << PIXEL_SHIFT)     + mb_y * h->linesize)  * 16;\n\n    dest_cb = h->cur_pic.f.data[1] +  (mb_x << PIXEL_SHIFT) * 8 + mb_y * h->uvlinesize * block_h;\n\n    dest_cr = h->cur_pic.f.data[2] +  (mb_x << PIXEL_SHIFT) * 8 + mb_y * h->uvlinesize * block_h;\n\n\n\n    h->vdsp.prefetch(dest_y  + (h->mb_x & 3) * 4 * h->linesize   + (64 << PIXEL_SHIFT), h->linesize,       4);\n\n    h->vdsp.prefetch(dest_cb + (h->mb_x & 7)     * h->uvlinesize + (64 << PIXEL_SHIFT), dest_cr - dest_cb, 2);\n\n\n\n    h->list_counts[mb_xy] = h->list_count;\n\n\n\n    if (!SIMPLE && MB_FIELD) {\n\n        linesize     = h->mb_linesize = h->linesize * 2;\n\n        uvlinesize   = h->mb_uvlinesize = h->uvlinesize * 2;\n\n        block_offset = &h->block_offset[48];\n\n        if (mb_y & 1) { // FIXME move out of this function?\n\n            dest_y  -= h->linesize * 15;\n\n            dest_cb -= h->uvlinesize * (block_h - 1);\n\n            dest_cr -= h->uvlinesize * (block_h - 1);\n\n        }\n\n        if (FRAME_MBAFF) {\n\n            int list;\n\n            for (list = 0; list < h->list_count; list++) {\n\n                if (!USES_LIST(mb_type, list))\n\n                    continue;\n\n                if (IS_16X16(mb_type)) {\n\n                    int8_t *ref = &h->ref_cache[list][scan8[0]];\n\n                    fill_rectangle(ref, 4, 4, 8, (16 + *ref) ^ (h->mb_y & 1), 1);\n\n                } else {\n\n                    for (i = 0; i < 16; i += 4) {\n\n                        int ref = h->ref_cache[list][scan8[i]];\n\n                        if (ref >= 0)\n\n                            fill_rectangle(&h->ref_cache[list][scan8[i]], 2, 2,\n\n                                           8, (16 + ref) ^ (h->mb_y & 1), 1);\n\n                    }\n\n                }\n\n            }\n\n        }\n\n    } else {\n\n        linesize   = h->mb_linesize   = h->linesize;\n\n        uvlinesize = h->mb_uvlinesize = h->uvlinesize;\n\n        // dct_offset = s->linesize * 16;\n\n    }\n\n\n\n    if (!SIMPLE && IS_INTRA_PCM(mb_type)) {\n\n        const int bit_depth = h->sps.bit_depth_luma;\n\n        if (PIXEL_SHIFT) {\n\n            int j;\n\n            GetBitContext gb;\n\n            init_get_bits(&gb, (uint8_t *)h->intra_pcm_ptr,\n\n                          ff_h264_mb_sizes[h->sps.chroma_format_idc] * bit_depth);\n\n\n\n            for (i = 0; i < 16; i++) {\n\n                uint16_t *tmp_y = (uint16_t *)(dest_y + i * linesize);\n\n                for (j = 0; j < 16; j++)\n\n                    tmp_y[j] = get_bits(&gb, bit_depth);\n\n            }\n\n            if (SIMPLE || !CONFIG_GRAY || !(h->flags & CODEC_FLAG_GRAY)) {\n\n                if (!h->sps.chroma_format_idc) {\n\n                    for (i = 0; i < block_h; i++) {\n\n                        uint16_t *tmp_cb = (uint16_t *)(dest_cb + i * uvlinesize);\n\n                        uint16_t *tmp_cr = (uint16_t *)(dest_cr + i * uvlinesize);\n\n                        for (j = 0; j < 8; j++) {\n\n                            tmp_cb[j] = tmp_cr[j] = 1 << (bit_depth - 1);\n\n                        }\n\n                    }\n\n                } else {\n\n                    for (i = 0; i < block_h; i++) {\n\n                        uint16_t *tmp_cb = (uint16_t *)(dest_cb + i * uvlinesize);\n\n                        for (j = 0; j < 8; j++)\n\n                            tmp_cb[j] = get_bits(&gb, bit_depth);\n\n                    }\n\n                    for (i = 0; i < block_h; i++) {\n\n                        uint16_t *tmp_cr = (uint16_t *)(dest_cr + i * uvlinesize);\n\n                        for (j = 0; j < 8; j++)\n\n                            tmp_cr[j] = get_bits(&gb, bit_depth);\n\n                    }\n\n                }\n\n            }\n\n        } else {\n\n            for (i = 0; i < 16; i++)\n\n                memcpy(dest_y + i * linesize, (uint8_t *)h->intra_pcm_ptr + i * 16, 16);\n\n            if (SIMPLE || !CONFIG_GRAY || !(h->flags & CODEC_FLAG_GRAY)) {\n\n                if (!h->sps.chroma_format_idc) {\n\n                    for (i = 0; i < 8; i++) {\n\n                        memset(dest_cb + i*uvlinesize, 1 << (bit_depth - 1), 8);\n\n                        memset(dest_cr + i*uvlinesize, 1 << (bit_depth - 1), 8);\n\n                    }\n\n                } else {\n\n                    uint8_t *src_cb = (uint8_t *)h->intra_pcm_ptr + 256;\n\n                    uint8_t *src_cr = (uint8_t *)h->intra_pcm_ptr + 256 + block_h * 8;\n\n                    for (i = 0; i < block_h; i++) {\n\n                        memcpy(dest_cb + i * uvlinesize, src_cb + i * 8, 8);\n\n                        memcpy(dest_cr + i * uvlinesize, src_cr + i * 8, 8);\n\n                    }\n\n                }\n\n            }\n\n        }\n\n    } else {\n\n        if (IS_INTRA(mb_type)) {\n\n            if (h->deblocking_filter)\n\n                xchg_mb_border(h, dest_y, dest_cb, dest_cr, linesize,\n\n                               uvlinesize, 1, 0, SIMPLE, PIXEL_SHIFT);\n\n\n\n            if (SIMPLE || !CONFIG_GRAY || !(h->flags & CODEC_FLAG_GRAY)) {\n\n                h->hpc.pred8x8[h->chroma_pred_mode](dest_cb, uvlinesize);\n\n                h->hpc.pred8x8[h->chroma_pred_mode](dest_cr, uvlinesize);\n\n            }\n\n\n\n            hl_decode_mb_predict_luma(h, mb_type, is_h264, SIMPLE,\n\n                                      transform_bypass, PIXEL_SHIFT,\n\n                                      block_offset, linesize, dest_y, 0);\n\n\n\n            if (h->deblocking_filter)\n\n                xchg_mb_border(h, dest_y, dest_cb, dest_cr, linesize,\n\n                               uvlinesize, 0, 0, SIMPLE, PIXEL_SHIFT);\n\n        } else if (is_h264) {\n\n            if (chroma422) {\n\n                FUNC(hl_motion_422)(h, dest_y, dest_cb, dest_cr,\n\n                              h->me.qpel_put, h->h264chroma.put_h264_chroma_pixels_tab,\n\n                              h->me.qpel_avg, h->h264chroma.avg_h264_chroma_pixels_tab,\n\n                              h->h264dsp.weight_h264_pixels_tab,\n\n                              h->h264dsp.biweight_h264_pixels_tab);\n\n            } else {\n\n                FUNC(hl_motion_420)(h, dest_y, dest_cb, dest_cr,\n\n                              h->me.qpel_put, h->h264chroma.put_h264_chroma_pixels_tab,\n\n                              h->me.qpel_avg, h->h264chroma.avg_h264_chroma_pixels_tab,\n\n                              h->h264dsp.weight_h264_pixels_tab,\n\n                              h->h264dsp.biweight_h264_pixels_tab);\n\n            }\n\n        }\n\n\n\n        hl_decode_mb_idct_luma(h, mb_type, is_h264, SIMPLE, transform_bypass,\n\n                               PIXEL_SHIFT, block_offset, linesize, dest_y, 0);\n\n\n\n        if ((SIMPLE || !CONFIG_GRAY || !(h->flags & CODEC_FLAG_GRAY)) &&\n\n            (h->cbp & 0x30)) {\n\n            uint8_t *dest[2] = { dest_cb, dest_cr };\n\n            if (transform_bypass) {\n\n                if (IS_INTRA(mb_type) && h->sps.profile_idc == 244 &&\n\n                    (h->chroma_pred_mode == VERT_PRED8x8 ||\n\n                     h->chroma_pred_mode == HOR_PRED8x8)) {\n\n                    h->hpc.pred8x8_add[h->chroma_pred_mode](dest[0],\n\n                                                            block_offset + 16,\n\n                                                            h->mb + (16 * 16 * 1 << PIXEL_SHIFT),\n\n                                                            uvlinesize);\n\n                    h->hpc.pred8x8_add[h->chroma_pred_mode](dest[1],\n\n                                                            block_offset + 32,\n\n                                                            h->mb + (16 * 16 * 2 << PIXEL_SHIFT),\n\n                                                            uvlinesize);\n\n                } else {\n\n                    idct_add = h->h264dsp.h264_add_pixels4;\n\n                    for (j = 1; j < 3; j++) {\n\n                        for (i = j * 16; i < j * 16 + 4; i++)\n\n                            if (h->non_zero_count_cache[scan8[i]] ||\n\n                                dctcoef_get(h->mb, PIXEL_SHIFT, i * 16))\n\n                                idct_add(dest[j - 1] + block_offset[i],\n\n                                         h->mb + (i * 16 << PIXEL_SHIFT),\n\n                                         uvlinesize);\n\n                        if (chroma422) {\n\n                            for (i = j * 16 + 4; i < j * 16 + 8; i++)\n\n                                if (h->non_zero_count_cache[scan8[i + 4]] ||\n\n                                    dctcoef_get(h->mb, PIXEL_SHIFT, i * 16))\n\n                                    idct_add(dest[j - 1] + block_offset[i + 4],\n\n                                             h->mb + (i * 16 << PIXEL_SHIFT),\n\n                                             uvlinesize);\n\n                        }\n\n                    }\n\n                }\n\n            } else {\n\n                if (is_h264) {\n\n                    int qp[2];\n\n                    if (chroma422) {\n\n                        qp[0] = h->chroma_qp[0] + 3;\n\n                        qp[1] = h->chroma_qp[1] + 3;\n\n                    } else {\n\n                        qp[0] = h->chroma_qp[0];\n\n                        qp[1] = h->chroma_qp[1];\n\n                    }\n\n                    if (h->non_zero_count_cache[scan8[CHROMA_DC_BLOCK_INDEX + 0]])\n\n                        h->h264dsp.h264_chroma_dc_dequant_idct(h->mb + (16 * 16 * 1 << PIXEL_SHIFT),\n\n                                                               h->dequant4_coeff[IS_INTRA(mb_type) ? 1 : 4][qp[0]][0]);\n\n                    if (h->non_zero_count_cache[scan8[CHROMA_DC_BLOCK_INDEX + 1]])\n\n                        h->h264dsp.h264_chroma_dc_dequant_idct(h->mb + (16 * 16 * 2 << PIXEL_SHIFT),\n\n                                                               h->dequant4_coeff[IS_INTRA(mb_type) ? 2 : 5][qp[1]][0]);\n\n                    h->h264dsp.h264_idct_add8(dest, block_offset,\n\n                                              h->mb, uvlinesize,\n\n                                              h->non_zero_count_cache);\n\n                } else if (CONFIG_SVQ3_DECODER) {\n\n                    h->h264dsp.h264_chroma_dc_dequant_idct(h->mb + 16 * 16 * 1,\n\n                                                           h->dequant4_coeff[IS_INTRA(mb_type) ? 1 : 4][h->chroma_qp[0]][0]);\n\n                    h->h264dsp.h264_chroma_dc_dequant_idct(h->mb + 16 * 16 * 2,\n\n                                                           h->dequant4_coeff[IS_INTRA(mb_type) ? 2 : 5][h->chroma_qp[1]][0]);\n\n                    for (j = 1; j < 3; j++) {\n\n                        for (i = j * 16; i < j * 16 + 4; i++)\n\n                            if (h->non_zero_count_cache[scan8[i]] || h->mb[i * 16]) {\n\n                                uint8_t *const ptr = dest[j - 1] + block_offset[i];\n\n                                ff_svq3_add_idct_c(ptr, h->mb + i * 16,\n\n                                                   uvlinesize,\n\n                                                   ff_h264_chroma_qp[0][h->qscale + 12] - 12, 2);\n\n                            }\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        if (h->cbp || IS_INTRA(mb_type)) {\n\n            h->dsp.clear_blocks(h->mb);\n\n            h->dsp.clear_blocks(h->mb + (24 * 16 << PIXEL_SHIFT));\n\n        }\n\n    }\n\n}\n", "idx": 14819}
{"project": "FFmpeg", "commit_id": "2df0c32ea12ddfa72ba88309812bfb13b674130f", "target": 0, "func": "static av_cold int mp3lame_encode_init(AVCodecContext *avctx)\n\n{\n\n    LAMEContext *s = avctx->priv_data;\n\n    int ret;\n\n\n\n    s->avctx = avctx;\n\n\n\n    /* initialize LAME and get defaults */\n\n    if (!(s->gfp = lame_init()))\n\n        return AVERROR(ENOMEM);\n\n\n\n    lame_set_num_channels(s->gfp, avctx->channels);\n\n    lame_set_mode(s->gfp, avctx->channels > 1 ? s->joint_stereo ? JOINT_STEREO : STEREO : MONO);\n\n\n\n    /* sample rate */\n\n    lame_set_in_samplerate (s->gfp, avctx->sample_rate);\n\n    lame_set_out_samplerate(s->gfp, avctx->sample_rate);\n\n\n\n    /* algorithmic quality */\n\n    if (avctx->compression_level == FF_COMPRESSION_DEFAULT)\n\n        lame_set_quality(s->gfp, 5);\n\n    else\n\n        lame_set_quality(s->gfp, avctx->compression_level);\n\n\n\n    /* rate control */\n\n    if (avctx->flags & CODEC_FLAG_QSCALE) { // VBR\n\n        lame_set_VBR(s->gfp, vbr_default);\n\n        lame_set_VBR_quality(s->gfp, avctx->global_quality / (float)FF_QP2LAMBDA);\n\n    } else {\n\n        if (avctx->bit_rate) {\n\n            if (s->abr) {                   // ABR\n\n                lame_set_VBR(s->gfp, vbr_abr);\n\n                lame_set_VBR_mean_bitrate_kbps(s->gfp, avctx->bit_rate / 1000);\n\n            } else                          // CBR\n\n                lame_set_brate(s->gfp, avctx->bit_rate / 1000);\n\n        }\n\n    }\n\n\n\n    /* do not get a Xing VBR header frame from LAME */\n\n    lame_set_bWriteVbrTag(s->gfp,0);\n\n\n\n    /* bit reservoir usage */\n\n    lame_set_disable_reservoir(s->gfp, !s->reservoir);\n\n\n\n    /* set specified parameters */\n\n    if (lame_init_params(s->gfp) < 0) {\n\n        ret = -1;\n\n        goto error;\n\n    }\n\n\n\n    /* get encoder delay */\n\n    avctx->delay = lame_get_encoder_delay(s->gfp) + 528 + 1;\n\n    ff_af_queue_init(avctx, &s->afq);\n\n\n\n    avctx->frame_size  = lame_get_framesize(s->gfp);\n\n\n\n    /* allocate float sample buffers */\n\n    if (avctx->sample_fmt == AV_SAMPLE_FMT_FLTP) {\n\n        int ch;\n\n        for (ch = 0; ch < avctx->channels; ch++) {\n\n            s->samples_flt[ch] = av_malloc(avctx->frame_size *\n\n                                           sizeof(*s->samples_flt[ch]));\n\n            if (!s->samples_flt[ch]) {\n\n                ret = AVERROR(ENOMEM);\n\n                goto error;\n\n            }\n\n        }\n\n    }\n\n\n\n    ret = realloc_buffer(s);\n\n    if (ret < 0)\n\n        goto error;\n\n\n\n    avpriv_float_dsp_init(&s->fdsp, avctx->flags & CODEC_FLAG_BITEXACT);\n\n\n\n    return 0;\n\nerror:\n\n    mp3lame_encode_close(avctx);\n\n    return ret;\n\n}\n", "idx": 14870}
{"project": "qemu", "commit_id": "f186d64d8fda4bb22c15beb8e45b7814fbd8b51e", "target": 0, "func": "void replay_account_executed_instructions(void)\n\n{\n\n    if (replay_mode == REPLAY_MODE_PLAY) {\n\n        replay_mutex_lock();\n\n        if (replay_state.instructions_count > 0) {\n\n            int count = (int)(replay_get_current_step()\n\n                              - replay_state.current_step);\n\n            replay_state.instructions_count -= count;\n\n            replay_state.current_step += count;\n\n            if (replay_state.instructions_count == 0) {\n\n                assert(replay_data_kind == EVENT_INSTRUCTION);\n\n                replay_finish_event();\n\n                /* Wake up iothread. This is required because\n\n                   timers will not expire until clock counters\n\n                   will be read from the log. */\n\n                qemu_notify_event();\n\n            }\n\n        }\n\n        replay_mutex_unlock();\n\n    }\n\n}\n", "idx": 14890}
{"project": "qemu", "commit_id": "d0bce760e04b1658a3b4ac95be2839ae20fd86db", "target": 1, "func": "static void omap_i2c_set_slave_addr(OMAPI2C *s, uint8_t addr)\n\n{\n\n    uint16_t data = addr;\n\n\n\n    memwrite(s->addr + OMAP_I2C_SA, &data, 2);\n\n    memread(s->addr + OMAP_I2C_SA, &data, 2);\n\n    g_assert_cmphex(data, ==, addr);\n\n}\n", "idx": 14943}
{"project": "FFmpeg", "commit_id": "f90c9c306f4e8334f29972b6c90201929ccce546", "target": 0, "func": "static void * attribute_align_arg worker(void *v){\n\n    AVCodecContext *avctx = v;\n\n    ThreadContext *c = avctx->internal->frame_thread_encoder;\n\n    AVPacket *pkt = NULL;\n\n\n\n    while(!c->exit){\n\n        int got_packet, ret;\n\n        AVFrame *frame;\n\n        Task task;\n\n\n\n        if(!pkt) pkt= av_mallocz(sizeof(*pkt));\n\n        if(!pkt) continue;\n\n        av_init_packet(pkt);\n\n\n\n        pthread_mutex_lock(&c->task_fifo_mutex);\n\n        while (av_fifo_size(c->task_fifo) <= 0 || c->exit) {\n\n            if(c->exit){\n\n                pthread_mutex_unlock(&c->task_fifo_mutex);\n\n                goto end;\n\n            }\n\n            pthread_cond_wait(&c->task_fifo_cond, &c->task_fifo_mutex);\n\n        }\n\n        av_fifo_generic_read(c->task_fifo, &task, sizeof(task), NULL);\n\n        pthread_mutex_unlock(&c->task_fifo_mutex);\n\n        frame = task.indata;\n\n\n\n        ret = avcodec_encode_video2(avctx, pkt, frame, &got_packet);\n\n        pthread_mutex_lock(&c->buffer_mutex);\n\n        av_frame_unref(frame);\n\n        pthread_mutex_unlock(&c->buffer_mutex);\n\n        av_frame_free(&frame);\n\n        if(got_packet) {\n\n            av_dup_packet(pkt);\n\n        } else {\n\n            pkt->data = NULL;\n\n            pkt->size = 0;\n\n        }\n\n        pthread_mutex_lock(&c->finished_task_mutex);\n\n        c->finished_tasks[task.index].outdata = pkt; pkt = NULL;\n\n        c->finished_tasks[task.index].return_code = ret;\n\n        pthread_cond_signal(&c->finished_task_cond);\n\n        pthread_mutex_unlock(&c->finished_task_mutex);\n\n    }\n\nend:\n\n    av_free(pkt);\n\n    pthread_mutex_lock(&c->buffer_mutex);\n\n    avcodec_close(avctx);\n\n    pthread_mutex_unlock(&c->buffer_mutex);\n\n    av_freep(&avctx);\n\n    return NULL;\n\n}\n", "idx": 14963}
{"project": "qemu", "commit_id": "c0f4ce7751f0b9a9a7815f931a09a6c3de127cee", "target": 0, "func": "static void do_cont(void)\n\n{\n\n    vm_start();\n\n}\n", "idx": 14965}
{"project": "qemu", "commit_id": "b2c98d9d392c87c9b9e975d30f79924719d9cbbe", "target": 0, "func": "static void tgen_ext8u(TCGContext *s, TCGType type, TCGReg dest, TCGReg src)\n\n{\n\n    if (facilities & FACILITY_EXT_IMM) {\n\n        tcg_out_insn(s, RRE, LLGCR, dest, src);\n\n        return;\n\n    }\n\n\n\n    if (dest == src) {\n\n        tcg_out_movi(s, type, TCG_TMP0, 0xff);\n\n        src = TCG_TMP0;\n\n    } else {\n\n        tcg_out_movi(s, type, dest, 0xff);\n\n    }\n\n    if (type == TCG_TYPE_I32) {\n\n        tcg_out_insn(s, RR, NR, dest, src);\n\n    } else {\n\n        tcg_out_insn(s, RRE, NGR, dest, src);\n\n    }\n\n}\n", "idx": 15026}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static bool esp_mem_accepts(void *opaque, target_phys_addr_t addr,\n\n                            unsigned size, bool is_write)\n\n{\n\n    return (size == 1) || (is_write && size == 4);\n\n}\n", "idx": 15027}
{"project": "qemu", "commit_id": "16b781aaef69c90d5f4f5456615f0c26a4f45740", "target": 0, "func": "SDState *sd_init(BlockBackend *blk, bool is_spi)\n\n{\n\n    SDState *sd;\n\n\n\n    if (blk && blk_is_read_only(blk)) {\n\n        fprintf(stderr, \"sd_init: Cannot use read-only drive\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    sd = (SDState *) g_malloc0(sizeof(SDState));\n\n    sd->buf = blk_blockalign(blk, 512);\n\n    sd->spi = is_spi;\n\n    sd->enable = true;\n\n    sd_reset(sd, blk);\n\n    if (sd->blk) {\n\n        blk_attach_dev_nofail(sd->blk, sd);\n\n        blk_set_dev_ops(sd->blk, &sd_block_ops, sd);\n\n    }\n\n    vmstate_register(NULL, -1, &sd_vmstate, sd);\n\n    return sd;\n\n}\n", "idx": 15041}
{"project": "FFmpeg", "commit_id": "0ecca7a49f8e254c12a3a1de048d738bfbb614c6", "target": 1, "func": "static void svq1_encode_plane(SVQ1Context *s, int plane, unsigned char *src_plane, unsigned char *ref_plane, unsigned char *decoded_plane,\n\n    int width, int height, int src_stride, int stride)\n\n{\n\n    int x, y;\n\n    int i;\n\n    int block_width, block_height;\n\n    int level;\n\n    int threshold[6];\n\n    const int lambda= (s->picture.quality*s->picture.quality) >> (2*FF_LAMBDA_SHIFT);\n\n\n\n    /* figure out the acceptable level thresholds in advance */\n\n    threshold[5] = QUALITY_THRESHOLD;\n\n    for (level = 4; level >= 0; level--)\n\n        threshold[level] = threshold[level + 1] * THRESHOLD_MULTIPLIER;\n\n\n\n    block_width = (width + 15) / 16;\n\n    block_height = (height + 15) / 16;\n\n\n\n    if(s->picture.pict_type == P_TYPE){\n\n        s->m.avctx= s->avctx;\n\n        s->m.current_picture_ptr= &s->m.current_picture;\n\n        s->m.last_picture_ptr   = &s->m.last_picture;\n\n        s->m.last_picture.data[0]= ref_plane;\n\n        s->m.linesize=\n\n        s->m.last_picture.linesize[0]= \n\n        s->m.new_picture.linesize[0]= \n\n        s->m.current_picture.linesize[0]= stride;\n\n        s->m.width= width;\n\n        s->m.height= height;\n\n        s->m.mb_width= block_width;\n\n        s->m.mb_height= block_height;\n\n        s->m.mb_stride= s->m.mb_width+1;\n\n        s->m.b8_stride= 2*s->m.mb_width+1;\n\n        s->m.f_code=1;\n\n        s->m.pict_type= s->picture.pict_type;\n\n        s->m.qscale= s->picture.quality/FF_QP2LAMBDA;\n\n        s->m.me_method= s->avctx->me_method;\n\n        \n\n        if(!s->motion_val8[plane]){\n\n            s->motion_val8 [plane]= av_mallocz((s->m.b8_stride*block_height*2 + 2)*2*sizeof(int16_t));\n\n            s->motion_val16[plane]= av_mallocz((s->m.mb_stride*(block_height + 2) + 1)*2*sizeof(int16_t));\n\n        }\n\n\n\n        s->m.mb_type= s->mb_type;\n\n        \n\n        //dummies, to avoid segfaults\n\n        s->m.current_picture.mb_mean=   (uint8_t *)s->dummy;\n\n        s->m.current_picture.mb_var=    (uint16_t*)s->dummy;\n\n        s->m.current_picture.mc_mb_var= (uint16_t*)s->dummy;\n\n        s->m.current_picture.mb_type= s->dummy;\n\n        \n\n        s->m.current_picture.motion_val[0]= s->motion_val8[plane] + 2;\n\n        s->m.p_mv_table= s->motion_val16[plane] + s->m.mb_stride + 1;\n\n        s->m.dsp= s->dsp; //move\n\n        ff_init_me(&s->m);\n\n    \n\n        s->m.me.dia_size= s->avctx->dia_size;\n\n        s->m.first_slice_line=1;\n\n        for (y = 0; y < block_height; y++) {\n\n            uint8_t src[stride*16];\n\n            \n\n            s->m.new_picture.data[0]= src - y*16*stride; //ugly\n\n            s->m.mb_y= y;\n\n    \n\n            for(i=0; i<16 && i + 16*y<height; i++){\n\n                memcpy(&src[i*stride], &src_plane[(i+16*y)*src_stride], width);\n\n                for(x=width; x<16*block_width; x++)\n\n                    src[i*stride+x]= src[i*stride+x-1];\n\n            }\n\n            for(; i<16 && i + 16*y<16*block_height; i++)\n\n                memcpy(&src[i*stride], &src[(i-1)*stride], 16*block_width);\n\n    \n\n            for (x = 0; x < block_width; x++) {\n\n                s->m.mb_x= x;\n\n                ff_init_block_index(&s->m);\n\n                ff_update_block_index(&s->m);\n\n                \n\n                ff_estimate_p_frame_motion(&s->m, x, y);\n\n            }\n\n            s->m.first_slice_line=0;\n\n        }\n\n    \n\n        ff_fix_long_p_mvs(&s->m);\n\n        ff_fix_long_mvs(&s->m, NULL, 0, s->m.p_mv_table, s->m.f_code, CANDIDATE_MB_TYPE_INTER, 0);\n\n    }\n\n        \n\n    s->m.first_slice_line=1;\n\n    for (y = 0; y < block_height; y++) {\n\n        uint8_t src[stride*16];\n\n        \n\n        for(i=0; i<16 && i + 16*y<height; i++){\n\n            memcpy(&src[i*stride], &src_plane[(i+16*y)*src_stride], width);\n\n            for(x=width; x<16*block_width; x++)\n\n                src[i*stride+x]= src[i*stride+x-1];\n\n        }\n\n        for(; i<16 && i + 16*y<16*block_height; i++)\n\n            memcpy(&src[i*stride], &src[(i-1)*stride], 16*block_width);\n\n\n\n        s->m.mb_y= y;\n\n        for (x = 0; x < block_width; x++) {\n\n            uint8_t reorder_buffer[3][6][7*32];\n\n            int count[3][6];\n\n            int offset = y * 16 * stride + x * 16;\n\n            uint8_t *decoded= decoded_plane + offset;\n\n            uint8_t *ref= ref_plane + offset;\n\n            int score[4]={0,0,0,0}, best;\n\n            uint8_t temp[16*stride];\n\n\n\n            s->m.mb_x= x;\n\n            ff_init_block_index(&s->m);\n\n            ff_update_block_index(&s->m);\n\n            \n\n            if(s->picture.pict_type == I_TYPE || (s->m.mb_type[x + y*s->m.mb_stride]&CANDIDATE_MB_TYPE_INTRA)){\n\n                for(i=0; i<6; i++){\n\n                    init_put_bits(&s->reorder_pb[i], reorder_buffer[0][i], 7*32);\n\n                }\n\n                if(s->picture.pict_type == P_TYPE){\n\n                    const uint8_t *vlc= svq1_block_type_vlc[SVQ1_BLOCK_INTRA];\n\n                    put_bits(&s->reorder_pb[5], vlc[1], vlc[0]);\n\n                    score[0]= vlc[1]*lambda;\n\n                }\n\n                score[0]+= encode_block(s, src+16*x, NULL, temp, stride, 5, 64, lambda, 1);\n\n                for(i=0; i<6; i++){\n\n                    count[0][i]= put_bits_count(&s->reorder_pb[i]);\n\n                    flush_put_bits(&s->reorder_pb[i]);\n\n                }\n\n            }else\n\n                score[0]= INT_MAX;\n\n            \n\n            best=0;\n\n            \n\n            if(s->picture.pict_type == P_TYPE){\n\n                const uint8_t *vlc= svq1_block_type_vlc[SVQ1_BLOCK_INTER];\n\n                int mx, my, pred_x, pred_y, dxy;\n\n                int16_t *motion_ptr;\n\n\n\n                motion_ptr= h263_pred_motion(&s->m, 0, 0, &pred_x, &pred_y);\n\n                if(s->m.mb_type[x + y*s->m.mb_stride]&CANDIDATE_MB_TYPE_INTER){\n\n                    for(i=0; i<6; i++)\n\n                        init_put_bits(&s->reorder_pb[i], reorder_buffer[1][i], 7*32);\n\n\n\n                    put_bits(&s->reorder_pb[5], vlc[1], vlc[0]);\n\n    \n\n                    s->m.pb= s->reorder_pb[5];                \n\n                    mx= motion_ptr[0];\n\n                    my= motion_ptr[1];\n\n                    assert(mx>=-32 && mx<=31);\n\n                    assert(my>=-32 && my<=31);\n\n                    assert(pred_x>=-32 && pred_x<=31);\n\n                    assert(pred_y>=-32 && pred_y<=31);\n\n                    ff_h263_encode_motion(&s->m, mx - pred_x, 1);\n\n                    ff_h263_encode_motion(&s->m, my - pred_y, 1);\n\n                    s->reorder_pb[5]= s->m.pb;\n\n                    score[1] += lambda*put_bits_count(&s->reorder_pb[5]);\n\n    \n\n                    dxy= (mx&1) + 2*(my&1);\n\n                    \n\n                    s->dsp.put_pixels_tab[0][dxy](temp+16, ref + (mx>>1) + stride*(my>>1), stride, 16);\n\n                    \n\n                    score[1]+= encode_block(s, src+16*x, temp+16, decoded, stride, 5, 64, lambda, 0);\n\n                    best= score[1] <= score[0];\n\n\n\n                    vlc= svq1_block_type_vlc[SVQ1_BLOCK_SKIP];\n\n                    score[2]= s->dsp.sse[0](NULL, src+16*x, ref, stride, 16);\n\n                    score[2]+= vlc[1]*lambda;\n\n                    if(score[2] < score[best] && mx==0 && my==0){\n\n                        best=2;\n\n                        s->dsp.put_pixels_tab[0][0](decoded, ref, stride, 16);\n\n                        for(i=0; i<6; i++){\n\n                            count[2][i]=0;\n\n                        }\n\n                        put_bits(&s->pb, vlc[1], vlc[0]);\n\n                    }\n\n                }\n\n\n\n                if(best==1){\n\n                    for(i=0; i<6; i++){\n\n                        count[1][i]= put_bits_count(&s->reorder_pb[i]);\n\n                        flush_put_bits(&s->reorder_pb[i]);\n\n                    }\n\n                }else{\n\n                    motion_ptr[0                 ] = motion_ptr[1                 ]=\n\n                    motion_ptr[2                 ] = motion_ptr[3                 ]=\n\n                    motion_ptr[0+2*s->m.b8_stride] = motion_ptr[1+2*s->m.b8_stride]=\n\n                    motion_ptr[2+2*s->m.b8_stride] = motion_ptr[3+2*s->m.b8_stride]=0;\n\n                }\n\n            }\n\n                \n\n            s->rd_total += score[best];\n\n\n\n            for(i=5; i>=0; i--){\n\n                ff_copy_bits(&s->pb, reorder_buffer[best][i], count[best][i]);\n\n            }\n\n            if(best==0){\n\n                s->dsp.put_pixels_tab[0][0](decoded, temp, stride, 16);\n\n            }\n\n        }\n\n        s->m.first_slice_line=0;\n\n    }\n\n}\n", "idx": 15134}
{"project": "qemu", "commit_id": "c7e35da348e2e4df072e6979c48fa5283e07d1db", "target": 1, "func": "static inline abi_long host_to_target_timespec(abi_ulong target_addr,\n\n                                               struct timespec *host_ts)\n\n{\n\n    struct target_timespec *target_ts;\n\n\n\n    if (!lock_user_struct(VERIFY_WRITE, target_ts, target_addr, 0))\n\n        return -TARGET_EFAULT;\n\n    target_ts->tv_sec = tswapal(host_ts->tv_sec);\n\n    target_ts->tv_nsec = tswapal(host_ts->tv_nsec);\n\n    unlock_user_struct(target_ts, target_addr, 1);\n\n    return 0;\n\n}\n", "idx": 15217}
{"project": "qemu", "commit_id": "1c275925bfbbc2de84a8f0e09d1dd70bbefb6da3", "target": 0, "func": "long do_sigreturn(CPUMBState *env)\n\n{\n\n    struct target_signal_frame *frame;\n\n    abi_ulong frame_addr;\n\n    target_sigset_t target_set;\n\n    sigset_t set;\n\n    int i;\n\n\n\n    frame_addr = env->regs[R_SP];\n\n    /* Make sure the guest isn't playing games.  */\n\n    if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 1))\n\n        goto badframe;\n\n\n\n    /* Restore blocked signals */\n\n    if (__get_user(target_set.sig[0], &frame->uc.tuc_mcontext.oldmask))\n\n        goto badframe;\n\n    for(i = 1; i < TARGET_NSIG_WORDS; i++) {\n\n        if (__get_user(target_set.sig[i], &frame->extramask[i - 1]))\n\n            goto badframe;\n\n    }\n\n    target_to_host_sigset_internal(&set, &target_set);\n\n    sigprocmask(SIG_SETMASK, &set, NULL);\n\n\n\n    restore_sigcontext(&frame->uc.tuc_mcontext, env);\n\n    /* We got here through a sigreturn syscall, our path back is via an\n\n       rtb insn so setup r14 for that.  */\n\n    env->regs[14] = env->sregs[SR_PC];\n\n \n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    return env->regs[10];\n\n  badframe:\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    force_sig(TARGET_SIGSEGV);\n\n}\n", "idx": 15458}
{"project": "FFmpeg", "commit_id": "3176217c60ca7828712985092d9102d331ea4f3d", "target": 0, "func": "int ff_h264_get_profile(SPS *sps)\n\n{\n\n    int profile = sps->profile_idc;\n\n\n\n    switch (sps->profile_idc) {\n\n    case FF_PROFILE_H264_BASELINE:\n\n        // constraint_set1_flag set to 1\n\n        profile |= (sps->constraint_set_flags & 1 << 1) ? FF_PROFILE_H264_CONSTRAINED : 0;\n\n        break;\n\n    case FF_PROFILE_H264_HIGH_10:\n\n    case FF_PROFILE_H264_HIGH_422:\n\n    case FF_PROFILE_H264_HIGH_444_PREDICTIVE:\n\n        // constraint_set3_flag set to 1\n\n        profile |= (sps->constraint_set_flags & 1 << 3) ? FF_PROFILE_H264_INTRA : 0;\n\n        break;\n\n    }\n\n\n\n    return profile;\n\n}\n", "idx": 15476}
{"project": "qemu", "commit_id": "59800ec8e52bcfa271fa61fb0aae19205ef1b7f1", "target": 0, "func": "uint64_t helper_fres(CPUPPCState *env, uint64_t arg)\n\n{\n\n    CPU_DoubleU farg;\n\n    float32 f32;\n\n\n\n    farg.ll = arg;\n\n\n\n    if (unlikely(float64_is_signaling_nan(farg.d))) {\n\n        /* sNaN reciprocal */\n\n        fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);\n\n    }\n\n    farg.d = float64_div(float64_one, farg.d, &env->fp_status);\n\n    f32 = float64_to_float32(farg.d, &env->fp_status);\n\n    farg.d = float32_to_float64(f32, &env->fp_status);\n\n\n\n    return farg.ll;\n\n}\n", "idx": 15523}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static int aio_epoll(AioContext *ctx, GPollFD *pfds,\n\n                     unsigned npfd, int64_t timeout)\n\n{\n\n    assert(false);\n\n}\n", "idx": 15550}
{"project": "qemu", "commit_id": "acc4af3fec335bb0778456f72bfb2c3591c11da4", "target": 0, "func": "static bool object_is_type(Object *obj, const char *typename)\n\n{\n\n    TypeImpl *target_type = type_get_by_name(typename);\n\n    TypeImpl *type = obj->class->type;\n\n    GSList *i;\n\n\n\n    /* Check if typename is a direct ancestor of type */\n\n    while (type) {\n\n        if (type == target_type) {\n\n            return true;\n\n        }\n\n\n\n        type = type_get_parent(type);\n\n    }\n\n\n\n    /* Check if obj has an interface of typename */\n\n    for (i = obj->interfaces; i; i = i->next) {\n\n        Interface *iface = i->data;\n\n\n\n        if (object_is_type(OBJECT(iface), typename)) {\n\n            return true;\n\n        }\n\n    }\n\n\n\n    return false;\n\n}\n", "idx": 15628}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void omap_prcm_write(void *opaque, target_phys_addr_t addr,\n\n                            uint64_t value, unsigned size)\n\n{\n\n    struct omap_prcm_s *s = (struct omap_prcm_s *) opaque;\n\n\n\n    if (size != 4) {\n\n        return omap_badwidth_write32(opaque, addr, value);\n\n    }\n\n\n\n    switch (addr) {\n\n    case 0x000:\t/* PRCM_REVISION */\n\n    case 0x054:\t/* PRCM_VOLTST */\n\n    case 0x084:\t/* PRCM_CLKCFG_STATUS */\n\n    case 0x1e4:\t/* PM_PWSTST_MPU */\n\n    case 0x220:\t/* CM_IDLEST1_CORE */\n\n    case 0x224:\t/* CM_IDLEST2_CORE */\n\n    case 0x22c:\t/* CM_IDLEST4_CORE */\n\n    case 0x2c8:\t/* PM_WKDEP_CORE */\n\n    case 0x2e4:\t/* PM_PWSTST_CORE */\n\n    case 0x320:\t/* CM_IDLEST_GFX */\n\n    case 0x3e4:\t/* PM_PWSTST_GFX */\n\n    case 0x420:\t/* CM_IDLEST_WKUP */\n\n    case 0x520:\t/* CM_IDLEST_CKGEN */\n\n    case 0x820:\t/* CM_IDLEST_DSP */\n\n    case 0x8e4:\t/* PM_PWSTST_DSP */\n\n        OMAP_RO_REG(addr);\n\n        return;\n\n\n\n    case 0x010:\t/* PRCM_SYSCONFIG */\n\n        s->sysconfig = value & 1;\n\n        break;\n\n\n\n    case 0x018:\t/* PRCM_IRQSTATUS_MPU */\n\n        s->irqst[0] &= ~value;\n\n        omap_prcm_int_update(s, 0);\n\n        break;\n\n    case 0x01c:\t/* PRCM_IRQENABLE_MPU */\n\n        s->irqen[0] = value & 0x3f;\n\n        omap_prcm_int_update(s, 0);\n\n        break;\n\n\n\n    case 0x050:\t/* PRCM_VOLTCTRL */\n\n        s->voltctrl = value & 0xf1c3;\n\n        break;\n\n\n\n    case 0x060:\t/* PRCM_CLKSRC_CTRL */\n\n        s->clksrc[0] = value & 0xdb;\n\n        /* TODO update clocks */\n\n        break;\n\n\n\n    case 0x070:\t/* PRCM_CLKOUT_CTRL */\n\n        s->clkout[0] = value & 0xbbbb;\n\n        /* TODO update clocks */\n\n        break;\n\n\n\n    case 0x078:\t/* PRCM_CLKEMUL_CTRL */\n\n        s->clkemul[0] = value & 1;\n\n        /* TODO update clocks */\n\n        break;\n\n\n\n    case 0x080:\t/* PRCM_CLKCFG_CTRL */\n\n        break;\n\n\n\n    case 0x090:\t/* PRCM_VOLTSETUP */\n\n        s->setuptime[0] = value & 0xffff;\n\n        break;\n\n    case 0x094:\t/* PRCM_CLKSSETUP */\n\n        s->setuptime[1] = value & 0xffff;\n\n        break;\n\n\n\n    case 0x098:\t/* PRCM_POLCTRL */\n\n        s->clkpol[0] = value & 0x701;\n\n        break;\n\n\n\n    case 0x0b0:\t/* GENERAL_PURPOSE1 */\n\n    case 0x0b4:\t/* GENERAL_PURPOSE2 */\n\n    case 0x0b8:\t/* GENERAL_PURPOSE3 */\n\n    case 0x0bc:\t/* GENERAL_PURPOSE4 */\n\n    case 0x0c0:\t/* GENERAL_PURPOSE5 */\n\n    case 0x0c4:\t/* GENERAL_PURPOSE6 */\n\n    case 0x0c8:\t/* GENERAL_PURPOSE7 */\n\n    case 0x0cc:\t/* GENERAL_PURPOSE8 */\n\n    case 0x0d0:\t/* GENERAL_PURPOSE9 */\n\n    case 0x0d4:\t/* GENERAL_PURPOSE10 */\n\n    case 0x0d8:\t/* GENERAL_PURPOSE11 */\n\n    case 0x0dc:\t/* GENERAL_PURPOSE12 */\n\n    case 0x0e0:\t/* GENERAL_PURPOSE13 */\n\n    case 0x0e4:\t/* GENERAL_PURPOSE14 */\n\n    case 0x0e8:\t/* GENERAL_PURPOSE15 */\n\n    case 0x0ec:\t/* GENERAL_PURPOSE16 */\n\n    case 0x0f0:\t/* GENERAL_PURPOSE17 */\n\n    case 0x0f4:\t/* GENERAL_PURPOSE18 */\n\n    case 0x0f8:\t/* GENERAL_PURPOSE19 */\n\n    case 0x0fc:\t/* GENERAL_PURPOSE20 */\n\n        s->scratch[(addr - 0xb0) >> 2] = value;\n\n        break;\n\n\n\n    case 0x140:\t/* CM_CLKSEL_MPU */\n\n        s->clksel[0] = value & 0x1f;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x148:\t/* CM_CLKSTCTRL_MPU */\n\n        s->clkctrl[0] = value & 0x1f;\n\n        break;\n\n\n\n    case 0x158:\t/* RM_RSTST_MPU */\n\n        s->rst[0] &= ~value;\n\n        break;\n\n    case 0x1c8:\t/* PM_WKDEP_MPU */\n\n        s->wkup[0] = value & 0x15;\n\n        break;\n\n\n\n    case 0x1d4:\t/* PM_EVGENCTRL_MPU */\n\n        s->ev = value & 0x1f;\n\n        break;\n\n    case 0x1d8:\t/* PM_EVEGENONTIM_MPU */\n\n        s->evtime[0] = value;\n\n        break;\n\n    case 0x1dc:\t/* PM_EVEGENOFFTIM_MPU */\n\n        s->evtime[1] = value;\n\n        break;\n\n\n\n    case 0x1e0:\t/* PM_PWSTCTRL_MPU */\n\n        s->power[0] = value & 0xc0f;\n\n        break;\n\n\n\n    case 0x200:\t/* CM_FCLKEN1_CORE */\n\n        s->clken[0] = value & 0xbfffffff;\n\n        /* TODO update clocks */\n\n        /* The EN_EAC bit only gets/puts func_96m_clk.  */\n\n        break;\n\n    case 0x204:\t/* CM_FCLKEN2_CORE */\n\n        s->clken[1] = value & 0x00000007;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x210:\t/* CM_ICLKEN1_CORE */\n\n        s->clken[2] = value & 0xfffffff9;\n\n        /* TODO update clocks */\n\n        /* The EN_EAC bit only gets/puts core_l4_iclk.  */\n\n        break;\n\n    case 0x214:\t/* CM_ICLKEN2_CORE */\n\n        s->clken[3] = value & 0x00000007;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x21c:\t/* CM_ICLKEN4_CORE */\n\n        s->clken[4] = value & 0x0000001f;\n\n        /* TODO update clocks */\n\n        break;\n\n\n\n    case 0x230:\t/* CM_AUTOIDLE1_CORE */\n\n        s->clkidle[0] = value & 0xfffffff9;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x234:\t/* CM_AUTOIDLE2_CORE */\n\n        s->clkidle[1] = value & 0x00000007;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x238:\t/* CM_AUTOIDLE3_CORE */\n\n        s->clkidle[2] = value & 0x00000007;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x23c:\t/* CM_AUTOIDLE4_CORE */\n\n        s->clkidle[3] = value & 0x0000001f;\n\n        /* TODO update clocks */\n\n        break;\n\n\n\n    case 0x240:\t/* CM_CLKSEL1_CORE */\n\n        s->clksel[1] = value & 0x0fffbf7f;\n\n        /* TODO update clocks */\n\n        break;\n\n\n\n    case 0x244:\t/* CM_CLKSEL2_CORE */\n\n        s->clksel[2] = value & 0x00fffffc;\n\n        /* TODO update clocks */\n\n        break;\n\n\n\n    case 0x248:\t/* CM_CLKSTCTRL_CORE */\n\n        s->clkctrl[1] = value & 0x7;\n\n        break;\n\n\n\n    case 0x2a0:\t/* PM_WKEN1_CORE */\n\n        s->wken[0] = value & 0x04667ff8;\n\n        break;\n\n    case 0x2a4:\t/* PM_WKEN2_CORE */\n\n        s->wken[1] = value & 0x00000005;\n\n        break;\n\n\n\n    case 0x2b0:\t/* PM_WKST1_CORE */\n\n        s->wkst[0] &= ~value;\n\n        break;\n\n    case 0x2b4:\t/* PM_WKST2_CORE */\n\n        s->wkst[1] &= ~value;\n\n        break;\n\n\n\n    case 0x2e0:\t/* PM_PWSTCTRL_CORE */\n\n        s->power[1] = (value & 0x00fc3f) | (1 << 2);\n\n        break;\n\n\n\n    case 0x300:\t/* CM_FCLKEN_GFX */\n\n        s->clken[5] = value & 6;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x310:\t/* CM_ICLKEN_GFX */\n\n        s->clken[6] = value & 1;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x340:\t/* CM_CLKSEL_GFX */\n\n        s->clksel[3] = value & 7;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x348:\t/* CM_CLKSTCTRL_GFX */\n\n        s->clkctrl[2] = value & 1;\n\n        break;\n\n    case 0x350:\t/* RM_RSTCTRL_GFX */\n\n        s->rstctrl[0] = value & 1;\n\n        /* TODO: reset */\n\n        break;\n\n    case 0x358:\t/* RM_RSTST_GFX */\n\n        s->rst[1] &= ~value;\n\n        break;\n\n    case 0x3c8:\t/* PM_WKDEP_GFX */\n\n        s->wkup[1] = value & 0x13;\n\n        break;\n\n    case 0x3e0:\t/* PM_PWSTCTRL_GFX */\n\n        s->power[2] = (value & 0x00c0f) | (3 << 2);\n\n        break;\n\n\n\n    case 0x400:\t/* CM_FCLKEN_WKUP */\n\n        s->clken[7] = value & 0xd;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x410:\t/* CM_ICLKEN_WKUP */\n\n        s->clken[8] = value & 0x3f;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x430:\t/* CM_AUTOIDLE_WKUP */\n\n        s->clkidle[4] = value & 0x0000003f;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x440:\t/* CM_CLKSEL_WKUP */\n\n        s->clksel[4] = value & 3;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x450:\t/* RM_RSTCTRL_WKUP */\n\n        /* TODO: reset */\n\n        if (value & 2)\n\n            qemu_system_reset_request();\n\n        break;\n\n    case 0x454:\t/* RM_RSTTIME_WKUP */\n\n        s->rsttime_wkup = value & 0x1fff;\n\n        break;\n\n    case 0x458:\t/* RM_RSTST_WKUP */\n\n        s->rst[2] &= ~value;\n\n        break;\n\n    case 0x4a0:\t/* PM_WKEN_WKUP */\n\n        s->wken[2] = value & 0x00000005;\n\n        break;\n\n    case 0x4b0:\t/* PM_WKST_WKUP */\n\n        s->wkst[2] &= ~value;\n\n        break;\n\n\n\n    case 0x500:\t/* CM_CLKEN_PLL */\n\n        if (value & 0xffffff30)\n\n            fprintf(stderr, \"%s: write 0s in CM_CLKEN_PLL for \"\n\n                            \"future compatibility\\n\", __FUNCTION__);\n\n        if ((s->clken[9] ^ value) & 0xcc) {\n\n            s->clken[9] &= ~0xcc;\n\n            s->clken[9] |= value & 0xcc;\n\n            omap_prcm_apll_update(s);\n\n        }\n\n        if ((s->clken[9] ^ value) & 3) {\n\n            s->clken[9] &= ~3;\n\n            s->clken[9] |= value & 3;\n\n            omap_prcm_dpll_update(s);\n\n        }\n\n        break;\n\n    case 0x530:\t/* CM_AUTOIDLE_PLL */\n\n        s->clkidle[5] = value & 0x000000cf;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x540:\t/* CM_CLKSEL1_PLL */\n\n        if (value & 0xfc4000d7)\n\n            fprintf(stderr, \"%s: write 0s in CM_CLKSEL1_PLL for \"\n\n                            \"future compatibility\\n\", __FUNCTION__);\n\n        if ((s->clksel[5] ^ value) & 0x003fff00) {\n\n            s->clksel[5] = value & 0x03bfff28;\n\n            omap_prcm_dpll_update(s);\n\n        }\n\n        /* TODO update the other clocks */\n\n\n\n        s->clksel[5] = value & 0x03bfff28;\n\n        break;\n\n    case 0x544:\t/* CM_CLKSEL2_PLL */\n\n        if (value & ~3)\n\n            fprintf(stderr, \"%s: write 0s in CM_CLKSEL2_PLL[31:2] for \"\n\n                            \"future compatibility\\n\", __FUNCTION__);\n\n        if (s->clksel[6] != (value & 3)) {\n\n            s->clksel[6] = value & 3;\n\n            omap_prcm_dpll_update(s);\n\n        }\n\n        break;\n\n\n\n    case 0x800:\t/* CM_FCLKEN_DSP */\n\n        s->clken[10] = value & 0x501;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x810:\t/* CM_ICLKEN_DSP */\n\n        s->clken[11] = value & 0x2;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x830:\t/* CM_AUTOIDLE_DSP */\n\n        s->clkidle[6] = value & 0x2;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x840:\t/* CM_CLKSEL_DSP */\n\n        s->clksel[7] = value & 0x3fff;\n\n        /* TODO update clocks */\n\n        break;\n\n    case 0x848:\t/* CM_CLKSTCTRL_DSP */\n\n        s->clkctrl[3] = value & 0x101;\n\n        break;\n\n    case 0x850:\t/* RM_RSTCTRL_DSP */\n\n        /* TODO: reset */\n\n        break;\n\n    case 0x858:\t/* RM_RSTST_DSP */\n\n        s->rst[3] &= ~value;\n\n        break;\n\n    case 0x8c8:\t/* PM_WKDEP_DSP */\n\n        s->wkup[2] = value & 0x13;\n\n        break;\n\n    case 0x8e0:\t/* PM_PWSTCTRL_DSP */\n\n        s->power[3] = (value & 0x03017) | (3 << 2);\n\n        break;\n\n\n\n    case 0x8f0:\t/* PRCM_IRQSTATUS_DSP */\n\n        s->irqst[1] &= ~value;\n\n        omap_prcm_int_update(s, 1);\n\n        break;\n\n    case 0x8f4:\t/* PRCM_IRQENABLE_DSP */\n\n        s->irqen[1] = value & 0x7;\n\n        omap_prcm_int_update(s, 1);\n\n        break;\n\n\n\n    case 0x8f8:\t/* PRCM_IRQSTATUS_IVA */\n\n        s->irqst[2] &= ~value;\n\n        omap_prcm_int_update(s, 2);\n\n        break;\n\n    case 0x8fc:\t/* PRCM_IRQENABLE_IVA */\n\n        s->irqen[2] = value & 0x7;\n\n        omap_prcm_int_update(s, 2);\n\n        break;\n\n\n\n    default:\n\n        OMAP_BAD_REG(addr);\n\n        return;\n\n    }\n\n}\n", "idx": 15661}
{"project": "qemu", "commit_id": "9633fcc6a02f23e3ef00aa5fe3fe9c41f57c3456", "target": 1, "func": "static void init_proc_755 (CPUPPCState *env)\n\n{\n\n    gen_spr_ne_601(env);\n\n    gen_spr_7xx(env);\n\n    gen_spr_G2_755(env);\n\n    /* Time base */\n\n    gen_tbl(env);\n\n    /* L2 cache control */\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_L2CR, \"L2CR\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, NULL,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_L2PMCR, \"L2PMCR\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* Thermal management */\n\n    gen_spr_thrm(env);\n\n    /* Hardware implementation registers */\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID0, \"HID0\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID1, \"HID1\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID2, \"HID2\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* Memory management */\n\n    gen_low_BATs(env);\n\n    gen_high_BATs(env);\n\n    gen_6xx_7xx_soft_tlb(env, 64, 2);\n\n    init_excp_7x5(env);\n\n    env->dcache_line_size = 32;\n\n    env->icache_line_size = 32;\n\n    /* Allocate hardware IRQ controller */\n\n    ppc6xx_irq_init(env);\n\n}\n", "idx": 15686}
{"project": "qemu", "commit_id": "ae0bfb79aa0ac411a433433af4d74f1f08255608", "target": 0, "func": "static inline void powerpc_excp(CPUState *env, int excp_model, int excp)\n\n{\n\n    target_ulong msr, new_msr, vector;\n\n    int srr0, srr1, asrr0, asrr1;\n\n    int lpes0, lpes1, lev;\n\n\n\n    if (0) {\n\n        /* XXX: find a suitable condition to enable the hypervisor mode */\n\n        lpes0 = (env->spr[SPR_LPCR] >> 1) & 1;\n\n        lpes1 = (env->spr[SPR_LPCR] >> 2) & 1;\n\n    } else {\n\n        /* Those values ensure we won't enter the hypervisor mode */\n\n        lpes0 = 0;\n\n        lpes1 = 1;\n\n    }\n\n\n\n    qemu_log_mask(CPU_LOG_INT, \"Raise exception at \" TARGET_FMT_lx\n\n                  \" => %08x (%02x)\\n\", env->nip, excp, env->error_code);\n\n\n\n    /* new srr1 value excluding must-be-zero bits */\n\n    msr = env->msr & ~0x783f0000ULL;\n\n\n\n    /* new interrupt handler msr */\n\n    new_msr = env->msr & ((target_ulong)1 << MSR_ME);\n\n\n\n    /* target registers */\n\n    srr0 = SPR_SRR0;\n\n    srr1 = SPR_SRR1;\n\n    asrr0 = -1;\n\n    asrr1 = -1;\n\n\n\n    switch (excp) {\n\n    case POWERPC_EXCP_NONE:\n\n        /* Should never happen */\n\n        return;\n\n    case POWERPC_EXCP_CRITICAL:    /* Critical input                         */\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_40x:\n\n            srr0 = SPR_40x_SRR2;\n\n            srr1 = SPR_40x_SRR3;\n\n            break;\n\n        case POWERPC_EXCP_BOOKE:\n\n            srr0 = SPR_BOOKE_CSRR0;\n\n            srr1 = SPR_BOOKE_CSRR1;\n\n            break;\n\n        case POWERPC_EXCP_G2:\n\n            break;\n\n        default:\n\n            goto excp_invalid;\n\n        }\n\n        goto store_next;\n\n    case POWERPC_EXCP_MCHECK:    /* Machine check exception                  */\n\n        if (msr_me == 0) {\n\n            /* Machine check exception is not enabled.\n\n             * Enter checkstop state.\n\n             */\n\n            if (qemu_log_enabled()) {\n\n                qemu_log(\"Machine check while not allowed. \"\n\n                        \"Entering checkstop state\\n\");\n\n            } else {\n\n                fprintf(stderr, \"Machine check while not allowed. \"\n\n                        \"Entering checkstop state\\n\");\n\n            }\n\n            env->halted = 1;\n\n            env->interrupt_request |= CPU_INTERRUPT_EXITTB;\n\n        }\n\n        if (0) {\n\n            /* XXX: find a suitable condition to enable the hypervisor mode */\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        }\n\n\n\n        /* machine check exceptions don't have ME set */\n\n        new_msr &= ~((target_ulong)1 << MSR_ME);\n\n\n\n        /* XXX: should also have something loaded in DAR / DSISR */\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_40x:\n\n            srr0 = SPR_40x_SRR2;\n\n            srr1 = SPR_40x_SRR3;\n\n            break;\n\n        case POWERPC_EXCP_BOOKE:\n\n            srr0 = SPR_BOOKE_MCSRR0;\n\n            srr1 = SPR_BOOKE_MCSRR1;\n\n            asrr0 = SPR_BOOKE_CSRR0;\n\n            asrr1 = SPR_BOOKE_CSRR1;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        goto store_next;\n\n    case POWERPC_EXCP_DSI:       /* Data storage exception                   */\n\n        LOG_EXCP(\"DSI exception: DSISR=\" TARGET_FMT_lx\" DAR=\" TARGET_FMT_lx\n\n                 \"\\n\", env->spr[SPR_DSISR], env->spr[SPR_DAR]);\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        goto store_next;\n\n    case POWERPC_EXCP_ISI:       /* Instruction storage exception            */\n\n        LOG_EXCP(\"ISI exception: msr=\" TARGET_FMT_lx \", nip=\" TARGET_FMT_lx\n\n                 \"\\n\", msr, env->nip);\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        msr |= env->error_code;\n\n        goto store_next;\n\n    case POWERPC_EXCP_EXTERNAL:  /* External input                           */\n\n        if (lpes0 == 1)\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        goto store_next;\n\n    case POWERPC_EXCP_ALIGN:     /* Alignment exception                      */\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        /* XXX: this is false */\n\n        /* Get rS/rD and rA from faulting opcode */\n\n        env->spr[SPR_DSISR] |= (ldl_code((env->nip - 4)) & 0x03FF0000) >> 16;\n\n        goto store_current;\n\n    case POWERPC_EXCP_PROGRAM:   /* Program exception                        */\n\n        switch (env->error_code & ~0xF) {\n\n        case POWERPC_EXCP_FP:\n\n            if ((msr_fe0 == 0 && msr_fe1 == 0) || msr_fp == 0) {\n\n                LOG_EXCP(\"Ignore floating point exception\\n\");\n\n                env->exception_index = POWERPC_EXCP_NONE;\n\n                env->error_code = 0;\n\n                return;\n\n            }\n\n            if (lpes1 == 0)\n\n                new_msr |= (target_ulong)MSR_HVB;\n\n            msr |= 0x00100000;\n\n            if (msr_fe0 == msr_fe1)\n\n                goto store_next;\n\n            msr |= 0x00010000;\n\n            break;\n\n        case POWERPC_EXCP_INVAL:\n\n            LOG_EXCP(\"Invalid instruction at \" TARGET_FMT_lx \"\\n\", env->nip);\n\n            if (lpes1 == 0)\n\n                new_msr |= (target_ulong)MSR_HVB;\n\n            msr |= 0x00080000;\n\n            break;\n\n        case POWERPC_EXCP_PRIV:\n\n            if (lpes1 == 0)\n\n                new_msr |= (target_ulong)MSR_HVB;\n\n            msr |= 0x00040000;\n\n            break;\n\n        case POWERPC_EXCP_TRAP:\n\n            if (lpes1 == 0)\n\n                new_msr |= (target_ulong)MSR_HVB;\n\n            msr |= 0x00020000;\n\n            break;\n\n        default:\n\n            /* Should never occur */\n\n            cpu_abort(env, \"Invalid program exception %d. Aborting\\n\",\n\n                      env->error_code);\n\n            break;\n\n        }\n\n        goto store_current;\n\n    case POWERPC_EXCP_FPU:       /* Floating-point unavailable exception     */\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        goto store_current;\n\n    case POWERPC_EXCP_SYSCALL:   /* System call exception                    */\n\n        /* NOTE: this is a temporary hack to support graphics OSI\n\n           calls from the MOL driver */\n\n        /* XXX: To be removed */\n\n        if (env->gpr[3] == 0x113724fa && env->gpr[4] == 0x77810f9b &&\n\n            env->osi_call) {\n\n            if (env->osi_call(env) != 0) {\n\n                env->exception_index = POWERPC_EXCP_NONE;\n\n                env->error_code = 0;\n\n                return;\n\n            }\n\n        }\n\n        dump_syscall(env);\n\n        lev = env->error_code;\n\n        if (lev == 1 || (lpes0 == 0 && lpes1 == 0))\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        goto store_next;\n\n    case POWERPC_EXCP_APU:       /* Auxiliary processor unavailable          */\n\n        goto store_current;\n\n    case POWERPC_EXCP_DECR:      /* Decrementer exception                    */\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        goto store_next;\n\n    case POWERPC_EXCP_FIT:       /* Fixed-interval timer interrupt           */\n\n        /* FIT on 4xx */\n\n        LOG_EXCP(\"FIT exception\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_WDT:       /* Watchdog timer interrupt                 */\n\n        LOG_EXCP(\"WDT exception\\n\");\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_BOOKE:\n\n            srr0 = SPR_BOOKE_CSRR0;\n\n            srr1 = SPR_BOOKE_CSRR1;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        goto store_next;\n\n    case POWERPC_EXCP_DTLB:      /* Data TLB error                           */\n\n        goto store_next;\n\n    case POWERPC_EXCP_ITLB:      /* Instruction TLB error                    */\n\n        goto store_next;\n\n    case POWERPC_EXCP_DEBUG:     /* Debug interrupt                          */\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_BOOKE:\n\n            srr0 = SPR_BOOKE_DSRR0;\n\n            srr1 = SPR_BOOKE_DSRR1;\n\n            asrr0 = SPR_BOOKE_CSRR0;\n\n            asrr1 = SPR_BOOKE_CSRR1;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"Debug exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_SPEU:      /* SPE/embedded floating-point unavailable  */\n\n        goto store_current;\n\n    case POWERPC_EXCP_EFPDI:     /* Embedded floating-point data interrupt   */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"Embedded floating point data exception \"\n\n                  \"is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_EFPRI:     /* Embedded floating-point round interrupt  */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"Embedded floating point round exception \"\n\n                  \"is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_EPERFM:    /* Embedded performance monitor interrupt   */\n\n        /* XXX: TODO */\n\n        cpu_abort(env,\n\n                  \"Performance counter exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_DOORI:     /* Embedded doorbell interrupt              */\n\n        /* XXX: TODO */\n\n        cpu_abort(env,\n\n                  \"Embedded doorbell interrupt is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_DOORCI:    /* Embedded doorbell critical interrupt     */\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_BOOKE:\n\n            srr0 = SPR_BOOKE_CSRR0;\n\n            srr1 = SPR_BOOKE_CSRR1;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"Embedded doorbell critical interrupt \"\n\n                  \"is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_RESET:     /* System reset exception                   */\n\n        if (msr_pow) {\n\n            /* indicate that we resumed from power save mode */\n\n            msr |= 0x10000;\n\n        } else {\n\n            new_msr &= ~((target_ulong)1 << MSR_ME);\n\n        }\n\n\n\n        if (0) {\n\n            /* XXX: find a suitable condition to enable the hypervisor mode */\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        }\n\n        goto store_next;\n\n    case POWERPC_EXCP_DSEG:      /* Data segment exception                   */\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        goto store_next;\n\n    case POWERPC_EXCP_ISEG:      /* Instruction segment exception            */\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        goto store_next;\n\n    case POWERPC_EXCP_HDECR:     /* Hypervisor decrementer exception         */\n\n        srr0 = SPR_HSRR0;\n\n        srr1 = SPR_HSRR1;\n\n        new_msr |= (target_ulong)MSR_HVB;\n\n        new_msr |= env->msr & ((target_ulong)1 << MSR_RI);\n\n        goto store_next;\n\n    case POWERPC_EXCP_TRACE:     /* Trace exception                          */\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        goto store_next;\n\n    case POWERPC_EXCP_HDSI:      /* Hypervisor data storage exception        */\n\n        srr0 = SPR_HSRR0;\n\n        srr1 = SPR_HSRR1;\n\n        new_msr |= (target_ulong)MSR_HVB;\n\n        new_msr |= env->msr & ((target_ulong)1 << MSR_RI);\n\n        goto store_next;\n\n    case POWERPC_EXCP_HISI:      /* Hypervisor instruction storage exception */\n\n        srr0 = SPR_HSRR0;\n\n        srr1 = SPR_HSRR1;\n\n        new_msr |= (target_ulong)MSR_HVB;\n\n        new_msr |= env->msr & ((target_ulong)1 << MSR_RI);\n\n        goto store_next;\n\n    case POWERPC_EXCP_HDSEG:     /* Hypervisor data segment exception        */\n\n        srr0 = SPR_HSRR0;\n\n        srr1 = SPR_HSRR1;\n\n        new_msr |= (target_ulong)MSR_HVB;\n\n        new_msr |= env->msr & ((target_ulong)1 << MSR_RI);\n\n        goto store_next;\n\n    case POWERPC_EXCP_HISEG:     /* Hypervisor instruction segment exception */\n\n        srr0 = SPR_HSRR0;\n\n        srr1 = SPR_HSRR1;\n\n        new_msr |= (target_ulong)MSR_HVB;\n\n        new_msr |= env->msr & ((target_ulong)1 << MSR_RI);\n\n        goto store_next;\n\n    case POWERPC_EXCP_VPU:       /* Vector unavailable exception             */\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        goto store_current;\n\n    case POWERPC_EXCP_PIT:       /* Programmable interval timer interrupt    */\n\n        LOG_EXCP(\"PIT exception\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_IO:        /* IO error exception                       */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"601 IO error exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_RUNM:      /* Run mode exception                       */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"601 run mode exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_EMUL:      /* Emulation trap exception                 */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"602 emulation trap exception \"\n\n                  \"is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_IFTLB:     /* Instruction fetch TLB error              */\n\n        if (lpes1 == 0) /* XXX: check this */\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_602:\n\n        case POWERPC_EXCP_603:\n\n        case POWERPC_EXCP_603E:\n\n        case POWERPC_EXCP_G2:\n\n            goto tlb_miss_tgpr;\n\n        case POWERPC_EXCP_7x5:\n\n            goto tlb_miss;\n\n        case POWERPC_EXCP_74xx:\n\n            goto tlb_miss_74xx;\n\n        default:\n\n            cpu_abort(env, \"Invalid instruction TLB miss exception\\n\");\n\n            break;\n\n        }\n\n        break;\n\n    case POWERPC_EXCP_DLTLB:     /* Data load TLB miss                       */\n\n        if (lpes1 == 0) /* XXX: check this */\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_602:\n\n        case POWERPC_EXCP_603:\n\n        case POWERPC_EXCP_603E:\n\n        case POWERPC_EXCP_G2:\n\n            goto tlb_miss_tgpr;\n\n        case POWERPC_EXCP_7x5:\n\n            goto tlb_miss;\n\n        case POWERPC_EXCP_74xx:\n\n            goto tlb_miss_74xx;\n\n        default:\n\n            cpu_abort(env, \"Invalid data load TLB miss exception\\n\");\n\n            break;\n\n        }\n\n        break;\n\n    case POWERPC_EXCP_DSTLB:     /* Data store TLB miss                      */\n\n        if (lpes1 == 0) /* XXX: check this */\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        switch (excp_model) {\n\n        case POWERPC_EXCP_602:\n\n        case POWERPC_EXCP_603:\n\n        case POWERPC_EXCP_603E:\n\n        case POWERPC_EXCP_G2:\n\n        tlb_miss_tgpr:\n\n            /* Swap temporary saved registers with GPRs */\n\n            if (!(new_msr & ((target_ulong)1 << MSR_TGPR))) {\n\n                new_msr |= (target_ulong)1 << MSR_TGPR;\n\n                hreg_swap_gpr_tgpr(env);\n\n            }\n\n            goto tlb_miss;\n\n        case POWERPC_EXCP_7x5:\n\n        tlb_miss:\n\n#if defined (DEBUG_SOFTWARE_TLB)\n\n            if (qemu_log_enabled()) {\n\n                const char *es;\n\n                target_ulong *miss, *cmp;\n\n                int en;\n\n                if (excp == POWERPC_EXCP_IFTLB) {\n\n                    es = \"I\";\n\n                    en = 'I';\n\n                    miss = &env->spr[SPR_IMISS];\n\n                    cmp = &env->spr[SPR_ICMP];\n\n                } else {\n\n                    if (excp == POWERPC_EXCP_DLTLB)\n\n                        es = \"DL\";\n\n                    else\n\n                        es = \"DS\";\n\n                    en = 'D';\n\n                    miss = &env->spr[SPR_DMISS];\n\n                    cmp = &env->spr[SPR_DCMP];\n\n                }\n\n                qemu_log(\"6xx %sTLB miss: %cM \" TARGET_FMT_lx \" %cC \"\n\n                         TARGET_FMT_lx \" H1 \" TARGET_FMT_lx \" H2 \"\n\n                         TARGET_FMT_lx \" %08x\\n\", es, en, *miss, en, *cmp,\n\n                         env->spr[SPR_HASH1], env->spr[SPR_HASH2],\n\n                         env->error_code);\n\n            }\n\n#endif\n\n            msr |= env->crf[0] << 28;\n\n            msr |= env->error_code; /* key, D/I, S/L bits */\n\n            /* Set way using a LRU mechanism */\n\n            msr |= ((env->last_way + 1) & (env->nb_ways - 1)) << 17;\n\n            break;\n\n        case POWERPC_EXCP_74xx:\n\n        tlb_miss_74xx:\n\n#if defined (DEBUG_SOFTWARE_TLB)\n\n            if (qemu_log_enabled()) {\n\n                const char *es;\n\n                target_ulong *miss, *cmp;\n\n                int en;\n\n                if (excp == POWERPC_EXCP_IFTLB) {\n\n                    es = \"I\";\n\n                    en = 'I';\n\n                    miss = &env->spr[SPR_TLBMISS];\n\n                    cmp = &env->spr[SPR_PTEHI];\n\n                } else {\n\n                    if (excp == POWERPC_EXCP_DLTLB)\n\n                        es = \"DL\";\n\n                    else\n\n                        es = \"DS\";\n\n                    en = 'D';\n\n                    miss = &env->spr[SPR_TLBMISS];\n\n                    cmp = &env->spr[SPR_PTEHI];\n\n                }\n\n                qemu_log(\"74xx %sTLB miss: %cM \" TARGET_FMT_lx \" %cC \"\n\n                         TARGET_FMT_lx \" %08x\\n\", es, en, *miss, en, *cmp,\n\n                         env->error_code);\n\n            }\n\n#endif\n\n            msr |= env->error_code; /* key bit */\n\n            break;\n\n        default:\n\n            cpu_abort(env, \"Invalid data store TLB miss exception\\n\");\n\n            break;\n\n        }\n\n        goto store_next;\n\n    case POWERPC_EXCP_FPA:       /* Floating-point assist exception          */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"Floating point assist exception \"\n\n                  \"is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_DABR:      /* Data address breakpoint                  */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"DABR exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_IABR:      /* Instruction address breakpoint           */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"IABR exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_SMI:       /* System management interrupt              */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"SMI exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_THERM:     /* Thermal interrupt                        */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"Thermal management exception \"\n\n                  \"is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_PERFM:     /* Embedded performance monitor interrupt   */\n\n        if (lpes1 == 0)\n\n            new_msr |= (target_ulong)MSR_HVB;\n\n        /* XXX: TODO */\n\n        cpu_abort(env,\n\n                  \"Performance counter exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_VPUA:      /* Vector assist exception                  */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"VPU assist exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_SOFTP:     /* Soft patch exception                     */\n\n        /* XXX: TODO */\n\n        cpu_abort(env,\n\n                  \"970 soft-patch exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_MAINT:     /* Maintenance exception                    */\n\n        /* XXX: TODO */\n\n        cpu_abort(env,\n\n                  \"970 maintenance exception is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_MEXTBR:    /* Maskable external breakpoint             */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"Maskable external exception \"\n\n                  \"is not implemented yet !\\n\");\n\n        goto store_next;\n\n    case POWERPC_EXCP_NMEXTBR:   /* Non maskable external breakpoint         */\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"Non maskable external exception \"\n\n                  \"is not implemented yet !\\n\");\n\n        goto store_next;\n\n    default:\n\n    excp_invalid:\n\n        cpu_abort(env, \"Invalid PowerPC exception %d. Aborting\\n\", excp);\n\n        break;\n\n    store_current:\n\n        /* save current instruction location */\n\n        env->spr[srr0] = env->nip - 4;\n\n        break;\n\n    store_next:\n\n        /* save next instruction location */\n\n        env->spr[srr0] = env->nip;\n\n        break;\n\n    }\n\n    /* Save MSR */\n\n    env->spr[srr1] = msr;\n\n    /* If any alternate SRR register are defined, duplicate saved values */\n\n    if (asrr0 != -1)\n\n        env->spr[asrr0] = env->spr[srr0];\n\n    if (asrr1 != -1)\n\n        env->spr[asrr1] = env->spr[srr1];\n\n    /* If we disactivated any translation, flush TLBs */\n\n    if (new_msr & ((1 << MSR_IR) | (1 << MSR_DR)))\n\n        tlb_flush(env, 1);\n\n\n\n    if (msr_ile) {\n\n        new_msr |= (target_ulong)1 << MSR_LE;\n\n    }\n\n\n\n    /* Jump to handler */\n\n    vector = env->excp_vectors[excp];\n\n    if (vector == (target_ulong)-1ULL) {\n\n        cpu_abort(env, \"Raised an exception without defined vector %d\\n\",\n\n                  excp);\n\n    }\n\n    vector |= env->excp_prefix;\n\n#if defined(TARGET_PPC64)\n\n    if (excp_model == POWERPC_EXCP_BOOKE) {\n\n        if (!msr_icm) {\n\n            vector = (uint32_t)vector;\n\n        } else {\n\n            new_msr |= (target_ulong)1 << MSR_CM;\n\n        }\n\n    } else {\n\n        if (!msr_isf && !(env->mmu_model & POWERPC_MMU_64)) {\n\n            vector = (uint32_t)vector;\n\n        } else {\n\n            new_msr |= (target_ulong)1 << MSR_SF;\n\n        }\n\n    }\n\n#endif\n\n    /* XXX: we don't use hreg_store_msr here as already have treated\n\n     *      any special case that could occur. Just store MSR and update hflags\n\n     */\n\n    env->msr = new_msr & env->msr_mask;\n\n    hreg_compute_hflags(env);\n\n    env->nip = vector;\n\n    /* Reset exception state */\n\n    env->exception_index = POWERPC_EXCP_NONE;\n\n    env->error_code = 0;\n\n\n\n    if (env->mmu_model == POWERPC_MMU_BOOKE) {\n\n        /* XXX: The BookE changes address space when switching modes,\n\n                we should probably implement that as different MMU indexes,\n\n                but for the moment we do it the slow way and flush all.  */\n\n        tlb_flush(env, 1);\n\n    }\n\n}\n", "idx": 16138}
{"project": "FFmpeg", "commit_id": "2758cdedfb7ac61f8b5e4861f99218b6fd43491d", "target": 0, "func": "static int url_alloc_for_protocol(URLContext **puc, struct URLProtocol *up,\n\n                                  const char *filename, int flags,\n\n                                  const AVIOInterruptCB *int_cb)\n\n{\n\n    URLContext *uc;\n\n    int err;\n\n\n\n#if CONFIG_NETWORK\n\n    if (up->flags & URL_PROTOCOL_FLAG_NETWORK && !ff_network_init())\n\n        return AVERROR(EIO);\n\n#endif\n\n    uc = av_mallocz(sizeof(URLContext) + strlen(filename) + 1);\n\n    if (!uc) {\n\n        err = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    uc->av_class = &ffurl_context_class;\n\n    uc->filename = (char *)&uc[1];\n\n    strcpy(uc->filename, filename);\n\n    uc->prot            = up;\n\n    uc->flags           = flags;\n\n    uc->is_streamed     = 0; /* default = not streamed */\n\n    uc->max_packet_size = 0; /* default: stream file */\n\n    if (up->priv_data_size) {\n\n        uc->priv_data = av_mallocz(up->priv_data_size);\n\n        if (!uc->priv_data) {\n\n            err = AVERROR(ENOMEM);\n\n            goto fail;\n\n        }\n\n        if (up->priv_data_class) {\n\n            *(const AVClass **)uc->priv_data = up->priv_data_class;\n\n            av_opt_set_defaults(uc->priv_data);\n\n        }\n\n    }\n\n    if (int_cb)\n\n        uc->interrupt_callback = *int_cb;\n\n\n\n    *puc = uc;\n\n    return 0;\n\nfail:\n\n    *puc = NULL;\n\n    if (uc)\n\n        av_freep(&uc->priv_data);\n\n    av_freep(&uc);\n\n#if CONFIG_NETWORK\n\n    if (up->flags & URL_PROTOCOL_FLAG_NETWORK)\n\n        ff_network_close();\n\n#endif\n\n    return err;\n\n}\n", "idx": 16184}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static int rv10_decode_packet(AVCodecContext *avctx, const uint8_t *buf,\n\n                              int buf_size, int buf_size2)\n\n{\n\n    RVDecContext *rv = avctx->priv_data;\n\n    MpegEncContext *s = &rv->m;\n\n    int mb_count, mb_pos, left, start_mb_x, active_bits_size, ret;\n\n\n\n    active_bits_size = buf_size * 8;\n\n    init_get_bits(&s->gb, buf, FFMAX(buf_size, buf_size2) * 8);\n\n    if (s->codec_id == AV_CODEC_ID_RV10)\n\n        mb_count = rv10_decode_picture_header(s);\n\n    else\n\n        mb_count = rv20_decode_picture_header(rv);\n\n    if (mb_count < 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"HEADER ERROR\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (s->mb_x >= s->mb_width ||\n\n        s->mb_y >= s->mb_height) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"POS ERROR %d %d\\n\", s->mb_x, s->mb_y);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    mb_pos = s->mb_y * s->mb_width + s->mb_x;\n\n    left   = s->mb_width * s->mb_height - mb_pos;\n\n    if (mb_count > left) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"COUNT ERROR\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if ((s->mb_x == 0 && s->mb_y == 0) || s->current_picture_ptr == NULL) {\n\n        // FIXME write parser so we always have complete frames?\n\n        if (s->current_picture_ptr) {\n\n            ff_er_frame_end(&s->er);\n\n            ff_mpv_frame_end(s);\n\n            s->mb_x = s->mb_y = s->resync_mb_x = s->resync_mb_y = 0;\n\n        }\n\n        if ((ret = ff_mpv_frame_start(s, avctx)) < 0)\n\n            return ret;\n\n        ff_mpeg_er_frame_start(s);\n\n    } else {\n\n        if (s->current_picture_ptr->f->pict_type != s->pict_type) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"Slice type mismatch\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n\n\n    av_dlog(avctx, \"qscale=%d\\n\", s->qscale);\n\n\n\n    /* default quantization values */\n\n    if (s->codec_id == AV_CODEC_ID_RV10) {\n\n        if (s->mb_y == 0)\n\n            s->first_slice_line = 1;\n\n    } else {\n\n        s->first_slice_line = 1;\n\n        s->resync_mb_x      = s->mb_x;\n\n    }\n\n    start_mb_x     = s->mb_x;\n\n    s->resync_mb_y = s->mb_y;\n\n    if (s->h263_aic) {\n\n        s->y_dc_scale_table =\n\n        s->c_dc_scale_table = ff_aic_dc_scale_table;\n\n    } else {\n\n        s->y_dc_scale_table =\n\n        s->c_dc_scale_table = ff_mpeg1_dc_scale_table;\n\n    }\n\n\n\n    if (s->modified_quant)\n\n        s->chroma_qscale_table = ff_h263_chroma_qscale_table;\n\n\n\n    ff_set_qscale(s, s->qscale);\n\n\n\n    s->rv10_first_dc_coded[0] = 0;\n\n    s->rv10_first_dc_coded[1] = 0;\n\n    s->rv10_first_dc_coded[2] = 0;\n\n    s->block_wrap[0] =\n\n    s->block_wrap[1] =\n\n    s->block_wrap[2] =\n\n    s->block_wrap[3] = s->b8_stride;\n\n    s->block_wrap[4] =\n\n    s->block_wrap[5] = s->mb_stride;\n\n    ff_init_block_index(s);\n\n\n\n    /* decode each macroblock */\n\n    for (s->mb_num_left = mb_count; s->mb_num_left > 0; s->mb_num_left--) {\n\n        int ret;\n\n        ff_update_block_index(s);\n\n        av_dlog(avctx, \"**mb x=%d y=%d\\n\", s->mb_x, s->mb_y);\n\n\n\n        s->mv_dir  = MV_DIR_FORWARD;\n\n        s->mv_type = MV_TYPE_16X16;\n\n        ret = ff_h263_decode_mb(s, s->block);\n\n\n\n        // Repeat the slice end check from ff_h263_decode_mb with our active\n\n        // bitstream size\n\n        if (ret != SLICE_ERROR) {\n\n            int v = show_bits(&s->gb, 16);\n\n\n\n            if (get_bits_count(&s->gb) + 16 > active_bits_size)\n\n                v >>= get_bits_count(&s->gb) + 16 - active_bits_size;\n\n\n\n            if (!v)\n\n                ret = SLICE_END;\n\n        }\n\n        if (ret != SLICE_ERROR && active_bits_size < get_bits_count(&s->gb) &&\n\n            8 * buf_size2 >= get_bits_count(&s->gb)) {\n\n            active_bits_size = buf_size2 * 8;\n\n            av_log(avctx, AV_LOG_DEBUG, \"update size from %d to %d\\n\",\n\n                   8 * buf_size, active_bits_size);\n\n            ret = SLICE_OK;\n\n        }\n\n\n\n        if (ret == SLICE_ERROR || active_bits_size < get_bits_count(&s->gb)) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"ERROR at MB %d %d\\n\", s->mb_x,\n\n                   s->mb_y);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        if (s->pict_type != AV_PICTURE_TYPE_B)\n\n            ff_h263_update_motion_val(s);\n\n        ff_mpv_decode_mb(s, s->block);\n\n        if (s->loop_filter)\n\n            ff_h263_loop_filter(s);\n\n\n\n        if (++s->mb_x == s->mb_width) {\n\n            s->mb_x = 0;\n\n            s->mb_y++;\n\n            ff_init_block_index(s);\n\n        }\n\n        if (s->mb_x == s->resync_mb_x)\n\n            s->first_slice_line = 0;\n\n        if (ret == SLICE_END)\n\n            break;\n\n    }\n\n\n\n    ff_er_add_slice(&s->er, start_mb_x, s->resync_mb_y, s->mb_x - 1, s->mb_y,\n\n                    ER_MB_END);\n\n\n\n    return active_bits_size;\n\n}\n", "idx": 16185}
{"project": "qemu", "commit_id": "d88d3a093898bd1dc0898c7c87b0d3f555a24a6e", "target": 0, "func": "static void mipsnet_ioport_write(void *opaque, hwaddr addr,\n\n                                 uint64_t val, unsigned int size)\n\n{\n\n    MIPSnetState *s = opaque;\n\n\n\n    addr &= 0x3f;\n\n    trace_mipsnet_write(addr, val);\n\n    switch (addr) {\n\n    case MIPSNET_TX_DATA_COUNT:\n\n\ts->tx_count = (val <= MAX_ETH_FRAME_SIZE) ? val : 0;\n\n        s->tx_written = 0;\n\n        break;\n\n    case MIPSNET_INT_CTL:\n\n        if (val & MIPSNET_INTCTL_TXDONE) {\n\n            s->intctl &= ~MIPSNET_INTCTL_TXDONE;\n\n        } else if (val & MIPSNET_INTCTL_RXDONE) {\n\n            s->intctl &= ~MIPSNET_INTCTL_RXDONE;\n\n        } else if (val & MIPSNET_INTCTL_TESTBIT) {\n\n            mipsnet_reset(s);\n\n            s->intctl |= MIPSNET_INTCTL_TESTBIT;\n\n        } else if (!val) {\n\n            /* ACK testbit interrupt, flag was cleared on read. */\n\n        }\n\n        s->busy = !!s->intctl;\n\n        mipsnet_update_irq(s);\n\n        if (mipsnet_can_receive(s->nic->ncs)) {\n\n            qemu_flush_queued_packets(qemu_get_queue(s->nic));\n\n        }\n\n        break;\n\n    case MIPSNET_TX_DATA_BUFFER:\n\n        s->tx_buffer[s->tx_written++] = val;\n\n        if (s->tx_written == s->tx_count) {\n\n            /* Send buffer. */\n\n            trace_mipsnet_send(s->tx_count);\n\n            qemu_send_packet(qemu_get_queue(s->nic), s->tx_buffer, s->tx_count);\n\n            s->tx_count = s->tx_written = 0;\n\n            s->intctl |= MIPSNET_INTCTL_TXDONE;\n\n            s->busy = 1;\n\n            mipsnet_update_irq(s);\n\n        }\n\n        break;\n\n    /* Read-only registers */\n\n    case MIPSNET_DEV_ID:\n\n    case MIPSNET_BUSY:\n\n    case MIPSNET_RX_DATA_COUNT:\n\n    case MIPSNET_INTERRUPT_INFO:\n\n    case MIPSNET_RX_DATA_BUFFER:\n\n    default:\n\n        break;\n\n    }\n\n}\n", "idx": 16243}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void qmp_input_stack_object_free(StackObject *tos)\n\n{\n\n    if (tos->h) {\n\n        g_hash_table_unref(tos->h);\n\n    }\n\n\n\n    g_free(tos);\n\n}\n", "idx": 16277}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "bool timer_expired(QEMUTimer *timer_head, int64_t current_time)\n\n{\n\n    return timer_expired_ns(timer_head, current_time * timer_head->scale);\n\n}\n", "idx": 16279}
{"project": "qemu", "commit_id": "0c866a7ed47bc8a2df320e59bc669e4784d8ad2f", "target": 0, "func": "_syscall3(int,sys_faccessat,int,dirfd,const char *,pathname,int,mode)\n\n#endif\n\n#if defined(TARGET_NR_fchmodat) && defined(__NR_fchmodat)\n\n_syscall3(int,sys_fchmodat,int,dirfd,const char *,pathname, mode_t,mode)\n\n#endif\n\n#if defined(TARGET_NR_fchownat) && defined(__NR_fchownat) && defined(USE_UID16)\n\n_syscall5(int,sys_fchownat,int,dirfd,const char *,pathname,\n\n          uid_t,owner,gid_t,group,int,flags)\n\n#endif\n\n#if (defined(TARGET_NR_fstatat64) || defined(TARGET_NR_newfstatat)) && \\\n\n        defined(__NR_fstatat64)\n\n_syscall4(int,sys_fstatat64,int,dirfd,const char *,pathname,\n\n          struct stat *,buf,int,flags)\n\n#endif\n\n#if defined(TARGET_NR_futimesat) && defined(__NR_futimesat)\n\n_syscall3(int,sys_futimesat,int,dirfd,const char *,pathname,\n\n         const struct timeval *,times)\n\n#endif\n\n#if (defined(TARGET_NR_newfstatat) || defined(TARGET_NR_fstatat64) ) && \\\n\n        defined(__NR_newfstatat)\n\n_syscall4(int,sys_newfstatat,int,dirfd,const char *,pathname,\n\n          struct stat *,buf,int,flags)\n\n#endif\n\n#if defined(TARGET_NR_linkat) && defined(__NR_linkat)\n\n_syscall5(int,sys_linkat,int,olddirfd,const char *,oldpath,\n\n      int,newdirfd,const char *,newpath,int,flags)\n\n#endif\n\n#if defined(TARGET_NR_mkdirat) && defined(__NR_mkdirat)\n\n_syscall3(int,sys_mkdirat,int,dirfd,const char *,pathname,mode_t,mode)\n\n#endif\n\n#if defined(TARGET_NR_mknodat) && defined(__NR_mknodat)\n\n_syscall4(int,sys_mknodat,int,dirfd,const char *,pathname,\n\n          mode_t,mode,dev_t,dev)\n\n#endif\n\n#if defined(TARGET_NR_openat) && defined(__NR_openat)\n\n_syscall4(int,sys_openat,int,dirfd,const char *,pathname,int,flags,mode_t,mode)\n\n#endif\n\n#if defined(TARGET_NR_readlinkat) && defined(__NR_readlinkat)\n\n_syscall4(int,sys_readlinkat,int,dirfd,const char *,pathname,\n\n          char *,buf,size_t,bufsize)\n\n#endif\n\n#if defined(TARGET_NR_renameat) && defined(__NR_renameat)\n\n_syscall4(int,sys_renameat,int,olddirfd,const char *,oldpath,\n\n          int,newdirfd,const char *,newpath)\n\n#endif\n\n#if defined(TARGET_NR_symlinkat) && defined(__NR_symlinkat)\n\n_syscall3(int,sys_symlinkat,const char *,oldpath,\n\n          int,newdirfd,const char *,newpath)\n\n#endif\n\n#if defined(TARGET_NR_unlinkat) && defined(__NR_unlinkat)\n\n_syscall3(int,sys_unlinkat,int,dirfd,const char *,pathname,int,flags)\n\n#endif\n\n\n\n#endif /* CONFIG_ATFILE */\n\n\n\n#ifdef CONFIG_UTIMENSAT\n\nstatic int sys_utimensat(int dirfd, const char *pathname,\n\n    const struct timespec times[2], int flags)\n\n{\n\n    if (pathname == NULL)\n\n        return futimens(dirfd, times);\n\n    else\n\n        return utimensat(dirfd, pathname, times, flags);\n\n}\n", "idx": 16307}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static int decode_chunks(AVCodecContext *avctx, AVFrame *picture,\n\n                         int *got_output, const uint8_t *buf, int buf_size)\n\n{\n\n    Mpeg1Context *s = avctx->priv_data;\n\n    MpegEncContext *s2 = &s->mpeg_enc_ctx;\n\n    const uint8_t *buf_ptr = buf;\n\n    const uint8_t *buf_end = buf + buf_size;\n\n    int ret, input_size;\n\n    int last_code = 0, skip_frame = 0;\n\n\n\n    for (;;) {\n\n        /* find next start code */\n\n        uint32_t start_code = -1;\n\n        buf_ptr = avpriv_find_start_code(buf_ptr, buf_end, &start_code);\n\n        if (start_code > 0x1ff) {\n\n            if (!skip_frame) {\n\n                if (HAVE_THREADS &&\n\n                    (avctx->active_thread_type & FF_THREAD_SLICE) &&\n\n                    !avctx->hwaccel) {\n\n                    int i;\n\n\n\n                    avctx->execute(avctx, slice_decode_thread,\n\n                                   &s2->thread_context[0], NULL,\n\n                                   s->slice_count, sizeof(void *));\n\n                    for (i = 0; i < s->slice_count; i++)\n\n                        s2->er.error_count += s2->thread_context[i]->er.error_count;\n\n                }\n\n\n\n                ret = slice_end(avctx, picture);\n\n                if (ret < 0)\n\n                    return ret;\n\n                else if (ret) {\n\n                    // FIXME: merge with the stuff in mpeg_decode_slice\n\n                    if (s2->last_picture_ptr || s2->low_delay)\n\n                        *got_output = 1;\n\n                }\n\n            }\n\n            s2->pict_type = 0;\n\n            return FFMAX(0, buf_ptr - buf - s2->parse_context.last_index);\n\n        }\n\n\n\n        input_size = buf_end - buf_ptr;\n\n\n\n        if (avctx->debug & FF_DEBUG_STARTCODE)\n\n            av_log(avctx, AV_LOG_DEBUG, \"%3\"PRIX32\" at %td left %d\\n\",\n\n                   start_code, buf_ptr - buf, input_size);\n\n\n\n        /* prepare data for next start code */\n\n        switch (start_code) {\n\n        case SEQ_START_CODE:\n\n            if (last_code == 0) {\n\n                mpeg1_decode_sequence(avctx, buf_ptr, input_size);\n\n                s->sync = 1;\n\n            } else {\n\n                av_log(avctx, AV_LOG_ERROR,\n\n                       \"ignoring SEQ_START_CODE after %X\\n\", last_code);\n\n                if (avctx->err_recognition & AV_EF_EXPLODE)\n\n                    return AVERROR_INVALIDDATA;\n\n            }\n\n            break;\n\n\n\n        case PICTURE_START_CODE:\n\n            if (s2->width <= 0 || s2->height <= 0) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Invalid frame dimensions %dx%d.\\n\",\n\n                       s2->width, s2->height);\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n\n\n            if (HAVE_THREADS && (avctx->active_thread_type & FF_THREAD_SLICE) &&\n\n                !avctx->hwaccel && s->slice_count) {\n\n                int i;\n\n\n\n                avctx->execute(avctx, slice_decode_thread,\n\n                               s2->thread_context, NULL,\n\n                               s->slice_count, sizeof(void *));\n\n                for (i = 0; i < s->slice_count; i++)\n\n                    s2->er.error_count += s2->thread_context[i]->er.error_count;\n\n                s->slice_count = 0;\n\n            }\n\n            if (last_code == 0 || last_code == SLICE_MIN_START_CODE) {\n\n                ret = mpeg_decode_postinit(avctx);\n\n                if (ret < 0) {\n\n                    av_log(avctx, AV_LOG_ERROR,\n\n                           \"mpeg_decode_postinit() failure\\n\");\n\n                    return ret;\n\n                }\n\n\n\n                /* We have a complete image: we try to decompress it. */\n\n                if (mpeg1_decode_picture(avctx, buf_ptr, input_size) < 0)\n\n                    s2->pict_type = 0;\n\n                s->first_slice = 1;\n\n                last_code      = PICTURE_START_CODE;\n\n            } else {\n\n                av_log(avctx, AV_LOG_ERROR,\n\n                       \"ignoring pic after %X\\n\", last_code);\n\n                if (avctx->err_recognition & AV_EF_EXPLODE)\n\n                    return AVERROR_INVALIDDATA;\n\n            }\n\n            break;\n\n        case EXT_START_CODE:\n\n            init_get_bits(&s2->gb, buf_ptr, input_size * 8);\n\n\n\n            switch (get_bits(&s2->gb, 4)) {\n\n            case 0x1:\n\n                if (last_code == 0) {\n\n                    mpeg_decode_sequence_extension(s);\n\n                } else {\n\n                    av_log(avctx, AV_LOG_ERROR,\n\n                           \"ignoring seq ext after %X\\n\", last_code);\n\n                    if (avctx->err_recognition & AV_EF_EXPLODE)\n\n                        return AVERROR_INVALIDDATA;\n\n                }\n\n                break;\n\n            case 0x2:\n\n                mpeg_decode_sequence_display_extension(s);\n\n                break;\n\n            case 0x3:\n\n                mpeg_decode_quant_matrix_extension(s2);\n\n                break;\n\n            case 0x7:\n\n                mpeg_decode_picture_display_extension(s);\n\n                break;\n\n            case 0x8:\n\n                if (last_code == PICTURE_START_CODE) {\n\n                    mpeg_decode_picture_coding_extension(s);\n\n                } else {\n\n                    av_log(avctx, AV_LOG_ERROR,\n\n                           \"ignoring pic cod ext after %X\\n\", last_code);\n\n                    if (avctx->err_recognition & AV_EF_EXPLODE)\n\n                        return AVERROR_INVALIDDATA;\n\n                }\n\n                break;\n\n            }\n\n            break;\n\n        case USER_START_CODE:\n\n            mpeg_decode_user_data(avctx, buf_ptr, input_size);\n\n            break;\n\n        case GOP_START_CODE:\n\n            if (last_code == 0) {\n\n                s2->first_field = 0;\n\n                mpeg_decode_gop(avctx, buf_ptr, input_size);\n\n                s->sync = 1;\n\n            } else {\n\n                av_log(avctx, AV_LOG_ERROR,\n\n                       \"ignoring GOP_START_CODE after %X\\n\", last_code);\n\n                if (avctx->err_recognition & AV_EF_EXPLODE)\n\n                    return AVERROR_INVALIDDATA;\n\n            }\n\n            break;\n\n        default:\n\n            if (start_code >= SLICE_MIN_START_CODE &&\n\n                start_code <= SLICE_MAX_START_CODE && last_code != 0) {\n\n                const int field_pic = s2->picture_structure != PICT_FRAME;\n\n                int mb_y = (start_code - SLICE_MIN_START_CODE) << field_pic;\n\n                last_code = SLICE_MIN_START_CODE;\n\n\n\n                if (s2->picture_structure == PICT_BOTTOM_FIELD)\n\n                    mb_y++;\n\n\n\n                if (mb_y >= s2->mb_height) {\n\n                    av_log(s2->avctx, AV_LOG_ERROR,\n\n                           \"slice below image (%d >= %d)\\n\", mb_y, s2->mb_height);\n\n                    return -1;\n\n                }\n\n\n\n                if (s2->last_picture_ptr == NULL) {\n\n                    /* Skip B-frames if we do not have reference frames and\n\n                     * GOP is not closed. */\n\n                    if (s2->pict_type == AV_PICTURE_TYPE_B) {\n\n                        if (!s->closed_gop) {\n\n                            skip_frame = 1;\n\n                            break;\n\n                        }\n\n                    }\n\n                }\n\n                if (s2->pict_type == AV_PICTURE_TYPE_I)\n\n                    s->sync = 1;\n\n                if (s2->next_picture_ptr == NULL) {\n\n                    /* Skip P-frames if we do not have a reference frame or\n\n                     * we have an invalid header. */\n\n                    if (s2->pict_type == AV_PICTURE_TYPE_P && !s->sync) {\n\n                        skip_frame = 1;\n\n                        break;\n\n                    }\n\n                }\n\n                if ((avctx->skip_frame >= AVDISCARD_NONREF &&\n\n                     s2->pict_type == AV_PICTURE_TYPE_B) ||\n\n                    (avctx->skip_frame >= AVDISCARD_NONKEY &&\n\n                     s2->pict_type != AV_PICTURE_TYPE_I) ||\n\n                    avctx->skip_frame >= AVDISCARD_ALL) {\n\n                    skip_frame = 1;\n\n                    break;\n\n                }\n\n\n\n                if (!s->mpeg_enc_ctx_allocated)\n\n                    break;\n\n\n\n                if (s2->codec_id == AV_CODEC_ID_MPEG2VIDEO) {\n\n                    if (mb_y < avctx->skip_top ||\n\n                        mb_y >= s2->mb_height - avctx->skip_bottom)\n\n                        break;\n\n                }\n\n\n\n                if (!s2->pict_type) {\n\n                    av_log(avctx, AV_LOG_ERROR, \"Missing picture start code\\n\");\n\n                    if (avctx->err_recognition & AV_EF_EXPLODE)\n\n                        return AVERROR_INVALIDDATA;\n\n                    break;\n\n                }\n\n\n\n                if (s->first_slice) {\n\n                    skip_frame     = 0;\n\n                    s->first_slice = 0;\n\n                    if (mpeg_field_start(s2, buf, buf_size) < 0)\n\n                        return -1;\n\n                }\n\n                if (!s2->current_picture_ptr) {\n\n                    av_log(avctx, AV_LOG_ERROR,\n\n                           \"current_picture not initialized\\n\");\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n\n\n                if (HAVE_THREADS &&\n\n                    (avctx->active_thread_type & FF_THREAD_SLICE) &&\n\n                    !avctx->hwaccel) {\n\n                    int threshold = (s2->mb_height * s->slice_count +\n\n                                     s2->slice_context_count / 2) /\n\n                                    s2->slice_context_count;\n\n                    if (threshold <= mb_y) {\n\n                        MpegEncContext *thread_context = s2->thread_context[s->slice_count];\n\n\n\n                        thread_context->start_mb_y = mb_y;\n\n                        thread_context->end_mb_y   = s2->mb_height;\n\n                        if (s->slice_count) {\n\n                            s2->thread_context[s->slice_count - 1]->end_mb_y = mb_y;\n\n                            ret = ff_update_duplicate_context(thread_context, s2);\n\n                            if (ret < 0)\n\n                                return ret;\n\n                        }\n\n                        init_get_bits(&thread_context->gb, buf_ptr, input_size * 8);\n\n                        s->slice_count++;\n\n                    }\n\n                    buf_ptr += 2; // FIXME add minimum number of bytes per slice\n\n                } else {\n\n                    ret = mpeg_decode_slice(s2, mb_y, &buf_ptr, input_size);\n\n                    emms_c();\n\n\n\n                    if (ret < 0) {\n\n                        if (avctx->err_recognition & AV_EF_EXPLODE)\n\n                            return ret;\n\n                        if (s2->resync_mb_x >= 0 && s2->resync_mb_y >= 0)\n\n                            ff_er_add_slice(&s2->er, s2->resync_mb_x,\n\n                                            s2->resync_mb_y, s2->mb_x, s2->mb_y,\n\n                                            ER_AC_ERROR | ER_DC_ERROR | ER_MV_ERROR);\n\n                    } else {\n\n                        ff_er_add_slice(&s2->er, s2->resync_mb_x,\n\n                                        s2->resync_mb_y, s2->mb_x - 1, s2->mb_y,\n\n                                        ER_AC_END | ER_DC_END | ER_MV_END);\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 16503}
{"project": "qemu", "commit_id": "d4cd45028898a37afb45fb449954115b4960d4e9", "target": 0, "func": "static int xen_pt_bar_reg_init(XenPCIPassthroughState *s, XenPTRegInfo *reg,\n\n                               uint32_t real_offset, uint32_t *data)\n\n{\n\n    uint32_t reg_field = 0;\n\n    int index;\n\n\n\n    index = xen_pt_bar_offset_to_index(reg->offset);\n\n    if (index < 0 || index >= PCI_NUM_REGIONS) {\n\n        XEN_PT_ERR(&s->dev, \"Internal error: Invalid BAR index [%d].\\n\", index);\n\n        return -1;\n\n    }\n\n\n\n    /* set BAR flag */\n\n    s->bases[index].bar_flag = xen_pt_bar_reg_parse(s, reg);\n\n    if (s->bases[index].bar_flag == XEN_PT_BAR_FLAG_UNUSED) {\n\n        reg_field = XEN_PT_INVALID_REG;\n\n    }\n\n\n\n    *data = reg_field;\n\n    return 0;\n\n}\n", "idx": 16533}
{"project": "qemu", "commit_id": "f020ed36fef7780e81a94543ae6388d8dc144ab6", "target": 0, "func": "static void ehci_frame_timer(void *opaque)\n\n{\n\n    EHCIState *ehci = opaque;\n\n    int schedules = 0;\n\n    int64_t expire_time, t_now;\n\n    uint64_t ns_elapsed;\n\n    int frames;\n\n    int i;\n\n    int skipped_frames = 0;\n\n\n\n    t_now = qemu_get_clock_ns(vm_clock);\n\n    ns_elapsed = t_now - ehci->last_run_ns;\n\n    frames = ns_elapsed / FRAME_TIMER_NS;\n\n\n\n    if (ehci_periodic_enabled(ehci) || ehci->pstate != EST_INACTIVE) {\n\n        schedules++;\n\n        expire_time = t_now + (get_ticks_per_sec() / FRAME_TIMER_FREQ);\n\n\n\n        for (i = 0; i < frames; i++) {\n\n            ehci_update_frindex(ehci, 1);\n\n\n\n            if (frames - i > ehci->maxframes) {\n\n                skipped_frames++;\n\n            } else {\n\n                ehci_advance_periodic_state(ehci);\n\n            }\n\n\n\n            ehci->last_run_ns += FRAME_TIMER_NS;\n\n        }\n\n    } else {\n\n        if (ehci->async_stepdown < ehci->maxframes / 2) {\n\n            ehci->async_stepdown++;\n\n        }\n\n        expire_time = t_now + (get_ticks_per_sec()\n\n                               * ehci->async_stepdown / FRAME_TIMER_FREQ);\n\n        ehci_update_frindex(ehci, frames);\n\n        ehci->last_run_ns += FRAME_TIMER_NS * frames;\n\n    }\n\n\n\n#if 0\n\n    if (skipped_frames) {\n\n        DPRINTF(\"WARNING - EHCI skipped %d frames\\n\", skipped_frames);\n\n    }\n\n#endif\n\n\n\n    /*  Async is not inside loop since it executes everything it can once\n\n     *  called\n\n     */\n\n    if (ehci_async_enabled(ehci) || ehci->astate != EST_INACTIVE) {\n\n        schedules++;\n\n        qemu_bh_schedule(ehci->async_bh);\n\n    }\n\n\n\n    if (schedules) {\n\n        qemu_mod_timer(ehci->frame_timer, expire_time);\n\n    }\n\n}\n", "idx": 16541}
{"project": "qemu", "commit_id": "ac1970fbe8ad5a70174f462109ac0f6c7bf1bc43", "target": 0, "func": "static void phys_page_set(target_phys_addr_t index, target_phys_addr_t nb,\n\n                          uint16_t leaf)\n\n{\n\n    /* Wildly overreserve - it doesn't matter much. */\n\n    phys_map_node_reserve(3 * P_L2_LEVELS);\n\n\n\n    phys_page_set_level(&phys_map, &index, &nb, leaf, P_L2_LEVELS - 1);\n\n}\n", "idx": 16569}
{"project": "FFmpeg", "commit_id": "b0cd14fb1dab4b044f7fe6b53ac635409849de77", "target": 0, "func": "int hw_device_setup_for_decode(InputStream *ist)\n\n{\n\n    enum AVHWDeviceType type;\n\n    HWDevice *dev;\n\n    int err;\n\n\n\n    if (ist->hwaccel_device) {\n\n        dev = hw_device_get_by_name(ist->hwaccel_device);\n\n        if (!dev) {\n\n            char *tmp;\n\n            type = hw_device_match_type_by_hwaccel(ist->hwaccel_id);\n\n            if (type == AV_HWDEVICE_TYPE_NONE) {\n\n                // No match - this isn't necessarily invalid, though,\n\n                // because an explicit device might not be needed or\n\n                // the hwaccel setup could be handled elsewhere.\n\n                return 0;\n\n            }\n\n            tmp = av_asprintf(\"%s:%s\", av_hwdevice_get_type_name(type),\n\n                              ist->hwaccel_device);\n\n            if (!tmp)\n\n                return AVERROR(ENOMEM);\n\n            err = hw_device_init_from_string(tmp, &dev);\n\n            av_free(tmp);\n\n            if (err < 0)\n\n                return err;\n\n        }\n\n    } else {\n\n        if (ist->hwaccel_id != HWACCEL_NONE)\n\n            type = hw_device_match_type_by_hwaccel(ist->hwaccel_id);\n\n        else\n\n            type = hw_device_match_type_in_name(ist->dec->name);\n\n        if (type != AV_HWDEVICE_TYPE_NONE) {\n\n            dev = hw_device_get_by_type(type);\n\n            if (!dev) {\n\n                hw_device_init_from_string(av_hwdevice_get_type_name(type),\n\n                                           &dev);\n\n            }\n\n        } else {\n\n            // No device required.\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    if (!dev) {\n\n        av_log(ist->dec_ctx, AV_LOG_WARNING, \"No device available \"\n\n               \"for decoder (device type %s for codec %s).\\n\",\n\n               av_hwdevice_get_type_name(type), ist->dec->name);\n\n        return 0;\n\n    }\n\n\n\n    ist->dec_ctx->hw_device_ctx = av_buffer_ref(dev->device_ref);\n\n    if (!ist->dec_ctx->hw_device_ctx)\n\n        return AVERROR(ENOMEM);\n\n\n\n    return 0;\n\n}\n", "idx": 16577}
{"project": "FFmpeg", "commit_id": "f78cd0c243b9149c7f604ecf1006d78e344aa6ca", "target": 1, "func": "void ff_prores_idct(DCTELEM *block, const int16_t *qmat)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < 64; i++)\n\n        block[i] *= qmat[i];\n\n\n\n    for (i = 0; i < 8; i++)\n\n        idctRowCondDC_10(block + i*8);\n\n\n\n    for (i = 0; i < 64; i++)\n\n        block[i] >>= 2;\n\n\n\n    for (i = 0; i < 8; i++)\n\n        idctSparseCol_10(block + i);\n\n}\n", "idx": 16660}
{"project": "FFmpeg", "commit_id": "c341f734e5f9d6af4a8fdcceb6f5d12de6395c76", "target": 1, "func": "static av_always_inline void encode_mb_internal(MpegEncContext *s,\n\n                                                int motion_x, int motion_y,\n\n                                                int mb_block_height,\n\n                                                int mb_block_width,\n\n                                                int mb_block_count)\n\n{\n\n    int16_t weight[12][64];\n\n    int16_t orig[12][64];\n\n    const int mb_x = s->mb_x;\n\n    const int mb_y = s->mb_y;\n\n    int i;\n\n    int skip_dct[12];\n\n    int dct_offset = s->linesize * 8; // default for progressive frames\n\n    int uv_dct_offset = s->uvlinesize * 8;\n\n    uint8_t *ptr_y, *ptr_cb, *ptr_cr;\n\n    int wrap_y, wrap_c;\n\n\n\n    for (i = 0; i < mb_block_count; i++)\n\n        skip_dct[i] = s->skipdct;\n\n\n\n    if (s->adaptive_quant) {\n\n        const int last_qp = s->qscale;\n\n        const int mb_xy = mb_x + mb_y * s->mb_stride;\n\n\n\n        s->lambda = s->lambda_table[mb_xy];\n\n        update_qscale(s);\n\n\n\n        if (!(s->mpv_flags & FF_MPV_FLAG_QP_RD)) {\n\n            s->qscale = s->current_picture_ptr->qscale_table[mb_xy];\n\n            s->dquant = s->qscale - last_qp;\n\n\n\n            if (s->out_format == FMT_H263) {\n\n                s->dquant = av_clip(s->dquant, -2, 2);\n\n\n\n                if (s->codec_id == AV_CODEC_ID_MPEG4) {\n\n                    if (!s->mb_intra) {\n\n                        if (s->pict_type == AV_PICTURE_TYPE_B) {\n\n                            if (s->dquant & 1 || s->mv_dir & MV_DIRECT)\n\n                                s->dquant = 0;\n\n                        }\n\n                        if (s->mv_type == MV_TYPE_8X8)\n\n                            s->dquant = 0;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        ff_set_qscale(s, last_qp + s->dquant);\n\n    } else if (s->mpv_flags & FF_MPV_FLAG_QP_RD)\n\n        ff_set_qscale(s, s->qscale + s->dquant);\n\n\n\n    wrap_y = s->linesize;\n\n    wrap_c = s->uvlinesize;\n\n    ptr_y  = s->new_picture.f.data[0] +\n\n             (mb_y * 16 * wrap_y)              + mb_x * 16;\n\n    ptr_cb = s->new_picture.f.data[1] +\n\n             (mb_y * mb_block_height * wrap_c) + mb_x * mb_block_width;\n\n    ptr_cr = s->new_picture.f.data[2] +\n\n             (mb_y * mb_block_height * wrap_c) + mb_x * mb_block_width;\n\n\n\n    if((mb_x*16+16 > s->width || mb_y*16+16 > s->height) && s->codec_id != AV_CODEC_ID_AMV){\n\n        uint8_t *ebuf = s->edge_emu_buffer + 32;\n\n        int cw = (s->width  + s->chroma_x_shift) >> s->chroma_x_shift;\n\n        int ch = (s->height + s->chroma_y_shift) >> s->chroma_y_shift;\n\n        s->vdsp.emulated_edge_mc(ebuf, ptr_y, wrap_y, 16, 16, mb_x * 16,\n\n                                 mb_y * 16, s->width, s->height);\n\n        ptr_y = ebuf;\n\n        s->vdsp.emulated_edge_mc(ebuf + 18 * wrap_y, ptr_cb, wrap_c, mb_block_width,\n\n                                 mb_block_height, mb_x * mb_block_width, mb_y * mb_block_height,\n\n                                 cw, ch);\n\n        ptr_cb = ebuf + 18 * wrap_y;\n\n        s->vdsp.emulated_edge_mc(ebuf + 18 * wrap_y + 16, ptr_cr, wrap_c, mb_block_width,\n\n                                 mb_block_height, mb_x * mb_block_width, mb_y * mb_block_height,\n\n                                 cw, ch);\n\n        ptr_cr = ebuf + 18 * wrap_y + 16;\n\n    }\n\n\n\n    if (s->mb_intra) {\n\n        if (s->flags & CODEC_FLAG_INTERLACED_DCT) {\n\n            int progressive_score, interlaced_score;\n\n\n\n            s->interlaced_dct = 0;\n\n            progressive_score = s->dsp.ildct_cmp[4](s, ptr_y,\n\n                                                    NULL, wrap_y, 8) +\n\n                                s->dsp.ildct_cmp[4](s, ptr_y + wrap_y * 8,\n\n                                                    NULL, wrap_y, 8) - 400;\n\n\n\n            if (progressive_score > 0) {\n\n                interlaced_score = s->dsp.ildct_cmp[4](s, ptr_y,\n\n                                                       NULL, wrap_y * 2, 8) +\n\n                                   s->dsp.ildct_cmp[4](s, ptr_y + wrap_y,\n\n                                                       NULL, wrap_y * 2, 8);\n\n                if (progressive_score > interlaced_score) {\n\n                    s->interlaced_dct = 1;\n\n\n\n                    dct_offset = wrap_y;\n\n                    uv_dct_offset = wrap_c;\n\n                    wrap_y <<= 1;\n\n                    if (s->chroma_format == CHROMA_422 ||\n\n                        s->chroma_format == CHROMA_444)\n\n                        wrap_c <<= 1;\n\n                }\n\n            }\n\n        }\n\n\n\n        s->dsp.get_pixels(s->block[0], ptr_y                  , wrap_y);\n\n        s->dsp.get_pixels(s->block[1], ptr_y              + 8 , wrap_y);\n\n        s->dsp.get_pixels(s->block[2], ptr_y + dct_offset     , wrap_y);\n\n        s->dsp.get_pixels(s->block[3], ptr_y + dct_offset + 8 , wrap_y);\n\n\n\n        if (s->flags & CODEC_FLAG_GRAY) {\n\n            skip_dct[4] = 1;\n\n            skip_dct[5] = 1;\n\n        } else {\n\n            s->dsp.get_pixels(s->block[4], ptr_cb, wrap_c);\n\n            s->dsp.get_pixels(s->block[5], ptr_cr, wrap_c);\n\n            if (!s->chroma_y_shift && s->chroma_x_shift) { /* 422 */\n\n                s->dsp.get_pixels(s->block[6], ptr_cb + uv_dct_offset, wrap_c);\n\n                s->dsp.get_pixels(s->block[7], ptr_cr + uv_dct_offset, wrap_c);\n\n            } else if (!s->chroma_y_shift && !s->chroma_x_shift) { /* 444 */\n\n                s->dsp.get_pixels(s->block[6], ptr_cb + 8, wrap_c);\n\n                s->dsp.get_pixels(s->block[7], ptr_cr + 8, wrap_c);\n\n                s->dsp.get_pixels(s->block[8], ptr_cb + uv_dct_offset, wrap_c);\n\n                s->dsp.get_pixels(s->block[9], ptr_cr + uv_dct_offset, wrap_c);\n\n                s->dsp.get_pixels(s->block[10], ptr_cb + uv_dct_offset + 8, wrap_c);\n\n                s->dsp.get_pixels(s->block[11], ptr_cr + uv_dct_offset + 8, wrap_c);\n\n            }\n\n        }\n\n    } else {\n\n        op_pixels_func (*op_pix)[4];\n\n        qpel_mc_func (*op_qpix)[16];\n\n        uint8_t *dest_y, *dest_cb, *dest_cr;\n\n\n\n        dest_y  = s->dest[0];\n\n        dest_cb = s->dest[1];\n\n        dest_cr = s->dest[2];\n\n\n\n        if ((!s->no_rounding) || s->pict_type == AV_PICTURE_TYPE_B) {\n\n            op_pix  = s->hdsp.put_pixels_tab;\n\n            op_qpix = s->dsp.put_qpel_pixels_tab;\n\n        } else {\n\n            op_pix  = s->hdsp.put_no_rnd_pixels_tab;\n\n            op_qpix = s->dsp.put_no_rnd_qpel_pixels_tab;\n\n        }\n\n\n\n        if (s->mv_dir & MV_DIR_FORWARD) {\n\n            ff_MPV_motion(s, dest_y, dest_cb, dest_cr, 0,\n\n                          s->last_picture.f.data,\n\n                          op_pix, op_qpix);\n\n            op_pix  = s->hdsp.avg_pixels_tab;\n\n            op_qpix = s->dsp.avg_qpel_pixels_tab;\n\n        }\n\n        if (s->mv_dir & MV_DIR_BACKWARD) {\n\n            ff_MPV_motion(s, dest_y, dest_cb, dest_cr, 1,\n\n                          s->next_picture.f.data,\n\n                          op_pix, op_qpix);\n\n        }\n\n\n\n        if (s->flags & CODEC_FLAG_INTERLACED_DCT) {\n\n            int progressive_score, interlaced_score;\n\n\n\n            s->interlaced_dct = 0;\n\n            progressive_score = s->dsp.ildct_cmp[0](s, dest_y,\n\n                                                    ptr_y,              wrap_y,\n\n                                                    8) +\n\n                                s->dsp.ildct_cmp[0](s, dest_y + wrap_y * 8,\n\n                                                    ptr_y + wrap_y * 8, wrap_y,\n\n                                                    8) - 400;\n\n\n\n            if (s->avctx->ildct_cmp == FF_CMP_VSSE)\n\n                progressive_score -= 400;\n\n\n\n            if (progressive_score > 0) {\n\n                interlaced_score = s->dsp.ildct_cmp[0](s, dest_y,\n\n                                                       ptr_y,\n\n                                                       wrap_y * 2, 8) +\n\n                                   s->dsp.ildct_cmp[0](s, dest_y + wrap_y,\n\n                                                       ptr_y + wrap_y,\n\n                                                       wrap_y * 2, 8);\n\n\n\n                if (progressive_score > interlaced_score) {\n\n                    s->interlaced_dct = 1;\n\n\n\n                    dct_offset = wrap_y;\n\n                    uv_dct_offset = wrap_c;\n\n                    wrap_y <<= 1;\n\n                    if (s->chroma_format == CHROMA_422)\n\n                        wrap_c <<= 1;\n\n                }\n\n            }\n\n        }\n\n\n\n        s->dsp.diff_pixels(s->block[0], ptr_y, dest_y, wrap_y);\n\n        s->dsp.diff_pixels(s->block[1], ptr_y + 8, dest_y + 8, wrap_y);\n\n        s->dsp.diff_pixels(s->block[2], ptr_y + dct_offset,\n\n                           dest_y + dct_offset, wrap_y);\n\n        s->dsp.diff_pixels(s->block[3], ptr_y + dct_offset + 8,\n\n                           dest_y + dct_offset + 8, wrap_y);\n\n\n\n        if (s->flags & CODEC_FLAG_GRAY) {\n\n            skip_dct[4] = 1;\n\n            skip_dct[5] = 1;\n\n        } else {\n\n            s->dsp.diff_pixels(s->block[4], ptr_cb, dest_cb, wrap_c);\n\n            s->dsp.diff_pixels(s->block[5], ptr_cr, dest_cr, wrap_c);\n\n            if (!s->chroma_y_shift) { /* 422 */\n\n                s->dsp.diff_pixels(s->block[6], ptr_cb + uv_dct_offset,\n\n                                   dest_cb + uv_dct_offset, wrap_c);\n\n                s->dsp.diff_pixels(s->block[7], ptr_cr + uv_dct_offset,\n\n                                   dest_cr + uv_dct_offset, wrap_c);\n\n            }\n\n        }\n\n        /* pre quantization */\n\n        if (s->current_picture.mc_mb_var[s->mb_stride * mb_y + mb_x] <\n\n                2 * s->qscale * s->qscale) {\n\n            // FIXME optimize\n\n            if (s->dsp.sad[1](NULL, ptr_y , dest_y,\n\n                              wrap_y, 8) < 20 * s->qscale)\n\n                skip_dct[0] = 1;\n\n            if (s->dsp.sad[1](NULL, ptr_y + 8,\n\n                              dest_y + 8, wrap_y, 8) < 20 * s->qscale)\n\n                skip_dct[1] = 1;\n\n            if (s->dsp.sad[1](NULL, ptr_y + dct_offset,\n\n                              dest_y + dct_offset, wrap_y, 8) < 20 * s->qscale)\n\n                skip_dct[2] = 1;\n\n            if (s->dsp.sad[1](NULL, ptr_y + dct_offset + 8,\n\n                              dest_y + dct_offset + 8,\n\n                              wrap_y, 8) < 20 * s->qscale)\n\n                skip_dct[3] = 1;\n\n            if (s->dsp.sad[1](NULL, ptr_cb, dest_cb,\n\n                              wrap_c, 8) < 20 * s->qscale)\n\n                skip_dct[4] = 1;\n\n            if (s->dsp.sad[1](NULL, ptr_cr, dest_cr,\n\n                              wrap_c, 8) < 20 * s->qscale)\n\n                skip_dct[5] = 1;\n\n            if (!s->chroma_y_shift) { /* 422 */\n\n                if (s->dsp.sad[1](NULL, ptr_cb + uv_dct_offset,\n\n                                  dest_cb + uv_dct_offset,\n\n                                  wrap_c, 8) < 20 * s->qscale)\n\n                    skip_dct[6] = 1;\n\n                if (s->dsp.sad[1](NULL, ptr_cr + uv_dct_offset,\n\n                                  dest_cr + uv_dct_offset,\n\n                                  wrap_c, 8) < 20 * s->qscale)\n\n                    skip_dct[7] = 1;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (s->quantizer_noise_shaping) {\n\n        if (!skip_dct[0])\n\n            get_visual_weight(weight[0], ptr_y                 , wrap_y);\n\n        if (!skip_dct[1])\n\n            get_visual_weight(weight[1], ptr_y              + 8, wrap_y);\n\n        if (!skip_dct[2])\n\n            get_visual_weight(weight[2], ptr_y + dct_offset    , wrap_y);\n\n        if (!skip_dct[3])\n\n            get_visual_weight(weight[3], ptr_y + dct_offset + 8, wrap_y);\n\n        if (!skip_dct[4])\n\n            get_visual_weight(weight[4], ptr_cb                , wrap_c);\n\n        if (!skip_dct[5])\n\n            get_visual_weight(weight[5], ptr_cr                , wrap_c);\n\n        if (!s->chroma_y_shift) { /* 422 */\n\n            if (!skip_dct[6])\n\n                get_visual_weight(weight[6], ptr_cb + uv_dct_offset,\n\n                                  wrap_c);\n\n            if (!skip_dct[7])\n\n                get_visual_weight(weight[7], ptr_cr + uv_dct_offset,\n\n                                  wrap_c);\n\n        }\n\n        memcpy(orig[0], s->block[0], sizeof(int16_t) * 64 * mb_block_count);\n\n    }\n\n\n\n    /* DCT & quantize */\n\n    av_assert2(s->out_format != FMT_MJPEG || s->qscale == 8);\n\n    {\n\n        for (i = 0; i < mb_block_count; i++) {\n\n            if (!skip_dct[i]) {\n\n                int overflow;\n\n                s->block_last_index[i] = s->dct_quantize(s, s->block[i], i, s->qscale, &overflow);\n\n                // FIXME we could decide to change to quantizer instead of\n\n                // clipping\n\n                // JS: I don't think that would be a good idea it could lower\n\n                //     quality instead of improve it. Just INTRADC clipping\n\n                //     deserves changes in quantizer\n\n                if (overflow)\n\n                    clip_coeffs(s, s->block[i], s->block_last_index[i]);\n\n            } else\n\n                s->block_last_index[i] = -1;\n\n        }\n\n        if (s->quantizer_noise_shaping) {\n\n            for (i = 0; i < mb_block_count; i++) {\n\n                if (!skip_dct[i]) {\n\n                    s->block_last_index[i] =\n\n                        dct_quantize_refine(s, s->block[i], weight[i],\n\n                                            orig[i], i, s->qscale);\n\n                }\n\n            }\n\n        }\n\n\n\n        if (s->luma_elim_threshold && !s->mb_intra)\n\n            for (i = 0; i < 4; i++)\n\n                dct_single_coeff_elimination(s, i, s->luma_elim_threshold);\n\n        if (s->chroma_elim_threshold && !s->mb_intra)\n\n            for (i = 4; i < mb_block_count; i++)\n\n                dct_single_coeff_elimination(s, i, s->chroma_elim_threshold);\n\n\n\n        if (s->mpv_flags & FF_MPV_FLAG_CBP_RD) {\n\n            for (i = 0; i < mb_block_count; i++) {\n\n                if (s->block_last_index[i] == -1)\n\n                    s->coded_score[i] = INT_MAX / 256;\n\n            }\n\n        }\n\n    }\n\n\n\n    if ((s->flags & CODEC_FLAG_GRAY) && s->mb_intra) {\n\n        s->block_last_index[4] =\n\n        s->block_last_index[5] = 0;\n\n        s->block[4][0] =\n\n        s->block[5][0] = (1024 + s->c_dc_scale / 2) / s->c_dc_scale;\n\n        if (!s->chroma_y_shift) { /* 422 / 444 */\n\n            for (i=6; i<12; i++) {\n\n                s->block_last_index[i] = 0;\n\n                s->block[i][0] = s->block[4][0];\n\n            }\n\n        }\n\n    }\n\n\n\n    // non c quantize code returns incorrect block_last_index FIXME\n\n    if (s->alternate_scan && s->dct_quantize != ff_dct_quantize_c) {\n\n        for (i = 0; i < mb_block_count; i++) {\n\n            int j;\n\n            if (s->block_last_index[i] > 0) {\n\n                for (j = 63; j > 0; j--) {\n\n                    if (s->block[i][s->intra_scantable.permutated[j]])\n\n                        break;\n\n                }\n\n                s->block_last_index[i] = j;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* huffman encode */\n\n    switch(s->codec_id){ //FIXME funct ptr could be slightly faster\n\n    case AV_CODEC_ID_MPEG1VIDEO:\n\n    case AV_CODEC_ID_MPEG2VIDEO:\n\n        if (CONFIG_MPEG1VIDEO_ENCODER || CONFIG_MPEG2VIDEO_ENCODER)\n\n            ff_mpeg1_encode_mb(s, s->block, motion_x, motion_y);\n\n        break;\n\n    case AV_CODEC_ID_MPEG4:\n\n        if (CONFIG_MPEG4_ENCODER)\n\n            ff_mpeg4_encode_mb(s, s->block, motion_x, motion_y);\n\n        break;\n\n    case AV_CODEC_ID_MSMPEG4V2:\n\n    case AV_CODEC_ID_MSMPEG4V3:\n\n    case AV_CODEC_ID_WMV1:\n\n        if (CONFIG_MSMPEG4_ENCODER)\n\n            ff_msmpeg4_encode_mb(s, s->block, motion_x, motion_y);\n\n        break;\n\n    case AV_CODEC_ID_WMV2:\n\n        if (CONFIG_WMV2_ENCODER)\n\n            ff_wmv2_encode_mb(s, s->block, motion_x, motion_y);\n\n        break;\n\n    case AV_CODEC_ID_H261:\n\n        if (CONFIG_H261_ENCODER)\n\n            ff_h261_encode_mb(s, s->block, motion_x, motion_y);\n\n        break;\n\n    case AV_CODEC_ID_H263:\n\n    case AV_CODEC_ID_H263P:\n\n    case AV_CODEC_ID_FLV1:\n\n    case AV_CODEC_ID_RV10:\n\n    case AV_CODEC_ID_RV20:\n\n        if (CONFIG_H263_ENCODER)\n\n            ff_h263_encode_mb(s, s->block, motion_x, motion_y);\n\n        break;\n\n    case AV_CODEC_ID_MJPEG:\n\n    case AV_CODEC_ID_AMV:\n\n        if (CONFIG_MJPEG_ENCODER)\n\n            ff_mjpeg_encode_mb(s, s->block);\n\n        break;\n\n    default:\n\n        av_assert1(0);\n\n    }\n\n}\n", "idx": 16709}
{"project": "qemu", "commit_id": "b92ad3949bc9cacd1652b4e07e7f6003b9e512af", "target": 0, "func": "static void create_gic(VirtBoardInfo *vbi, qemu_irq *pic, bool secure)\n\n{\n\n    /* We create a standalone GIC v2 */\n\n    DeviceState *gicdev;\n\n    SysBusDevice *gicbusdev;\n\n    const char *gictype;\n\n    int i;\n\n\n\n    gictype = gic_class_name();\n\n\n\n    gicdev = qdev_create(NULL, gictype);\n\n    qdev_prop_set_uint32(gicdev, \"revision\", 2);\n\n    qdev_prop_set_uint32(gicdev, \"num-cpu\", smp_cpus);\n\n    /* Note that the num-irq property counts both internal and external\n\n     * interrupts; there are always 32 of the former (mandated by GIC spec).\n\n     */\n\n    qdev_prop_set_uint32(gicdev, \"num-irq\", NUM_IRQS + 32);\n\n    if (!kvm_irqchip_in_kernel()) {\n\n        qdev_prop_set_bit(gicdev, \"has-security-extensions\", secure);\n\n    }\n\n    qdev_init_nofail(gicdev);\n\n    gicbusdev = SYS_BUS_DEVICE(gicdev);\n\n    sysbus_mmio_map(gicbusdev, 0, vbi->memmap[VIRT_GIC_DIST].base);\n\n    sysbus_mmio_map(gicbusdev, 1, vbi->memmap[VIRT_GIC_CPU].base);\n\n\n\n    /* Wire the outputs from each CPU's generic timer to the\n\n     * appropriate GIC PPI inputs, and the GIC's IRQ output to\n\n     * the CPU's IRQ input.\n\n     */\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        DeviceState *cpudev = DEVICE(qemu_get_cpu(i));\n\n        int ppibase = NUM_IRQS + i * GIC_INTERNAL + GIC_NR_SGIS;\n\n        int irq;\n\n        /* Mapping from the output timer irq lines from the CPU to the\n\n         * GIC PPI inputs we use for the virt board.\n\n         */\n\n        const int timer_irq[] = {\n\n            [GTIMER_PHYS] = ARCH_TIMER_NS_EL1_IRQ,\n\n            [GTIMER_VIRT] = ARCH_TIMER_VIRT_IRQ,\n\n            [GTIMER_HYP]  = ARCH_TIMER_NS_EL2_IRQ,\n\n            [GTIMER_SEC]  = ARCH_TIMER_S_EL1_IRQ,\n\n        };\n\n\n\n        for (irq = 0; irq < ARRAY_SIZE(timer_irq); irq++) {\n\n            qdev_connect_gpio_out(cpudev, irq,\n\n                                  qdev_get_gpio_in(gicdev,\n\n                                                   ppibase + timer_irq[irq]));\n\n        }\n\n\n\n        sysbus_connect_irq(gicbusdev, i, qdev_get_gpio_in(cpudev, ARM_CPU_IRQ));\n\n        sysbus_connect_irq(gicbusdev, i + smp_cpus,\n\n                           qdev_get_gpio_in(cpudev, ARM_CPU_FIQ));\n\n    }\n\n\n\n    for (i = 0; i < NUM_IRQS; i++) {\n\n        pic[i] = qdev_get_gpio_in(gicdev, i);\n\n    }\n\n\n\n    fdt_add_gic_node(vbi);\n\n\n\n    create_v2m(vbi, pic);\n\n}\n", "idx": 16737}
{"project": "qemu", "commit_id": "bea60dd7679364493a0d7f5b54316c767cf894ef", "target": 1, "func": "static void vnc_desktop_resize(VncState *vs)\n\n{\n\n    DisplaySurface *ds = vs->vd->ds;\n\n\n\n    if (vs->csock == -1 || !vnc_has_feature(vs, VNC_FEATURE_RESIZE)) {\n\n        return;\n\n    }\n\n    if (vs->client_width == surface_width(ds) &&\n\n        vs->client_height == surface_height(ds)) {\n\n        return;\n\n    }\n\n    vs->client_width = surface_width(ds);\n\n    vs->client_height = surface_height(ds);\n\n    vnc_lock_output(vs);\n\n    vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n\n    vnc_write_u8(vs, 0);\n\n    vnc_write_u16(vs, 1); /* number of rects */\n\n    vnc_framebuffer_update(vs, 0, 0, vs->client_width, vs->client_height,\n\n                           VNC_ENCODING_DESKTOPRESIZE);\n\n    vnc_unlock_output(vs);\n\n    vnc_flush(vs);\n\n}\n", "idx": 16759}
{"project": "qemu", "commit_id": "4837a1a51638ef1719bf8149591a57e7207db41a", "target": 1, "func": "static int blk_get_request(struct XenBlkDev *blkdev, struct ioreq *ioreq, RING_IDX rc)\n\n{\n\n    switch (blkdev->protocol) {\n\n    case BLKIF_PROTOCOL_NATIVE:\n\n        memcpy(&ioreq->req, RING_GET_REQUEST(&blkdev->rings.native, rc),\n\n               sizeof(ioreq->req));\n\n        break;\n\n    case BLKIF_PROTOCOL_X86_32:\n\n        blkif_get_x86_32_req(&ioreq->req,\n\n                             RING_GET_REQUEST(&blkdev->rings.x86_32_part, rc));\n\n        break;\n\n    case BLKIF_PROTOCOL_X86_64:\n\n        blkif_get_x86_64_req(&ioreq->req,\n\n                             RING_GET_REQUEST(&blkdev->rings.x86_64_part, rc));\n\n        break;\n\n    }\n\n\n\n    return 0;\n\n}", "idx": 16850}
{"project": "qemu", "commit_id": "3dc6f8693694a649a9c83f1e2746565b47683923", "target": 0, "func": "static int64_t nfs_client_open(NFSClient *client, QDict *options,\n\n                               int flags, int open_flags, Error **errp)\n\n{\n\n    int ret = -EINVAL;\n\n    QemuOpts *opts = NULL;\n\n    Error *local_err = NULL;\n\n    struct stat st;\n\n    char *file = NULL, *strp = NULL;\n\n\n\n    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);\n\n    qemu_opts_absorb_qdict(opts, options, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    client->path = g_strdup(qemu_opt_get(opts, \"path\"));\n\n    if (!client->path) {\n\n        ret = -EINVAL;\n\n        error_setg(errp, \"No path was specified\");\n\n        goto fail;\n\n    }\n\n\n\n    strp = strrchr(client->path, '/');\n\n    if (strp == NULL) {\n\n        error_setg(errp, \"Invalid URL specified\");\n\n        goto fail;\n\n    }\n\n    file = g_strdup(strp);\n\n    *strp = 0;\n\n\n\n    /* Pop the config into our state object, Exit if invalid */\n\n    client->server = nfs_config(options, errp);\n\n    if (!client->server) {\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    client->context = nfs_init_context();\n\n    if (client->context == NULL) {\n\n        error_setg(errp, \"Failed to init NFS context\");\n\n        goto fail;\n\n    }\n\n\n\n    if (qemu_opt_get(opts, \"user\")) {\n\n        client->uid = qemu_opt_get_number(opts, \"user\", 0);\n\n        nfs_set_uid(client->context, client->uid);\n\n    }\n\n\n\n    if (qemu_opt_get(opts, \"group\")) {\n\n        client->gid = qemu_opt_get_number(opts, \"group\", 0);\n\n        nfs_set_gid(client->context, client->gid);\n\n    }\n\n\n\n    if (qemu_opt_get(opts, \"tcp-syn-count\")) {\n\n        client->tcp_syncnt = qemu_opt_get_number(opts, \"tcp-syn-count\", 0);\n\n        nfs_set_tcp_syncnt(client->context, client->tcp_syncnt);\n\n    }\n\n\n\n#ifdef LIBNFS_FEATURE_READAHEAD\n\n    if (qemu_opt_get(opts, \"readahead-size\")) {\n\n        if (open_flags & BDRV_O_NOCACHE) {\n\n            error_setg(errp, \"Cannot enable NFS readahead \"\n\n                             \"if cache.direct = on\");\n\n            goto fail;\n\n        }\n\n        client->readahead = qemu_opt_get_number(opts, \"readahead-size\", 0);\n\n        if (client->readahead > QEMU_NFS_MAX_READAHEAD_SIZE) {\n\n            error_report(\"NFS Warning: Truncating NFS readahead \"\n\n                         \"size to %d\", QEMU_NFS_MAX_READAHEAD_SIZE);\n\n            client->readahead = QEMU_NFS_MAX_READAHEAD_SIZE;\n\n        }\n\n        nfs_set_readahead(client->context, client->readahead);\n\n#ifdef LIBNFS_FEATURE_PAGECACHE\n\n        nfs_set_pagecache_ttl(client->context, 0);\n\n#endif\n\n        client->cache_used = true;\n\n    }\n\n#endif\n\n\n\n#ifdef LIBNFS_FEATURE_PAGECACHE\n\n    if (qemu_opt_get(opts, \"page-cache-size\")) {\n\n        if (open_flags & BDRV_O_NOCACHE) {\n\n            error_setg(errp, \"Cannot enable NFS pagecache \"\n\n                             \"if cache.direct = on\");\n\n            goto fail;\n\n        }\n\n        client->pagecache = qemu_opt_get_number(opts, \"page-cache-size\", 0);\n\n        if (client->pagecache > QEMU_NFS_MAX_PAGECACHE_SIZE) {\n\n            error_report(\"NFS Warning: Truncating NFS pagecache \"\n\n                         \"size to %d pages\", QEMU_NFS_MAX_PAGECACHE_SIZE);\n\n            client->pagecache = QEMU_NFS_MAX_PAGECACHE_SIZE;\n\n        }\n\n        nfs_set_pagecache(client->context, client->pagecache);\n\n        nfs_set_pagecache_ttl(client->context, 0);\n\n        client->cache_used = true;\n\n    }\n\n#endif\n\n\n\n#ifdef LIBNFS_FEATURE_DEBUG\n\n    if (qemu_opt_get(opts, \"debug\")) {\n\n        client->debug = qemu_opt_get_number(opts, \"debug\", 0);\n\n        /* limit the maximum debug level to avoid potential flooding\n\n         * of our log files. */\n\n        if (client->debug > QEMU_NFS_MAX_DEBUG_LEVEL) {\n\n            error_report(\"NFS Warning: Limiting NFS debug level \"\n\n                         \"to %d\", QEMU_NFS_MAX_DEBUG_LEVEL);\n\n            client->debug = QEMU_NFS_MAX_DEBUG_LEVEL;\n\n        }\n\n        nfs_set_debug(client->context, client->debug);\n\n    }\n\n#endif\n\n\n\n    ret = nfs_mount(client->context, client->server->host, client->path);\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Failed to mount nfs share: %s\",\n\n                   nfs_get_error(client->context));\n\n        goto fail;\n\n    }\n\n\n\n    if (flags & O_CREAT) {\n\n        ret = nfs_creat(client->context, file, 0600, &client->fh);\n\n        if (ret < 0) {\n\n            error_setg(errp, \"Failed to create file: %s\",\n\n                       nfs_get_error(client->context));\n\n            goto fail;\n\n        }\n\n    } else {\n\n        ret = nfs_open(client->context, file, flags, &client->fh);\n\n        if (ret < 0) {\n\n            error_setg(errp, \"Failed to open file : %s\",\n\n                       nfs_get_error(client->context));\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    ret = nfs_fstat(client->context, client->fh, &st);\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Failed to fstat file: %s\",\n\n                   nfs_get_error(client->context));\n\n        goto fail;\n\n    }\n\n\n\n    ret = DIV_ROUND_UP(st.st_size, BDRV_SECTOR_SIZE);\n\n    client->st_blocks = st.st_blocks;\n\n    client->has_zero_init = S_ISREG(st.st_mode);\n\n    *strp = '/';\n\n    goto out;\n\n\n\nfail:\n\n    nfs_client_close(client);\n\nout:\n\n    qemu_opts_del(opts);\n\n    g_free(file);\n\n    return ret;\n\n}\n", "idx": 16895}
{"project": "FFmpeg", "commit_id": "b3f9f7a33337e9b64e6044b0010e2722fa0b2f9c", "target": 0, "func": "static AVStream *new_pes_av_stream(PESContext *pes, uint32_t prog_reg_desc, uint32_t code)\n\n{\n\n    AVStream *st = av_new_stream(pes->stream, pes->pid);\n\n\n\n    if (!st)\n\n        return NULL;\n\n\n\n    av_set_pts_info(st, 33, 1, 90000);\n\n    st->priv_data = pes;\n\n    st->codec->codec_type = CODEC_TYPE_DATA;\n\n    st->codec->codec_id   = CODEC_ID_NONE;\n\n    st->need_parsing = AVSTREAM_PARSE_FULL;\n\n    pes->st = st;\n\n\n\n    dprintf(pes->stream, \"stream_type=%x pid=%x prog_reg_desc=%.4s\\n\",\n\n            pes->stream_type, pes->pid, (char*)&prog_reg_desc);\n\n\n\n    st->codec->codec_tag = pes->stream_type;\n\n\n\n    mpegts_find_stream_type(st, pes->stream_type, ISO_types);\n\n    if (prog_reg_desc == AV_RL32(\"HDMV\") &&\n\n        st->codec->codec_id == CODEC_ID_NONE) {\n\n        mpegts_find_stream_type(st, pes->stream_type, HDMV_types);\n\n        if (pes->stream_type == 0x83) {\n\n            // HDMV TrueHD streams also contain an AC3 coded version of the\n\n            // audio track - add a second stream for this\n\n            AVStream *sub_st;\n\n            // priv_data cannot be shared between streams\n\n            PESContext *sub_pes = av_malloc(sizeof(*sub_pes));\n\n            if (!sub_pes)\n\n                return NULL;\n\n            memcpy(sub_pes, pes, sizeof(*sub_pes));\n\n\n\n            sub_st = av_new_stream(pes->stream, pes->pid);\n\n            if (!sub_st) {\n\n                av_free(sub_pes);\n\n                return NULL;\n\n            }\n\n\n\n            av_set_pts_info(sub_st, 33, 1, 90000);\n\n            sub_st->priv_data = sub_pes;\n\n            sub_st->codec->codec_type = CODEC_TYPE_AUDIO;\n\n            sub_st->codec->codec_id   = CODEC_ID_AC3;\n\n            sub_st->need_parsing = AVSTREAM_PARSE_FULL;\n\n            sub_pes->sub_st = pes->sub_st = sub_st;\n\n        }\n\n    }\n\n    if (st->codec->codec_id == CODEC_ID_NONE)\n\n        mpegts_find_stream_type(st, pes->stream_type, MISC_types);\n\n\n\n    /* stream was not present in PMT, guess based on PES start code */\n\n    if (st->codec->codec_id == CODEC_ID_NONE) {\n\n        if (code >= 0x1c0 && code <= 0x1df) {\n\n            st->codec->codec_type = CODEC_TYPE_AUDIO;\n\n            st->codec->codec_id = CODEC_ID_MP2;\n\n        } else if (code == 0x1bd) {\n\n            st->codec->codec_type = CODEC_TYPE_AUDIO;\n\n            st->codec->codec_id = CODEC_ID_AC3;\n\n        }\n\n    }\n\n\n\n    return st;\n\n}\n", "idx": 16897}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "BlockAIOCB *dma_bdrv_io(\n\n    BlockDriverState *bs, QEMUSGList *sg, uint64_t sector_num,\n\n    DMAIOFunc *io_func, BlockCompletionFunc *cb,\n\n    void *opaque, DMADirection dir)\n\n{\n\n    DMAAIOCB *dbs = qemu_aio_get(&dma_aiocb_info, bs, cb, opaque);\n\n\n\n    trace_dma_bdrv_io(dbs, bs, sector_num, (dir == DMA_DIRECTION_TO_DEVICE));\n\n\n\n    dbs->acb = NULL;\n\n    dbs->bs = bs;\n\n    dbs->sg = sg;\n\n    dbs->sector_num = sector_num;\n\n    dbs->sg_cur_index = 0;\n\n    dbs->sg_cur_byte = 0;\n\n    dbs->dir = dir;\n\n    dbs->io_func = io_func;\n\n    dbs->bh = NULL;\n\n    qemu_iovec_init(&dbs->iov, sg->nsg);\n\n    dma_bdrv_cb(dbs, 0);\n\n    return &dbs->common;\n\n}\n", "idx": 16898}
{"project": "qemu", "commit_id": "b02ef3d92b19ad304a84433d3817f0903296ebc7", "target": 0, "func": "static void assign_storage(SCLPDevice *sclp, SCCB *sccb)\n\n{\n\n    MemoryRegion *mr = NULL;\n\n    uint64_t this_subregion_size;\n\n    AssignStorage *assign_info = (AssignStorage *) sccb;\n\n    sclpMemoryHotplugDev *mhd = get_sclp_memory_hotplug_dev();\n\n    assert(mhd);\n\n    ram_addr_t assign_addr = (assign_info->rn - 1) * mhd->rzm;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n\n\n    if ((assign_addr % MEM_SECTION_SIZE == 0) &&\n\n        (assign_addr >= mhd->padded_ram_size)) {\n\n        /* Re-use existing memory region if found */\n\n        mr = memory_region_find(sysmem, assign_addr, 1).mr;\n\n        memory_region_unref(mr);\n\n        if (!mr) {\n\n\n\n            MemoryRegion *standby_ram = g_new(MemoryRegion, 1);\n\n\n\n            /* offset to align to standby_subregion_size for allocation */\n\n            ram_addr_t offset = assign_addr -\n\n                                (assign_addr - mhd->padded_ram_size)\n\n                                % mhd->standby_subregion_size;\n\n\n\n            /* strlen(\"standby.ram\") + 4 (Max of KVM_MEMORY_SLOTS) +  NULL */\n\n            char id[16];\n\n            snprintf(id, 16, \"standby.ram%d\",\n\n                     (int)((offset - mhd->padded_ram_size) /\n\n                     mhd->standby_subregion_size) + 1);\n\n\n\n            /* Allocate a subregion of the calculated standby_subregion_size */\n\n            if (offset + mhd->standby_subregion_size >\n\n                mhd->padded_ram_size + mhd->standby_mem_size) {\n\n                this_subregion_size = mhd->padded_ram_size +\n\n                  mhd->standby_mem_size - offset;\n\n            } else {\n\n                this_subregion_size = mhd->standby_subregion_size;\n\n            }\n\n\n\n            memory_region_init_ram(standby_ram, NULL, id, this_subregion_size, &error_abort);\n\n            /* This is a hack to make memory hotunplug work again. Once we have\n\n             * subdevices, we have to unparent them when unassigning memory,\n\n             * instead of doing it via the ref count of the MemoryRegion. */\n\n            object_ref(OBJECT(standby_ram));\n\n            object_unparent(OBJECT(standby_ram));\n\n            vmstate_register_ram_global(standby_ram);\n\n            memory_region_add_subregion(sysmem, offset, standby_ram);\n\n        }\n\n        /* The specified subregion is no longer in standby */\n\n        mhd->standby_state_map[(assign_addr - mhd->padded_ram_size)\n\n                               / MEM_SECTION_SIZE] = 1;\n\n    }\n\n    sccb->h.response_code = cpu_to_be16(SCLP_RC_NORMAL_COMPLETION);\n\n}\n", "idx": 16916}
{"project": "qemu", "commit_id": "7e97cd88148876bad36ee7c66d526dcaed328d0d", "target": 0, "func": "static void tcg_init_vcpu(void *_env)\n\n{\n\n    CPUState *env = _env;\n\n    /* share a single thread for all cpus with TCG */\n\n    if (!tcg_cpu_thread) {\n\n        env->thread = qemu_mallocz(sizeof(QemuThread));\n\n        env->halt_cond = qemu_mallocz(sizeof(QemuCond));\n\n        qemu_cond_init(env->halt_cond);\n\n        qemu_thread_create(env->thread, tcg_cpu_thread_fn, env);\n\n        while (env->created == 0)\n\n            qemu_cond_timedwait(&qemu_cpu_cond, &qemu_global_mutex, 100);\n\n        tcg_cpu_thread = env->thread;\n\n        tcg_halt_cond = env->halt_cond;\n\n    } else {\n\n        env->thread = tcg_cpu_thread;\n\n        env->halt_cond = tcg_halt_cond;\n\n    }\n\n}\n", "idx": 16948}
{"project": "FFmpeg", "commit_id": "c8dcff0cdb17d0aa03ac729eba12d1a20f1f59c8", "target": 0, "func": "static int h264_frame_start(H264Context *h)\n\n{\n\n    H264Picture *pic;\n\n    int i, ret;\n\n    const int pixel_shift = h->pixel_shift;\n\n\n\n    ret = initialize_cur_frame(h);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    pic = h->cur_pic_ptr;\n\n    pic->reference              = h->droppable ? 0 : h->picture_structure;\n\n    pic->f->coded_picture_number = h->coded_picture_number++;\n\n    pic->field_picture          = h->picture_structure != PICT_FRAME;\n\n    pic->frame_num               = h->frame_num;\n\n    /*\n\n     * Zero key_frame here; IDR markings per slice in frame or fields are ORed\n\n     * in later.\n\n     * See decode_nal_units().\n\n     */\n\n    pic->f->key_frame = 0;\n\n    pic->mmco_reset  = 0;\n\n    pic->recovered   = 0;\n\n\n\n    if (CONFIG_ERROR_RESILIENCE && h->enable_er)\n\n        ff_er_frame_start(&h->slice_ctx[0].er);\n\n\n\n    for (i = 0; i < 16; i++) {\n\n        h->block_offset[i]           = (4 * ((scan8[i] - scan8[0]) & 7) << pixel_shift) + 4 * pic->f->linesize[0] * ((scan8[i] - scan8[0]) >> 3);\n\n        h->block_offset[48 + i]      = (4 * ((scan8[i] - scan8[0]) & 7) << pixel_shift) + 8 * pic->f->linesize[0] * ((scan8[i] - scan8[0]) >> 3);\n\n    }\n\n    for (i = 0; i < 16; i++) {\n\n        h->block_offset[16 + i]      =\n\n        h->block_offset[32 + i]      = (4 * ((scan8[i] - scan8[0]) & 7) << pixel_shift) + 4 * pic->f->linesize[1] * ((scan8[i] - scan8[0]) >> 3);\n\n        h->block_offset[48 + 16 + i] =\n\n        h->block_offset[48 + 32 + i] = (4 * ((scan8[i] - scan8[0]) & 7) << pixel_shift) + 8 * pic->f->linesize[1] * ((scan8[i] - scan8[0]) >> 3);\n\n    }\n\n\n\n    /* Some macroblocks can be accessed before they're available in case\n\n     * of lost slices, MBAFF or threading. */\n\n    memset(h->slice_table, -1,\n\n           (h->mb_height * h->mb_stride - 1) * sizeof(*h->slice_table));\n\n\n\n    /* We mark the current picture as non-reference after allocating it, so\n\n     * that if we break out due to an error it can be released automatically\n\n     * in the next ff_mpv_frame_start().\n\n     */\n\n    h->cur_pic_ptr->reference = 0;\n\n\n\n    h->cur_pic_ptr->field_poc[0] = h->cur_pic_ptr->field_poc[1] = INT_MAX;\n\n\n\n    h->next_output_pic = NULL;\n\n\n\n    assert(h->cur_pic_ptr->long_ref == 0);\n\n\n\n    return 0;\n\n}\n", "idx": 16988}
{"project": "qemu", "commit_id": "0e9b9edae7bebfd31fdbead4ccbbce03876a7edd", "target": 0, "func": "void acpi_setup(void)\n\n{\n\n    PCMachineState *pcms = PC_MACHINE(qdev_get_machine());\n\n    PCMachineClass *pcmc = PC_MACHINE_GET_CLASS(pcms);\n\n    AcpiBuildTables tables;\n\n    AcpiBuildState *build_state;\n\n\n\n    if (!pcms->fw_cfg) {\n\n        ACPI_BUILD_DPRINTF(\"No fw cfg. Bailing out.\\n\");\n\n        return;\n\n    }\n\n\n\n    if (!pcmc->has_acpi_build) {\n\n        ACPI_BUILD_DPRINTF(\"ACPI build disabled. Bailing out.\\n\");\n\n        return;\n\n    }\n\n\n\n    if (!acpi_enabled) {\n\n        ACPI_BUILD_DPRINTF(\"ACPI disabled. Bailing out.\\n\");\n\n        return;\n\n    }\n\n\n\n    build_state = g_malloc0(sizeof *build_state);\n\n\n\n    acpi_set_pci_info();\n\n\n\n    acpi_build_tables_init(&tables);\n\n    acpi_build(&tables, MACHINE(pcms));\n\n\n\n    /* Now expose it all to Guest */\n\n    build_state->table_mr = acpi_add_rom_blob(build_state, tables.table_data,\n\n                                               ACPI_BUILD_TABLE_FILE,\n\n                                               ACPI_BUILD_TABLE_MAX_SIZE);\n\n    assert(build_state->table_mr != NULL);\n\n\n\n    build_state->linker_mr =\n\n        acpi_add_rom_blob(build_state, tables.linker, \"etc/table-loader\", 0);\n\n\n\n    fw_cfg_add_file(pcms->fw_cfg, ACPI_BUILD_TPMLOG_FILE,\n\n                    tables.tcpalog->data, acpi_data_len(tables.tcpalog));\n\n\n\n    if (!pcmc->rsdp_in_ram) {\n\n        /*\n\n         * Keep for compatibility with old machine types.\n\n         * Though RSDP is small, its contents isn't immutable, so\n\n         * we'll update it along with the rest of tables on guest access.\n\n         */\n\n        uint32_t rsdp_size = acpi_data_len(tables.rsdp);\n\n\n\n        build_state->rsdp = g_memdup(tables.rsdp->data, rsdp_size);\n\n        fw_cfg_add_file_callback(pcms->fw_cfg, ACPI_BUILD_RSDP_FILE,\n\n                                 acpi_build_update, build_state,\n\n                                 build_state->rsdp, rsdp_size);\n\n        build_state->rsdp_mr = NULL;\n\n    } else {\n\n        build_state->rsdp = NULL;\n\n        build_state->rsdp_mr = acpi_add_rom_blob(build_state, tables.rsdp,\n\n                                                  ACPI_BUILD_RSDP_FILE, 0);\n\n    }\n\n\n\n    qemu_register_reset(acpi_build_reset, build_state);\n\n    acpi_build_reset(build_state);\n\n    vmstate_register(NULL, 0, &vmstate_acpi_build, build_state);\n\n\n\n    /* Cleanup tables but don't free the memory: we track it\n\n     * in build_state.\n\n     */\n\n    acpi_build_tables_cleanup(&tables, false);\n\n}\n", "idx": 17006}
{"project": "FFmpeg", "commit_id": "e0c6cce44729d94e2a5507a4b6d031f23e8bd7b6", "target": 0, "func": "DECLARE_WEIGHT(sse2)\n\nDECLARE_WEIGHT(ssse3)\n\n\n\n/** @{ */\n\n/**\n\n * Define one qpel function.\n\n * LOOPSIZE must be already set to the number of pixels processed per\n\n * iteration in the inner loop of the called functions.\n\n * COFF(x) must be already defined so as to provide the offset into any\n\n * array of coeffs used by the called function for the qpel position x.\n\n */\n\n#define QPEL_FUNC_DECL(OP, SIZE, PH, PV, OPT)                           \\\n\nstatic void OP ## rv40_qpel ##SIZE ##_mc ##PH ##PV ##OPT(uint8_t *dst,  \\\n\n                                                         uint8_t *src,  \\\n\n                                                         int stride)    \\\n\n{                                                                       \\\n\n    int i;                                                              \\\n\n    if (PH && PV) {                                                     \\\n\n        DECLARE_ALIGNED(16, uint8_t, tmp)[SIZE * (SIZE + 5)];           \\\n\n        uint8_t *tmpptr = tmp + SIZE * 2;                               \\\n\n        src -= stride * 2;                                              \\\n\n                                                                        \\\n\n        for (i = 0; i < SIZE; i += LOOPSIZE)                            \\\n\n            ff_put_rv40_qpel_h ##OPT(tmp + i, SIZE, src + i, stride,    \\\n\n                                     SIZE + 5, HCOFF(PH));              \\\n\n        for (i = 0; i < SIZE; i += LOOPSIZE)                            \\\n\n            ff_ ##OP ##rv40_qpel_v ##OPT(dst + i, stride, tmpptr + i,   \\\n\n                                         SIZE, SIZE, VCOFF(PV));        \\\n\n    } else if (PV) {                                                    \\\n\n        for (i = 0; i < SIZE; i += LOOPSIZE)                            \\\n\n            ff_ ##OP ##rv40_qpel_v ## OPT(dst + i, stride, src + i,     \\\n\n                                          stride, SIZE, VCOFF(PV));     \\\n\n    } else {                                                            \\\n\n        for (i = 0; i < SIZE; i += LOOPSIZE)                            \\\n\n            ff_ ##OP ##rv40_qpel_h ## OPT(dst + i, stride, src + i,     \\\n\n                                          stride, SIZE, HCOFF(PH));     \\\n\n    }                                                                   \\\n\n};\n\n\n\n/** Declare functions for sizes 8 and 16 and given operations\n\n *  and qpel position. */\n\n#define QPEL_FUNCS_DECL(OP, PH, PV, OPT) \\\n\n    QPEL_FUNC_DECL(OP,  8, PH, PV, OPT)  \\\n\n    QPEL_FUNC_DECL(OP, 16, PH, PV, OPT)\n\n\n\n/** Declare all functions for all sizes and qpel positions */\n\n#define QPEL_MC_DECL(OP, OPT)                                           \\\n\nvoid ff_ ##OP ##rv40_qpel_h ##OPT(uint8_t *dst, ptrdiff_t dstStride,    \\\n\n                                  const uint8_t *src,                   \\\n\n                                  ptrdiff_t srcStride,                  \\\n\n                                  int len, int m);                      \\\n\nvoid ff_ ##OP ##rv40_qpel_v ##OPT(uint8_t *dst, ptrdiff_t dstStride,    \\\n\n                                  const uint8_t *src,                   \\\n\n                                  ptrdiff_t srcStride,                  \\\n\n                                  int len, int m);                      \\\n\nQPEL_FUNCS_DECL(OP, 0, 1, OPT)                                          \\\n\nQPEL_FUNCS_DECL(OP, 0, 3, OPT)                                          \\\n\nQPEL_FUNCS_DECL(OP, 1, 0, OPT)                                          \\\n\nQPEL_FUNCS_DECL(OP, 1, 1, OPT)                                          \\\n\nQPEL_FUNCS_DECL(OP, 1, 2, OPT)                                          \\\n\nQPEL_FUNCS_DECL(OP, 1, 3, OPT)                                          \\\n\nQPEL_FUNCS_DECL(OP, 2, 1, OPT)                                          \\\n\nQPEL_FUNCS_DECL(OP, 2, 2, OPT)                                          \\\n\nQPEL_FUNCS_DECL(OP, 2, 3, OPT)                                          \\\n\nQPEL_FUNCS_DECL(OP, 3, 0, OPT)                                          \\\n\nQPEL_FUNCS_DECL(OP, 3, 1, OPT)                                          \\\n\nQPEL_FUNCS_DECL(OP, 3, 2, OPT)\n\n/** @} */\n\n\n\n#define LOOPSIZE  8\n\n#define HCOFF(x)  (32 * (x - 1))\n\n#define VCOFF(x)  (32 * (x - 1))\n\nQPEL_MC_DECL(put_, _ssse3)\n\nQPEL_MC_DECL(avg_, _ssse3)\n\n\n\n#undef LOOPSIZE\n\n#undef HCOFF\n\n#undef VCOFF\n\n#define LOOPSIZE  8\n\n#define HCOFF(x)  (64 * (x - 1))\n\n#define VCOFF(x)  (64 * (x - 1))\n\nQPEL_MC_DECL(put_, _sse2)\n\nQPEL_MC_DECL(avg_, _sse2)\n\n\n\n#if ARCH_X86_32\n\n#undef LOOPSIZE\n\n#undef HCOFF\n\n#undef VCOFF\n\n#define LOOPSIZE  4\n\n#define HCOFF(x)  (64 * (x - 1))\n\n#define VCOFF(x)  (64 * (x - 1))\n\n\n\nQPEL_MC_DECL(put_, _mmx)\n\n\n\n#define ff_put_rv40_qpel_h_mmx2  ff_put_rv40_qpel_h_mmx\n\n#define ff_put_rv40_qpel_v_mmx2  ff_put_rv40_qpel_v_mmx\n\nQPEL_MC_DECL(avg_, _mmx2)\n\n\n\n#define ff_put_rv40_qpel_h_3dnow  ff_put_rv40_qpel_h_mmx\n\n#define ff_put_rv40_qpel_v_3dnow  ff_put_rv40_qpel_v_mmx\n\nQPEL_MC_DECL(avg_, _3dnow)\n\n#endif\n\n\n\n/** @{ */\n\n/** Set one function */\n\n#define QPEL_FUNC_SET(OP, SIZE, PH, PV, OPT)                            \\\n\n    c-> OP ## pixels_tab[2 - SIZE / 8][4 * PV + PH] = OP ## rv40_qpel ##SIZE ## _mc ##PH ##PV ##OPT;\n\n\n\n/** Set functions put and avg for sizes 8 and 16 and a given qpel position */\n\n#define QPEL_FUNCS_SET(OP, PH, PV, OPT)         \\\n\n    QPEL_FUNC_SET(OP,  8, PH, PV, OPT)          \\\n\n    QPEL_FUNC_SET(OP, 16, PH, PV, OPT)\n\n\n\n/** Set all functions for all sizes and qpel positions */\n\n#define QPEL_MC_SET(OP, OPT)   \\\n\nQPEL_FUNCS_SET (OP, 0, 1, OPT) \\\n\nQPEL_FUNCS_SET (OP, 0, 3, OPT) \\\n\nQPEL_FUNCS_SET (OP, 1, 0, OPT) \\\n\nQPEL_FUNCS_SET (OP, 1, 1, OPT) \\\n\nQPEL_FUNCS_SET (OP, 1, 2, OPT) \\\n\nQPEL_FUNCS_SET (OP, 1, 3, OPT) \\\n\nQPEL_FUNCS_SET (OP, 2, 1, OPT) \\\n\nQPEL_FUNCS_SET (OP, 2, 2, OPT) \\\n\nQPEL_FUNCS_SET (OP, 2, 3, OPT) \\\n\nQPEL_FUNCS_SET (OP, 3, 0, OPT) \\\n\nQPEL_FUNCS_SET (OP, 3, 1, OPT) \\\n\nQPEL_FUNCS_SET (OP, 3, 2, OPT)\n\n/** @} */\n\n\n\n#endif /* HAVE_YASM */\n\n\n\nvoid ff_rv40dsp_init_x86(RV34DSPContext *c, DSPContext *dsp)\n\n{\n\n#if HAVE_YASM\n\n    int mm_flags = av_get_cpu_flags();\n\n\n\n    if (mm_flags & AV_CPU_FLAG_MMX) {\n\n        c->put_chroma_pixels_tab[0] = ff_put_rv40_chroma_mc8_mmx;\n\n        c->put_chroma_pixels_tab[1] = ff_put_rv40_chroma_mc4_mmx;\n\n#if HAVE_INLINE_ASM\n\n        c->put_pixels_tab[0][15] = ff_put_rv40_qpel16_mc33_mmx;\n\n        c->put_pixels_tab[1][15] = ff_put_rv40_qpel8_mc33_mmx;\n\n        c->avg_pixels_tab[0][15] = ff_avg_rv40_qpel16_mc33_mmx;\n\n        c->avg_pixels_tab[1][15] = ff_avg_rv40_qpel8_mc33_mmx;\n\n#endif /* HAVE_INLINE_ASM */\n\n#if ARCH_X86_32\n\n        QPEL_MC_SET(put_, _mmx)\n\n#endif\n\n    }\n\n    if (mm_flags & AV_CPU_FLAG_MMXEXT) {\n\n        c->avg_chroma_pixels_tab[0] = ff_avg_rv40_chroma_mc8_mmx2;\n\n        c->avg_chroma_pixels_tab[1] = ff_avg_rv40_chroma_mc4_mmx2;\n\n        c->rv40_weight_pixels_tab[0][0] = ff_rv40_weight_func_rnd_16_mmx2;\n\n        c->rv40_weight_pixels_tab[0][1] = ff_rv40_weight_func_rnd_8_mmx2;\n\n        c->rv40_weight_pixels_tab[1][0] = ff_rv40_weight_func_nornd_16_mmx2;\n\n        c->rv40_weight_pixels_tab[1][1] = ff_rv40_weight_func_nornd_8_mmx2;\n\n#if ARCH_X86_32\n\n        QPEL_MC_SET(avg_, _mmx2)\n\n#endif\n\n    } else if (mm_flags & AV_CPU_FLAG_3DNOW) {\n\n        c->avg_chroma_pixels_tab[0] = ff_avg_rv40_chroma_mc8_3dnow;\n\n        c->avg_chroma_pixels_tab[1] = ff_avg_rv40_chroma_mc4_3dnow;\n\n#if ARCH_X86_32\n\n        QPEL_MC_SET(avg_, _3dnow)\n\n#endif\n\n    }\n\n    if (mm_flags & AV_CPU_FLAG_SSE2) {\n\n        c->rv40_weight_pixels_tab[0][0] = ff_rv40_weight_func_rnd_16_sse2;\n\n        c->rv40_weight_pixels_tab[0][1] = ff_rv40_weight_func_rnd_8_sse2;\n\n        c->rv40_weight_pixels_tab[1][0] = ff_rv40_weight_func_nornd_16_sse2;\n\n        c->rv40_weight_pixels_tab[1][1] = ff_rv40_weight_func_nornd_8_sse2;\n\n        QPEL_MC_SET(put_, _sse2)\n\n        QPEL_MC_SET(avg_, _sse2)\n\n    }\n\n    if (mm_flags & AV_CPU_FLAG_SSSE3) {\n\n        c->rv40_weight_pixels_tab[0][0] = ff_rv40_weight_func_rnd_16_ssse3;\n\n        c->rv40_weight_pixels_tab[0][1] = ff_rv40_weight_func_rnd_8_ssse3;\n\n        c->rv40_weight_pixels_tab[1][0] = ff_rv40_weight_func_nornd_16_ssse3;\n\n        c->rv40_weight_pixels_tab[1][1] = ff_rv40_weight_func_nornd_8_ssse3;\n\n        QPEL_MC_SET(put_, _ssse3)\n\n        QPEL_MC_SET(avg_, _ssse3)\n\n    }\n\n#endif /* HAVE_YASM */\n\n}\n", "idx": 17020}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static TCGv new_tmp(void)\n\n{\n\n    TCGv tmp;\n\n    if (num_temps == MAX_TEMPS)\n\n        abort();\n\n\n\n    if (GET_TCGV(temps[num_temps]))\n\n      return temps[num_temps++];\n\n\n\n    tmp = tcg_temp_new(TCG_TYPE_I32);\n\n    temps[num_temps++] = tmp;\n\n    return tmp;\n\n}\n", "idx": 17088}
{"project": "qemu", "commit_id": "9658e4c342e6ae0d775101f8f6bb6efb16789af1", "target": 0, "func": "void cpu_mips_store_status(CPUMIPSState *env, target_ulong val)\n\n{\n\n    uint32_t mask = env->CP0_Status_rw_bitmask;\n\n    target_ulong old = env->CP0_Status;\n\n\n\n    if (env->insn_flags & ISA_MIPS32R6) {\n\n        bool has_supervisor = extract32(mask, CP0St_KSU, 2) == 0x3;\n\n#if defined(TARGET_MIPS64)\n\n        uint32_t ksux = (1 << CP0St_KX) & val;\n\n        ksux |= (ksux >> 1) & val; /* KX = 0 forces SX to be 0 */\n\n        ksux |= (ksux >> 1) & val; /* SX = 0 forces UX to be 0 */\n\n        val = (val & ~(7 << CP0St_UX)) | ksux;\n\n#endif\n\n        if (has_supervisor && extract32(val, CP0St_KSU, 2) == 0x3) {\n\n            mask &= ~(3 << CP0St_KSU);\n\n        }\n\n        mask &= ~(((1 << CP0St_SR) | (1 << CP0St_NMI)) & val);\n\n    }\n\n\n\n    env->CP0_Status = (old & ~mask) | (val & mask);\n\n#if defined(TARGET_MIPS64)\n\n    if ((env->CP0_Status ^ old) & (old & (7 << CP0St_UX))) {\n\n        /* Access to at least one of the 64-bit segments has been disabled */\n\n        cpu_mips_tlb_flush(env);\n\n    }\n\n#endif\n\n    if (env->CP0_Config3 & (1 << CP0C3_MT)) {\n\n        sync_c0_status(env, env, env->current_tc);\n\n    } else {\n\n        compute_hflags(env);\n\n    }\n\n}\n", "idx": 17091}
{"project": "qemu", "commit_id": "32bafa8fdd098d52fbf1102d5a5e48d29398c0aa", "target": 0, "func": "static SocketAddress *nbd_config(BDRVNBDState *s, QDict *options, char **export,\n\n                                 Error **errp)\n\n{\n\n    SocketAddress *saddr;\n\n\n\n    if (qdict_haskey(options, \"path\") == qdict_haskey(options, \"host\")) {\n\n        if (qdict_haskey(options, \"path\")) {\n\n            error_setg(errp, \"path and host may not be used at the same time.\");\n\n        } else {\n\n            error_setg(errp, \"one of path and host must be specified.\");\n\n        }\n\n        return NULL;\n\n    }\n\n\n\n    saddr = g_new0(SocketAddress, 1);\n\n\n\n    if (qdict_haskey(options, \"path\")) {\n\n        UnixSocketAddress *q_unix;\n\n        saddr->type = SOCKET_ADDRESS_KIND_UNIX;\n\n        q_unix = saddr->u.q_unix = g_new0(UnixSocketAddress, 1);\n\n        q_unix->path = g_strdup(qdict_get_str(options, \"path\"));\n\n        qdict_del(options, \"path\");\n\n    } else {\n\n        InetSocketAddress *inet;\n\n        saddr->type = SOCKET_ADDRESS_KIND_INET;\n\n        inet = saddr->u.inet = g_new0(InetSocketAddress, 1);\n\n        inet->host = g_strdup(qdict_get_str(options, \"host\"));\n\n        if (!qdict_get_try_str(options, \"port\")) {\n\n            inet->port = g_strdup_printf(\"%d\", NBD_DEFAULT_PORT);\n\n        } else {\n\n            inet->port = g_strdup(qdict_get_str(options, \"port\"));\n\n        }\n\n        qdict_del(options, \"host\");\n\n        qdict_del(options, \"port\");\n\n    }\n\n\n\n    s->client.is_unix = saddr->type == SOCKET_ADDRESS_KIND_UNIX;\n\n\n\n    *export = g_strdup(qdict_get_try_str(options, \"export\"));\n\n    if (*export) {\n\n        qdict_del(options, \"export\");\n\n    }\n\n\n\n    return saddr;\n\n}\n", "idx": 17140}
{"project": "qemu", "commit_id": "27a69bb088bee6d4efea254659422fb9c751b3c7", "target": 0, "func": "static inline void gen_evmwumi(DisasContext *ctx)\n\n{\n\n    TCGv_i64 t0, t1;\n\n\n\n    if (unlikely(!ctx->spe_enabled)) {\n\n        gen_exception(ctx, POWERPC_EXCP_APU);\n\n        return;\n\n    }\n\n\n\n    t0 = tcg_temp_new_i64();\n\n    t1 = tcg_temp_new_i64();\n\n\n\n    /* t0 := rA; t1 := rB */\n\n#if defined(TARGET_PPC64)\n\n    tcg_gen_ext32u_tl(t0, cpu_gpr[rA(ctx->opcode)]);\n\n    tcg_gen_ext32u_tl(t1, cpu_gpr[rB(ctx->opcode)]);\n\n#else\n\n    tcg_gen_extu_tl_i64(t0, cpu_gpr[rA(ctx->opcode)]);\n\n    tcg_gen_extu_tl_i64(t1, cpu_gpr[rB(ctx->opcode)]);\n\n#endif\n\n\n\n    tcg_gen_mul_i64(t0, t0, t1);  /* t0 := rA * rB */\n\n\n\n    gen_store_gpr64(rD(ctx->opcode), t0); /* rD := t0 */\n\n\n\n    tcg_temp_free_i64(t0);\n\n    tcg_temp_free_i64(t1);\n\n}\n", "idx": 17251}
{"project": "FFmpeg", "commit_id": "4c7b023d56e09a78a587d036db1b64bf7c493b3d", "target": 0, "func": "static int nvdec_vp9_end_frame(AVCodecContext *avctx)\n\n{\n\n    NVDECContext *ctx = avctx->internal->hwaccel_priv_data;\n\n    int ret = ff_nvdec_end_frame(avctx);\n\n    ctx->bitstream = NULL;\n\n    return ret;\n\n}\n", "idx": 17259}
{"project": "qemu", "commit_id": "51b19ebe4320f3dcd93cea71235c1219318ddfd2", "target": 0, "func": "static int v9fs_xattr_read(V9fsState *s, V9fsPDU *pdu, V9fsFidState *fidp,\n\n                           uint64_t off, uint32_t max_count)\n\n{\n\n    ssize_t err;\n\n    size_t offset = 7;\n\n    int read_count;\n\n    int64_t xattr_len;\n\n    V9fsVirtioState *v = container_of(s, V9fsVirtioState, state);\n\n    VirtQueueElement *elem = &v->elems[pdu->idx];\n\n\n\n    xattr_len = fidp->fs.xattr.len;\n\n    read_count = xattr_len - off;\n\n    if (read_count > max_count) {\n\n        read_count = max_count;\n\n    } else if (read_count < 0) {\n\n        /*\n\n         * read beyond XATTR value\n\n         */\n\n        read_count = 0;\n\n    }\n\n    err = pdu_marshal(pdu, offset, \"d\", read_count);\n\n    if (err < 0) {\n\n        return err;\n\n    }\n\n    offset += err;\n\n\n\n    err = v9fs_pack(elem->in_sg, elem->in_num, offset,\n\n                    ((char *)fidp->fs.xattr.value) + off,\n\n                    read_count);\n\n    if (err < 0) {\n\n        return err;\n\n    }\n\n    offset += err;\n\n    return offset;\n\n}\n", "idx": 17299}
{"project": "qemu", "commit_id": "213189ab65d83ecd9072f27c80a15dcb91b6bdbf", "target": 0, "func": "static void virtio_blk_dma_restart_cb(void *opaque, int running, int reason)\n\n{\n\n    VirtIOBlock *s = opaque;\n\n    VirtIOBlockReq *req = s->rq;\n\n\n\n    if (!running)\n\n        return;\n\n\n\n    s->rq = NULL;\n\n\n\n    while (req) {\n\n        virtio_blk_handle_write(req);\n\n        req = req->next;\n\n    }\n\n}\n", "idx": 17305}
{"project": "qemu", "commit_id": "0d9acba8fddbf970c7353083e6a60b47017ce3e4", "target": 1, "func": "static void audio_init (PCIBus *pci_bus)\n\n{\n\n    struct soundhw *c;\n\n    int audio_enabled = 0;\n\n\n\n    for (c = soundhw; !audio_enabled && c->name; ++c) {\n\n        audio_enabled = c->enabled;\n\n    }\n\n\n\n    if (audio_enabled) {\n\n        AudioState *s;\n\n\n\n        s = AUD_init ();\n\n        if (s) {\n\n            for (c = soundhw; c->name; ++c) {\n\n                if (c->enabled)\n\n                    c->init.init_pci (pci_bus, s);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 17386}
{"project": "qemu", "commit_id": "94ef4f337fb614f18b765a8e0e878a4c23cdedcd", "target": 1, "func": "void vga_ioport_write(void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    VGACommonState *s = opaque;\n\n    int index;\n\n\n\n    /* check port range access depending on color/monochrome mode */\n\n    if (vga_ioport_invalid(s, addr)) {\n\n        return;\n\n    }\n\n#ifdef DEBUG_VGA\n\n    printf(\"VGA: write addr=0x%04x data=0x%02x\\n\", addr, val);\n\n#endif\n\n\n\n    switch(addr) {\n\n    case VGA_ATT_W:\n\n        if (s->ar_flip_flop == 0) {\n\n            val &= 0x3f;\n\n            s->ar_index = val;\n\n        } else {\n\n            index = s->ar_index & 0x1f;\n\n            switch(index) {\n\n            case VGA_ATC_PALETTE0 ... VGA_ATC_PALETTEF:\n\n                s->ar[index] = val & 0x3f;\n\n                break;\n\n            case VGA_ATC_MODE:\n\n                s->ar[index] = val & ~0x10;\n\n                break;\n\n            case VGA_ATC_OVERSCAN:\n\n                s->ar[index] = val;\n\n                break;\n\n            case VGA_ATC_PLANE_ENABLE:\n\n                s->ar[index] = val & ~0xc0;\n\n                break;\n\n            case VGA_ATC_PEL:\n\n                s->ar[index] = val & ~0xf0;\n\n                break;\n\n            case VGA_ATC_COLOR_PAGE:\n\n                s->ar[index] = val & ~0xf0;\n\n                break;\n\n            default:\n\n                break;\n\n            }\n\n        }\n\n        s->ar_flip_flop ^= 1;\n\n        break;\n\n    case VGA_MIS_W:\n\n        s->msr = val & ~0x10;\n\n        s->update_retrace_info(s);\n\n        break;\n\n    case VGA_SEQ_I:\n\n        s->sr_index = val & 7;\n\n        break;\n\n    case VGA_SEQ_D:\n\n#ifdef DEBUG_VGA_REG\n\n        printf(\"vga: write SR%x = 0x%02x\\n\", s->sr_index, val);\n\n#endif\n\n        s->sr[s->sr_index] = val & sr_mask[s->sr_index];\n\n        vbe_update_vgaregs(s);\n\n        if (s->sr_index == VGA_SEQ_CLOCK_MODE) {\n\n            s->update_retrace_info(s);\n\n        }\n\n        vga_update_memory_access(s);\n\n        break;\n\n    case VGA_PEL_IR:\n\n        s->dac_read_index = val;\n\n        s->dac_sub_index = 0;\n\n        s->dac_state = 3;\n\n        break;\n\n    case VGA_PEL_IW:\n\n        s->dac_write_index = val;\n\n        s->dac_sub_index = 0;\n\n        s->dac_state = 0;\n\n        break;\n\n    case VGA_PEL_D:\n\n        s->dac_cache[s->dac_sub_index] = val;\n\n        if (++s->dac_sub_index == 3) {\n\n            memcpy(&s->palette[s->dac_write_index * 3], s->dac_cache, 3);\n\n            s->dac_sub_index = 0;\n\n            s->dac_write_index++;\n\n        }\n\n        break;\n\n    case VGA_GFX_I:\n\n        s->gr_index = val & 0x0f;\n\n        break;\n\n    case VGA_GFX_D:\n\n#ifdef DEBUG_VGA_REG\n\n        printf(\"vga: write GR%x = 0x%02x\\n\", s->gr_index, val);\n\n#endif\n\n        s->gr[s->gr_index] = val & gr_mask[s->gr_index];\n\n        vbe_update_vgaregs(s);\n\n        vga_update_memory_access(s);\n\n        break;\n\n    case VGA_CRT_IM:\n\n    case VGA_CRT_IC:\n\n        s->cr_index = val;\n\n        break;\n\n    case VGA_CRT_DM:\n\n    case VGA_CRT_DC:\n\n#ifdef DEBUG_VGA_REG\n\n        printf(\"vga: write CR%x = 0x%02x\\n\", s->cr_index, val);\n\n#endif\n\n        /* handle CR0-7 protection */\n\n        if ((s->cr[VGA_CRTC_V_SYNC_END] & VGA_CR11_LOCK_CR0_CR7) &&\n\n            s->cr_index <= VGA_CRTC_OVERFLOW) {\n\n            /* can always write bit 4 of CR7 */\n\n            if (s->cr_index == VGA_CRTC_OVERFLOW) {\n\n                s->cr[VGA_CRTC_OVERFLOW] = (s->cr[VGA_CRTC_OVERFLOW] & ~0x10) |\n\n                    (val & 0x10);\n\n                vbe_update_vgaregs(s);\n\n            }\n\n            return;\n\n        }\n\n        s->cr[s->cr_index] = val;\n\n        vbe_update_vgaregs(s);\n\n\n\n        switch(s->cr_index) {\n\n        case VGA_CRTC_H_TOTAL:\n\n        case VGA_CRTC_H_SYNC_START:\n\n        case VGA_CRTC_H_SYNC_END:\n\n        case VGA_CRTC_V_TOTAL:\n\n        case VGA_CRTC_OVERFLOW:\n\n        case VGA_CRTC_V_SYNC_END:\n\n        case VGA_CRTC_MODE:\n\n            s->update_retrace_info(s);\n\n            break;\n\n        }\n\n        break;\n\n    case VGA_IS1_RM:\n\n    case VGA_IS1_RC:\n\n        s->fcr = val & 0x10;\n\n        break;\n\n    }\n\n}\n", "idx": 17448}
{"project": "FFmpeg", "commit_id": "fa2a34cd40d124161c748bb0f430dc63c94dd0da", "target": 0, "func": "int show_filters(void *optctx, const char *opt, const char *arg)\n\n{\n\n    AVFilter av_unused(**filter) = NULL;\n\n\n\n    printf(\"Filters:\\n\");\n\n#if CONFIG_AVFILTER\n\n    while ((filter = av_filter_next(filter)) && *filter)\n\n        printf(\"%-16s %s\\n\", (*filter)->name, (*filter)->description);\n\n#endif\n\n    return 0;\n\n}\n", "idx": 17492}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "static void free_schro_frame(SchroFrame *frame, void *priv)\n\n{\n\n    AVFrame *p_pic = priv;\n\n    av_frame_free(&p_pic);\n\n}\n", "idx": 17544}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "float64 HELPER(ucf64_divd)(float64 a, float64 b, CPUUniCore32State *env)\n\n{\n\n    return float64_div(a, b, &env->ucf64.fp_status);\n\n}\n", "idx": 17571}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "static OSStatus audioDeviceIOProc(\n\n    AudioDeviceID inDevice,\n\n    const AudioTimeStamp* inNow,\n\n    const AudioBufferList* inInputData,\n\n    const AudioTimeStamp* inInputTime,\n\n    AudioBufferList* outOutputData,\n\n    const AudioTimeStamp* inOutputTime,\n\n    void* hwptr)\n\n{\n\n    UInt32 frame, frameCount;\n\n    float *out = outOutputData->mBuffers[0].mData;\n\n    HWVoiceOut *hw = hwptr;\n\n    coreaudioVoiceOut *core = (coreaudioVoiceOut *) hwptr;\n\n    int rpos, live;\n\n    st_sample_t *src;\n\n#ifndef FLOAT_MIXENG\n\n#ifdef RECIPROCAL\n\n    const float scale = 1.f / UINT_MAX;\n\n#else\n\n    const float scale = UINT_MAX;\n\n#endif\n\n#endif\n\n\n\n    if (coreaudio_lock (core, \"audioDeviceIOProc\")) {\n\n        inInputTime = 0;\n\n        return 0;\n\n    }\n\n\n\n    frameCount = core->audioDevicePropertyBufferFrameSize;\n\n    live = core->live;\n\n\n\n    /* if there are not enough samples, set signal and return */\n\n    if (live < frameCount) {\n\n        inInputTime = 0;\n\n        coreaudio_unlock (core, \"audioDeviceIOProc(empty)\");\n\n        return 0;\n\n    }\n\n\n\n    rpos = core->rpos;\n\n    src = hw->mix_buf + rpos;\n\n\n\n    /* fill buffer */\n\n    for (frame = 0; frame < frameCount; frame++) {\n\n#ifdef FLOAT_MIXENG\n\n        *out++ = src[frame].l; /* left channel */\n\n        *out++ = src[frame].r; /* right channel */\n\n#else\n\n#ifdef RECIPROCAL\n\n        *out++ = src[frame].l * scale; /* left channel */\n\n        *out++ = src[frame].r * scale; /* right channel */\n\n#else\n\n        *out++ = src[frame].l / scale; /* left channel */\n\n        *out++ = src[frame].r / scale; /* right channel */\n\n#endif\n\n#endif\n\n    }\n\n\n\n    rpos = (rpos + frameCount) % hw->samples;\n\n    core->decr += frameCount;\n\n    core->rpos = rpos;\n\n\n\n    coreaudio_unlock (core, \"audioDeviceIOProc\");\n\n    return 0;\n\n}\n", "idx": 17600}
{"project": "FFmpeg", "commit_id": "5d2b8850746b4513a43938f60930b060cad36ee5", "target": 0, "func": "int ff_start_frame(AVFilterLink *link, AVFilterBufferRef *picref)\n\n{\n\n    int (*start_frame)(AVFilterLink *, AVFilterBufferRef *);\n\n    AVFilterPad *src = link->srcpad;\n\n    AVFilterPad *dst = link->dstpad;\n\n    int ret, perms;\n\n    AVFilterCommand *cmd= link->dst->command_queue;\n\n    int64_t pts;\n\n\n\n    FF_TPRINTF_START(NULL, start_frame); ff_tlog_link(NULL, link, 0); ff_tlog(NULL, \" \"); ff_tlog_ref(NULL, picref, 1);\n\n\n\n    av_assert1(picref->format                     == link->format);\n\n    av_assert1(picref->video->w                   == link->w);\n\n    av_assert1(picref->video->h                   == link->h);\n\n\n\n    if (link->closed) {\n\n        avfilter_unref_buffer(picref);\n\n        return AVERROR_EOF;\n\n    }\n\n\n\n    if (!(start_frame = dst->start_frame))\n\n        start_frame = default_start_frame;\n\n\n\n    av_assert1((picref->perms & src->min_perms) == src->min_perms);\n\n    picref->perms &= ~ src->rej_perms;\n\n    perms = picref->perms;\n\n\n\n    if (picref->linesize[0] < 0)\n\n        perms |= AV_PERM_NEG_LINESIZES;\n\n    /* prepare to copy the picture if it has insufficient permissions */\n\n    if ((dst->min_perms & perms) != dst->min_perms || dst->rej_perms & perms) {\n\n        av_log(link->dst, AV_LOG_DEBUG,\n\n                \"frame copy needed (have perms %x, need %x, reject %x)\\n\",\n\n                picref->perms,\n\n                link->dstpad->min_perms, link->dstpad->rej_perms);\n\n\n\n        link->cur_buf = ff_get_video_buffer(link, dst->min_perms, link->w, link->h);\n\n        if (!link->cur_buf) {\n\n            avfilter_unref_bufferp(&picref);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n\n\n        link->src_buf = picref;\n\n        avfilter_copy_buffer_ref_props(link->cur_buf, link->src_buf);\n\n\n\n        /* copy palette if required */\n\n        if (av_pix_fmt_descriptors[link->format].flags & PIX_FMT_PAL)\n\n            memcpy(link->cur_buf->data[1], link->src_buf-> data[1], AVPALETTE_SIZE);\n\n    }\n\n    else\n\n        link->cur_buf = picref;\n\n\n\n    link->cur_buf_copy = link->cur_buf;\n\n\n\n    while(cmd && cmd->time <= picref->pts * av_q2d(link->time_base)){\n\n        av_log(link->dst, AV_LOG_DEBUG,\n\n               \"Processing command time:%f command:%s arg:%s\\n\",\n\n               cmd->time, cmd->command, cmd->arg);\n\n        avfilter_process_command(link->dst, cmd->command, cmd->arg, 0, 0, cmd->flags);\n\n        ff_command_queue_pop(link->dst);\n\n        cmd= link->dst->command_queue;\n\n    }\n\n    pts = link->cur_buf->pts;\n\n    ret = start_frame(link, link->cur_buf);\n\n    ff_update_link_current_pts(link, pts);\n\n    if (ret < 0)\n\n        clear_link(link);\n\n    else\n\n        /* incoming buffers must not be freed in start frame,\n\n           because they can still be in use by the automatic copy mechanism */\n\n        av_assert1(link->cur_buf_copy->buf->refcount > 0);\n\n\n\n    return ret;\n\n}\n", "idx": 17621}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "static bool bdrv_drain_one(BlockDriverState *bs)\n\n{\n\n    bool bs_busy;\n\n\n\n    bdrv_flush_io_queue(bs);\n\n    bdrv_start_throttled_reqs(bs);\n\n    bs_busy = bdrv_requests_pending(bs);\n\n    bs_busy |= aio_poll(bdrv_get_aio_context(bs), bs_busy);\n\n    return bs_busy;\n\n}\n", "idx": 17623}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int svq1_encode_init(AVCodecContext *avctx)\n\n{\n\n    SVQ1EncContext *const s = avctx->priv_data;\n\n    int ret;\n\n\n\n    ff_hpeldsp_init(&s->hdsp, avctx->flags);\n\n    ff_me_cmp_init(&s->mecc, avctx);\n\n    ff_mpegvideoencdsp_init(&s->m.mpvencdsp, avctx);\n\n\n\n    avctx->coded_frame = av_frame_alloc();\n\n    s->current_picture = av_frame_alloc();\n\n    s->last_picture    = av_frame_alloc();\n\n    if (!avctx->coded_frame || !s->current_picture || !s->last_picture) {\n\n        svq1_encode_end(avctx);\n\n        return AVERROR(ENOMEM);\n\n    }\n\n\n\n    s->frame_width  = avctx->width;\n\n    s->frame_height = avctx->height;\n\n\n\n    s->y_block_width  = (s->frame_width  + 15) / 16;\n\n    s->y_block_height = (s->frame_height + 15) / 16;\n\n\n\n    s->c_block_width  = (s->frame_width  / 4 + 15) / 16;\n\n    s->c_block_height = (s->frame_height / 4 + 15) / 16;\n\n\n\n    s->avctx               = avctx;\n\n    s->m.avctx             = avctx;\n\n\n\n    if ((ret = ff_mpv_common_init(&s->m)) < 0) {\n\n        svq1_encode_end(avctx);\n\n        return ret;\n\n    }\n\n\n\n    s->m.picture_structure = PICT_FRAME;\n\n    s->m.me.temp           =\n\n    s->m.me.scratchpad     = av_mallocz((avctx->width + 64) *\n\n                                        2 * 16 * 2 * sizeof(uint8_t));\n\n    s->m.me.map            = av_mallocz(ME_MAP_SIZE * sizeof(uint32_t));\n\n    s->m.me.score_map      = av_mallocz(ME_MAP_SIZE * sizeof(uint32_t));\n\n    s->mb_type             = av_mallocz((s->y_block_width + 1) *\n\n                                        s->y_block_height * sizeof(int16_t));\n\n    s->dummy               = av_mallocz((s->y_block_width + 1) *\n\n                                        s->y_block_height * sizeof(int32_t));\n\n    s->ssd_int8_vs_int16   = ssd_int8_vs_int16_c;\n\n\n\n    if (!s->m.me.temp || !s->m.me.scratchpad || !s->m.me.map ||\n\n        !s->m.me.score_map || !s->mb_type || !s->dummy) {\n\n        svq1_encode_end(avctx);\n\n        return AVERROR(ENOMEM);\n\n    }\n\n\n\n    if (ARCH_PPC)\n\n        ff_svq1enc_init_ppc(s);\n\n    if (ARCH_X86)\n\n        ff_svq1enc_init_x86(s);\n\n\n\n    ff_h263_encode_init(&s->m); // mv_penalty\n\n\n\n    return 0;\n\n}\n", "idx": 17677}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void dp8393x_writeb(void *opaque, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    uint16_t old_val = dp8393x_readw(opaque, addr & ~0x1);\n\n\n\n    switch (addr & 3) {\n\n    case 0:\n\n        val = val | (old_val & 0xff00);\n\n        break;\n\n    case 1:\n\n        val = (val << 8) | (old_val & 0x00ff);\n\n        break;\n\n    }\n\n    dp8393x_writew(opaque, addr & ~0x1, val);\n\n}\n", "idx": 17688}
{"project": "qemu", "commit_id": "d1fdf257d52822695f5ace6c586e059aa17d4b79", "target": 0, "func": "static ssize_t nbd_co_receive_request(NBDRequestData *req,\n\n                                      NBDRequest *request)\n\n{\n\n    NBDClient *client = req->client;\n\n    ssize_t rc;\n\n\n\n    g_assert(qemu_in_coroutine());\n\n    assert(client->recv_coroutine == qemu_coroutine_self());\n\n    rc = nbd_receive_request(client->ioc, request);\n\n    if (rc < 0) {\n\n        if (rc != -EAGAIN) {\n\n            rc = -EIO;\n\n        }\n\n        goto out;\n\n    }\n\n\n\n    TRACE(\"Decoding type\");\n\n\n\n    if (request->type != NBD_CMD_WRITE) {\n\n        /* No payload, we are ready to read the next request.  */\n\n        req->complete = true;\n\n    }\n\n\n\n    if (request->type == NBD_CMD_DISC) {\n\n        /* Special case: we're going to disconnect without a reply,\n\n         * whether or not flags, from, or len are bogus */\n\n        TRACE(\"Request type is DISCONNECT\");\n\n        rc = -EIO;\n\n        goto out;\n\n    }\n\n\n\n    /* Check for sanity in the parameters, part 1.  Defer as many\n\n     * checks as possible until after reading any NBD_CMD_WRITE\n\n     * payload, so we can try and keep the connection alive.  */\n\n    if ((request->from + request->len) < request->from) {\n\n        LOG(\"integer overflow detected, you're probably being attacked\");\n\n        rc = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    if (request->type == NBD_CMD_READ || request->type == NBD_CMD_WRITE) {\n\n        if (request->len > NBD_MAX_BUFFER_SIZE) {\n\n            LOG(\"len (%\" PRIu32\" ) is larger than max len (%u)\",\n\n                request->len, NBD_MAX_BUFFER_SIZE);\n\n            rc = -EINVAL;\n\n            goto out;\n\n        }\n\n\n\n        req->data = blk_try_blockalign(client->exp->blk, request->len);\n\n        if (req->data == NULL) {\n\n            rc = -ENOMEM;\n\n            goto out;\n\n        }\n\n    }\n\n    if (request->type == NBD_CMD_WRITE) {\n\n        TRACE(\"Reading %\" PRIu32 \" byte(s)\", request->len);\n\n\n\n        if (read_sync(client->ioc, req->data, request->len, NULL) < 0) {\n\n            LOG(\"reading from socket failed\");\n\n            rc = -EIO;\n\n            goto out;\n\n        }\n\n        req->complete = true;\n\n    }\n\n\n\n    /* Sanity checks, part 2. */\n\n    if (request->from + request->len > client->exp->size) {\n\n        LOG(\"operation past EOF; From: %\" PRIu64 \", Len: %\" PRIu32\n\n            \", Size: %\" PRIu64, request->from, request->len,\n\n            (uint64_t)client->exp->size);\n\n        rc = request->type == NBD_CMD_WRITE ? -ENOSPC : -EINVAL;\n\n        goto out;\n\n    }\n\n    if (request->flags & ~(NBD_CMD_FLAG_FUA | NBD_CMD_FLAG_NO_HOLE)) {\n\n        LOG(\"unsupported flags (got 0x%x)\", request->flags);\n\n        rc = -EINVAL;\n\n        goto out;\n\n    }\n\n    if (request->type != NBD_CMD_WRITE_ZEROES &&\n\n        (request->flags & NBD_CMD_FLAG_NO_HOLE)) {\n\n        LOG(\"unexpected flags (got 0x%x)\", request->flags);\n\n        rc = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    rc = 0;\n\n\n\nout:\n\n    client->recv_coroutine = NULL;\n\n    nbd_client_receive_next_request(client);\n\n\n\n    return rc;\n\n}\n", "idx": 17692}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int asf_probe(AVProbeData *pd)\n\n{\n\n    /* check file header */\n\n    if (pd->buf_size <= 32)\n\n        return 0;\n\n\n\n    if (!memcmp(pd->buf, &asf_header, sizeof(GUID)))\n\n        return AVPROBE_SCORE_MAX;\n\n    else\n\n        return 0;\n\n}\n", "idx": 17734}
{"project": "qemu", "commit_id": "ad718d01ba0af531d10b0a8685cf5047edfd1891", "target": 1, "func": "int qemu_opt_set_bool(QemuOpts *opts, const char *name, bool val)\n\n{\n\n    QemuOpt *opt;\n\n    const QemuOptDesc *desc = opts->list->desc;\n\n    int i;\n\n\n\n    for (i = 0; desc[i].name != NULL; i++) {\n\n        if (strcmp(desc[i].name, name) == 0) {\n\n            break;\n\n        }\n\n    }\n\n    if (desc[i].name == NULL) {\n\n        if (i == 0) {\n\n            /* empty list -> allow any */;\n\n        } else {\n\n            qerror_report(QERR_INVALID_PARAMETER, name);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    opt = g_malloc0(sizeof(*opt));\n\n    opt->name = g_strdup(name);\n\n    opt->opts = opts;\n\n    QTAILQ_INSERT_TAIL(&opts->head, opt, next);\n\n    if (desc[i].name != NULL) {\n\n        opt->desc = desc+i;\n\n    }\n\n    opt->value.boolean = !!val;\n\n    return 0;\n\n}\n", "idx": 17783}
{"project": "qemu", "commit_id": "5839e53bbc0fec56021d758aab7610df421ed8c8", "target": 1, "func": "BlockDriverState *bdrv_new(const char *device_name, Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    int i;\n\n\n\n    if (bdrv_find(device_name)) {\n\n        error_setg(errp, \"Device with id '%s' already exists\",\n\n                   device_name);\n\n        return NULL;\n\n    }\n\n    if (bdrv_find_node(device_name)) {\n\n        error_setg(errp, \"Device with node-name '%s' already exists\",\n\n                   device_name);\n\n        return NULL;\n\n    }\n\n\n\n    bs = g_malloc0(sizeof(BlockDriverState));\n\n    QLIST_INIT(&bs->dirty_bitmaps);\n\n    pstrcpy(bs->device_name, sizeof(bs->device_name), device_name);\n\n    if (device_name[0] != '\\0') {\n\n        QTAILQ_INSERT_TAIL(&bdrv_states, bs, device_list);\n\n    }\n\n    for (i = 0; i < BLOCK_OP_TYPE_MAX; i++) {\n\n        QLIST_INIT(&bs->op_blockers[i]);\n\n    }\n\n    bdrv_iostatus_disable(bs);\n\n    notifier_list_init(&bs->close_notifiers);\n\n    notifier_with_return_list_init(&bs->before_write_notifiers);\n\n    qemu_co_queue_init(&bs->throttled_reqs[0]);\n\n    qemu_co_queue_init(&bs->throttled_reqs[1]);\n\n    bs->refcnt = 1;\n\n    bs->aio_context = qemu_get_aio_context();\n\n\n\n    return bs;\n\n}\n", "idx": 17858}
{"project": "qemu", "commit_id": "651eb0f41b793021f7de672de78892def5819fb9", "target": 1, "func": "static int kvm_set_user_memory_region(KVMState *s, KVMSlot *slot)\n\n{\n\n    struct kvm_userspace_memory_region mem;\n\n\n\n    mem.slot = slot->slot;\n\n    mem.guest_phys_addr = slot->start_addr;\n\n    mem.userspace_addr = (unsigned long)slot->ram;\n\n    mem.flags = slot->flags;\n\n    if (s->migration_log) {\n\n        mem.flags |= KVM_MEM_LOG_DIRTY_PAGES;\n\n    }\n\n    if (mem.flags & KVM_MEM_READONLY) {\n\n        /* Set the slot size to 0 before setting the slot to the desired\n\n         * value. This is needed based on KVM commit 75d61fbc. */\n\n        mem.memory_size = 0;\n\n        kvm_vm_ioctl(s, KVM_SET_USER_MEMORY_REGION, &mem);\n\n    }\n\n    mem.memory_size = slot->memory_size;\n\n    return kvm_vm_ioctl(s, KVM_SET_USER_MEMORY_REGION, &mem);\n\n}\n", "idx": 17871}
{"project": "FFmpeg", "commit_id": "53509d20cac1f9c4bb7e746f36e25d6fc66ae31b", "target": 1, "func": "static int decode_frame(AVCodecContext *avctx, void *data, int *data_size,\n\n                        AVPacket *avpkt)\n\n{\n\n    V210DecContext *s = avctx->priv_data;\n\n\n\n    int h, w, stride, aligned_input;\n\n    AVFrame *pic = avctx->coded_frame;\n\n    const uint8_t *psrc = avpkt->data;\n\n    uint16_t *y, *u, *v;\n\n\n\n    if (s->custom_stride )\n\n        stride = s->custom_stride;\n\n    else {\n\n        int aligned_width = ((avctx->width + 47) / 48) * 48;\n\n        stride = aligned_width * 8 / 3;\n\n    }\n\n\n\n    aligned_input = !((uintptr_t)psrc & 0xf) && !(stride & 0xf);\n\n    if (aligned_input != s->aligned_input) {\n\n        s->aligned_input = aligned_input;\n\n        if (HAVE_MMX)\n\n            v210_x86_init(s);\n\n    }\n\n\n\n    if (pic->data[0])\n\n        avctx->release_buffer(avctx, pic);\n\n\n\n    if (avpkt->size < stride * avctx->height) {\n\n        av_log(avctx, AV_LOG_ERROR, \"packet too small\\n\");\n\n        return -1;\n\n    }\n\n\n\n    pic->reference = 0;\n\n    if (avctx->get_buffer(avctx, pic) < 0)\n\n        return -1;\n\n\n\n    y = (uint16_t*)pic->data[0];\n\n    u = (uint16_t*)pic->data[1];\n\n    v = (uint16_t*)pic->data[2];\n\n    pic->pict_type = AV_PICTURE_TYPE_I;\n\n    pic->key_frame = 1;\n\n\n\n    for (h = 0; h < avctx->height; h++) {\n\n        const uint32_t *src = (const uint32_t*)psrc;\n\n        uint32_t val;\n\n\n\n        w = (avctx->width / 6) * 6;\n\n        s->unpack_frame(src, y, u, v, w);\n\n\n\n        y += w;\n\n        u += w >> 1;\n\n        v += w >> 1;\n\n        src += (w << 1) / 3;\n\n\n\n        if (w < avctx->width - 1) {\n\n            READ_PIXELS(u, y, v);\n\n\n\n            val  = av_le2ne32(*src++);\n\n            *y++ =  val & 0x3FF;\n\n        }\n\n        if (w < avctx->width - 3) {\n\n            *u++ = (val >> 10) & 0x3FF;\n\n            *y++ = (val >> 20) & 0x3FF;\n\n\n\n            val  = av_le2ne32(*src++);\n\n            *v++ =  val & 0x3FF;\n\n            *y++ = (val >> 10) & 0x3FF;\n\n        }\n\n\n\n        psrc += stride;\n\n        y += pic->linesize[0] / 2 - avctx->width;\n\n        u += pic->linesize[1] / 2 - avctx->width / 2;\n\n        v += pic->linesize[2] / 2 - avctx->width / 2;\n\n    }\n\n\n\n    *data_size = sizeof(AVFrame);\n\n    *(AVFrame*)data = *avctx->coded_frame;\n\n\n\n    return avpkt->size;\n\n}\n", "idx": 17878}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static void usb_msd_send_status(MSDState *s, USBPacket *p)\n\n{\n\n    struct usb_msd_csw csw;\n\n    int len;\n\n\n\n    csw.sig = cpu_to_le32(0x53425355);\n\n    csw.tag = cpu_to_le32(s->tag);\n\n    csw.residue = s->residue;\n\n    csw.status = s->result;\n\n\n\n    len = MIN(sizeof(csw), p->len);\n\n    memcpy(p->data, &csw, len);\n\n}\n", "idx": 18028}
{"project": "qemu", "commit_id": "09b9418c6d085a0728372aa760ebd10128a020b1", "target": 1, "func": "static target_long monitor_get_psr (const struct MonitorDef *md, int val)\n\n{\n\n    CPUState *env = mon_get_cpu();\n\n    if (!env)\n\n        return 0;\n\n    return GET_PSR(env);\n\n}\n", "idx": 18078}
{"project": "qemu", "commit_id": "d9f62dde1303286b24ac8ce88be27e2b9b9c5f46", "target": 0, "func": "opts_start_list(Visitor *v, const char *name, Error **errp)\n\n{\n\n    OptsVisitor *ov = to_ov(v);\n\n\n\n    /* we can't traverse a list in a list */\n\n    assert(ov->list_mode == LM_NONE);\n\n    ov->repeated_opts = lookup_distinct(ov, name, errp);\n\n    if (ov->repeated_opts != NULL) {\n\n        ov->list_mode = LM_STARTED;\n\n    }\n\n}\n", "idx": 18102}
{"project": "qemu", "commit_id": "3098dba01c7daab60762b6f6624ea88c0d6cb65a", "target": 0, "func": "void DBDMA_schedule(void)\n\n{\n\n    CPUState *env = cpu_single_env;\n\n    if (env)\n\n        cpu_interrupt(env, CPU_INTERRUPT_EXIT);\n\n}\n", "idx": 18133}
{"project": "qemu", "commit_id": "7385aed20db5d83979f683b9d0048674411e963c", "target": 0, "func": "void helper_fdmulq(CPUSPARCState *env, float64 src1, float64 src2)\n\n{\n\n    clear_float_exceptions(env);\n\n    QT0 = float128_mul(float64_to_float128(src1, &env->fp_status),\n\n                       float64_to_float128(src2, &env->fp_status),\n\n                       &env->fp_status);\n\n    check_ieee_exceptions(env);\n\n}\n", "idx": 18146}
{"project": "qemu", "commit_id": "3b22c4707decb706b10ce023534f8b79413ff9fe", "target": 0, "func": "void helper_iret_real(int shift)\n\n{\n\n    uint32_t sp, new_cs, new_eip, new_eflags, new_esp;\n\n    uint8_t *ssp;\n\n    int eflags_mask;\n\n    \n\n    sp = env->regs[R_ESP] & 0xffff;\n\n    ssp = env->segs[R_SS].base + sp;\n\n    if (shift == 1) {\n\n        /* 32 bits */\n\n        new_eflags = ldl(ssp + 8);\n\n        new_cs = ldl(ssp + 4) & 0xffff;\n\n        new_eip = ldl(ssp) & 0xffff;\n\n    } else {\n\n        /* 16 bits */\n\n        new_eflags = lduw(ssp + 4);\n\n        new_cs = lduw(ssp + 2);\n\n        new_eip = lduw(ssp);\n\n    }\n\n    new_esp = sp + (6 << shift);\n\n    env->regs[R_ESP] = (env->regs[R_ESP] & 0xffff0000) | \n\n        (new_esp & 0xffff);\n\n    load_seg_vm(R_CS, new_cs);\n\n    env->eip = new_eip;\n\n    eflags_mask = FL_UPDATE_CPL0_MASK;\n\n    if (shift == 0)\n\n        eflags_mask &= 0xffff;\n\n    load_eflags(new_eflags, eflags_mask);\n\n}\n", "idx": 18149}
{"project": "qemu", "commit_id": "33e66b86d89040f0a9e99aa53deb74ce8936a649", "target": 1, "func": "USBDevice *usb_msd_init(const char *filename)\n\n{\n\n    static int nr=0;\n\n    char id[8];\n\n    QemuOpts *opts;\n\n    DriveInfo *dinfo;\n\n    USBDevice *dev;\n\n    int fatal_error;\n\n    const char *p1;\n\n    char fmt[32];\n\n\n\n    /* parse -usbdevice disk: syntax into drive opts */\n\n    snprintf(id, sizeof(id), \"usb%d\", nr++);\n\n    opts = qemu_opts_create(&qemu_drive_opts, id, 0);\n\n\n\n    p1 = strchr(filename, ':');\n\n    if (p1++) {\n\n        const char *p2;\n\n\n\n        if (strstart(filename, \"format=\", &p2)) {\n\n            int len = MIN(p1 - p2, sizeof(fmt));\n\n            pstrcpy(fmt, len, p2);\n\n            qemu_opt_set(opts, \"format\", fmt);\n\n        } else if (*filename != ':') {\n\n            printf(\"unrecognized USB mass-storage option %s\\n\", filename);\n\n            return NULL;\n\n        }\n\n        filename = p1;\n\n    }\n\n    if (!*filename) {\n\n        printf(\"block device specification needed\\n\");\n\n        return NULL;\n\n    }\n\n    qemu_opt_set(opts, \"file\", filename);\n\n    qemu_opt_set(opts, \"if\", \"none\");\n\n\n\n    /* create host drive */\n\n    dinfo = drive_init(opts, NULL, &fatal_error);\n\n    if (!dinfo) {\n\n        qemu_opts_del(opts);\n\n        return NULL;\n\n    }\n\n\n\n    /* create guest device */\n\n    dev = usb_create(NULL /* FIXME */, \"QEMU USB MSD\");\n\n    qdev_prop_set_drive(&dev->qdev, \"drive\", dinfo);\n\n    qdev_init(&dev->qdev);\n\n\n\n    return dev;\n\n}\n", "idx": 18179}
{"project": "qemu", "commit_id": "3182664220571d11d4fe03ecdc10fcc1e842ed32", "target": 0, "func": "static bool is_zero(BlockDriverState *bs, int64_t offset, int64_t bytes)\n\n{\n\n    int nr;\n\n    int64_t res;\n\n    int64_t start;\n\n\n\n    /* TODO: Widening to sector boundaries should only be needed as\n\n     * long as we can't query finer granularity. */\n\n    start = QEMU_ALIGN_DOWN(offset, BDRV_SECTOR_SIZE);\n\n    bytes = QEMU_ALIGN_UP(offset + bytes, BDRV_SECTOR_SIZE) - start;\n\n\n\n    /* Clamp to image length, before checking status of underlying sectors */\n\n    if (start + bytes > bs->total_sectors * BDRV_SECTOR_SIZE) {\n\n        bytes = bs->total_sectors * BDRV_SECTOR_SIZE - start;\n\n    }\n\n\n\n    if (!bytes) {\n\n        return true;\n\n    }\n\n    res = bdrv_get_block_status_above(bs, NULL, start >> BDRV_SECTOR_BITS,\n\n                                      bytes >> BDRV_SECTOR_BITS, &nr, NULL);\n\n    return res >= 0 && (res & BDRV_BLOCK_ZERO) &&\n\n        nr * BDRV_SECTOR_SIZE == bytes;\n\n}\n", "idx": 18238}
{"project": "qemu", "commit_id": "f293709c6af7a65a9bcec09cdba7a60183657a3e", "target": 1, "func": "static inline void code_gen_alloc(size_t tb_size)\n\n{\n\n    tcg_ctx.code_gen_buffer_size = size_code_gen_buffer(tb_size);\n\n    tcg_ctx.code_gen_buffer = alloc_code_gen_buffer();\n\n    if (tcg_ctx.code_gen_buffer == NULL) {\n\n        fprintf(stderr, \"Could not allocate dynamic translator buffer\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    qemu_madvise(tcg_ctx.code_gen_buffer, tcg_ctx.code_gen_buffer_size,\n\n                 QEMU_MADV_HUGEPAGE);\n\n\n\n    /* Estimate a good size for the number of TBs we can support.  We\n\n       still haven't deducted the prologue from the buffer size here,\n\n       but that's minimal and won't affect the estimate much.  */\n\n    tcg_ctx.code_gen_max_blocks\n\n        = tcg_ctx.code_gen_buffer_size / CODE_GEN_AVG_BLOCK_SIZE;\n\n    tcg_ctx.tb_ctx.tbs = g_new(TranslationBlock, tcg_ctx.code_gen_max_blocks);\n\n\n\n    qemu_mutex_init(&tcg_ctx.tb_ctx.tb_lock);\n\n}\n", "idx": 18320}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void cirrus_mmio_write(void *opaque, target_phys_addr_t addr,\n\n                              uint64_t val, unsigned size)\n\n{\n\n    CirrusVGAState *s = opaque;\n\n\n\n    if (addr >= 0x100) {\n\n\tcirrus_mmio_blt_write(s, addr - 0x100, val);\n\n    } else {\n\n        cirrus_vga_ioport_write(s, addr + 0x3c0, val);\n\n    }\n\n}\n", "idx": 18353}
{"project": "qemu", "commit_id": "503006983a19be0b481946afac2cab0bdd21f124", "target": 0, "func": "void register_cp_regs_for_features(ARMCPU *cpu)\n\n{\n\n    /* Register all the coprocessor registers based on feature bits */\n\n    CPUARMState *env = &cpu->env;\n\n    if (arm_feature(env, ARM_FEATURE_M)) {\n\n        /* M profile has no coprocessor registers */\n\n        return;\n\n    }\n\n\n\n    define_arm_cp_regs(cpu, cp_reginfo);\n\n    if (!arm_feature(env, ARM_FEATURE_V8)) {\n\n        /* Must go early as it is full of wildcards that may be\n\n         * overridden by later definitions.\n\n         */\n\n        define_arm_cp_regs(cpu, not_v8_cp_reginfo);\n\n    }\n\n\n\n    if (arm_feature(env, ARM_FEATURE_V6)) {\n\n        /* The ID registers all have impdef reset values */\n\n        ARMCPRegInfo v6_idregs[] = {\n\n            { .name = \"ID_PFR0\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 1, .opc2 = 0,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_pfr0 },\n\n            { .name = \"ID_PFR1\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 1, .opc2 = 1,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_pfr1 },\n\n            { .name = \"ID_DFR0\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 1, .opc2 = 2,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_dfr0 },\n\n            { .name = \"ID_AFR0\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 1, .opc2 = 3,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_afr0 },\n\n            { .name = \"ID_MMFR0\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 1, .opc2 = 4,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_mmfr0 },\n\n            { .name = \"ID_MMFR1\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 1, .opc2 = 5,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_mmfr1 },\n\n            { .name = \"ID_MMFR2\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 1, .opc2 = 6,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_mmfr2 },\n\n            { .name = \"ID_MMFR3\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 1, .opc2 = 7,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_mmfr3 },\n\n            { .name = \"ID_ISAR0\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 2, .opc2 = 0,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_isar0 },\n\n            { .name = \"ID_ISAR1\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 2, .opc2 = 1,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_isar1 },\n\n            { .name = \"ID_ISAR2\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 2, .opc2 = 2,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_isar2 },\n\n            { .name = \"ID_ISAR3\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 2, .opc2 = 3,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_isar3 },\n\n            { .name = \"ID_ISAR4\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 2, .opc2 = 4,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_isar4 },\n\n            { .name = \"ID_ISAR5\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 2, .opc2 = 5,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_isar5 },\n\n            /* 6..7 are as yet unallocated and must RAZ */\n\n            { .name = \"ID_ISAR6\", .cp = 15, .crn = 0, .crm = 2,\n\n              .opc1 = 0, .opc2 = 6, .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = 0 },\n\n            { .name = \"ID_ISAR7\", .cp = 15, .crn = 0, .crm = 2,\n\n              .opc1 = 0, .opc2 = 7, .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = 0 },\n\n            REGINFO_SENTINEL\n\n        };\n\n        define_arm_cp_regs(cpu, v6_idregs);\n\n        define_arm_cp_regs(cpu, v6_cp_reginfo);\n\n    } else {\n\n        define_arm_cp_regs(cpu, not_v6_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_V6K)) {\n\n        define_arm_cp_regs(cpu, v6k_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_V7)) {\n\n        /* v7 performance monitor control register: same implementor\n\n         * field as main ID register, and we implement only the cycle\n\n         * count register.\n\n         */\n\n#ifndef CONFIG_USER_ONLY\n\n        ARMCPRegInfo pmcr = {\n\n            .name = \"PMCR\", .cp = 15, .crn = 9, .crm = 12, .opc1 = 0, .opc2 = 0,\n\n            .access = PL0_RW, .resetvalue = cpu->midr & 0xff000000,\n\n            .type = ARM_CP_IO,\n\n            .fieldoffset = offsetof(CPUARMState, cp15.c9_pmcr),\n\n            .accessfn = pmreg_access, .writefn = pmcr_write,\n\n            .raw_writefn = raw_write,\n\n        };\n\n        define_one_arm_cp_reg(cpu, &pmcr);\n\n#endif\n\n        ARMCPRegInfo clidr = {\n\n            .name = \"CLIDR\", .state = ARM_CP_STATE_BOTH,\n\n            .opc0 = 3, .crn = 0, .crm = 0, .opc1 = 1, .opc2 = 1,\n\n            .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = cpu->clidr\n\n        };\n\n        define_one_arm_cp_reg(cpu, &clidr);\n\n        define_arm_cp_regs(cpu, v7_cp_reginfo);\n\n    } else {\n\n        define_arm_cp_regs(cpu, not_v7_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_V8)) {\n\n        /* AArch64 ID registers, which all have impdef reset values */\n\n        ARMCPRegInfo v8_idregs[] = {\n\n            { .name = \"ID_AA64PFR0_EL1\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 4, .opc2 = 0,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_aa64pfr0 },\n\n            { .name = \"ID_AA64PFR1_EL1\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 4, .opc2 = 1,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_aa64pfr1},\n\n            { .name = \"ID_AA64DFR0_EL1\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 5, .opc2 = 0,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              /* We mask out the PMUVer field, because we don't currently\n\n               * implement the PMU. Not advertising it prevents the guest\n\n               * from trying to use it and getting UNDEFs on registers we\n\n               * don't implement.\n\n               */\n\n              .resetvalue = cpu->id_aa64dfr0 & ~0xf00 },\n\n            { .name = \"ID_AA64DFR1_EL1\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 5, .opc2 = 1,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_aa64dfr1 },\n\n            { .name = \"ID_AA64AFR0_EL1\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 5, .opc2 = 4,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_aa64afr0 },\n\n            { .name = \"ID_AA64AFR1_EL1\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 5, .opc2 = 5,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_aa64afr1 },\n\n            { .name = \"ID_AA64ISAR0_EL1\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 6, .opc2 = 0,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_aa64isar0 },\n\n            { .name = \"ID_AA64ISAR1_EL1\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 6, .opc2 = 1,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_aa64isar1 },\n\n            { .name = \"ID_AA64MMFR0_EL1\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 7, .opc2 = 0,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_aa64mmfr0 },\n\n            { .name = \"ID_AA64MMFR1_EL1\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 7, .opc2 = 1,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->id_aa64mmfr1 },\n\n            { .name = \"MVFR0_EL1\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 3, .opc2 = 0,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->mvfr0 },\n\n            { .name = \"MVFR1_EL1\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 3, .opc2 = 1,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->mvfr1 },\n\n            { .name = \"MVFR2_EL1\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 3, .opc2 = 2,\n\n              .access = PL1_R, .type = ARM_CP_CONST,\n\n              .resetvalue = cpu->mvfr2 },\n\n            REGINFO_SENTINEL\n\n        };\n\n        ARMCPRegInfo rvbar = {\n\n            .name = \"RVBAR_EL1\", .state = ARM_CP_STATE_AA64,\n\n            .opc0 = 3, .opc1 = 0, .crn = 12, .crm = 0, .opc2 = 2,\n\n            .type = ARM_CP_CONST, .access = PL1_R, .resetvalue = cpu->rvbar\n\n        };\n\n        define_one_arm_cp_reg(cpu, &rvbar);\n\n        define_arm_cp_regs(cpu, v8_idregs);\n\n        define_arm_cp_regs(cpu, v8_cp_reginfo);\n\n        define_aarch64_debug_regs(cpu);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_EL2)) {\n\n        define_arm_cp_regs(cpu, v8_el2_cp_reginfo);\n\n    } else {\n\n        /* If EL2 is missing but higher ELs are enabled, we need to\n\n         * register the no_el2 reginfos.\n\n         */\n\n        if (arm_feature(env, ARM_FEATURE_EL3)) {\n\n            define_arm_cp_regs(cpu, v8_el3_no_el2_cp_reginfo);\n\n        }\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_EL3)) {\n\n        define_arm_cp_regs(cpu, v8_el3_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_MPU)) {\n\n        /* These are the MPU registers prior to PMSAv6. Any new\n\n         * PMSA core later than the ARM946 will require that we\n\n         * implement the PMSAv6 or PMSAv7 registers, which are\n\n         * completely different.\n\n         */\n\n        assert(!arm_feature(env, ARM_FEATURE_V6));\n\n        define_arm_cp_regs(cpu, pmsav5_cp_reginfo);\n\n    } else {\n\n        define_arm_cp_regs(cpu, vmsa_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_THUMB2EE)) {\n\n        define_arm_cp_regs(cpu, t2ee_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_GENERIC_TIMER)) {\n\n        define_arm_cp_regs(cpu, generic_timer_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_VAPA)) {\n\n        define_arm_cp_regs(cpu, vapa_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_CACHE_TEST_CLEAN)) {\n\n        define_arm_cp_regs(cpu, cache_test_clean_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_CACHE_DIRTY_REG)) {\n\n        define_arm_cp_regs(cpu, cache_dirty_status_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_CACHE_BLOCK_OPS)) {\n\n        define_arm_cp_regs(cpu, cache_block_ops_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_OMAPCP)) {\n\n        define_arm_cp_regs(cpu, omap_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_STRONGARM)) {\n\n        define_arm_cp_regs(cpu, strongarm_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_XSCALE)) {\n\n        define_arm_cp_regs(cpu, xscale_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_DUMMY_C15_REGS)) {\n\n        define_arm_cp_regs(cpu, dummy_c15_cp_reginfo);\n\n    }\n\n    if (arm_feature(env, ARM_FEATURE_LPAE)) {\n\n        define_arm_cp_regs(cpu, lpae_cp_reginfo);\n\n    }\n\n    /* Slightly awkwardly, the OMAP and StrongARM cores need all of\n\n     * cp15 crn=0 to be writes-ignored, whereas for other cores they should\n\n     * be read-only (ie write causes UNDEF exception).\n\n     */\n\n    {\n\n        ARMCPRegInfo id_pre_v8_midr_cp_reginfo[] = {\n\n            /* Pre-v8 MIDR space.\n\n             * Note that the MIDR isn't a simple constant register because\n\n             * of the TI925 behaviour where writes to another register can\n\n             * cause the MIDR value to change.\n\n             *\n\n             * Unimplemented registers in the c15 0 0 0 space default to\n\n             * MIDR. Define MIDR first as this entire space, then CTR, TCMTR\n\n             * and friends override accordingly.\n\n             */\n\n            { .name = \"MIDR\",\n\n              .cp = 15, .crn = 0, .crm = 0, .opc1 = 0, .opc2 = CP_ANY,\n\n              .access = PL1_R, .resetvalue = cpu->midr,\n\n              .writefn = arm_cp_write_ignore, .raw_writefn = raw_write,\n\n              .fieldoffset = offsetof(CPUARMState, cp15.c0_cpuid),\n\n              .type = ARM_CP_OVERRIDE },\n\n            /* crn = 0 op1 = 0 crm = 3..7 : currently unassigned; we RAZ. */\n\n            { .name = \"DUMMY\",\n\n              .cp = 15, .crn = 0, .crm = 3, .opc1 = 0, .opc2 = CP_ANY,\n\n              .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = 0 },\n\n            { .name = \"DUMMY\",\n\n              .cp = 15, .crn = 0, .crm = 4, .opc1 = 0, .opc2 = CP_ANY,\n\n              .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = 0 },\n\n            { .name = \"DUMMY\",\n\n              .cp = 15, .crn = 0, .crm = 5, .opc1 = 0, .opc2 = CP_ANY,\n\n              .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = 0 },\n\n            { .name = \"DUMMY\",\n\n              .cp = 15, .crn = 0, .crm = 6, .opc1 = 0, .opc2 = CP_ANY,\n\n              .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = 0 },\n\n            { .name = \"DUMMY\",\n\n              .cp = 15, .crn = 0, .crm = 7, .opc1 = 0, .opc2 = CP_ANY,\n\n              .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = 0 },\n\n            REGINFO_SENTINEL\n\n        };\n\n        ARMCPRegInfo id_v8_midr_cp_reginfo[] = {\n\n            /* v8 MIDR -- the wildcard isn't necessary, and nor is the\n\n             * variable-MIDR TI925 behaviour. Instead we have a single\n\n             * (strictly speaking IMPDEF) alias of the MIDR, REVIDR.\n\n             */\n\n            { .name = \"MIDR_EL1\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 0, .opc2 = 0,\n\n              .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = cpu->midr },\n\n            { .name = \"REVIDR_EL1\", .state = ARM_CP_STATE_BOTH,\n\n              .opc0 = 3, .opc1 = 0, .crn = 0, .crm = 0, .opc2 = 6,\n\n              .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = cpu->midr },\n\n            REGINFO_SENTINEL\n\n        };\n\n        ARMCPRegInfo id_cp_reginfo[] = {\n\n            /* These are common to v8 and pre-v8 */\n\n            { .name = \"CTR\",\n\n              .cp = 15, .crn = 0, .crm = 0, .opc1 = 0, .opc2 = 1,\n\n              .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = cpu->ctr },\n\n            { .name = \"CTR_EL0\", .state = ARM_CP_STATE_AA64,\n\n              .opc0 = 3, .opc1 = 3, .opc2 = 1, .crn = 0, .crm = 0,\n\n              .access = PL0_R, .accessfn = ctr_el0_access,\n\n              .type = ARM_CP_CONST, .resetvalue = cpu->ctr },\n\n            /* TCMTR and TLBTR exist in v8 but have no 64-bit versions */\n\n            { .name = \"TCMTR\",\n\n              .cp = 15, .crn = 0, .crm = 0, .opc1 = 0, .opc2 = 2,\n\n              .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = 0 },\n\n            { .name = \"TLBTR\",\n\n              .cp = 15, .crn = 0, .crm = 0, .opc1 = 0, .opc2 = 3,\n\n              .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = 0 },\n\n            REGINFO_SENTINEL\n\n        };\n\n        ARMCPRegInfo crn0_wi_reginfo = {\n\n            .name = \"CRN0_WI\", .cp = 15, .crn = 0, .crm = CP_ANY,\n\n            .opc1 = CP_ANY, .opc2 = CP_ANY, .access = PL1_W,\n\n            .type = ARM_CP_NOP | ARM_CP_OVERRIDE\n\n        };\n\n        if (arm_feature(env, ARM_FEATURE_OMAPCP) ||\n\n            arm_feature(env, ARM_FEATURE_STRONGARM)) {\n\n            ARMCPRegInfo *r;\n\n            /* Register the blanket \"writes ignored\" value first to cover the\n\n             * whole space. Then update the specific ID registers to allow write\n\n             * access, so that they ignore writes rather than causing them to\n\n             * UNDEF.\n\n             */\n\n            define_one_arm_cp_reg(cpu, &crn0_wi_reginfo);\n\n            for (r = id_pre_v8_midr_cp_reginfo;\n\n                 r->type != ARM_CP_SENTINEL; r++) {\n\n                r->access = PL1_RW;\n\n            }\n\n            for (r = id_cp_reginfo; r->type != ARM_CP_SENTINEL; r++) {\n\n                r->access = PL1_RW;\n\n            }\n\n        }\n\n        if (arm_feature(env, ARM_FEATURE_V8)) {\n\n            define_arm_cp_regs(cpu, id_v8_midr_cp_reginfo);\n\n        } else {\n\n            define_arm_cp_regs(cpu, id_pre_v8_midr_cp_reginfo);\n\n        }\n\n        define_arm_cp_regs(cpu, id_cp_reginfo);\n\n    }\n\n\n\n    if (arm_feature(env, ARM_FEATURE_MPIDR)) {\n\n        define_arm_cp_regs(cpu, mpidr_cp_reginfo);\n\n    }\n\n\n\n    if (arm_feature(env, ARM_FEATURE_AUXCR)) {\n\n        ARMCPRegInfo auxcr = {\n\n            .name = \"ACTLR_EL1\", .state = ARM_CP_STATE_BOTH,\n\n            .opc0 = 3, .opc1 = 0, .crn = 1, .crm = 0, .opc2 = 1,\n\n            .access = PL1_RW, .type = ARM_CP_CONST,\n\n            .resetvalue = cpu->reset_auxcr\n\n        };\n\n        define_one_arm_cp_reg(cpu, &auxcr);\n\n    }\n\n\n\n    if (arm_feature(env, ARM_FEATURE_CBAR)) {\n\n        if (arm_feature(env, ARM_FEATURE_AARCH64)) {\n\n            /* 32 bit view is [31:18] 0...0 [43:32]. */\n\n            uint32_t cbar32 = (extract64(cpu->reset_cbar, 18, 14) << 18)\n\n                | extract64(cpu->reset_cbar, 32, 12);\n\n            ARMCPRegInfo cbar_reginfo[] = {\n\n                { .name = \"CBAR\",\n\n                  .type = ARM_CP_CONST,\n\n                  .cp = 15, .crn = 15, .crm = 0, .opc1 = 4, .opc2 = 0,\n\n                  .access = PL1_R, .resetvalue = cpu->reset_cbar },\n\n                { .name = \"CBAR_EL1\", .state = ARM_CP_STATE_AA64,\n\n                  .type = ARM_CP_CONST,\n\n                  .opc0 = 3, .opc1 = 1, .crn = 15, .crm = 3, .opc2 = 0,\n\n                  .access = PL1_R, .resetvalue = cbar32 },\n\n                REGINFO_SENTINEL\n\n            };\n\n            /* We don't implement a r/w 64 bit CBAR currently */\n\n            assert(arm_feature(env, ARM_FEATURE_CBAR_RO));\n\n            define_arm_cp_regs(cpu, cbar_reginfo);\n\n        } else {\n\n            ARMCPRegInfo cbar = {\n\n                .name = \"CBAR\",\n\n                .cp = 15, .crn = 15, .crm = 0, .opc1 = 4, .opc2 = 0,\n\n                .access = PL1_R|PL3_W, .resetvalue = cpu->reset_cbar,\n\n                .fieldoffset = offsetof(CPUARMState,\n\n                                        cp15.c15_config_base_address)\n\n            };\n\n            if (arm_feature(env, ARM_FEATURE_CBAR_RO)) {\n\n                cbar.access = PL1_R;\n\n                cbar.fieldoffset = 0;\n\n                cbar.type = ARM_CP_CONST;\n\n            }\n\n            define_one_arm_cp_reg(cpu, &cbar);\n\n        }\n\n    }\n\n\n\n    /* Generic registers whose values depend on the implementation */\n\n    {\n\n        ARMCPRegInfo sctlr = {\n\n            .name = \"SCTLR\", .state = ARM_CP_STATE_BOTH,\n\n            .opc0 = 3, .crn = 1, .crm = 0, .opc1 = 0, .opc2 = 0,\n\n            .access = PL1_RW, .fieldoffset = offsetof(CPUARMState, cp15.c1_sys),\n\n            .writefn = sctlr_write, .resetvalue = cpu->reset_sctlr,\n\n            .raw_writefn = raw_write,\n\n        };\n\n        if (arm_feature(env, ARM_FEATURE_XSCALE)) {\n\n            /* Normally we would always end the TB on an SCTLR write, but Linux\n\n             * arch/arm/mach-pxa/sleep.S expects two instructions following\n\n             * an MMU enable to execute from cache.  Imitate this behaviour.\n\n             */\n\n            sctlr.type |= ARM_CP_SUPPRESS_TB_END;\n\n        }\n\n        define_one_arm_cp_reg(cpu, &sctlr);\n\n    }\n\n}\n", "idx": 18356}
{"project": "qemu", "commit_id": "db50f280cf5f714e64ff2b134aae138908f07502", "target": 1, "func": "static target_ulong h_resize_hpt_prepare(PowerPCCPU *cpu,\n\n                                         sPAPRMachineState *spapr,\n\n                                         target_ulong opcode,\n\n                                         target_ulong *args)\n\n{\n\n    target_ulong flags = args[0];\n\n    int shift = args[1];\n\n    sPAPRPendingHPT *pending = spapr->pending_hpt;\n\n    uint64_t current_ram_size = MACHINE(spapr)->ram_size;\n\n    int rc;\n\n\n\n    if (spapr->resize_hpt == SPAPR_RESIZE_HPT_DISABLED) {\n\n        return H_AUTHORITY;\n\n    }\n\n\n\n    if (!spapr->htab_shift) {\n\n        /* Radix guest, no HPT */\n\n        return H_NOT_AVAILABLE;\n\n    }\n\n\n\n    trace_spapr_h_resize_hpt_prepare(flags, shift);\n\n\n\n    if (flags != 0) {\n\n        return H_PARAMETER;\n\n    }\n\n\n\n    if (shift && ((shift < 18) || (shift > 46))) {\n\n        return H_PARAMETER;\n\n    }\n\n\n\n    current_ram_size = pc_existing_dimms_capacity(&error_fatal);\n\n\n\n    /* We only allow the guest to allocate an HPT one order above what\n\n     * we'd normally give them (to stop a small guest claiming a huge\n\n     * chunk of resources in the HPT */\n\n    if (shift > (spapr_hpt_shift_for_ramsize(current_ram_size) + 1)) {\n\n        return H_RESOURCE;\n\n    }\n\n\n\n    rc = kvmppc_resize_hpt_prepare(cpu, flags, shift);\n\n    if (rc != -ENOSYS) {\n\n        return resize_hpt_convert_rc(rc);\n\n    }\n\n\n\n    if (pending) {\n\n        /* something already in progress */\n\n        if (pending->shift == shift) {\n\n            /* and it's suitable */\n\n            if (pending->complete) {\n\n                return pending->ret;\n\n            } else {\n\n                return H_LONG_BUSY_ORDER_100_MSEC;\n\n            }\n\n        }\n\n\n\n        /* not suitable, cancel and replace */\n\n        cancel_hpt_prepare(spapr);\n\n    }\n\n\n\n    if (!shift) {\n\n        /* nothing to do */\n\n        return H_SUCCESS;\n\n    }\n\n\n\n    /* start new prepare */\n\n\n\n    pending = g_new0(sPAPRPendingHPT, 1);\n\n    pending->shift = shift;\n\n    pending->ret = H_HARDWARE;\n\n\n\n    qemu_thread_create(&pending->thread, \"sPAPR HPT prepare\",\n\n                       hpt_prepare_thread, pending, QEMU_THREAD_DETACHED);\n\n\n\n    spapr->pending_hpt = pending;\n\n\n\n    /* In theory we could estimate the time more accurately based on\n\n     * the new size, but there's not much point */\n\n    return H_LONG_BUSY_ORDER_100_MSEC;\n\n}\n", "idx": 18411}
{"project": "FFmpeg", "commit_id": "f92f4935acd7d974adfd1deebdf1bb06cbe107ca", "target": 1, "func": "static void count_usage(uint8_t *src, int width,\n\n                        int height, uint32_t *counts)\n\n{\n\n    int i, j;\n\n\n\n    for (j = 0; j < height; j++) {\n\n        for (i = 0; i < width; i++) {\n\n            counts[src[i]]++;\n\n        }\n\n        src += width;\n\n    }\n\n}\n", "idx": 18427}
{"project": "FFmpeg", "commit_id": "06599638dd678c9939df0fd83ff693c43b25971d", "target": 0, "func": "static int decode_frame_header(NUTContext *nut, int *flags_ret, int64_t *pts, int *stream_id, int frame_code){\n\n    AVFormatContext *s= nut->avf;\n\n    ByteIOContext *bc = &s->pb;\n\n    StreamContext *stc;\n\n    int size, flags, size_mul, pts_delta, i, reserved_count;\n\n    uint64_t tmp;\n\n\n\n    if(url_ftell(bc) > nut->last_syncpoint_pos + nut->max_distance){\n\n        av_log(s, AV_LOG_ERROR, \"last frame must have been damaged %Ld > %Ld + %d\\n\", url_ftell(bc), nut->last_syncpoint_pos, nut->max_distance);\n\n        return -1;\n\n    }\n\n\n\n    flags          = nut->frame_code[frame_code].flags;\n\n    size_mul       = nut->frame_code[frame_code].size_mul;\n\n    size           = nut->frame_code[frame_code].size_lsb;\n\n    *stream_id     = nut->frame_code[frame_code].stream_id;\n\n    pts_delta      = nut->frame_code[frame_code].pts_delta;\n\n    reserved_count = nut->frame_code[frame_code].reserved_count;\n\n\n\n    if(flags & FLAG_INVALID)\n\n        return -1;\n\n    if(flags & FLAG_CODED)\n\n        flags ^= get_v(bc);\n\n    if(flags & FLAG_STREAM_ID){\n\n        GET_V(*stream_id, tmp < s->nb_streams)\n\n    }\n\n    stc= &nut->stream[*stream_id];\n\n    if(flags&FLAG_CODED_PTS){\n\n        int coded_pts= get_v(bc);\n\n//FIXME check last_pts validity?\n\n        if(coded_pts < (1<<stc->msb_pts_shift)){\n\n            *pts=lsb2full(stc, coded_pts);\n\n        }else\n\n            *pts=coded_pts - (1<<stc->msb_pts_shift);\n\n    }else\n\n        *pts= stc->last_pts + pts_delta;\n\n    if(flags&FLAG_SIZE_MSB){\n\n        size += size_mul*get_v(bc);\n\n    }\n\n    if(flags&FLAG_RESERVED)\n\n        reserved_count= get_v(bc);\n\n    for(i=0; i<reserved_count; i++)\n\n        get_v(bc);\n\n    if(flags&FLAG_CHECKSUM){\n\n        get_be32(bc); //FIXME check this\n\n    }else if(size > 2*nut->max_distance){\n\n        av_log(s, AV_LOG_ERROR, \"frame size > 2max_distance and no checksum\\n\");\n\n        return -1;\n\n    }\n\n    *flags_ret= flags;\n\n\n\n    stc->last_pts= *pts;\n\n    stc->last_key_frame= flags&FLAG_KEY; //FIXME change to last flags\n\n\n\n    return size;\n\n}\n", "idx": 18501}
{"project": "FFmpeg", "commit_id": "358078d9bb89d6266e274720eba8582ec7b1c6b7", "target": 0, "func": "static av_cold int alac_encode_init(AVCodecContext *avctx)\n\n{\n\n    AlacEncodeContext *s = avctx->priv_data;\n\n    int ret;\n\n    uint8_t *alac_extradata;\n\n\n\n    avctx->frame_size = s->frame_size = DEFAULT_FRAME_SIZE;\n\n\n\n    if (avctx->sample_fmt != AV_SAMPLE_FMT_S16) {\n\n        av_log(avctx, AV_LOG_ERROR, \"only pcm_s16 input samples are supported\\n\");\n\n        return -1;\n\n    }\n\n\n\n    /* TODO: Correctly implement multi-channel ALAC.\n\n             It is similar to multi-channel AAC, in that it has a series of\n\n             single-channel (SCE), channel-pair (CPE), and LFE elements. */\n\n    if (avctx->channels > 2) {\n\n        av_log(avctx, AV_LOG_ERROR, \"only mono or stereo input is currently supported\\n\");\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    // Set default compression level\n\n    if (avctx->compression_level == FF_COMPRESSION_DEFAULT)\n\n        s->compression_level = 2;\n\n    else\n\n        s->compression_level = av_clip(avctx->compression_level, 0, 2);\n\n\n\n    // Initialize default Rice parameters\n\n    s->rc.history_mult    = 40;\n\n    s->rc.initial_history = 10;\n\n    s->rc.k_modifier      = 14;\n\n    s->rc.rice_modifier   = 4;\n\n\n\n    s->max_coded_frame_size = get_max_frame_size(avctx->frame_size,\n\n                                                 avctx->channels,\n\n                                                 DEFAULT_SAMPLE_SIZE);\n\n\n\n    // FIXME: consider wasted_bytes\n\n    s->write_sample_size  = DEFAULT_SAMPLE_SIZE + avctx->channels - 1;\n\n\n\n    avctx->extradata = av_mallocz(ALAC_EXTRADATA_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);\n\n    if (!avctx->extradata) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto error;\n\n    }\n\n    avctx->extradata_size = ALAC_EXTRADATA_SIZE;\n\n\n\n    alac_extradata = avctx->extradata;\n\n    AV_WB32(alac_extradata,    ALAC_EXTRADATA_SIZE);\n\n    AV_WB32(alac_extradata+4,  MKBETAG('a','l','a','c'));\n\n    AV_WB32(alac_extradata+12, avctx->frame_size);\n\n    AV_WB8 (alac_extradata+17, DEFAULT_SAMPLE_SIZE);\n\n    AV_WB8 (alac_extradata+21, avctx->channels);\n\n    AV_WB32(alac_extradata+24, s->max_coded_frame_size);\n\n    AV_WB32(alac_extradata+28,\n\n            avctx->sample_rate * avctx->channels * DEFAULT_SAMPLE_SIZE); // average bitrate\n\n    AV_WB32(alac_extradata+32, avctx->sample_rate);\n\n\n\n    // Set relevant extradata fields\n\n    if (s->compression_level > 0) {\n\n        AV_WB8(alac_extradata+18, s->rc.history_mult);\n\n        AV_WB8(alac_extradata+19, s->rc.initial_history);\n\n        AV_WB8(alac_extradata+20, s->rc.k_modifier);\n\n    }\n\n\n\n    s->min_prediction_order = DEFAULT_MIN_PRED_ORDER;\n\n    if (avctx->min_prediction_order >= 0) {\n\n        if (avctx->min_prediction_order < MIN_LPC_ORDER ||\n\n           avctx->min_prediction_order > ALAC_MAX_LPC_ORDER) {\n\n            av_log(avctx, AV_LOG_ERROR, \"invalid min prediction order: %d\\n\",\n\n                   avctx->min_prediction_order);\n\n            ret = AVERROR(EINVAL);\n\n            goto error;\n\n        }\n\n\n\n        s->min_prediction_order = avctx->min_prediction_order;\n\n    }\n\n\n\n    s->max_prediction_order = DEFAULT_MAX_PRED_ORDER;\n\n    if (avctx->max_prediction_order >= 0) {\n\n        if (avctx->max_prediction_order < MIN_LPC_ORDER ||\n\n            avctx->max_prediction_order > ALAC_MAX_LPC_ORDER) {\n\n            av_log(avctx, AV_LOG_ERROR, \"invalid max prediction order: %d\\n\",\n\n                   avctx->max_prediction_order);\n\n            ret = AVERROR(EINVAL);\n\n            goto error;\n\n        }\n\n\n\n        s->max_prediction_order = avctx->max_prediction_order;\n\n    }\n\n\n\n    if (s->max_prediction_order < s->min_prediction_order) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"invalid prediction orders: min=%d max=%d\\n\",\n\n               s->min_prediction_order, s->max_prediction_order);\n\n        ret = AVERROR(EINVAL);\n\n        goto error;\n\n    }\n\n\n\n    avctx->coded_frame = avcodec_alloc_frame();\n\n    if (!avctx->coded_frame) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto error;\n\n    }\n\n\n\n    s->avctx = avctx;\n\n\n\n    if ((ret = ff_lpc_init(&s->lpc_ctx, avctx->frame_size,\n\n                           s->max_prediction_order,\n\n                           FF_LPC_TYPE_LEVINSON)) < 0) {\n\n        goto error;\n\n    }\n\n\n\n    return 0;\n\nerror:\n\n    alac_encode_close(avctx);\n\n    return ret;\n\n}\n", "idx": 18503}
{"project": "FFmpeg", "commit_id": "d7b542ae294aaf818f2a00c5606e009cf931e77c", "target": 1, "func": "static int ogg_packet(AVFormatContext *s, int *str, int *dstart, int *dsize,\n\n                      int64_t *fpos)\n\n{\n\n    struct ogg *ogg = s->priv_data;\n\n    int idx, i, ret;\n\n    struct ogg_stream *os;\n\n    int complete = 0;\n\n    int segp = 0, psize = 0;\n\n\n\n    av_dlog(s, \"ogg_packet: curidx=%i\\n\", ogg->curidx);\n\n\n\n    do{\n\n        idx = ogg->curidx;\n\n\n\n        while (idx < 0){\n\n            ret = ogg_read_page(s, &idx);\n\n            if (ret < 0)\n\n                return ret;\n\n        }\n\n\n\n        os = ogg->streams + idx;\n\n\n\n        av_dlog(s, \"ogg_packet: idx=%d pstart=%d psize=%d segp=%d nsegs=%d\\n\",\n\n                idx, os->pstart, os->psize, os->segp, os->nsegs);\n\n\n\n        if (!os->codec){\n\n            if (os->header < 0){\n\n                os->codec = ogg_find_codec (os->buf, os->bufpos);\n\n                if (!os->codec){\n\n                    av_log(s, AV_LOG_WARNING, \"Codec not found\\n\");\n\n                    os->header = 0;\n\n                    return 0;\n\n                }\n\n            }else{\n\n                return 0;\n\n            }\n\n        }\n\n\n\n        segp = os->segp;\n\n        psize = os->psize;\n\n\n\n        while (os->segp < os->nsegs){\n\n            int ss = os->segments[os->segp++];\n\n            os->psize += ss;\n\n            if (ss < 255){\n\n                complete = 1;\n\n                break;\n\n            }\n\n        }\n\n\n\n        if (!complete && os->segp == os->nsegs){\n\n            ogg->curidx = -1;\n\n            os->incomplete = 1;\n\n        }\n\n    }while (!complete);\n\n\n\n\n\n    if (os->granule == -1)\n\n        av_log(s, AV_LOG_WARNING, \"Page at %\"PRId64\" is missing granule\\n\", os->page_pos);\n\n\n\n    ogg->curidx = idx;\n\n    os->incomplete = 0;\n\n\n\n    if (os->header) {\n\n        os->header = os->codec->header (s, idx);\n\n        if (!os->header){\n\n            os->segp = segp;\n\n            os->psize = psize;\n\n\n\n            // We have reached the first non-header packet in this stream.\n\n            // Unfortunately more header packets may still follow for others,\n\n            // but if we continue with header parsing we may lose data packets.\n\n            ogg->headers = 1;\n\n\n\n            // Update the header state for all streams and\n\n            // compute the data_offset.\n\n            if (!s->data_offset)\n\n                s->data_offset = os->sync_pos;\n\n            for (i = 0; i < ogg->nstreams; i++) {\n\n                struct ogg_stream *cur_os = ogg->streams + i;\n\n\n\n                // if we have a partial non-header packet, its start is\n\n                // obviously at or after the data start\n\n                if (cur_os->incomplete)\n\n                    s->data_offset = FFMIN(s->data_offset, cur_os->sync_pos);\n\n            }\n\n        }else{\n\n            os->pstart += os->psize;\n\n            os->psize = 0;\n\n        }\n\n    } else {\n\n        os->pflags = 0;\n\n        os->pduration = 0;\n\n        if (os->codec && os->codec->packet)\n\n            os->codec->packet (s, idx);\n\n        if (str)\n\n            *str = idx;\n\n        if (dstart)\n\n            *dstart = os->pstart;\n\n        if (dsize)\n\n            *dsize = os->psize;\n\n        if (fpos)\n\n            *fpos = os->sync_pos;\n\n        os->pstart += os->psize;\n\n        os->psize = 0;\n\n        if(os->pstart == os->bufpos)\n\n            os->bufpos = os->pstart = 0;\n\n        os->sync_pos = os->page_pos;\n\n    }\n\n\n\n    // determine whether there are more complete packets in this page\n\n    // if not, the page's granule will apply to this packet\n\n    os->page_end = 1;\n\n    for (i = os->segp; i < os->nsegs; i++)\n\n        if (os->segments[i] < 255) {\n\n            os->page_end = 0;\n\n            break;\n\n        }\n\n\n\n    if (os->segp == os->nsegs)\n\n        ogg->curidx = -1;\n\n\n\n    return 0;\n\n}\n", "idx": 18560}
{"project": "qemu", "commit_id": "e3e09d87c6e69c2da684d5aacabe3124ebcb6f8e", "target": 0, "func": "static void trigger_prot_fault(CPUS390XState *env, target_ulong vaddr,\n\n                               uint64_t mode)\n\n{\n\n    CPUState *cs = CPU(s390_env_get_cpu(env));\n\n    int ilen = ILEN_LATER_INC;\n\n    int bits = trans_bits(env, mode) | 4;\n\n\n\n    DPRINTF(\"%s: vaddr=%016\" PRIx64 \" bits=%d\\n\", __func__, vaddr, bits);\n\n\n\n    stq_phys(cs->as,\n\n             env->psa + offsetof(LowCore, trans_exc_code), vaddr | bits);\n\n    trigger_pgm_exception(env, PGM_PROTECTION, ilen);\n\n}\n", "idx": 18613}
{"project": "qemu", "commit_id": "e7ca56562990991bc614a43b9351ee0737f3045d", "target": 0, "func": "void string_output_visitor_cleanup(StringOutputVisitor *sov)\n\n{\n\n    if (sov->string) {\n\n        g_string_free(sov->string, true);\n\n    }\n\n\n\n    g_list_foreach(sov->ranges, free_range, NULL);\n\n    g_list_free(sov->ranges);\n\n    g_free(sov);\n\n}\n", "idx": 18621}
{"project": "FFmpeg", "commit_id": "4cc896ea5f06f8b1ebcde6d876d9c5b59ef9a016", "target": 1, "func": "void av_register_output_format(AVOutputFormat *format)\n\n{\n\n    AVOutputFormat **p = last_oformat;\n\n\n\n    format->next = NULL;\n\n    while(*p || avpriv_atomic_ptr_cas((void * volatile *)p, NULL, format))\n\n        p = &(*p)->next;\n\n    last_oformat = &format->next;\n\n}\n", "idx": 18643}
{"project": "FFmpeg", "commit_id": "171ec812235a5d22fa421242351ee2da5a96c3ba", "target": 1, "func": "static void rv34_pred_4x4_block(RV34DecContext *r, uint8_t *dst, int stride, int itype, int up, int left, int down, int right)\n\n{\n\n    uint8_t *prev = dst - stride + 4;\n\n    uint32_t topleft;\n\n\n\n    if(!up && !left)\n\n        itype = DC_128_PRED;\n\n    else if(!up){\n\n        if(itype == VERT_PRED) itype = HOR_PRED;\n\n        if(itype == DC_PRED)   itype = LEFT_DC_PRED;\n\n    }else if(!left){\n\n        if(itype == HOR_PRED)  itype = VERT_PRED;\n\n        if(itype == DC_PRED)   itype = TOP_DC_PRED;\n\n        if(itype == DIAG_DOWN_LEFT_PRED) itype = DIAG_DOWN_LEFT_PRED_RV40_NODOWN;\n\n    }\n\n    if(!down){\n\n        if(itype == DIAG_DOWN_LEFT_PRED) itype = DIAG_DOWN_LEFT_PRED_RV40_NODOWN;\n\n        if(itype == HOR_UP_PRED) itype = HOR_UP_PRED_RV40_NODOWN;\n\n        if(itype == VERT_LEFT_PRED) itype = VERT_LEFT_PRED_RV40_NODOWN;\n\n    }\n\n    if(!right && up){\n\n        topleft = dst[-stride + 3] * 0x01010101;\n\n        prev = (uint8_t*)&topleft;\n\n    }\n\n    r->h.pred4x4[itype](dst, prev, stride);\n\n}\n", "idx": 18753}
{"project": "FFmpeg", "commit_id": "22fa406f384eb9d825b1d691332e1f928750d55b", "target": 1, "func": "static av_cold int MP3lame_encode_init(AVCodecContext *avctx)\n\n{\n\n    Mp3AudioContext *s = avctx->priv_data;\n\n\n\n    if (avctx->channels > 2)\n\n        return -1;\n\n\n\n    s->stereo = avctx->channels > 1 ? 1 : 0;\n\n\n\n    if ((s->gfp = lame_init()) == NULL)\n\n        goto err;\n\n    lame_set_in_samplerate(s->gfp, avctx->sample_rate);\n\n    lame_set_out_samplerate(s->gfp, avctx->sample_rate);\n\n    lame_set_num_channels(s->gfp, avctx->channels);\n\n    if(avctx->compression_level == FF_COMPRESSION_DEFAULT) {\n\n        lame_set_quality(s->gfp, 5);\n\n    } else {\n\n        lame_set_quality(s->gfp, avctx->compression_level);\n\n    }\n\n    lame_set_mode(s->gfp, s->stereo ? JOINT_STEREO : MONO);\n\n    lame_set_brate(s->gfp, avctx->bit_rate/1000);\n\n    if(avctx->flags & CODEC_FLAG_QSCALE) {\n\n        lame_set_brate(s->gfp, 0);\n\n        lame_set_VBR(s->gfp, vbr_default);\n\n        lame_set_VBR_quality(s->gfp, avctx->global_quality/(float)FF_QP2LAMBDA);\n\n    }\n\n    lame_set_bWriteVbrTag(s->gfp,0);\n\n    lame_set_disable_reservoir(s->gfp, avctx->flags2 & CODEC_FLAG2_BIT_RESERVOIR ? 0 : 1);\n\n    if (lame_init_params(s->gfp) < 0)\n\n        goto err_close;\n\n\n\n    avctx->frame_size = lame_get_framesize(s->gfp);\n\n\n\n    avctx->coded_frame= avcodec_alloc_frame();\n\n    avctx->coded_frame->key_frame= 1;\n\n\n\n    return 0;\n\n\n\nerr_close:\n\n    lame_close(s->gfp);\n\nerr:\n\n    return -1;\n\n}\n", "idx": 18756}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "size_t qsb_get_length(const QEMUSizedBuffer *qsb)\n\n{\n\n    return qsb->used;\n\n}\n", "idx": 18955}
{"project": "FFmpeg", "commit_id": "b69b43e2c471c4febbffaf313875396256b6a51e", "target": 1, "func": "static int transcode_subtitles(InputStream *ist, AVPacket *pkt, int *got_output)\n\n{\n\n    AVSubtitle subtitle;\n\n    int i, ret = avcodec_decode_subtitle2(ist->dec_ctx,\n\n                                          &subtitle, got_output, pkt);\n\n\n\n    check_decode_result(got_output, ret);\n\n\n\n    if (ret < 0 || !*got_output) {\n\n        if (!pkt->size)\n\n            sub2video_flush(ist);\n\n        return ret;\n\n    }\n\n\n\n    if (ist->fix_sub_duration) {\n\n        int end = 1;\n\n        if (ist->prev_sub.got_output) {\n\n            end = av_rescale(subtitle.pts - ist->prev_sub.subtitle.pts,\n\n                             1000, AV_TIME_BASE);\n\n            if (end < ist->prev_sub.subtitle.end_display_time) {\n\n                av_log(ist->dec_ctx, AV_LOG_DEBUG,\n\n                       \"Subtitle duration reduced from %d to %d%s\\n\",\n\n                       ist->prev_sub.subtitle.end_display_time, end,\n\n                       end <= 0 ? \", dropping it\" : \"\");\n\n                ist->prev_sub.subtitle.end_display_time = end;\n\n            }\n\n        }\n\n        FFSWAP(int,        *got_output, ist->prev_sub.got_output);\n\n        FFSWAP(int,        ret,         ist->prev_sub.ret);\n\n        FFSWAP(AVSubtitle, subtitle,    ist->prev_sub.subtitle);\n\n        if (end <= 0)\n\n            goto out;\n\n    }\n\n\n\n    if (!*got_output)\n\n        return ret;\n\n\n\n    sub2video_update(ist, &subtitle);\n\n\n\n    if (!subtitle.num_rects)\n\n        goto out;\n\n\n\n    ist->frames_decoded++;\n\n\n\n    for (i = 0; i < nb_output_streams; i++) {\n\n        OutputStream *ost = output_streams[i];\n\n\n\n        if (!check_output_constraints(ist, ost) || !ost->encoding_needed\n\n            || ost->enc->type != AVMEDIA_TYPE_SUBTITLE)\n\n            continue;\n\n\n\n        do_subtitle_out(output_files[ost->file_index]->ctx, ost, ist, &subtitle);\n\n    }\n\n\n\nout:\n\n    avsubtitle_free(&subtitle);\n\n    return ret;\n\n}\n", "idx": 19051}
{"project": "qemu", "commit_id": "fe40e627c51e38922b64b02b6163aea4b6aad896", "target": 0, "func": "static void object_set_link_property(Object *obj, Visitor *v, void *opaque,\n\n                                     const char *name, Error **errp)\n\n{\n\n    Object **child = opaque;\n\n    bool ambiguous = false;\n\n    const char *type;\n\n    char *path;\n\n\n\n    type = object_property_get_type(obj, name, NULL);\n\n\n\n    visit_type_str(v, &path, name, errp);\n\n\n\n    if (*child) {\n\n        object_unref(*child);\n\n    }\n\n\n\n    if (strcmp(path, \"\") != 0) {\n\n        Object *target;\n\n\n\n        target = object_resolve_path(path, &ambiguous);\n\n        if (target) {\n\n            gchar *target_type;\n\n\n\n            target_type = g_strdup_printf(\"link<%s>\",\n\n                                          object_get_typename(OBJECT(target)));\n\n            if (strcmp(target_type, type) == 0) {\n\n                *child = target;\n\n                object_ref(target);\n\n            } else {\n\n                error_set(errp, QERR_INVALID_PARAMETER_TYPE, name, type);\n\n            }\n\n\n\n            g_free(target_type);\n\n        } else {\n\n            error_set(errp, QERR_DEVICE_NOT_FOUND, path);\n\n        }\n\n    } else {\n\n        *child = NULL;\n\n    }\n\n\n\n    g_free(path);\n\n}\n", "idx": 19181}
{"project": "qemu", "commit_id": "88affa1c77c9019f3450f851495997897bd14e40", "target": 1, "func": "static void do_info_trace(Monitor *mon)\n\n{\n\n    st_print_trace((FILE *)mon, &monitor_fprintf);\n\n}\n", "idx": 19213}
{"project": "qemu", "commit_id": "444bc908611ccaf4512dc37c33ac3b54d873a62b", "target": 1, "func": "static void scsi_unmap_complete(void *opaque, int ret)\n\n{\n\n    UnmapCBData *data = opaque;\n\n    SCSIDiskReq *r = data->r;\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n    uint64_t sector_num;\n\n    uint32_t nb_sectors;\n\n\n\n    r->req.aiocb = NULL;\n\n    if (ret < 0) {\n\n        if (scsi_handle_rw_error(r, -ret)) {\n\n            goto done;\n\n        }\n\n    }\n\n\n\n    if (data->count > 0 && !r->req.io_canceled) {\n\n        sector_num = ldq_be_p(&data->inbuf[0]);\n\n        nb_sectors = ldl_be_p(&data->inbuf[8]) & 0xffffffffULL;\n\n        if (sector_num > sector_num + nb_sectors ||\n\n            sector_num + nb_sectors - 1 > s->qdev.max_lba) {\n\n            scsi_check_condition(r, SENSE_CODE(LBA_OUT_OF_RANGE));\n\n            goto done;\n\n        }\n\n\n\n        r->req.aiocb = bdrv_aio_discard(s->qdev.conf.bs,\n\n                                        sector_num * (s->qdev.blocksize / 512),\n\n                                        nb_sectors * (s->qdev.blocksize / 512),\n\n                                        scsi_unmap_complete, data);\n\n        data->count--;\n\n        data->inbuf += 16;\n\n        return;\n\n    }\n\n\n\ndone:\n\n    if (data->count == 0) {\n\n        scsi_req_complete(&r->req, GOOD);\n\n    }\n\n    if (!r->req.io_canceled) {\n\n        scsi_req_unref(&r->req);\n\n    }\n\n    g_free(data);\n\n}\n", "idx": 19227}
{"project": "qemu", "commit_id": "5c843af22604edecda10d4bb89d4eede9e1bd3d0", "target": 1, "func": "int net_init_slirp(const Netdev *netdev, const char *name,\n\n                   NetClientState *peer, Error **errp)\n\n{\n\n    /* FIXME error_setg(errp, ...) on failure */\n\n    struct slirp_config_str *config;\n\n    char *vnet;\n\n    int ret;\n\n    const NetdevUserOptions *user;\n\n    const char **dnssearch;\n\n    bool ipv4 = true, ipv6 = true;\n\n\n\n    assert(netdev->type == NET_CLIENT_DRIVER_USER);\n\n    user = &netdev->u.user;\n\n\n\n    if ((user->has_ipv6 && user->ipv6 && !user->has_ipv4) ||\n\n        (user->has_ipv4 && !user->ipv4)) {\n\n        ipv4 = 0;\n\n    }\n\n    if ((user->has_ipv4 && user->ipv4 && !user->has_ipv6) ||\n\n        (user->has_ipv6 && !user->ipv6)) {\n\n        ipv6 = 0;\n\n    }\n\n\n\n    vnet = user->has_net ? g_strdup(user->net) :\n\n           user->has_ip  ? g_strdup_printf(\"%s/24\", user->ip) :\n\n           NULL;\n\n\n\n    dnssearch = slirp_dnssearch(user->dnssearch);\n\n\n\n    /* all optional fields are initialized to \"all bits zero\" */\n\n\n\n    net_init_slirp_configs(user->hostfwd, SLIRP_CFG_HOSTFWD);\n\n    net_init_slirp_configs(user->guestfwd, 0);\n\n\n\n    ret = net_slirp_init(peer, \"user\", name, user->q_restrict,\n\n                         ipv4, vnet, user->host,\n\n                         ipv6, user->ipv6_prefix, user->ipv6_prefixlen,\n\n                         user->ipv6_host, user->hostname, user->tftp,\n\n                         user->bootfile, user->dhcpstart,\n\n                         user->dns, user->ipv6_dns, user->smb,\n\n                         user->smbserver, dnssearch);\n\n\n\n    while (slirp_configs) {\n\n        config = slirp_configs;\n\n        slirp_configs = config->next;\n\n        g_free(config);\n\n    }\n\n\n\n    g_free(vnet);\n\n    g_free(dnssearch);\n\n\n\n    return ret;\n\n}\n", "idx": 19248}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void exynos4210_pmu_write(void *opaque, target_phys_addr_t offset,\n\n                                 uint64_t val, unsigned size)\n\n{\n\n    Exynos4210PmuState *s = (Exynos4210PmuState *)opaque;\n\n    unsigned i;\n\n    const Exynos4210PmuReg *reg_p = exynos4210_pmu_regs;\n\n\n\n    for (i = 0; i < PMU_NUM_OF_REGISTERS; i++) {\n\n        if (reg_p->offset == offset) {\n\n            PRINT_DEBUG_EXTEND(\"%s <0x%04x> <- 0x%04x\\n\", reg_p->name,\n\n                    (uint32_t)offset, (uint32_t)val);\n\n            s->reg[i] = val;\n\n            return;\n\n        }\n\n        reg_p++;\n\n    }\n\n    PRINT_DEBUG(\"QEMU PMU ERROR: bad write offset 0x%04x\\n\", (uint32_t)offset);\n\n}\n", "idx": 19278}
{"project": "qemu", "commit_id": "45416789e8ccced568a4984af61974adfbfa0f62", "target": 0, "func": "static int omap_validate_emiff_addr(struct omap_mpu_state_s *s,\n\n                target_phys_addr_t addr)\n\n{\n\n    return addr >= OMAP_EMIFF_BASE && addr < OMAP_EMIFF_BASE + s->sdram_size;\n\n}\n", "idx": 19281}
{"project": "FFmpeg", "commit_id": "cdfc38f43b94e8ec3a9be10de2767778946d6eb5", "target": 1, "func": "static int xa_read_packet(AVFormatContext *s,\n\n                          AVPacket *pkt)\n\n{\n\n    MaxisXADemuxContext *xa = s->priv_data;\n\n    AVStream *st = s->streams[0];\n\n    ByteIOContext *pb = s->pb;\n\n    unsigned int packet_size;\n\n    int ret;\n\n\n\n    if(xa->sent_bytes > xa->out_size)\n\n        return AVERROR(EIO);\n\n    /* 1 byte header and 14 bytes worth of samples * number channels per block */\n\n    packet_size = 15*st->codec->channels;\n\n\n\n    ret = av_get_packet(pb, pkt, packet_size);\n\n    if(ret != packet_size)\n\n        return AVERROR(EIO);\n\n\n\n    pkt->stream_index = st->index;\n\n    xa->sent_bytes += packet_size;\n\n    pkt->pts = xa->audio_frame_counter;\n\n    /* 14 bytes Samples per channel with 2 samples per byte */\n\n    xa->audio_frame_counter += 28 * st->codec->channels;\n\n\n\n    return ret;\n\n}\n", "idx": 19361}
{"project": "qemu", "commit_id": "7385aed20db5d83979f683b9d0048674411e963c", "target": 0, "func": "static inline void gen_op_fcmps(int fccno, TCGv_i32 r_rs1, TCGv_i32 r_rs2)\n\n{\n\n    switch (fccno) {\n\n    case 0:\n\n        gen_helper_fcmps(cpu_env, r_rs1, r_rs2);\n\n        break;\n\n    case 1:\n\n        gen_helper_fcmps_fcc1(cpu_env, r_rs1, r_rs2);\n\n        break;\n\n    case 2:\n\n        gen_helper_fcmps_fcc2(cpu_env, r_rs1, r_rs2);\n\n        break;\n\n    case 3:\n\n        gen_helper_fcmps_fcc3(cpu_env, r_rs1, r_rs2);\n\n        break;\n\n    }\n\n}\n", "idx": 19480}
{"project": "qemu", "commit_id": "4f2d3d705c1ae7dce29254e2c4645c84e77a74d4", "target": 0, "func": "void qdev_prop_set_defaults(DeviceState *dev, Property *props)\n\n{\n\n    if (!props)\n\n        return;\n\n    while (props->name) {\n\n        if (props->defval) {\n\n            qdev_prop_cpy(dev, props, props->defval);\n\n        }\n\n        props++;\n\n    }\n\n}\n", "idx": 19520}
{"project": "qemu", "commit_id": "9f1d4b1d6939d39fe570d886f6a651f4764bcbcb", "target": 0, "func": "static uint32_t openpic_iack(OpenPICState *opp, IRQDest *dst, int cpu)\n\n{\n\n    IRQSource *src;\n\n    int retval, irq;\n\n\n\n    DPRINTF(\"Lower OpenPIC INT output\\n\");\n\n    qemu_irq_lower(dst->irqs[OPENPIC_OUTPUT_INT]);\n\n\n\n    irq = IRQ_get_next(opp, &dst->raised);\n\n    DPRINTF(\"IACK: irq=%d\\n\", irq);\n\n\n\n    if (irq == -1) {\n\n        /* No more interrupt pending */\n\n        return opp->spve;\n\n    }\n\n\n\n    src = &opp->src[irq];\n\n    if (!(src->ivpr & IVPR_ACTIVITY_MASK) ||\n\n            !(IVPR_PRIORITY(src->ivpr) > dst->ctpr)) {\n\n        /* - Spurious level-sensitive IRQ\n\n         * - Priorities has been changed\n\n         *   and the pending IRQ isn't allowed anymore\n\n         */\n\n        src->ivpr &= ~IVPR_ACTIVITY_MASK;\n\n        retval = opp->spve;\n\n    } else {\n\n        /* IRQ enter servicing state */\n\n        IRQ_setbit(&dst->servicing, irq);\n\n        retval = IVPR_VECTOR(opp, src->ivpr);\n\n    }\n\n    IRQ_resetbit(&dst->raised, irq);\n\n    if (!src->level) {\n\n        /* edge-sensitive IRQ */\n\n        src->ivpr &= ~IVPR_ACTIVITY_MASK;\n\n        src->pending = 0;\n\n    }\n\n\n\n    if ((irq >= opp->irq_ipi0) &&  (irq < (opp->irq_ipi0 + MAX_IPI))) {\n\n        src->idr &= ~(1 << cpu);\n\n        if (src->idr && !src->level) {\n\n            /* trigger on CPUs that didn't know about it yet */\n\n            openpic_set_irq(opp, irq, 1);\n\n            openpic_set_irq(opp, irq, 0);\n\n            /* if all CPUs knew about it, set active bit again */\n\n            src->ivpr |= IVPR_ACTIVITY_MASK;\n\n        }\n\n    }\n\n\n\n    return retval;\n\n}\n", "idx": 19573}
{"project": "FFmpeg", "commit_id": "c3390fd56cf55259ea7665ecea6c8aeddf56e2fc", "target": 1, "func": "static av_cold int ra144_decode_init(AVCodecContext * avctx)\n{\n    RA144Context *ractx = avctx->priv_data;\n    ractx->avctx = avctx;\n    ractx->lpc_coef[0] = ractx->lpc_tables[0];\n    ractx->lpc_coef[1] = ractx->lpc_tables[1];\n    avctx->channels       = 1;\n    avctx->channel_layout = AV_CH_LAYOUT_MONO;\n    avctx->sample_fmt     = AV_SAMPLE_FMT_S16;\n    return 0;\n}", "idx": 19788}
{"project": "qemu", "commit_id": "f68ec8379e88502b4841a110c070e9b118d3151c", "target": 1, "func": "void ide_flush_cache(IDEState *s)\n\n{\n\n    if (s->bs == NULL) {\n\n        ide_flush_cb(s, 0);\n\n        return;\n\n    }\n\n\n\n\n    bdrv_acct_start(s->bs, &s->acct, 0, BDRV_ACCT_FLUSH);\n\n    bdrv_aio_flush(s->bs, ide_flush_cb, s);\n\n}", "idx": 19823}
{"project": "FFmpeg", "commit_id": "b7dc6f662868fbdad779c61c233b1d19d8b89d3c", "target": 1, "func": "static void RENAME(swScale)(SwsContext *c, uint8_t* srcParam[], int srcStrideParam[], int srcSliceY,\n\n             int srcSliceH, uint8_t* dstParam[], int dstStrideParam[]){\n\n\n\n\t/* load a few things into local vars to make the code more readable? and faster */\n\n\tconst int srcW= c->srcW;\n\n\tconst int dstW= c->dstW;\n\n\tconst int dstH= c->dstH;\n\n\tconst int chrDstW= c->chrDstW;\n\n\tconst int lumXInc= c->lumXInc;\n\n\tconst int chrXInc= c->chrXInc;\n\n\tconst int dstFormat= c->dstFormat;\n\n\tconst int flags= c->flags;\n\n\tconst int canMMX2BeUsed= c->canMMX2BeUsed;\n\n\tint16_t *vLumFilterPos= c->vLumFilterPos;\n\n\tint16_t *vChrFilterPos= c->vChrFilterPos;\n\n\tint16_t *hLumFilterPos= c->hLumFilterPos;\n\n\tint16_t *hChrFilterPos= c->hChrFilterPos;\n\n\tint16_t *vLumFilter= c->vLumFilter;\n\n\tint16_t *vChrFilter= c->vChrFilter;\n\n\tint16_t *hLumFilter= c->hLumFilter;\n\n\tint16_t *hChrFilter= c->hChrFilter;\n\n\tint16_t *lumMmxFilter= c->lumMmxFilter;\n\n\tint16_t *chrMmxFilter= c->chrMmxFilter;\n\n\tconst int vLumFilterSize= c->vLumFilterSize;\n\n\tconst int vChrFilterSize= c->vChrFilterSize;\n\n\tconst int hLumFilterSize= c->hLumFilterSize;\n\n\tconst int hChrFilterSize= c->hChrFilterSize;\n\n\tint16_t **lumPixBuf= c->lumPixBuf;\n\n\tint16_t **chrPixBuf= c->chrPixBuf;\n\n\tconst int vLumBufSize= c->vLumBufSize;\n\n\tconst int vChrBufSize= c->vChrBufSize;\n\n\tuint8_t *funnyYCode= c->funnyYCode;\n\n\tuint8_t *funnyUVCode= c->funnyUVCode;\n\n\tuint8_t *formatConvBuffer= c->formatConvBuffer;\n\n\n\n\t/* vars whch will change and which we need to storw back in the context */\n\n\tint dstY= c->dstY;\n\n\tint lumBufIndex= c->lumBufIndex;\n\n\tint chrBufIndex= c->chrBufIndex;\n\n\tint lastInLumBuf= c->lastInLumBuf;\n\n\tint lastInChrBuf= c->lastInChrBuf;\n\n\tint srcStride[3];\n\n\tint dstStride[3];\n\n\tuint8_t *src[3];\n\n\tuint8_t *dst[3];\n\n\t\n\n\tif(c->srcFormat == IMGFMT_I420){\n\n\t\tsrc[0]= srcParam[0];\n\n\t\tsrc[1]= srcParam[2];\n\n\t\tsrc[2]= srcParam[1];\n\n\t\tsrcStride[0]= srcStrideParam[0];\n\n\t\tsrcStride[1]= srcStrideParam[2];\n\n\t\tsrcStride[2]= srcStrideParam[1];\n\n\t}\n\n\telse if(c->srcFormat==IMGFMT_YV12){\n\n\t\tsrc[0]= srcParam[0];\n\n\t\tsrc[1]= srcParam[1];\n\n\t\tsrc[2]= srcParam[2];\n\n\t\tsrcStride[0]= srcStrideParam[0];\n\n\t\tsrcStride[1]= srcStrideParam[1];\n\n\t\tsrcStride[2]= srcStrideParam[2];\n\n\t}\n\n\telse if(isPacked(c->srcFormat)){\n\n\t\tsrc[0]=\n\n\t\tsrc[1]=\n\n\t\tsrc[2]= srcParam[0];\n\n\t\tsrcStride[0]= srcStrideParam[0];\n\n\t\tsrcStride[1]=\n\n\t\tsrcStride[2]= srcStrideParam[0]<<1;\n\n\t}\n\n\telse if(isGray(c->srcFormat)){\n\n\t\tsrc[0]= srcParam[0];\n\n\t\tsrc[1]=\n\n\t\tsrc[2]= NULL;\n\n\t\tsrcStride[0]= srcStrideParam[0];\n\n\t\tsrcStride[1]=\n\n\t\tsrcStride[2]= 0;\n\n\t}\n\n\n\n\tif(dstFormat == IMGFMT_I420){\n\n\t\tdst[0]= dstParam[0];\n\n\t\tdst[1]= dstParam[2];\n\n\t\tdst[2]= dstParam[1];\n\n\t\tdstStride[0]= dstStrideParam[0];\n\n\t\tdstStride[1]= dstStrideParam[2];\n\n\t\tdstStride[2]= dstStrideParam[1];\n\n\t}else{\n\n\t\tdst[0]= dstParam[0];\n\n\t\tdst[1]= dstParam[1];\n\n\t\tdst[2]= dstParam[2];\n\n\t\tdstStride[0]= dstStrideParam[0];\n\n\t\tdstStride[1]= dstStrideParam[1];\n\n\t\tdstStride[2]= dstStrideParam[2];\n\n\t}\n\n\n\n//printf(\"sws Strides:%d %d %d -> %d %d %d\\n\", srcStride[0],srcStride[1],srcStride[2],\n\n//dstStride[0],dstStride[1],dstStride[2]);\n\n\n\n\tif(dstStride[0]%8 !=0 || dstStride[1]%8 !=0 || dstStride[2]%8 !=0)\n\n\t{\n\n\t\tstatic int firstTime=1; //FIXME move this into the context perhaps\n\n\t\tif(flags & SWS_PRINT_INFO && firstTime)\n\n\t\t{\n\n\t\t\tfprintf(stderr, \"SwScaler: Warning: dstStride is not aligned!\\n\"\n\n\t\t\t\t\t\"SwScaler:          ->cannot do aligned memory acesses anymore\\n\");\n\n\t\t\tfirstTime=0;\n\n\t\t}\n\n\t}\n\n\n\n\t/* Note the user might start scaling the picture in the middle so this will not get executed\n\n\t   this is not really intended but works currently, so ppl might do it */\n\n\tif(srcSliceY ==0){\n\n\t\tlumBufIndex=0;\n\n\t\tchrBufIndex=0;\n\n\t\tdstY=0;\t\n\n\t\tlastInLumBuf= -1;\n\n\t\tlastInChrBuf= -1;\n\n\t}\n\n\n\n\tfor(;dstY < dstH; dstY++){\n\n\t\tunsigned char *dest =dst[0]+dstStride[0]*dstY;\n\n\t\tunsigned char *uDest=dst[1]+dstStride[1]*(dstY>>1);\n\n\t\tunsigned char *vDest=dst[2]+dstStride[2]*(dstY>>1);\n\n\t\tconst int chrDstY= isHalfChrV(dstFormat) ? (dstY>>1) : dstY;\n\n\n\n\t\tconst int firstLumSrcY= vLumFilterPos[dstY]; //First line needed as input\n\n\t\tconst int firstChrSrcY= vChrFilterPos[chrDstY]; //First line needed as input\n\n\t\tconst int lastLumSrcY= firstLumSrcY + vLumFilterSize -1; // Last line needed as input\n\n\t\tconst int lastChrSrcY= firstChrSrcY + vChrFilterSize -1; // Last line needed as input\n\n\n\n\t\t//handle holes (FAST_BILINEAR & weird filters)\n\n\t\tif(firstLumSrcY > lastInLumBuf) lastInLumBuf= firstLumSrcY-1;\n\n\t\tif(firstChrSrcY > lastInChrBuf) lastInChrBuf= firstChrSrcY-1;\n\n//printf(\"%d %d %d\\n\", firstChrSrcY, lastInChrBuf, vChrBufSize);\n\n\t\tASSERT(firstLumSrcY >= lastInLumBuf - vLumBufSize + 1)\n\n\t\tASSERT(firstChrSrcY >= lastInChrBuf - vChrBufSize + 1)\n\n\n\n\t\t// Do we have enough lines in this slice to output the dstY line\n\n\t\tif(lastLumSrcY < srcSliceY + srcSliceH && lastChrSrcY < ((srcSliceY + srcSliceH + 1)>>1))\n\n\t\t{\n\n\t\t\t//Do horizontal scaling\n\n\t\t\twhile(lastInLumBuf < lastLumSrcY)\n\n\t\t\t{\n\n\t\t\t\tuint8_t *s= src[0]+(lastInLumBuf + 1 - srcSliceY)*srcStride[0];\n\n\t\t\t\tlumBufIndex++;\n\n//\t\t\t\tprintf(\"%d %d %d %d\\n\", lumBufIndex, vLumBufSize, lastInLumBuf,  lastLumSrcY);\n\n\t\t\t\tASSERT(lumBufIndex < 2*vLumBufSize)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY < srcSliceH)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY >= 0)\n\n//\t\t\t\tprintf(\"%d %d\\n\", lumBufIndex, vLumBufSize);\n\n\t\t\t\tRENAME(hyscale)(lumPixBuf[ lumBufIndex ], dstW, s, srcW, lumXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hLumFilter, hLumFilterPos, hLumFilterSize,\n\n\t\t\t\t\t\tfunnyYCode, c->srcFormat, formatConvBuffer);\n\n\t\t\t\tlastInLumBuf++;\n\n\t\t\t}\n\n\t\t\twhile(lastInChrBuf < lastChrSrcY)\n\n\t\t\t{\n\n\t\t\t\tuint8_t *src1= src[1]+(lastInChrBuf + 1 - (srcSliceY>>1))*srcStride[1];\n\n\t\t\t\tuint8_t *src2= src[2]+(lastInChrBuf + 1 - (srcSliceY>>1))*srcStride[2];\n\n\t\t\t\tchrBufIndex++;\n\n\t\t\t\tASSERT(chrBufIndex < 2*vChrBufSize)\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - (srcSliceY>>1) < ((srcSliceH+1)>>1))\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - (srcSliceY>>1) >= 0)\n\n\t\t\t\t//FIXME replace parameters through context struct (some at least)\n\n\t\t\t\tRENAME(hcscale)(chrPixBuf[ chrBufIndex ], chrDstW, src1, src2, (srcW+1)>>1, chrXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hChrFilter, hChrFilterPos, hChrFilterSize,\n\n\t\t\t\t\t\tfunnyUVCode, c->srcFormat, formatConvBuffer);\n\n\t\t\t\tlastInChrBuf++;\n\n\t\t\t}\n\n\t\t\t//wrap buf index around to stay inside the ring buffer\n\n\t\t\tif(lumBufIndex >= vLumBufSize ) lumBufIndex-= vLumBufSize;\n\n\t\t\tif(chrBufIndex >= vChrBufSize ) chrBufIndex-= vChrBufSize;\n\n\t\t}\n\n\t\telse // not enough lines left in this slice -> load the rest in the buffer\n\n\t\t{\n\n/*\t\tprintf(\"%d %d Last:%d %d LastInBuf:%d %d Index:%d %d Y:%d FSize: %d %d BSize: %d %d\\n\",\n\n\t\t\tfirstChrSrcY,firstLumSrcY,lastChrSrcY,lastLumSrcY,\n\n\t\t\tlastInChrBuf,lastInLumBuf,chrBufIndex,lumBufIndex,dstY,vChrFilterSize,vLumFilterSize,\n\n\t\t\tvChrBufSize, vLumBufSize);\n\n*/\n\n\t\t\t//Do horizontal scaling\n\n\t\t\twhile(lastInLumBuf+1 < srcSliceY + srcSliceH)\n\n\t\t\t{\n\n\t\t\t\tuint8_t *s= src[0]+(lastInLumBuf + 1 - srcSliceY)*srcStride[0];\n\n\t\t\t\tlumBufIndex++;\n\n\t\t\t\tASSERT(lumBufIndex < 2*vLumBufSize)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY < srcSliceH)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY >= 0)\n\n\t\t\t\tRENAME(hyscale)(lumPixBuf[ lumBufIndex ], dstW, s, srcW, lumXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hLumFilter, hLumFilterPos, hLumFilterSize,\n\n\t\t\t\t\t\tfunnyYCode, c->srcFormat, formatConvBuffer);\n\n\t\t\t\tlastInLumBuf++;\n\n\t\t\t}\n\n\t\t\twhile(lastInChrBuf+1 < ((srcSliceY + srcSliceH)>>1))\n\n\t\t\t{\n\n\t\t\t\tuint8_t *src1= src[1]+(lastInChrBuf + 1 - (srcSliceY>>1))*srcStride[1];\n\n\t\t\t\tuint8_t *src2= src[2]+(lastInChrBuf + 1 - (srcSliceY>>1))*srcStride[2];\n\n\t\t\t\tchrBufIndex++;\n\n\t\t\t\tASSERT(chrBufIndex < 2*vChrBufSize)\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - (srcSliceY>>1) < ((srcSliceH+1)>>1))\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - (srcSliceY>>1) >= 0)\n\n\t\t\t\tRENAME(hcscale)(chrPixBuf[ chrBufIndex ], chrDstW, src1, src2, (srcW+1)>>1, chrXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hChrFilter, hChrFilterPos, hChrFilterSize,\n\n\t\t\t\t\t\tfunnyUVCode, c->srcFormat, formatConvBuffer);\n\n\t\t\t\tlastInChrBuf++;\n\n\t\t\t}\n\n\t\t\t//wrap buf index around to stay inside the ring buffer\n\n\t\t\tif(lumBufIndex >= vLumBufSize ) lumBufIndex-= vLumBufSize;\n\n\t\t\tif(chrBufIndex >= vChrBufSize ) chrBufIndex-= vChrBufSize;\n\n\t\t\tbreak; //we cant output a dstY line so lets try with the next slice\n\n\t\t}\n\n\n\n#ifdef HAVE_MMX\n\n\t\tb5Dither= dither8[dstY&1];\n\n\t\tg6Dither= dither4[dstY&1];\n\n\t\tg5Dither= dither8[dstY&1];\n\n\t\tr5Dither= dither8[(dstY+1)&1];\n\n#endif\n\n\t    if(dstY < dstH-2)\n\n\t    {\n\n\t\tif(isPlanarYUV(dstFormat)) //YV12 like\n\n\t\t{\n\n\t\t\tif(dstY&1) uDest=vDest= NULL; //FIXME split functions in lumi / chromi\n\n\t\t\tif(vLumFilterSize == 1 && vChrFilterSize == 1) // Unscaled YV12\n\n\t\t\t{\n\n\t\t\t\tint16_t *lumBuf = lumPixBuf[0];\n\n\t\t\t\tint16_t *chrBuf= chrPixBuf[0];\n\n\t\t\t\tRENAME(yuv2yuv1)(lumBuf, chrBuf, dest, uDest, vDest, dstW);\n\n\t\t\t}\n\n\t\t\telse //General YV12\n\n\t\t\t{\n\n\t\t\t\tint16_t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;\n\n\t\t\t\tint16_t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;\n\n\t\t\t\tRENAME(yuv2yuvX)(\n\n\t\t\t\t\tvLumFilter+dstY*vLumFilterSize     , lumSrcPtr, vLumFilterSize,\n\n\t\t\t\t\tvChrFilter+(dstY>>1)*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\t\tdest, uDest, vDest, dstW,\n\n\t\t\t\t\tlumMmxFilter+dstY*vLumFilterSize*4, chrMmxFilter+(dstY>>1)*vChrFilterSize*4);\n\n\t\t\t}\n\n\t\t}\n\n\t\telse\n\n\t\t{\n\n\t\t\tint16_t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;\n\n\t\t\tint16_t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;\n\n\n\n\t\t\tASSERT(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2);\n\n\t\t\tASSERT(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2);\n\n\t\t\tif(vLumFilterSize == 1 && vChrFilterSize == 2) //Unscaled RGB\n\n\t\t\t{\n\n\t\t\t\tint chrAlpha= vChrFilter[2*dstY+1];\n\n\n\n\t\t\t\tRENAME(yuv2rgb1)(*lumSrcPtr, *chrSrcPtr, *(chrSrcPtr+1),\n\n\t\t\t\t\t\t dest, dstW, chrAlpha, dstFormat, flags);\n\n\t\t\t}\n\n\t\t\telse if(vLumFilterSize == 2 && vChrFilterSize == 2) //BiLinear Upscale RGB\n\n\t\t\t{\n\n\t\t\t\tint lumAlpha= vLumFilter[2*dstY+1];\n\n\t\t\t\tint chrAlpha= vChrFilter[2*dstY+1];\n\n\n\n\t\t\t\tRENAME(yuv2rgb2)(*lumSrcPtr, *(lumSrcPtr+1), *chrSrcPtr, *(chrSrcPtr+1),\n\n\t\t\t\t\t\t dest, dstW, lumAlpha, chrAlpha, dstFormat, flags);\n\n\t\t\t}\n\n\t\t\telse //General RGB\n\n\t\t\t{\n\n\t\t\t\tRENAME(yuv2rgbX)(\n\n\t\t\t\t\tvLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize,\n\n\t\t\t\t\tvChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\t\tdest, dstW, dstFormat,\n\n\t\t\t\t\tlumMmxFilter+dstY*vLumFilterSize*4, chrMmxFilter+dstY*vChrFilterSize*4);\n\n\t\t\t}\n\n\t\t}\n\n            }\n\n\t    else // hmm looks like we cant use MMX here without overwriting this arrays tail\n\n\t    {\n\n\t\tint16_t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;\n\n\t\tint16_t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;\n\n\t\tif(isPlanarYUV(dstFormat)) //YV12\n\n\t\t{\n\n\t\t\tif(dstY&1) uDest=vDest= NULL; //FIXME split functions in lumi / chromi\n\n\t\t\tyuv2yuvXinC(\n\n\t\t\t\tvLumFilter+dstY*vLumFilterSize     , lumSrcPtr, vLumFilterSize,\n\n\t\t\t\tvChrFilter+(dstY>>1)*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\tdest, uDest, vDest, dstW);\n\n\t\t}\n\n\t\telse\n\n\t\t{\n\n\t\t\tASSERT(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2);\n\n\t\t\tASSERT(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2);\n\n\t\t\tyuv2rgbXinC(\n\n\t\t\t\tvLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize,\n\n\t\t\t\tvChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\tdest, dstW, dstFormat);\n\n\t\t}\n\n\t    }\n\n\t}\n\n\n\n#ifdef HAVE_MMX\n\n\t__asm __volatile(SFENCE:::\"memory\");\n\n\t__asm __volatile(EMMS:::\"memory\");\n\n#endif\n\n\t/* store changed local vars back in the context */\n\n\tc->dstY= dstY;\n\n\tc->lumBufIndex= lumBufIndex;\n\n\tc->chrBufIndex= chrBufIndex;\n\n\tc->lastInLumBuf= lastInLumBuf;\n\n\tc->lastInChrBuf= lastInChrBuf;\n\n}\n", "idx": 19864}
{"project": "FFmpeg", "commit_id": "a3145d0335b04d143c26832c91dcc7242c758206", "target": 0, "func": "static av_cold int bmv_aud_decode_init(AVCodecContext *avctx)\n\n{\n\n    BMVAudioDecContext *c = avctx->priv_data;\n\n\n\n    if (avctx->channels != 2) {\n\n        av_log(avctx, AV_LOG_INFO, \"invalid number of channels\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    avctx->sample_fmt = AV_SAMPLE_FMT_S16;\n\n\n\n    avcodec_get_frame_defaults(&c->frame);\n\n    avctx->coded_frame = &c->frame;\n\n\n\n    return 0;\n\n}\n", "idx": 19919}
{"project": "qemu", "commit_id": "02b07434bed8360715198b4cbfdfebd17f7cac32", "target": 0, "func": "static int pxb_bus_num(PCIBus *bus)\n\n{\n\n    PXBDev *pxb = PXB_DEV(bus->parent_dev);\n\n\n\n    return pxb->bus_nr;\n\n}\n", "idx": 19949}
{"project": "qemu", "commit_id": "1208d7dd5fddc1fbd98de800d17429b4e5578848", "target": 0, "func": "void tcg_optimize(TCGContext *s)\n\n{\n\n    int oi, oi_next, nb_temps, nb_globals;\n\n\n\n    /* Array VALS has an element for each temp.\n\n       If this temp holds a constant then its value is kept in VALS' element.\n\n       If this temp is a copy of other ones then the other copies are\n\n       available through the doubly linked circular list. */\n\n\n\n    nb_temps = s->nb_temps;\n\n    nb_globals = s->nb_globals;\n\n    reset_all_temps(nb_temps);\n\n\n\n    for (oi = s->gen_first_op_idx; oi >= 0; oi = oi_next) {\n\n        tcg_target_ulong mask, partmask, affected;\n\n        int nb_oargs, nb_iargs, i;\n\n        TCGArg tmp;\n\n\n\n        TCGOp * const op = &s->gen_op_buf[oi];\n\n        TCGArg * const args = &s->gen_opparam_buf[op->args];\n\n        TCGOpcode opc = op->opc;\n\n        const TCGOpDef *def = &tcg_op_defs[opc];\n\n\n\n        oi_next = op->next;\n\n        if (opc == INDEX_op_call) {\n\n            nb_oargs = op->callo;\n\n            nb_iargs = op->calli;\n\n        } else {\n\n            nb_oargs = def->nb_oargs;\n\n            nb_iargs = def->nb_iargs;\n\n        }\n\n\n\n        /* Do copy propagation */\n\n        for (i = nb_oargs; i < nb_oargs + nb_iargs; i++) {\n\n            if (temps[args[i]].state == TCG_TEMP_COPY) {\n\n                args[i] = find_better_copy(s, args[i]);\n\n            }\n\n        }\n\n\n\n        /* For commutative operations make constant second argument */\n\n        switch (opc) {\n\n        CASE_OP_32_64(add):\n\n        CASE_OP_32_64(mul):\n\n        CASE_OP_32_64(and):\n\n        CASE_OP_32_64(or):\n\n        CASE_OP_32_64(xor):\n\n        CASE_OP_32_64(eqv):\n\n        CASE_OP_32_64(nand):\n\n        CASE_OP_32_64(nor):\n\n        CASE_OP_32_64(muluh):\n\n        CASE_OP_32_64(mulsh):\n\n            swap_commutative(args[0], &args[1], &args[2]);\n\n            break;\n\n        CASE_OP_32_64(brcond):\n\n            if (swap_commutative(-1, &args[0], &args[1])) {\n\n                args[2] = tcg_swap_cond(args[2]);\n\n            }\n\n            break;\n\n        CASE_OP_32_64(setcond):\n\n            if (swap_commutative(args[0], &args[1], &args[2])) {\n\n                args[3] = tcg_swap_cond(args[3]);\n\n            }\n\n            break;\n\n        CASE_OP_32_64(movcond):\n\n            if (swap_commutative(-1, &args[1], &args[2])) {\n\n                args[5] = tcg_swap_cond(args[5]);\n\n            }\n\n            /* For movcond, we canonicalize the \"false\" input reg to match\n\n               the destination reg so that the tcg backend can implement\n\n               a \"move if true\" operation.  */\n\n            if (swap_commutative(args[0], &args[4], &args[3])) {\n\n                args[5] = tcg_invert_cond(args[5]);\n\n            }\n\n            break;\n\n        CASE_OP_32_64(add2):\n\n            swap_commutative(args[0], &args[2], &args[4]);\n\n            swap_commutative(args[1], &args[3], &args[5]);\n\n            break;\n\n        CASE_OP_32_64(mulu2):\n\n        CASE_OP_32_64(muls2):\n\n            swap_commutative(args[0], &args[2], &args[3]);\n\n            break;\n\n        case INDEX_op_brcond2_i32:\n\n            if (swap_commutative2(&args[0], &args[2])) {\n\n                args[4] = tcg_swap_cond(args[4]);\n\n            }\n\n            break;\n\n        case INDEX_op_setcond2_i32:\n\n            if (swap_commutative2(&args[1], &args[3])) {\n\n                args[5] = tcg_swap_cond(args[5]);\n\n            }\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n\n\n        /* Simplify expressions for \"shift/rot r, 0, a => movi r, 0\",\n\n           and \"sub r, 0, a => neg r, a\" case.  */\n\n        switch (opc) {\n\n        CASE_OP_32_64(shl):\n\n        CASE_OP_32_64(shr):\n\n        CASE_OP_32_64(sar):\n\n        CASE_OP_32_64(rotl):\n\n        CASE_OP_32_64(rotr):\n\n            if (temps[args[1]].state == TCG_TEMP_CONST\n\n                && temps[args[1]].val == 0) {\n\n                tcg_opt_gen_movi(s, op, args, args[0], 0);\n\n                continue;\n\n            }\n\n            break;\n\n        CASE_OP_32_64(sub):\n\n            {\n\n                TCGOpcode neg_op;\n\n                bool have_neg;\n\n\n\n                if (temps[args[2]].state == TCG_TEMP_CONST) {\n\n                    /* Proceed with possible constant folding. */\n\n                    break;\n\n                }\n\n                if (opc == INDEX_op_sub_i32) {\n\n                    neg_op = INDEX_op_neg_i32;\n\n                    have_neg = TCG_TARGET_HAS_neg_i32;\n\n                } else {\n\n                    neg_op = INDEX_op_neg_i64;\n\n                    have_neg = TCG_TARGET_HAS_neg_i64;\n\n                }\n\n                if (!have_neg) {\n\n                    break;\n\n                }\n\n                if (temps[args[1]].state == TCG_TEMP_CONST\n\n                    && temps[args[1]].val == 0) {\n\n                    op->opc = neg_op;\n\n                    reset_temp(args[0]);\n\n                    args[1] = args[2];\n\n                    continue;\n\n                }\n\n            }\n\n            break;\n\n        CASE_OP_32_64(xor):\n\n        CASE_OP_32_64(nand):\n\n            if (temps[args[1]].state != TCG_TEMP_CONST\n\n                && temps[args[2]].state == TCG_TEMP_CONST\n\n                && temps[args[2]].val == -1) {\n\n                i = 1;\n\n                goto try_not;\n\n            }\n\n            break;\n\n        CASE_OP_32_64(nor):\n\n            if (temps[args[1]].state != TCG_TEMP_CONST\n\n                && temps[args[2]].state == TCG_TEMP_CONST\n\n                && temps[args[2]].val == 0) {\n\n                i = 1;\n\n                goto try_not;\n\n            }\n\n            break;\n\n        CASE_OP_32_64(andc):\n\n            if (temps[args[2]].state != TCG_TEMP_CONST\n\n                && temps[args[1]].state == TCG_TEMP_CONST\n\n                && temps[args[1]].val == -1) {\n\n                i = 2;\n\n                goto try_not;\n\n            }\n\n            break;\n\n        CASE_OP_32_64(orc):\n\n        CASE_OP_32_64(eqv):\n\n            if (temps[args[2]].state != TCG_TEMP_CONST\n\n                && temps[args[1]].state == TCG_TEMP_CONST\n\n                && temps[args[1]].val == 0) {\n\n                i = 2;\n\n                goto try_not;\n\n            }\n\n            break;\n\n        try_not:\n\n            {\n\n                TCGOpcode not_op;\n\n                bool have_not;\n\n\n\n                if (def->flags & TCG_OPF_64BIT) {\n\n                    not_op = INDEX_op_not_i64;\n\n                    have_not = TCG_TARGET_HAS_not_i64;\n\n                } else {\n\n                    not_op = INDEX_op_not_i32;\n\n                    have_not = TCG_TARGET_HAS_not_i32;\n\n                }\n\n                if (!have_not) {\n\n                    break;\n\n                }\n\n                op->opc = not_op;\n\n                reset_temp(args[0]);\n\n                args[1] = args[i];\n\n                continue;\n\n            }\n\n        default:\n\n            break;\n\n        }\n\n\n\n        /* Simplify expression for \"op r, a, const => mov r, a\" cases */\n\n        switch (opc) {\n\n        CASE_OP_32_64(add):\n\n        CASE_OP_32_64(sub):\n\n        CASE_OP_32_64(shl):\n\n        CASE_OP_32_64(shr):\n\n        CASE_OP_32_64(sar):\n\n        CASE_OP_32_64(rotl):\n\n        CASE_OP_32_64(rotr):\n\n        CASE_OP_32_64(or):\n\n        CASE_OP_32_64(xor):\n\n        CASE_OP_32_64(andc):\n\n            if (temps[args[1]].state != TCG_TEMP_CONST\n\n                && temps[args[2]].state == TCG_TEMP_CONST\n\n                && temps[args[2]].val == 0) {\n\n                tcg_opt_gen_mov(s, op, args, args[0], args[1]);\n\n                continue;\n\n            }\n\n            break;\n\n        CASE_OP_32_64(and):\n\n        CASE_OP_32_64(orc):\n\n        CASE_OP_32_64(eqv):\n\n            if (temps[args[1]].state != TCG_TEMP_CONST\n\n                && temps[args[2]].state == TCG_TEMP_CONST\n\n                && temps[args[2]].val == -1) {\n\n                tcg_opt_gen_mov(s, op, args, args[0], args[1]);\n\n                continue;\n\n            }\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n\n\n        /* Simplify using known-zero bits. Currently only ops with a single\n\n           output argument is supported. */\n\n        mask = -1;\n\n        affected = -1;\n\n        switch (opc) {\n\n        CASE_OP_32_64(ext8s):\n\n            if ((temps[args[1]].mask & 0x80) != 0) {\n\n                break;\n\n            }\n\n        CASE_OP_32_64(ext8u):\n\n            mask = 0xff;\n\n            goto and_const;\n\n        CASE_OP_32_64(ext16s):\n\n            if ((temps[args[1]].mask & 0x8000) != 0) {\n\n                break;\n\n            }\n\n        CASE_OP_32_64(ext16u):\n\n            mask = 0xffff;\n\n            goto and_const;\n\n        case INDEX_op_ext32s_i64:\n\n            if ((temps[args[1]].mask & 0x80000000) != 0) {\n\n                break;\n\n            }\n\n        case INDEX_op_ext32u_i64:\n\n            mask = 0xffffffffU;\n\n            goto and_const;\n\n\n\n        CASE_OP_32_64(and):\n\n            mask = temps[args[2]].mask;\n\n            if (temps[args[2]].state == TCG_TEMP_CONST) {\n\n        and_const:\n\n                affected = temps[args[1]].mask & ~mask;\n\n            }\n\n            mask = temps[args[1]].mask & mask;\n\n            break;\n\n\n\n        CASE_OP_32_64(andc):\n\n            /* Known-zeros does not imply known-ones.  Therefore unless\n\n               args[2] is constant, we can't infer anything from it.  */\n\n            if (temps[args[2]].state == TCG_TEMP_CONST) {\n\n                mask = ~temps[args[2]].mask;\n\n                goto and_const;\n\n            }\n\n            /* But we certainly know nothing outside args[1] may be set. */\n\n            mask = temps[args[1]].mask;\n\n            break;\n\n\n\n        case INDEX_op_sar_i32:\n\n            if (temps[args[2]].state == TCG_TEMP_CONST) {\n\n                tmp = temps[args[2]].val & 31;\n\n                mask = (int32_t)temps[args[1]].mask >> tmp;\n\n            }\n\n            break;\n\n        case INDEX_op_sar_i64:\n\n            if (temps[args[2]].state == TCG_TEMP_CONST) {\n\n                tmp = temps[args[2]].val & 63;\n\n                mask = (int64_t)temps[args[1]].mask >> tmp;\n\n            }\n\n            break;\n\n\n\n        case INDEX_op_shr_i32:\n\n            if (temps[args[2]].state == TCG_TEMP_CONST) {\n\n                tmp = temps[args[2]].val & 31;\n\n                mask = (uint32_t)temps[args[1]].mask >> tmp;\n\n            }\n\n            break;\n\n        case INDEX_op_shr_i64:\n\n            if (temps[args[2]].state == TCG_TEMP_CONST) {\n\n                tmp = temps[args[2]].val & 63;\n\n                mask = (uint64_t)temps[args[1]].mask >> tmp;\n\n            }\n\n            break;\n\n\n\n        case INDEX_op_trunc_shr_i32:\n\n            mask = (uint64_t)temps[args[1]].mask >> args[2];\n\n            break;\n\n\n\n        CASE_OP_32_64(shl):\n\n            if (temps[args[2]].state == TCG_TEMP_CONST) {\n\n                tmp = temps[args[2]].val & (TCG_TARGET_REG_BITS - 1);\n\n                mask = temps[args[1]].mask << tmp;\n\n            }\n\n            break;\n\n\n\n        CASE_OP_32_64(neg):\n\n            /* Set to 1 all bits to the left of the rightmost.  */\n\n            mask = -(temps[args[1]].mask & -temps[args[1]].mask);\n\n            break;\n\n\n\n        CASE_OP_32_64(deposit):\n\n            mask = deposit64(temps[args[1]].mask, args[3], args[4],\n\n                             temps[args[2]].mask);\n\n            break;\n\n\n\n        CASE_OP_32_64(or):\n\n        CASE_OP_32_64(xor):\n\n            mask = temps[args[1]].mask | temps[args[2]].mask;\n\n            break;\n\n\n\n        CASE_OP_32_64(setcond):\n\n        case INDEX_op_setcond2_i32:\n\n            mask = 1;\n\n            break;\n\n\n\n        CASE_OP_32_64(movcond):\n\n            mask = temps[args[3]].mask | temps[args[4]].mask;\n\n            break;\n\n\n\n        CASE_OP_32_64(ld8u):\n\n            mask = 0xff;\n\n            break;\n\n        CASE_OP_32_64(ld16u):\n\n            mask = 0xffff;\n\n            break;\n\n        case INDEX_op_ld32u_i64:\n\n            mask = 0xffffffffu;\n\n            break;\n\n\n\n        CASE_OP_32_64(qemu_ld):\n\n            {\n\n                TCGMemOpIdx oi = args[nb_oargs + nb_iargs];\n\n                TCGMemOp mop = get_memop(oi);\n\n                if (!(mop & MO_SIGN)) {\n\n                    mask = (2ULL << ((8 << (mop & MO_SIZE)) - 1)) - 1;\n\n                }\n\n            }\n\n            break;\n\n\n\n        default:\n\n            break;\n\n        }\n\n\n\n        /* 32-bit ops generate 32-bit results.  For the result is zero test\n\n           below, we can ignore high bits, but for further optimizations we\n\n           need to record that the high bits contain garbage.  */\n\n        partmask = mask;\n\n        if (!(def->flags & TCG_OPF_64BIT)) {\n\n            mask |= ~(tcg_target_ulong)0xffffffffu;\n\n            partmask &= 0xffffffffu;\n\n            affected &= 0xffffffffu;\n\n        }\n\n\n\n        if (partmask == 0) {\n\n            assert(nb_oargs == 1);\n\n            tcg_opt_gen_movi(s, op, args, args[0], 0);\n\n            continue;\n\n        }\n\n        if (affected == 0) {\n\n            assert(nb_oargs == 1);\n\n            tcg_opt_gen_mov(s, op, args, args[0], args[1]);\n\n            continue;\n\n        }\n\n\n\n        /* Simplify expression for \"op r, a, 0 => movi r, 0\" cases */\n\n        switch (opc) {\n\n        CASE_OP_32_64(and):\n\n        CASE_OP_32_64(mul):\n\n        CASE_OP_32_64(muluh):\n\n        CASE_OP_32_64(mulsh):\n\n            if ((temps[args[2]].state == TCG_TEMP_CONST\n\n                && temps[args[2]].val == 0)) {\n\n                tcg_opt_gen_movi(s, op, args, args[0], 0);\n\n                continue;\n\n            }\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n\n\n        /* Simplify expression for \"op r, a, a => mov r, a\" cases */\n\n        switch (opc) {\n\n        CASE_OP_32_64(or):\n\n        CASE_OP_32_64(and):\n\n            if (temps_are_copies(args[1], args[2])) {\n\n                tcg_opt_gen_mov(s, op, args, args[0], args[1]);\n\n                continue;\n\n            }\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n\n\n        /* Simplify expression for \"op r, a, a => movi r, 0\" cases */\n\n        switch (opc) {\n\n        CASE_OP_32_64(andc):\n\n        CASE_OP_32_64(sub):\n\n        CASE_OP_32_64(xor):\n\n            if (temps_are_copies(args[1], args[2])) {\n\n                tcg_opt_gen_movi(s, op, args, args[0], 0);\n\n                continue;\n\n            }\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n\n\n        /* Propagate constants through copy operations and do constant\n\n           folding.  Constants will be substituted to arguments by register\n\n           allocator where needed and possible.  Also detect copies. */\n\n        switch (opc) {\n\n        CASE_OP_32_64(mov):\n\n            tcg_opt_gen_mov(s, op, args, args[0], args[1]);\n\n            break;\n\n        CASE_OP_32_64(movi):\n\n            tcg_opt_gen_movi(s, op, args, args[0], args[1]);\n\n            break;\n\n\n\n        CASE_OP_32_64(not):\n\n        CASE_OP_32_64(neg):\n\n        CASE_OP_32_64(ext8s):\n\n        CASE_OP_32_64(ext8u):\n\n        CASE_OP_32_64(ext16s):\n\n        CASE_OP_32_64(ext16u):\n\n        case INDEX_op_ext32s_i64:\n\n        case INDEX_op_ext32u_i64:\n\n            if (temps[args[1]].state == TCG_TEMP_CONST) {\n\n                tmp = do_constant_folding(opc, temps[args[1]].val, 0);\n\n                tcg_opt_gen_movi(s, op, args, args[0], tmp);\n\n                break;\n\n            }\n\n            goto do_default;\n\n\n\n        case INDEX_op_trunc_shr_i32:\n\n            if (temps[args[1]].state == TCG_TEMP_CONST) {\n\n                tmp = do_constant_folding(opc, temps[args[1]].val, args[2]);\n\n                tcg_opt_gen_movi(s, op, args, args[0], tmp);\n\n                break;\n\n            }\n\n            goto do_default;\n\n\n\n        CASE_OP_32_64(add):\n\n        CASE_OP_32_64(sub):\n\n        CASE_OP_32_64(mul):\n\n        CASE_OP_32_64(or):\n\n        CASE_OP_32_64(and):\n\n        CASE_OP_32_64(xor):\n\n        CASE_OP_32_64(shl):\n\n        CASE_OP_32_64(shr):\n\n        CASE_OP_32_64(sar):\n\n        CASE_OP_32_64(rotl):\n\n        CASE_OP_32_64(rotr):\n\n        CASE_OP_32_64(andc):\n\n        CASE_OP_32_64(orc):\n\n        CASE_OP_32_64(eqv):\n\n        CASE_OP_32_64(nand):\n\n        CASE_OP_32_64(nor):\n\n        CASE_OP_32_64(muluh):\n\n        CASE_OP_32_64(mulsh):\n\n        CASE_OP_32_64(div):\n\n        CASE_OP_32_64(divu):\n\n        CASE_OP_32_64(rem):\n\n        CASE_OP_32_64(remu):\n\n            if (temps[args[1]].state == TCG_TEMP_CONST\n\n                && temps[args[2]].state == TCG_TEMP_CONST) {\n\n                tmp = do_constant_folding(opc, temps[args[1]].val,\n\n                                          temps[args[2]].val);\n\n                tcg_opt_gen_movi(s, op, args, args[0], tmp);\n\n                break;\n\n            }\n\n            goto do_default;\n\n\n\n        CASE_OP_32_64(deposit):\n\n            if (temps[args[1]].state == TCG_TEMP_CONST\n\n                && temps[args[2]].state == TCG_TEMP_CONST) {\n\n                tmp = deposit64(temps[args[1]].val, args[3], args[4],\n\n                                temps[args[2]].val);\n\n                tcg_opt_gen_movi(s, op, args, args[0], tmp);\n\n                break;\n\n            }\n\n            goto do_default;\n\n\n\n        CASE_OP_32_64(setcond):\n\n            tmp = do_constant_folding_cond(opc, args[1], args[2], args[3]);\n\n            if (tmp != 2) {\n\n                tcg_opt_gen_movi(s, op, args, args[0], tmp);\n\n                break;\n\n            }\n\n            goto do_default;\n\n\n\n        CASE_OP_32_64(brcond):\n\n            tmp = do_constant_folding_cond(opc, args[0], args[1], args[2]);\n\n            if (tmp != 2) {\n\n                if (tmp) {\n\n                    reset_all_temps(nb_temps);\n\n                    op->opc = INDEX_op_br;\n\n                    args[0] = args[3];\n\n                } else {\n\n                    tcg_op_remove(s, op);\n\n                }\n\n                break;\n\n            }\n\n            goto do_default;\n\n\n\n        CASE_OP_32_64(movcond):\n\n            tmp = do_constant_folding_cond(opc, args[1], args[2], args[5]);\n\n            if (tmp != 2) {\n\n                tcg_opt_gen_mov(s, op, args, args[0], args[4-tmp]);\n\n                break;\n\n            }\n\n            goto do_default;\n\n\n\n        case INDEX_op_add2_i32:\n\n        case INDEX_op_sub2_i32:\n\n            if (temps[args[2]].state == TCG_TEMP_CONST\n\n                && temps[args[3]].state == TCG_TEMP_CONST\n\n                && temps[args[4]].state == TCG_TEMP_CONST\n\n                && temps[args[5]].state == TCG_TEMP_CONST) {\n\n                uint32_t al = temps[args[2]].val;\n\n                uint32_t ah = temps[args[3]].val;\n\n                uint32_t bl = temps[args[4]].val;\n\n                uint32_t bh = temps[args[5]].val;\n\n                uint64_t a = ((uint64_t)ah << 32) | al;\n\n                uint64_t b = ((uint64_t)bh << 32) | bl;\n\n                TCGArg rl, rh;\n\n                TCGOp *op2 = insert_op_before(s, op, INDEX_op_movi_i32, 2);\n\n                TCGArg *args2 = &s->gen_opparam_buf[op2->args];\n\n\n\n                if (opc == INDEX_op_add2_i32) {\n\n                    a += b;\n\n                } else {\n\n                    a -= b;\n\n                }\n\n\n\n                rl = args[0];\n\n                rh = args[1];\n\n                tcg_opt_gen_movi(s, op, args, rl, (int32_t)a);\n\n                tcg_opt_gen_movi(s, op2, args2, rh, (int32_t)(a >> 32));\n\n\n\n                /* We've done all we need to do with the movi.  Skip it.  */\n\n                oi_next = op2->next;\n\n                break;\n\n            }\n\n            goto do_default;\n\n\n\n        case INDEX_op_mulu2_i32:\n\n            if (temps[args[2]].state == TCG_TEMP_CONST\n\n                && temps[args[3]].state == TCG_TEMP_CONST) {\n\n                uint32_t a = temps[args[2]].val;\n\n                uint32_t b = temps[args[3]].val;\n\n                uint64_t r = (uint64_t)a * b;\n\n                TCGArg rl, rh;\n\n                TCGOp *op2 = insert_op_before(s, op, INDEX_op_movi_i32, 2);\n\n                TCGArg *args2 = &s->gen_opparam_buf[op2->args];\n\n\n\n                rl = args[0];\n\n                rh = args[1];\n\n                tcg_opt_gen_movi(s, op, args, rl, (int32_t)r);\n\n                tcg_opt_gen_movi(s, op2, args2, rh, (int32_t)(r >> 32));\n\n\n\n                /* We've done all we need to do with the movi.  Skip it.  */\n\n                oi_next = op2->next;\n\n                break;\n\n            }\n\n            goto do_default;\n\n\n\n        case INDEX_op_brcond2_i32:\n\n            tmp = do_constant_folding_cond2(&args[0], &args[2], args[4]);\n\n            if (tmp != 2) {\n\n                if (tmp) {\n\n            do_brcond_true:\n\n                    reset_all_temps(nb_temps);\n\n                    op->opc = INDEX_op_br;\n\n                    args[0] = args[5];\n\n                } else {\n\n            do_brcond_false:\n\n                    tcg_op_remove(s, op);\n\n                }\n\n            } else if ((args[4] == TCG_COND_LT || args[4] == TCG_COND_GE)\n\n                       && temps[args[2]].state == TCG_TEMP_CONST\n\n                       && temps[args[3]].state == TCG_TEMP_CONST\n\n                       && temps[args[2]].val == 0\n\n                       && temps[args[3]].val == 0) {\n\n                /* Simplify LT/GE comparisons vs zero to a single compare\n\n                   vs the high word of the input.  */\n\n            do_brcond_high:\n\n                reset_all_temps(nb_temps);\n\n                op->opc = INDEX_op_brcond_i32;\n\n                args[0] = args[1];\n\n                args[1] = args[3];\n\n                args[2] = args[4];\n\n                args[3] = args[5];\n\n            } else if (args[4] == TCG_COND_EQ) {\n\n                /* Simplify EQ comparisons where one of the pairs\n\n                   can be simplified.  */\n\n                tmp = do_constant_folding_cond(INDEX_op_brcond_i32,\n\n                                               args[0], args[2], TCG_COND_EQ);\n\n                if (tmp == 0) {\n\n                    goto do_brcond_false;\n\n                } else if (tmp == 1) {\n\n                    goto do_brcond_high;\n\n                }\n\n                tmp = do_constant_folding_cond(INDEX_op_brcond_i32,\n\n                                               args[1], args[3], TCG_COND_EQ);\n\n                if (tmp == 0) {\n\n                    goto do_brcond_false;\n\n                } else if (tmp != 1) {\n\n                    goto do_default;\n\n                }\n\n            do_brcond_low:\n\n                reset_all_temps(nb_temps);\n\n                op->opc = INDEX_op_brcond_i32;\n\n                args[1] = args[2];\n\n                args[2] = args[4];\n\n                args[3] = args[5];\n\n            } else if (args[4] == TCG_COND_NE) {\n\n                /* Simplify NE comparisons where one of the pairs\n\n                   can be simplified.  */\n\n                tmp = do_constant_folding_cond(INDEX_op_brcond_i32,\n\n                                               args[0], args[2], TCG_COND_NE);\n\n                if (tmp == 0) {\n\n                    goto do_brcond_high;\n\n                } else if (tmp == 1) {\n\n                    goto do_brcond_true;\n\n                }\n\n                tmp = do_constant_folding_cond(INDEX_op_brcond_i32,\n\n                                               args[1], args[3], TCG_COND_NE);\n\n                if (tmp == 0) {\n\n                    goto do_brcond_low;\n\n                } else if (tmp == 1) {\n\n                    goto do_brcond_true;\n\n                }\n\n                goto do_default;\n\n            } else {\n\n                goto do_default;\n\n            }\n\n            break;\n\n\n\n        case INDEX_op_setcond2_i32:\n\n            tmp = do_constant_folding_cond2(&args[1], &args[3], args[5]);\n\n            if (tmp != 2) {\n\n            do_setcond_const:\n\n                tcg_opt_gen_movi(s, op, args, args[0], tmp);\n\n            } else if ((args[5] == TCG_COND_LT || args[5] == TCG_COND_GE)\n\n                       && temps[args[3]].state == TCG_TEMP_CONST\n\n                       && temps[args[4]].state == TCG_TEMP_CONST\n\n                       && temps[args[3]].val == 0\n\n                       && temps[args[4]].val == 0) {\n\n                /* Simplify LT/GE comparisons vs zero to a single compare\n\n                   vs the high word of the input.  */\n\n            do_setcond_high:\n\n                reset_temp(args[0]);\n\n                temps[args[0]].mask = 1;\n\n                op->opc = INDEX_op_setcond_i32;\n\n                args[1] = args[2];\n\n                args[2] = args[4];\n\n                args[3] = args[5];\n\n            } else if (args[5] == TCG_COND_EQ) {\n\n                /* Simplify EQ comparisons where one of the pairs\n\n                   can be simplified.  */\n\n                tmp = do_constant_folding_cond(INDEX_op_setcond_i32,\n\n                                               args[1], args[3], TCG_COND_EQ);\n\n                if (tmp == 0) {\n\n                    goto do_setcond_const;\n\n                } else if (tmp == 1) {\n\n                    goto do_setcond_high;\n\n                }\n\n                tmp = do_constant_folding_cond(INDEX_op_setcond_i32,\n\n                                               args[2], args[4], TCG_COND_EQ);\n\n                if (tmp == 0) {\n\n                    goto do_setcond_high;\n\n                } else if (tmp != 1) {\n\n                    goto do_default;\n\n                }\n\n            do_setcond_low:\n\n                reset_temp(args[0]);\n\n                temps[args[0]].mask = 1;\n\n                op->opc = INDEX_op_setcond_i32;\n\n                args[2] = args[3];\n\n                args[3] = args[5];\n\n            } else if (args[5] == TCG_COND_NE) {\n\n                /* Simplify NE comparisons where one of the pairs\n\n                   can be simplified.  */\n\n                tmp = do_constant_folding_cond(INDEX_op_setcond_i32,\n\n                                               args[1], args[3], TCG_COND_NE);\n\n                if (tmp == 0) {\n\n                    goto do_setcond_high;\n\n                } else if (tmp == 1) {\n\n                    goto do_setcond_const;\n\n                }\n\n                tmp = do_constant_folding_cond(INDEX_op_setcond_i32,\n\n                                               args[2], args[4], TCG_COND_NE);\n\n                if (tmp == 0) {\n\n                    goto do_setcond_low;\n\n                } else if (tmp == 1) {\n\n                    goto do_setcond_const;\n\n                }\n\n                goto do_default;\n\n            } else {\n\n                goto do_default;\n\n            }\n\n            break;\n\n\n\n        case INDEX_op_call:\n\n            if (!(args[nb_oargs + nb_iargs + 1]\n\n                  & (TCG_CALL_NO_READ_GLOBALS | TCG_CALL_NO_WRITE_GLOBALS))) {\n\n                for (i = 0; i < nb_globals; i++) {\n\n                    reset_temp(i);\n\n                }\n\n            }\n\n            goto do_reset_output;\n\n\n\n        default:\n\n        do_default:\n\n            /* Default case: we know nothing about operation (or were unable\n\n               to compute the operation result) so no propagation is done.\n\n               We trash everything if the operation is the end of a basic\n\n               block, otherwise we only trash the output args.  \"mask\" is\n\n               the non-zero bits mask for the first output arg.  */\n\n            if (def->flags & TCG_OPF_BB_END) {\n\n                reset_all_temps(nb_temps);\n\n            } else {\n\n        do_reset_output:\n\n                for (i = 0; i < nb_oargs; i++) {\n\n                    reset_temp(args[i]);\n\n                    /* Save the corresponding known-zero bits mask for the\n\n                       first output argument (only one supported so far). */\n\n                    if (i == 0) {\n\n                        temps[args[i]].mask = mask;\n\n                    }\n\n                }\n\n            }\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 20077}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void l2x0_class_init(ObjectClass *klass, void *data)\n\n{\n\n    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    k->init = l2x0_priv_init;\n\n    dc->vmsd = &vmstate_l2x0;\n\n    dc->no_user = 1;\n\n    dc->props = l2x0_properties;\n\n    dc->reset = l2x0_priv_reset;\n\n}\n", "idx": 20130}
{"project": "qemu", "commit_id": "1e39d97af086d525cd0408eaa5d19783ea165906", "target": 0, "func": "static void gen_interrupt(DisasContext *s, int intno,\n\n                          target_ulong cur_eip, target_ulong next_eip)\n\n{\n\n    gen_update_cc_op(s);\n\n    gen_jmp_im(cur_eip);\n\n    gen_helper_raise_interrupt(cpu_env, tcg_const_i32(intno),\n\n                               tcg_const_i32(next_eip - cur_eip));\n\n    s->is_jmp = DISAS_TB_JUMP;\n\n}\n", "idx": 20222}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "DriveInfo *drive_init(QemuOpts *opts, void *opaque,\n\n                      int *fatal_error)\n\n{\n\n    const char *buf;\n\n    const char *file = NULL;\n\n    char devname[128];\n\n    const char *serial;\n\n    const char *mediastr = \"\";\n\n    BlockInterfaceType type;\n\n    enum { MEDIA_DISK, MEDIA_CDROM } media;\n\n    int bus_id, unit_id;\n\n    int cyls, heads, secs, translation;\n\n    BlockDriver *drv = NULL;\n\n    QEMUMachine *machine = opaque;\n\n    int max_devs;\n\n    int index;\n\n    int cache;\n\n    int aio = 0;\n\n    int bdrv_flags, onerror;\n\n    const char *devaddr;\n\n    DriveInfo *dinfo;\n\n    int snapshot = 0;\n\n\n\n    *fatal_error = 1;\n\n\n\n    translation = BIOS_ATA_TRANSLATION_AUTO;\n\n    cache = 1;\n\n\n\n    if (machine && machine->use_scsi) {\n\n        type = IF_SCSI;\n\n        max_devs = MAX_SCSI_DEVS;\n\n        pstrcpy(devname, sizeof(devname), \"scsi\");\n\n    } else {\n\n        type = IF_IDE;\n\n        max_devs = MAX_IDE_DEVS;\n\n        pstrcpy(devname, sizeof(devname), \"ide\");\n\n    }\n\n    media = MEDIA_DISK;\n\n\n\n    /* extract parameters */\n\n    bus_id  = qemu_opt_get_number(opts, \"bus\", 0);\n\n    unit_id = qemu_opt_get_number(opts, \"unit\", -1);\n\n    index   = qemu_opt_get_number(opts, \"index\", -1);\n\n\n\n    cyls  = qemu_opt_get_number(opts, \"cyls\", 0);\n\n    heads = qemu_opt_get_number(opts, \"heads\", 0);\n\n    secs  = qemu_opt_get_number(opts, \"secs\", 0);\n\n\n\n    snapshot = qemu_opt_get_bool(opts, \"snapshot\", 0);\n\n\n\n    file = qemu_opt_get(opts, \"file\");\n\n    serial = qemu_opt_get(opts, \"serial\");\n\n\n\n    if ((buf = qemu_opt_get(opts, \"if\")) != NULL) {\n\n        pstrcpy(devname, sizeof(devname), buf);\n\n        if (!strcmp(buf, \"ide\")) {\n\n\t    type = IF_IDE;\n\n            max_devs = MAX_IDE_DEVS;\n\n        } else if (!strcmp(buf, \"scsi\")) {\n\n\t    type = IF_SCSI;\n\n            max_devs = MAX_SCSI_DEVS;\n\n        } else if (!strcmp(buf, \"floppy\")) {\n\n\t    type = IF_FLOPPY;\n\n            max_devs = 0;\n\n        } else if (!strcmp(buf, \"pflash\")) {\n\n\t    type = IF_PFLASH;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"mtd\")) {\n\n\t    type = IF_MTD;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"sd\")) {\n\n\t    type = IF_SD;\n\n            max_devs = 0;\n\n        } else if (!strcmp(buf, \"virtio\")) {\n\n            type = IF_VIRTIO;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"xen\")) {\n\n\t    type = IF_XEN;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"none\")) {\n\n\t    type = IF_NONE;\n\n            max_devs = 0;\n\n\t} else {\n\n            fprintf(stderr, \"qemu: unsupported bus type '%s'\\n\", buf);\n\n            return NULL;\n\n\t}\n\n    }\n\n\n\n    if (cyls || heads || secs) {\n\n        if (cyls < 1 || cyls > 16383) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical cyls number\\n\", buf);\n\n\t    return NULL;\n\n\t}\n\n        if (heads < 1 || heads > 16) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical heads number\\n\", buf);\n\n\t    return NULL;\n\n\t}\n\n        if (secs < 1 || secs > 63) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical secs number\\n\", buf);\n\n\t    return NULL;\n\n\t}\n\n    }\n\n\n\n    if ((buf = qemu_opt_get(opts, \"trans\")) != NULL) {\n\n        if (!cyls) {\n\n            fprintf(stderr,\n\n                    \"qemu: '%s' trans must be used with cyls,heads and secs\\n\",\n\n                    buf);\n\n            return NULL;\n\n        }\n\n        if (!strcmp(buf, \"none\"))\n\n            translation = BIOS_ATA_TRANSLATION_NONE;\n\n        else if (!strcmp(buf, \"lba\"))\n\n            translation = BIOS_ATA_TRANSLATION_LBA;\n\n        else if (!strcmp(buf, \"auto\"))\n\n            translation = BIOS_ATA_TRANSLATION_AUTO;\n\n\telse {\n\n            fprintf(stderr, \"qemu: '%s' invalid translation type\\n\", buf);\n\n\t    return NULL;\n\n\t}\n\n    }\n\n\n\n    if ((buf = qemu_opt_get(opts, \"media\")) != NULL) {\n\n        if (!strcmp(buf, \"disk\")) {\n\n\t    media = MEDIA_DISK;\n\n\t} else if (!strcmp(buf, \"cdrom\")) {\n\n            if (cyls || secs || heads) {\n\n                fprintf(stderr,\n\n                        \"qemu: '%s' invalid physical CHS format\\n\", buf);\n\n\t        return NULL;\n\n            }\n\n\t    media = MEDIA_CDROM;\n\n\t} else {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid media\\n\", buf);\n\n\t    return NULL;\n\n\t}\n\n    }\n\n\n\n    if ((buf = qemu_opt_get(opts, \"cache\")) != NULL) {\n\n        if (!strcmp(buf, \"off\") || !strcmp(buf, \"none\"))\n\n            cache = 0;\n\n        else if (!strcmp(buf, \"writethrough\"))\n\n            cache = 1;\n\n        else if (!strcmp(buf, \"writeback\"))\n\n            cache = 2;\n\n        else {\n\n           fprintf(stderr, \"qemu: invalid cache option\\n\");\n\n           return NULL;\n\n        }\n\n    }\n\n\n\n#ifdef CONFIG_LINUX_AIO\n\n    if ((buf = qemu_opt_get(opts, \"aio\")) != NULL) {\n\n        if (!strcmp(buf, \"threads\"))\n\n            aio = 0;\n\n        else if (!strcmp(buf, \"native\"))\n\n            aio = 1;\n\n        else {\n\n           fprintf(stderr, \"qemu: invalid aio option\\n\");\n\n           return NULL;\n\n        }\n\n    }\n\n#endif\n\n\n\n    if ((buf = qemu_opt_get(opts, \"format\")) != NULL) {\n\n       if (strcmp(buf, \"?\") == 0) {\n\n            fprintf(stderr, \"qemu: Supported formats:\");\n\n            bdrv_iterate_format(bdrv_format_print, NULL);\n\n            fprintf(stderr, \"\\n\");\n\n\t    return NULL;\n\n        }\n\n        drv = bdrv_find_format(buf);\n\n        if (!drv) {\n\n            fprintf(stderr, \"qemu: '%s' invalid format\\n\", buf);\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    onerror = BLOCK_ERR_STOP_ENOSPC;\n\n    if ((buf = qemu_opt_get(opts, \"werror\")) != NULL) {\n\n        if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO) {\n\n            fprintf(stderr, \"werror is no supported by this format\\n\");\n\n            return NULL;\n\n        }\n\n        if (!strcmp(buf, \"ignore\"))\n\n            onerror = BLOCK_ERR_IGNORE;\n\n        else if (!strcmp(buf, \"enospc\"))\n\n            onerror = BLOCK_ERR_STOP_ENOSPC;\n\n        else if (!strcmp(buf, \"stop\"))\n\n            onerror = BLOCK_ERR_STOP_ANY;\n\n        else if (!strcmp(buf, \"report\"))\n\n            onerror = BLOCK_ERR_REPORT;\n\n        else {\n\n            fprintf(stderr, \"qemu: '%s' invalid write error action\\n\", buf);\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    if ((devaddr = qemu_opt_get(opts, \"addr\")) != NULL) {\n\n        if (type != IF_VIRTIO) {\n\n            fprintf(stderr, \"addr is not supported\\n\");\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    /* compute bus and unit according index */\n\n\n\n    if (index != -1) {\n\n        if (bus_id != 0 || unit_id != -1) {\n\n            fprintf(stderr,\n\n                    \"qemu: index cannot be used with bus and unit\\n\");\n\n            return NULL;\n\n        }\n\n        if (max_devs == 0)\n\n        {\n\n            unit_id = index;\n\n            bus_id = 0;\n\n        } else {\n\n            unit_id = index % max_devs;\n\n            bus_id = index / max_devs;\n\n        }\n\n    }\n\n\n\n    /* if user doesn't specify a unit_id,\n\n     * try to find the first free\n\n     */\n\n\n\n    if (unit_id == -1) {\n\n       unit_id = 0;\n\n       while (drive_get(type, bus_id, unit_id) != NULL) {\n\n           unit_id++;\n\n           if (max_devs && unit_id >= max_devs) {\n\n               unit_id -= max_devs;\n\n               bus_id++;\n\n           }\n\n       }\n\n    }\n\n\n\n    /* check unit id */\n\n\n\n    if (max_devs && unit_id >= max_devs) {\n\n        fprintf(stderr, \"qemu: unit %d too big (max is %d)\\n\",\n\n                unit_id, max_devs - 1);\n\n        return NULL;\n\n    }\n\n\n\n    /*\n\n     * ignore multiple definitions\n\n     */\n\n\n\n    if (drive_get(type, bus_id, unit_id) != NULL) {\n\n        *fatal_error = 0;\n\n        return NULL;\n\n    }\n\n\n\n    /* init */\n\n\n\n    dinfo = qemu_mallocz(sizeof(*dinfo));\n\n    if ((buf = qemu_opts_id(opts)) != NULL) {\n\n        dinfo->id = qemu_strdup(buf);\n\n    } else {\n\n        /* no id supplied -> create one */\n\n        dinfo->id = qemu_mallocz(32);\n\n        if (type == IF_IDE || type == IF_SCSI)\n\n            mediastr = (media == MEDIA_CDROM) ? \"-cd\" : \"-hd\";\n\n        if (max_devs)\n\n            snprintf(dinfo->id, 32, \"%s%i%s%i\",\n\n                     devname, bus_id, mediastr, unit_id);\n\n        else\n\n            snprintf(dinfo->id, 32, \"%s%s%i\",\n\n                     devname, mediastr, unit_id);\n\n    }\n\n    dinfo->bdrv = bdrv_new(dinfo->id);\n\n    dinfo->devaddr = devaddr;\n\n    dinfo->type = type;\n\n    dinfo->bus = bus_id;\n\n    dinfo->unit = unit_id;\n\n    dinfo->onerror = onerror;\n\n    dinfo->opts = opts;\n\n    if (serial)\n\n        strncpy(dinfo->serial, serial, sizeof(serial));\n\n    TAILQ_INSERT_TAIL(&drives, dinfo, next);\n\n\n\n    switch(type) {\n\n    case IF_IDE:\n\n    case IF_SCSI:\n\n    case IF_XEN:\n\n        switch(media) {\n\n\tcase MEDIA_DISK:\n\n            if (cyls != 0) {\n\n                bdrv_set_geometry_hint(dinfo->bdrv, cyls, heads, secs);\n\n                bdrv_set_translation_hint(dinfo->bdrv, translation);\n\n            }\n\n\t    break;\n\n\tcase MEDIA_CDROM:\n\n            bdrv_set_type_hint(dinfo->bdrv, BDRV_TYPE_CDROM);\n\n\t    break;\n\n\t}\n\n        break;\n\n    case IF_SD:\n\n        /* FIXME: This isn't really a floppy, but it's a reasonable\n\n           approximation.  */\n\n    case IF_FLOPPY:\n\n        bdrv_set_type_hint(dinfo->bdrv, BDRV_TYPE_FLOPPY);\n\n        break;\n\n    case IF_PFLASH:\n\n    case IF_MTD:\n\n    case IF_NONE:\n\n        break;\n\n    case IF_VIRTIO:\n\n        /* add virtio block device */\n\n        opts = qemu_opts_create(&qemu_device_opts, NULL, 0);\n\n        qemu_opt_set(opts, \"driver\", \"virtio-blk-pci\");\n\n        qemu_opt_set(opts, \"drive\", dinfo->id);\n\n        if (devaddr)\n\n            qemu_opt_set(opts, \"addr\", devaddr);\n\n        break;\n\n    case IF_COUNT:\n\n        abort();\n\n    }\n\n    if (!file) {\n\n        *fatal_error = 0;\n\n        return NULL;\n\n    }\n\n    bdrv_flags = 0;\n\n    if (snapshot) {\n\n        bdrv_flags |= BDRV_O_SNAPSHOT;\n\n        cache = 2; /* always use write-back with snapshot */\n\n    }\n\n    if (cache == 0) /* no caching */\n\n        bdrv_flags |= BDRV_O_NOCACHE;\n\n    else if (cache == 2) /* write-back */\n\n        bdrv_flags |= BDRV_O_CACHE_WB;\n\n\n\n    if (aio == 1) {\n\n        bdrv_flags |= BDRV_O_NATIVE_AIO;\n\n    } else {\n\n        bdrv_flags &= ~BDRV_O_NATIVE_AIO;\n\n    }\n\n\n\n    if (bdrv_open2(dinfo->bdrv, file, bdrv_flags, drv) < 0) {\n\n        fprintf(stderr, \"qemu: could not open disk image %s\\n\",\n\n                        file);\n\n        return NULL;\n\n    }\n\n\n\n    if (bdrv_key_required(dinfo->bdrv))\n\n        autostart = 0;\n\n    *fatal_error = 0;\n\n    return dinfo;\n\n}\n", "idx": 20288}
{"project": "FFmpeg", "commit_id": "099d6813c27faf95257a529aa2c65dfde816a487", "target": 1, "func": "int ff_h264_alloc_tables(H264Context *h){\n\n    MpegEncContext * const s = &h->s;\n\n    const int big_mb_num= s->mb_stride * (s->mb_height+1);\n\n    const int row_mb_num= 2*s->mb_stride*s->avctx->thread_count;\n\n    int x,y;\n\n\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->intra4x4_pred_mode, row_mb_num * 8  * sizeof(uint8_t), fail)\n\n\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->non_zero_count    , big_mb_num * 48 * sizeof(uint8_t), fail)\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->slice_table_base  , (big_mb_num+s->mb_stride) * sizeof(*h->slice_table_base), fail)\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->cbp_table, big_mb_num * sizeof(uint16_t), fail)\n\n\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->chroma_pred_mode_table, big_mb_num * sizeof(uint8_t), fail)\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->mvd_table[0], 16*row_mb_num * sizeof(uint8_t), fail);\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->mvd_table[1], 16*row_mb_num * sizeof(uint8_t), fail);\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->direct_table, 4*big_mb_num * sizeof(uint8_t) , fail);\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->list_counts, big_mb_num * sizeof(uint8_t), fail)\n\n\n\n    memset(h->slice_table_base, -1, (big_mb_num+s->mb_stride)  * sizeof(*h->slice_table_base));\n\n    h->slice_table= h->slice_table_base + s->mb_stride*2 + 1;\n\n\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->mb2b_xy  , big_mb_num * sizeof(uint32_t), fail);\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->mb2br_xy , big_mb_num * sizeof(uint32_t), fail);\n\n    for(y=0; y<s->mb_height; y++){\n\n        for(x=0; x<s->mb_width; x++){\n\n            const int mb_xy= x + y*s->mb_stride;\n\n            const int b_xy = 4*x + 4*y*h->b_stride;\n\n\n\n            h->mb2b_xy [mb_xy]= b_xy;\n\n            h->mb2br_xy[mb_xy]= 8*(FMO ? mb_xy : (mb_xy % (2*s->mb_stride)));\n\n        }\n\n    }\n\n\n\n    s->obmc_scratchpad = NULL;\n\n\n\n    if(!h->dequant4_coeff[0])\n\n        init_dequant_tables(h);\n\n\n\n    return 0;\n\nfail:\n\n    free_tables(h, 1);\n\n    return -1;\n\n}\n", "idx": 20305}
{"project": "qemu", "commit_id": "de9e9d9f17a36ff76c1a02a5348835e5e0a081b0", "target": 0, "func": "static inline void gen_op_eval_bgu(TCGv dst, TCGv_i32 src)\n\n{\n\n    gen_mov_reg_Z(cpu_tmp0, src);\n\n    gen_mov_reg_C(dst, src);\n\n    tcg_gen_or_tl(dst, dst, cpu_tmp0);\n\n    tcg_gen_xori_tl(dst, dst, 0x1);\n\n}\n", "idx": 20436}
{"project": "qemu", "commit_id": "ab06ec43577177a442e8e5ca28d0154efe4ff60f", "target": 0, "func": "static void test_pxe_virtio_pci(void)\n\n{\n\n    test_pxe_one(\"-device virtio-net-pci,netdev=\" NETNAME, false);\n\n}\n", "idx": 20444}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline int blah (int32_t i)\n\n{\n\n    if (i > 0x43c07fff)\n\n        return 32767;\n\n    else if (i < 0x43bf8000)\n\n        return -32768;\n\n    else\n\n        return i - 0x43c00000;\n\n}\n", "idx": 20536}
{"project": "qemu", "commit_id": "5905fbc9c94ccd744c1b249472eafcc2d827548a", "target": 0, "func": "static bool bdrv_exceed_bps_limits(BlockDriverState *bs, int nb_sectors,\n\n                 bool is_write, double elapsed_time, uint64_t *wait)\n\n{\n\n    uint64_t bps_limit = 0;\n\n    double   bytes_limit, bytes_base, bytes_res;\n\n    double   slice_time, wait_time;\n\n\n\n    if (bs->io_limits.bps[BLOCK_IO_LIMIT_TOTAL]) {\n\n        bps_limit = bs->io_limits.bps[BLOCK_IO_LIMIT_TOTAL];\n\n    } else if (bs->io_limits.bps[is_write]) {\n\n        bps_limit = bs->io_limits.bps[is_write];\n\n    } else {\n\n        if (wait) {\n\n            *wait = 0;\n\n        }\n\n\n\n        return false;\n\n    }\n\n\n\n    slice_time = bs->slice_end - bs->slice_start;\n\n    slice_time /= (NANOSECONDS_PER_SECOND);\n\n    bytes_limit = bps_limit * slice_time;\n\n    bytes_base  = bs->nr_bytes[is_write] - bs->io_base.bytes[is_write];\n\n    if (bs->io_limits.bps[BLOCK_IO_LIMIT_TOTAL]) {\n\n        bytes_base += bs->nr_bytes[!is_write] - bs->io_base.bytes[!is_write];\n\n    }\n\n\n\n    /* bytes_base: the bytes of data which have been read/written; and\n\n     *             it is obtained from the history statistic info.\n\n     * bytes_res: the remaining bytes of data which need to be read/written.\n\n     * (bytes_base + bytes_res) / bps_limit: used to calcuate\n\n     *             the total time for completing reading/writting all data.\n\n     */\n\n    bytes_res   = (unsigned) nb_sectors * BDRV_SECTOR_SIZE;\n\n\n\n    if (bytes_base + bytes_res <= bytes_limit) {\n\n        if (wait) {\n\n            *wait = 0;\n\n        }\n\n\n\n        return false;\n\n    }\n\n\n\n    /* Calc approx time to dispatch */\n\n    wait_time = (bytes_base + bytes_res) / bps_limit - elapsed_time;\n\n\n\n    /* When the I/O rate at runtime exceeds the limits,\n\n     * bs->slice_end need to be extended in order that the current statistic\n\n     * info can be kept until the timer fire, so it is increased and tuned\n\n     * based on the result of experiment.\n\n     */\n\n    bs->slice_time = wait_time * BLOCK_IO_SLICE_TIME * 10;\n\n    bs->slice_end += bs->slice_time - 3 * BLOCK_IO_SLICE_TIME;\n\n    if (wait) {\n\n        *wait = wait_time * BLOCK_IO_SLICE_TIME * 10;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 20557}
{"project": "FFmpeg", "commit_id": "5745cf799a4389bc5d14f2b4daf32fe4631c50bc", "target": 1, "func": "static int read_extra_header(FFV1Context *f)\n\n{\n\n    RangeCoder *const c = &f->c;\n\n    uint8_t state[CONTEXT_SIZE];\n\n    int i, j, k, ret;\n\n    uint8_t state2[32][CONTEXT_SIZE];\n\n    unsigned crc = 0;\n\n\n\n    memset(state2, 128, sizeof(state2));\n\n    memset(state, 128, sizeof(state));\n\n\n\n    ff_init_range_decoder(c, f->avctx->extradata, f->avctx->extradata_size);\n\n    ff_build_rac_states(c, 0.05 * (1LL << 32), 256 - 8);\n\n\n\n    f->version = get_symbol(c, state, 0);\n\n    if (f->version < 2) {\n\n        av_log(f->avctx, AV_LOG_ERROR, \"Invalid version in global header\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (f->version > 2) {\n\n        c->bytestream_end -= 4;\n\n        f->micro_version = get_symbol(c, state, 0);\n\n        if (f->micro_version < 0)\n\n            return AVERROR_INVALIDDATA;\n\n    }\n\n    f->ac = f->avctx->coder_type = get_symbol(c, state, 0);\n\n    if (f->ac > 1) {\n\n        for (i = 1; i < 256; i++)\n\n            f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];\n\n    }\n\n\n\n    f->colorspace                 = get_symbol(c, state, 0); //YUV cs type\n\n    f->avctx->bits_per_raw_sample = get_symbol(c, state, 0);\n\n    f->chroma_planes              = get_rac(c, state);\n\n    f->chroma_h_shift             = get_symbol(c, state, 0);\n\n    f->chroma_v_shift             = get_symbol(c, state, 0);\n\n    f->transparency               = get_rac(c, state);\n\n    f->plane_count                = 1 + (f->chroma_planes || f->version<4) + f->transparency;\n\n    f->num_h_slices               = 1 + get_symbol(c, state, 0);\n\n    f->num_v_slices               = 1 + get_symbol(c, state, 0);\n\n\n\n    if (f->chroma_h_shift > 4U || f->chroma_v_shift > 4U) {\n\n        av_log(f->avctx, AV_LOG_ERROR, \"chroma shift parameters %d %d are invalid\\n\",\n\n               f->chroma_h_shift, f->chroma_v_shift);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (f->num_h_slices > (unsigned)f->width  || !f->num_h_slices ||\n\n        f->num_v_slices > (unsigned)f->height || !f->num_v_slices\n\n       ) {\n\n        av_log(f->avctx, AV_LOG_ERROR, \"slice count invalid\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    f->quant_table_count = get_symbol(c, state, 0);\n\n    if (f->quant_table_count > (unsigned)MAX_QUANT_TABLES)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    for (i = 0; i < f->quant_table_count; i++) {\n\n        f->context_count[i] = read_quant_tables(c, f->quant_tables[i]);\n\n        if (f->context_count[i] < 0) {\n\n            av_log(f->avctx, AV_LOG_ERROR, \"read_quant_table error\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n    if ((ret = ff_ffv1_allocate_initial_states(f)) < 0)\n\n        return ret;\n\n\n\n    for (i = 0; i < f->quant_table_count; i++)\n\n        if (get_rac(c, state)) {\n\n            for (j = 0; j < f->context_count[i]; j++)\n\n                for (k = 0; k < CONTEXT_SIZE; k++) {\n\n                    int pred = j ? f->initial_states[i][j - 1][k] : 128;\n\n                    f->initial_states[i][j][k] =\n\n                        (pred + get_symbol(c, state2[k], 1)) & 0xFF;\n\n                }\n\n        }\n\n\n\n    if (f->version > 2) {\n\n        f->ec = get_symbol(c, state, 0);\n\n        if (f->micro_version > 2)\n\n            f->intra = get_symbol(c, state, 0);\n\n    }\n\n\n\n    if (f->version > 2) {\n\n        unsigned v;\n\n        v = av_crc(av_crc_get_table(AV_CRC_32_IEEE), 0,\n\n                   f->avctx->extradata, f->avctx->extradata_size);\n\n        if (v || f->avctx->extradata_size < 4) {\n\n            av_log(f->avctx, AV_LOG_ERROR, \"CRC mismatch %X!\\n\", v);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        crc = AV_RB32(f->avctx->extradata + f->avctx->extradata_size - 4);\n\n    }\n\n\n\n    if (f->avctx->debug & FF_DEBUG_PICT_INFO)\n\n        av_log(f->avctx, AV_LOG_DEBUG,\n\n               \"global: ver:%d.%d, coder:%d, colorspace: %d bpr:%d chroma:%d(%d:%d), alpha:%d slices:%dx%d qtabs:%d ec:%d intra:%d CRC:0x%08X\\n\",\n\n               f->version, f->micro_version,\n\n               f->ac,\n\n               f->colorspace,\n\n               f->avctx->bits_per_raw_sample,\n\n               f->chroma_planes, f->chroma_h_shift, f->chroma_v_shift,\n\n               f->transparency,\n\n               f->num_h_slices, f->num_v_slices,\n\n               f->quant_table_count,\n\n               f->ec,\n\n               f->intra,\n\n               crc\n\n              );\n\n    return 0;\n\n}\n", "idx": 20642}
{"project": "FFmpeg", "commit_id": "ecf79c4d3e8baaf2f303278ef81db6f8407656bc", "target": 1, "func": "void ff_vorbis_ready_floor1_list(vorbis_floor1_entry * list, int values)\n\n{\n\n    int i;\n\n    list[0].sort = 0;\n\n    list[1].sort = 1;\n\n    for (i = 2; i < values; i++) {\n\n        int j;\n\n        list[i].low  = 0;\n\n        list[i].high = 1;\n\n        list[i].sort = i;\n\n        for (j = 2; j < i; j++) {\n\n            int tmp = list[j].x;\n\n            if (tmp < list[i].x) {\n\n                if (tmp > list[list[i].low].x)\n\n                    list[i].low  =  j;\n\n            } else {\n\n                if (tmp < list[list[i].high].x)\n\n                    list[i].high = j;\n\n            }\n\n        }\n\n    }\n\n    for (i = 0; i < values - 1; i++) {\n\n        int j;\n\n        for (j = i + 1; j < values; j++) {\n\n            if (list[list[i].sort].x > list[list[j].sort].x) {\n\n                int tmp = list[i].sort;\n\n                list[i].sort = list[j].sort;\n\n                list[j].sort = tmp;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 20670}
{"project": "qemu", "commit_id": "3dc6f8693694a649a9c83f1e2746565b47683923", "target": 0, "func": "static int kvm_arch_set_tsc_khz(CPUState *cs)\n\n{\n\n    X86CPU *cpu = X86_CPU(cs);\n\n    CPUX86State *env = &cpu->env;\n\n    int r;\n\n\n\n    if (!env->tsc_khz) {\n\n        return 0;\n\n    }\n\n\n\n    r = kvm_check_extension(cs->kvm_state, KVM_CAP_TSC_CONTROL) ?\n\n        kvm_vcpu_ioctl(cs, KVM_SET_TSC_KHZ, env->tsc_khz) :\n\n        -ENOTSUP;\n\n    if (r < 0) {\n\n        /* When KVM_SET_TSC_KHZ fails, it's an error only if the current\n\n         * TSC frequency doesn't match the one we want.\n\n         */\n\n        int cur_freq = kvm_check_extension(cs->kvm_state, KVM_CAP_GET_TSC_KHZ) ?\n\n                       kvm_vcpu_ioctl(cs, KVM_GET_TSC_KHZ) :\n\n                       -ENOTSUP;\n\n        if (cur_freq <= 0 || cur_freq != env->tsc_khz) {\n\n            error_report(\"warning: TSC frequency mismatch between \"\n\n                         \"VM (%\" PRId64 \" kHz) and host (%d kHz), \"\n\n                         \"and TSC scaling unavailable\",\n\n                         env->tsc_khz, cur_freq);\n\n            return r;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 20744}
{"project": "qemu", "commit_id": "d1fdf257d52822695f5ace6c586e059aa17d4b79", "target": 0, "func": "static int drop_sync(QIOChannel *ioc, size_t size, Error **errp)\n\n{\n\n    ssize_t ret = 0;\n\n    char small[1024];\n\n    char *buffer;\n\n\n\n    buffer = sizeof(small) >= size ? small : g_malloc(MIN(65536, size));\n\n    while (size > 0) {\n\n        ssize_t count = MIN(65536, size);\n\n        ret = read_sync(ioc, buffer, MIN(65536, size), errp);\n\n\n\n        if (ret < 0) {\n\n            goto cleanup;\n\n        }\n\n        size -= count;\n\n    }\n\n\n\n cleanup:\n\n    if (buffer != small) {\n\n        g_free(buffer);\n\n    }\n\n    return ret;\n\n}\n", "idx": 20929}
{"project": "FFmpeg", "commit_id": "03931ecf71710452fc9e89d4f18354f0b5e05395", "target": 0, "func": "static void ssim_4x4x2_core(const uint8_t *main, int main_stride,\n\n                            const uint8_t *ref, int ref_stride,\n\n                            int sums[2][4])\n\n{\n\n    int x, y, z;\n\n\n\n    for (z = 0; z < 2; z++) {\n\n        uint32_t s1 = 0, s2 = 0, ss = 0, s12 = 0;\n\n\n\n        for (y = 0; y < 4; y++) {\n\n            for (x = 0; x < 4; x++) {\n\n                int a = main[x + y * main_stride];\n\n                int b = ref[x + y * ref_stride];\n\n\n\n                s1  += a;\n\n                s2  += b;\n\n                ss  += a*a;\n\n                ss  += b*b;\n\n                s12 += a*b;\n\n            }\n\n        }\n\n\n\n        sums[z][0] = s1;\n\n        sums[z][1] = s2;\n\n        sums[z][2] = ss;\n\n        sums[z][3] = s12;\n\n        main += 4;\n\n        ref += 4;\n\n    }\n\n}\n", "idx": 20992}
{"project": "qemu", "commit_id": "2aece63c8a9d2c3a8ff41d2febc4cdeff2633331", "target": 0, "func": "static void ivshmem_check_memdev_is_busy(Object *obj, const char *name,\n\n                                         Object *val, Error **errp)\n\n{\n\n    MemoryRegion *mr;\n\n\n\n    mr = host_memory_backend_get_memory(MEMORY_BACKEND(val), &error_abort);\n\n    if (memory_region_is_mapped(mr)) {\n\n        char *path = object_get_canonical_path_component(val);\n\n        error_setg(errp, \"can't use already busy memdev: %s\", path);\n\n        g_free(path);\n\n    } else {\n\n        qdev_prop_allow_set_link_before_realize(obj, name, val, errp);\n\n    }\n\n}\n", "idx": 20997}
{"project": "qemu", "commit_id": "fc34059f080680b560b3f656988fdd9a75cd0eab", "target": 1, "func": "static void GCC_FMT_ATTR(2, 3) qtest_sendf(CharBackend *chr,\n\n                                           const char *fmt, ...)\n\n{\n\n    va_list ap;\n\n    gchar *buffer;\n\n\n\n    va_start(ap, fmt);\n\n    buffer = g_strdup_vprintf(fmt, ap);\n\n    qtest_send(chr, buffer);\n\n\n    va_end(ap);\n\n}", "idx": 21026}
{"project": "FFmpeg", "commit_id": "01ecb7172b684f1c4b3e748f95c5a9a494ca36ec", "target": 1, "func": "struct AACISError ff_aac_is_encoding_err(AACEncContext *s, ChannelElement *cpe,\n\n                                         int start, int w, int g, float ener0,\n\n                                         float ener1, float ener01,\n\n                                         int use_pcoeffs, int phase)\n\n{\n\n    int i, w2;\n\n    SingleChannelElement *sce0 = &cpe->ch[0];\n\n    SingleChannelElement *sce1 = &cpe->ch[1];\n\n    float *L = use_pcoeffs ? sce0->pcoeffs : sce0->coeffs;\n\n    float *R = use_pcoeffs ? sce1->pcoeffs : sce1->coeffs;\n\n    float *L34 = &s->scoefs[256*0], *R34 = &s->scoefs[256*1];\n\n    float *IS  = &s->scoefs[256*2], *I34 = &s->scoefs[256*3];\n\n    float dist1 = 0.0f, dist2 = 0.0f;\n\n    struct AACISError is_error = {0};\n\n\n\n    for (w2 = 0; w2 < sce0->ics.group_len[w]; w2++) {\n\n        FFPsyBand *band0 = &s->psy.ch[s->cur_channel+0].psy_bands[(w+w2)*16+g];\n\n        FFPsyBand *band1 = &s->psy.ch[s->cur_channel+1].psy_bands[(w+w2)*16+g];\n\n        int is_band_type, is_sf_idx = FFMAX(1, sce0->sf_idx[(w+w2)*16+g]-4);\n\n        float e01_34 = phase*pow(ener1/ener0, 3.0/4.0);\n\n        float maxval, dist_spec_err = 0.0f;\n\n        float minthr = FFMIN(band0->threshold, band1->threshold);\n\n        for (i = 0; i < sce0->ics.swb_sizes[g]; i++)\n\n            IS[i] = (L[start+(w+w2)*128+i] + phase*R[start+(w+w2)*128+i])*sqrt(ener0/ener01);\n\n        abs_pow34_v(L34, &L[start+(w+w2)*128], sce0->ics.swb_sizes[g]);\n\n        abs_pow34_v(R34, &R[start+(w+w2)*128], sce0->ics.swb_sizes[g]);\n\n        abs_pow34_v(I34, IS,                   sce0->ics.swb_sizes[g]);\n\n        maxval = find_max_val(1, sce0->ics.swb_sizes[g], I34);\n\n        is_band_type = find_min_book(maxval, is_sf_idx);\n\n        dist1 += quantize_band_cost(s, &L[start + (w+w2)*128], L34,\n\n                                    sce0->ics.swb_sizes[g],\n\n                                    sce0->sf_idx[(w+w2)*16+g],\n\n                                    sce0->band_type[(w+w2)*16+g],\n\n                                    s->lambda / band0->threshold, INFINITY, NULL, 0);\n\n        dist1 += quantize_band_cost(s, &R[start + (w+w2)*128], R34,\n\n                                    sce1->ics.swb_sizes[g],\n\n                                    sce1->sf_idx[(w+w2)*16+g],\n\n                                    sce1->band_type[(w+w2)*16+g],\n\n                                    s->lambda / band1->threshold, INFINITY, NULL, 0);\n\n        dist2 += quantize_band_cost(s, IS, I34, sce0->ics.swb_sizes[g],\n\n                                    is_sf_idx, is_band_type,\n\n                                    s->lambda / minthr, INFINITY, NULL, 0);\n\n        for (i = 0; i < sce0->ics.swb_sizes[g]; i++) {\n\n            dist_spec_err += (L34[i] - I34[i])*(L34[i] - I34[i]);\n\n            dist_spec_err += (R34[i] - I34[i]*e01_34)*(R34[i] - I34[i]*e01_34);\n\n        }\n\n        dist_spec_err *= s->lambda / minthr;\n\n        dist2 += dist_spec_err;\n\n    }\n\n\n\n    is_error.pass = dist2 <= dist1;\n\n    is_error.phase = phase;\n\n    is_error.error = fabsf(dist1 - dist2);\n\n    is_error.dist1 = dist1;\n\n    is_error.dist2 = dist2;\n\n\n\n    return is_error;\n\n}\n", "idx": 21045}
{"project": "FFmpeg", "commit_id": "4ce75387cdcbcef8afbaadc5b66232c25178c0c6", "target": 1, "func": "static int read_thread(void *arg)\n\n{\n\n    VideoState *is = arg;\n\n    AVFormatContext *ic = NULL;\n\n    int err, i, ret;\n\n    int st_index[AVMEDIA_TYPE_NB];\n\n    AVPacket pkt1, *pkt = &pkt1;\n\n    int64_t stream_start_time;\n\n    int pkt_in_play_range = 0;\n\n    AVDictionaryEntry *t;\n\n    AVDictionary **opts;\n\n    int orig_nb_streams;\n\n    SDL_mutex *wait_mutex = SDL_CreateMutex();\n\n    int scan_all_pmts_set = 0;\n\n    int64_t pkt_ts;\n\n\n\n    if (!wait_mutex) {\n\n        av_log(NULL, AV_LOG_FATAL, \"SDL_CreateMutex(): %s\\n\", SDL_GetError());\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    memset(st_index, -1, sizeof(st_index));\n\n    is->last_video_stream = is->video_stream = -1;\n\n    is->last_audio_stream = is->audio_stream = -1;\n\n    is->last_subtitle_stream = is->subtitle_stream = -1;\n\n    is->eof = 0;\n\n\n\n    ic = avformat_alloc_context();\n\n    if (!ic) {\n\n        av_log(NULL, AV_LOG_FATAL, \"Could not allocate context.\\n\");\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    ic->interrupt_callback.callback = decode_interrupt_cb;\n\n    ic->interrupt_callback.opaque = is;\n\n    if (!av_dict_get(format_opts, \"scan_all_pmts\", NULL, AV_DICT_MATCH_CASE)) {\n\n        av_dict_set(&format_opts, \"scan_all_pmts\", \"1\", AV_DICT_DONT_OVERWRITE);\n\n        scan_all_pmts_set = 1;\n\n    }\n\n    err = avformat_open_input(&ic, is->filename, is->iformat, &format_opts);\n\n    if (err < 0) {\n\n        print_error(is->filename, err);\n\n        ret = -1;\n\n        goto fail;\n\n    }\n\n    if (scan_all_pmts_set)\n\n        av_dict_set(&format_opts, \"scan_all_pmts\", NULL, AV_DICT_MATCH_CASE);\n\n\n\n    if ((t = av_dict_get(format_opts, \"\", NULL, AV_DICT_IGNORE_SUFFIX))) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Option %s not found.\\n\", t->key);\n\n        ret = AVERROR_OPTION_NOT_FOUND;\n\n        goto fail;\n\n    }\n\n    is->ic = ic;\n\n\n\n    if (genpts)\n\n        ic->flags |= AVFMT_FLAG_GENPTS;\n\n\n\n    av_format_inject_global_side_data(ic);\n\n\n\n    opts = setup_find_stream_info_opts(ic, codec_opts);\n\n    orig_nb_streams = ic->nb_streams;\n\n\n\n    err = avformat_find_stream_info(ic, opts);\n\n\n\n    for (i = 0; i < orig_nb_streams; i++)\n\n        av_dict_free(&opts[i]);\n\n    av_freep(&opts);\n\n\n\n    if (err < 0) {\n\n        av_log(NULL, AV_LOG_WARNING,\n\n               \"%s: could not find codec parameters\\n\", is->filename);\n\n        ret = -1;\n\n        goto fail;\n\n    }\n\n\n\n    if (ic->pb)\n\n        ic->pb->eof_reached = 0; // FIXME hack, ffplay maybe should not use avio_feof() to test for the end\n\n\n\n    if (seek_by_bytes < 0)\n\n        seek_by_bytes = !!(ic->iformat->flags & AVFMT_TS_DISCONT) && strcmp(\"ogg\", ic->iformat->name);\n\n\n\n    is->max_frame_duration = (ic->iformat->flags & AVFMT_TS_DISCONT) ? 10.0 : 3600.0;\n\n\n\n    if (!window_title && (t = av_dict_get(ic->metadata, \"title\", NULL, 0)))\n\n        window_title = av_asprintf(\"%s - %s\", t->value, input_filename);\n\n\n\n    /* if seeking requested, we execute it */\n\n    if (start_time != AV_NOPTS_VALUE) {\n\n        int64_t timestamp;\n\n\n\n        timestamp = start_time;\n\n        /* add the stream start time */\n\n        if (ic->start_time != AV_NOPTS_VALUE)\n\n            timestamp += ic->start_time;\n\n        ret = avformat_seek_file(ic, -1, INT64_MIN, timestamp, INT64_MAX, 0);\n\n        if (ret < 0) {\n\n            av_log(NULL, AV_LOG_WARNING, \"%s: could not seek to position %0.3f\\n\",\n\n                    is->filename, (double)timestamp / AV_TIME_BASE);\n\n        }\n\n    }\n\n\n\n    is->realtime = is_realtime(ic);\n\n\n\n    if (show_status)\n\n        av_dump_format(ic, 0, is->filename, 0);\n\n\n\n    for (i = 0; i < ic->nb_streams; i++) {\n\n        AVStream *st = ic->streams[i];\n\n        enum AVMediaType type = st->codec->codec_type;\n\n        st->discard = AVDISCARD_ALL;\n\n        if (wanted_stream_spec[type] && st_index[type] == -1)\n\n            if (avformat_match_stream_specifier(ic, st, wanted_stream_spec[type]) > 0)\n\n                st_index[type] = i;\n\n    }\n\n    for (i = 0; i < AVMEDIA_TYPE_NB; i++) {\n\n        if (wanted_stream_spec[i] && st_index[i] == -1) {\n\n            av_log(NULL, AV_LOG_ERROR, \"Stream specifier %s does not match any %s stream\\n\", wanted_stream_spec[i], av_get_media_type_string(i));\n\n            st_index[i] = INT_MAX;\n\n        }\n\n    }\n\n\n\n    if (!video_disable)\n\n        st_index[AVMEDIA_TYPE_VIDEO] =\n\n            av_find_best_stream(ic, AVMEDIA_TYPE_VIDEO,\n\n                                st_index[AVMEDIA_TYPE_VIDEO], -1, NULL, 0);\n\n    if (!audio_disable)\n\n        st_index[AVMEDIA_TYPE_AUDIO] =\n\n            av_find_best_stream(ic, AVMEDIA_TYPE_AUDIO,\n\n                                st_index[AVMEDIA_TYPE_AUDIO],\n\n                                st_index[AVMEDIA_TYPE_VIDEO],\n\n                                NULL, 0);\n\n    if (!video_disable && !subtitle_disable)\n\n        st_index[AVMEDIA_TYPE_SUBTITLE] =\n\n            av_find_best_stream(ic, AVMEDIA_TYPE_SUBTITLE,\n\n                                st_index[AVMEDIA_TYPE_SUBTITLE],\n\n                                (st_index[AVMEDIA_TYPE_AUDIO] >= 0 ?\n\n                                 st_index[AVMEDIA_TYPE_AUDIO] :\n\n                                 st_index[AVMEDIA_TYPE_VIDEO]),\n\n                                NULL, 0);\n\n\n\n    is->show_mode = show_mode;\n\n    if (st_index[AVMEDIA_TYPE_VIDEO] >= 0) {\n\n        AVStream *st = ic->streams[st_index[AVMEDIA_TYPE_VIDEO]];\n\n        AVCodecContext *avctx = st->codec;\n\n        AVRational sar = av_guess_sample_aspect_ratio(ic, st, NULL);\n\n        if (avctx->width)\n\n            set_default_window_size(avctx->width, avctx->height, sar);\n\n    }\n\n\n\n    /* open the streams */\n\n    if (st_index[AVMEDIA_TYPE_AUDIO] >= 0) {\n\n        stream_component_open(is, st_index[AVMEDIA_TYPE_AUDIO]);\n\n    }\n\n\n\n    ret = -1;\n\n    if (st_index[AVMEDIA_TYPE_VIDEO] >= 0) {\n\n        ret = stream_component_open(is, st_index[AVMEDIA_TYPE_VIDEO]);\n\n    }\n\n    if (is->show_mode == SHOW_MODE_NONE)\n\n        is->show_mode = ret >= 0 ? SHOW_MODE_VIDEO : SHOW_MODE_RDFT;\n\n\n\n    if (st_index[AVMEDIA_TYPE_SUBTITLE] >= 0) {\n\n        stream_component_open(is, st_index[AVMEDIA_TYPE_SUBTITLE]);\n\n    }\n\n\n\n    if (is->video_stream < 0 && is->audio_stream < 0) {\n\n        av_log(NULL, AV_LOG_FATAL, \"Failed to open file '%s' or configure filtergraph\\n\",\n\n               is->filename);\n\n        ret = -1;\n\n        goto fail;\n\n    }\n\n\n\n    if (infinite_buffer < 0 && is->realtime)\n\n        infinite_buffer = 1;\n\n\n\n    for (;;) {\n\n        if (is->abort_request)\n\n            break;\n\n        if (is->paused != is->last_paused) {\n\n            is->last_paused = is->paused;\n\n            if (is->paused)\n\n                is->read_pause_return = av_read_pause(ic);\n\n            else\n\n                av_read_play(ic);\n\n        }\n\n#if CONFIG_RTSP_DEMUXER || CONFIG_MMSH_PROTOCOL\n\n        if (is->paused &&\n\n                (!strcmp(ic->iformat->name, \"rtsp\") ||\n\n                 (ic->pb && !strncmp(input_filename, \"mmsh:\", 5)))) {\n\n            /* wait 10 ms to avoid trying to get another packet */\n\n            /* XXX: horrible */\n\n            SDL_Delay(10);\n\n            continue;\n\n        }\n\n#endif\n\n        if (is->seek_req) {\n\n            int64_t seek_target = is->seek_pos;\n\n            int64_t seek_min    = is->seek_rel > 0 ? seek_target - is->seek_rel + 2: INT64_MIN;\n\n            int64_t seek_max    = is->seek_rel < 0 ? seek_target - is->seek_rel - 2: INT64_MAX;\n\n// FIXME the +-2 is due to rounding being not done in the correct direction in generation\n\n//      of the seek_pos/seek_rel variables\n\n\n\n            ret = avformat_seek_file(is->ic, -1, seek_min, seek_target, seek_max, is->seek_flags);\n\n            if (ret < 0) {\n\n                av_log(NULL, AV_LOG_ERROR,\n\n                       \"%s: error while seeking\\n\", is->ic->filename);\n\n            } else {\n\n                if (is->audio_stream >= 0) {\n\n                    packet_queue_flush(&is->audioq);\n\n                    packet_queue_put(&is->audioq, &flush_pkt);\n\n                }\n\n                if (is->subtitle_stream >= 0) {\n\n                    packet_queue_flush(&is->subtitleq);\n\n                    packet_queue_put(&is->subtitleq, &flush_pkt);\n\n                }\n\n                if (is->video_stream >= 0) {\n\n                    packet_queue_flush(&is->videoq);\n\n                    packet_queue_put(&is->videoq, &flush_pkt);\n\n                }\n\n                if (is->seek_flags & AVSEEK_FLAG_BYTE) {\n\n                   set_clock(&is->extclk, NAN, 0);\n\n                } else {\n\n                   set_clock(&is->extclk, seek_target / (double)AV_TIME_BASE, 0);\n\n                }\n\n            }\n\n            is->seek_req = 0;\n\n            is->queue_attachments_req = 1;\n\n            is->eof = 0;\n\n            if (is->paused)\n\n                step_to_next_frame(is);\n\n        }\n\n        if (is->queue_attachments_req) {\n\n            if (is->video_st && is->video_st->disposition & AV_DISPOSITION_ATTACHED_PIC) {\n\n                AVPacket copy;\n\n                if ((ret = av_copy_packet(&copy, &is->video_st->attached_pic)) < 0)\n\n                    goto fail;\n\n                packet_queue_put(&is->videoq, &copy);\n\n                packet_queue_put_nullpacket(&is->videoq, is->video_stream);\n\n            }\n\n            is->queue_attachments_req = 0;\n\n        }\n\n\n\n        /* if the queue are full, no need to read more */\n\n        if (infinite_buffer<1 &&\n\n              (is->audioq.size + is->videoq.size + is->subtitleq.size > MAX_QUEUE_SIZE\n\n            || (   (is->audioq   .nb_packets > MIN_FRAMES || is->audio_stream < 0 || is->audioq.abort_request)\n\n                && (is->videoq   .nb_packets > MIN_FRAMES || is->video_stream < 0 || is->videoq.abort_request\n\n                    || (is->video_st->disposition & AV_DISPOSITION_ATTACHED_PIC))\n\n                && (is->subtitleq.nb_packets > MIN_FRAMES || is->subtitle_stream < 0 || is->subtitleq.abort_request)))) {\n\n            /* wait 10 ms */\n\n            SDL_LockMutex(wait_mutex);\n\n            SDL_CondWaitTimeout(is->continue_read_thread, wait_mutex, 10);\n\n            SDL_UnlockMutex(wait_mutex);\n\n            continue;\n\n        }\n\n        if (!is->paused &&\n\n            (!is->audio_st || (is->auddec.finished == is->audioq.serial && frame_queue_nb_remaining(&is->sampq) == 0)) &&\n\n            (!is->video_st || (is->viddec.finished == is->videoq.serial && frame_queue_nb_remaining(&is->pictq) == 0))) {\n\n            if (loop != 1 && (!loop || --loop)) {\n\n                stream_seek(is, start_time != AV_NOPTS_VALUE ? start_time : 0, 0, 0);\n\n            } else if (autoexit) {\n\n                ret = AVERROR_EOF;\n\n                goto fail;\n\n            }\n\n        }\n\n        ret = av_read_frame(ic, pkt);\n\n        if (ret < 0) {\n\n            if ((ret == AVERROR_EOF || avio_feof(ic->pb)) && !is->eof) {\n\n                if (is->video_stream >= 0)\n\n                    packet_queue_put_nullpacket(&is->videoq, is->video_stream);\n\n                if (is->audio_stream >= 0)\n\n                    packet_queue_put_nullpacket(&is->audioq, is->audio_stream);\n\n                if (is->subtitle_stream >= 0)\n\n                    packet_queue_put_nullpacket(&is->subtitleq, is->subtitle_stream);\n\n                is->eof = 1;\n\n            }\n\n            if (ic->pb && ic->pb->error)\n\n                break;\n\n            SDL_LockMutex(wait_mutex);\n\n            SDL_CondWaitTimeout(is->continue_read_thread, wait_mutex, 10);\n\n            SDL_UnlockMutex(wait_mutex);\n\n            continue;\n\n        } else {\n\n            is->eof = 0;\n\n        }\n\n        /* check if packet is in play range specified by user, then queue, otherwise discard */\n\n        stream_start_time = ic->streams[pkt->stream_index]->start_time;\n\n        pkt_ts = pkt->pts == AV_NOPTS_VALUE ? pkt->dts : pkt->pts;\n\n        pkt_in_play_range = duration == AV_NOPTS_VALUE ||\n\n                (pkt_ts - (stream_start_time != AV_NOPTS_VALUE ? stream_start_time : 0)) *\n\n                av_q2d(ic->streams[pkt->stream_index]->time_base) -\n\n                (double)(start_time != AV_NOPTS_VALUE ? start_time : 0) / 1000000\n\n                <= ((double)duration / 1000000);\n\n        if (pkt->stream_index == is->audio_stream && pkt_in_play_range) {\n\n            packet_queue_put(&is->audioq, pkt);\n\n        } else if (pkt->stream_index == is->video_stream && pkt_in_play_range\n\n                   && !(is->video_st->disposition & AV_DISPOSITION_ATTACHED_PIC)) {\n\n            packet_queue_put(&is->videoq, pkt);\n\n        } else if (pkt->stream_index == is->subtitle_stream && pkt_in_play_range) {\n\n            packet_queue_put(&is->subtitleq, pkt);\n\n        } else {\n\n            av_free_packet(pkt);\n\n        }\n\n    }\n\n    /* wait until the end */\n\n    while (!is->abort_request) {\n\n        SDL_Delay(100);\n\n    }\n\n\n\n    ret = 0;\n\n fail:\n\n    /* close each stream */\n\n    if (is->audio_stream >= 0)\n\n        stream_component_close(is, is->audio_stream);\n\n    if (is->video_stream >= 0)\n\n        stream_component_close(is, is->video_stream);\n\n    if (is->subtitle_stream >= 0)\n\n        stream_component_close(is, is->subtitle_stream);\n\n    if (ic) {\n\n        avformat_close_input(&ic);\n\n        is->ic = NULL;\n\n    }\n\n\n\n    if (ret != 0) {\n\n        SDL_Event event;\n\n\n\n        event.type = FF_QUIT_EVENT;\n\n        event.user.data1 = is;\n\n        SDL_PushEvent(&event);\n\n    }\n\n    SDL_DestroyMutex(wait_mutex);\n\n    return 0;\n\n}\n", "idx": 21141}
{"project": "FFmpeg", "commit_id": "9bcbb250e23959075765edd3cb4c1fcb46736d7d", "target": 0, "func": "static inline void RENAME(yuv2yuv1_ar)(SwsContext *c, const int16_t *lumSrc,\n\n                                       const int16_t *chrUSrc, const int16_t *chrVSrc,\n\n                                       const int16_t *alpSrc,\n\n                                       uint8_t *dest, uint8_t *uDest, uint8_t *vDest,\n\n                                       uint8_t *aDest, int dstW, int chrDstW)\n\n{\n\n    int p= 4;\n\n    const uint8_t *src[4]= { alpSrc + dstW, lumSrc + dstW, chrUSrc + chrDstW, chrVSrc + chrDstW };\n\n    uint8_t *dst[4]= { aDest, dest, uDest, vDest };\n\n    x86_reg counter[4]= { dstW, dstW, chrDstW, chrDstW };\n\n\n\n    while (p--) {\n\n        if (dst[p]) {\n\n            __asm__ volatile(\n\n                \"mov %2, %%\"REG_a\"                    \\n\\t\"\n\n                \"pcmpeqw %%mm7, %%mm7                 \\n\\t\"\n\n                \"psrlw                 $15, %%mm7     \\n\\t\"\n\n                \"psllw                  $6, %%mm7     \\n\\t\"\n\n                \".p2align                4            \\n\\t\" /* FIXME Unroll? */\n\n                \"1:                                   \\n\\t\"\n\n                \"movq  (%0, %%\"REG_a\", 2), %%mm0      \\n\\t\"\n\n                \"movq 8(%0, %%\"REG_a\", 2), %%mm1      \\n\\t\"\n\n                \"paddsw             %%mm7, %%mm0      \\n\\t\"\n\n                \"paddsw             %%mm7, %%mm1      \\n\\t\"\n\n                \"psraw                 $7, %%mm0      \\n\\t\"\n\n                \"psraw                 $7, %%mm1      \\n\\t\"\n\n                \"packuswb           %%mm1, %%mm0      \\n\\t\"\n\n                MOVNTQ(%%mm0, (%1, %%REGa))\n\n                \"add                   $8, %%\"REG_a\"  \\n\\t\"\n\n                \"jnc                   1b             \\n\\t\"\n\n                :: \"r\" (src[p]), \"r\" (dst[p] + counter[p]),\n\n                   \"g\" (-counter[p])\n\n                : \"%\"REG_a\n\n            );\n\n        }\n\n    }\n\n}\n", "idx": 21148}
{"project": "qemu", "commit_id": "a15fcc3cf69ee3d408f60d6cc316488d2b0249b4", "target": 1, "func": "void visit_start_struct(Visitor *v, const char *name, void **obj,\n\n                        size_t size, Error **errp)\n\n{\n\n    Error *err = NULL;\n\n\n\n    if (obj) {\n\n        assert(size);\n\n        assert(v->type != VISITOR_OUTPUT || *obj);\n\n    }\n\n    v->start_struct(v, name, obj, size, &err);\n\n    if (obj && v->type == VISITOR_INPUT) {\n\n        assert(!err != !*obj);\n\n    }\n\n    error_propagate(errp, err);\n\n}\n", "idx": 21160}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "int qemu_timeout_ns_to_ms(int64_t ns)\n\n{\n\n    int64_t ms;\n\n    if (ns < 0) {\n\n        return -1;\n\n    }\n\n\n\n    if (!ns) {\n\n        return 0;\n\n    }\n\n\n\n    /* Always round up, because it's better to wait too long than to wait too\n\n     * little and effectively busy-wait\n\n     */\n\n    ms = DIV_ROUND_UP(ns, SCALE_MS);\n\n\n\n    /* To avoid overflow problems, limit this to 2^31, i.e. approx 25 days */\n\n    if (ms > (int64_t) INT32_MAX) {\n\n        ms = INT32_MAX;\n\n    }\n\n\n\n    return (int) ms;\n\n}\n", "idx": 21215}
{"project": "qemu", "commit_id": "13d1fd44c46629aad672f192abbf02238c6cbf36", "target": 1, "func": "static void qxl_init_ramsize(PCIQXLDevice *qxl, uint32_t ram_min_mb)\n\n{\n\n    /* vga ram (bar 0) */\n\n    if (qxl->ram_size_mb != -1) {\n\n        qxl->vga.vram_size = qxl->ram_size_mb * 1024 * 1024;\n\n    }\n\n    if (qxl->vga.vram_size < ram_min_mb * 1024 * 1024) {\n\n        qxl->vga.vram_size = ram_min_mb * 1024 * 1024;\n\n    }\n\n\n\n    /* vram32 (surfaces, 32bit, bar 1) */\n\n    if (qxl->vram32_size_mb != -1) {\n\n        qxl->vram32_size = qxl->vram32_size_mb * 1024 * 1024;\n\n    }\n\n    if (qxl->vram32_size < 4096) {\n\n        qxl->vram32_size = 4096;\n\n    }\n\n\n\n    /* vram (surfaces, 64bit, bar 4+5) */\n\n    if (qxl->vram_size_mb != -1) {\n\n        qxl->vram_size = qxl->vram_size_mb * 1024 * 1024;\n\n    }\n\n    if (qxl->vram_size < qxl->vram32_size) {\n\n        qxl->vram_size = qxl->vram32_size;\n\n    }\n\n\n\n    if (qxl->revision == 1) {\n\n        qxl->vram32_size = 4096;\n\n        qxl->vram_size = 4096;\n\n    }\n\n    qxl->vga.vram_size = msb_mask(qxl->vga.vram_size * 2 - 1);\n\n    qxl->vram32_size = msb_mask(qxl->vram32_size * 2 - 1);\n\n    qxl->vram_size = msb_mask(qxl->vram_size * 2 - 1);\n\n}\n", "idx": 21230}
{"project": "qemu", "commit_id": "a7c31816288a8f20fc387d69d441413e7a8c9ff1", "target": 0, "func": "static void dump_qobject(fprintf_function func_fprintf, void *f,\n\n                         int comp_indent, QObject *obj)\n\n{\n\n    switch (qobject_type(obj)) {\n\n        case QTYPE_QINT: {\n\n            QInt *value = qobject_to_qint(obj);\n\n            func_fprintf(f, \"%\" PRId64, qint_get_int(value));\n\n            break;\n\n        }\n\n        case QTYPE_QSTRING: {\n\n            QString *value = qobject_to_qstring(obj);\n\n            func_fprintf(f, \"%s\", qstring_get_str(value));\n\n            break;\n\n        }\n\n        case QTYPE_QDICT: {\n\n            QDict *value = qobject_to_qdict(obj);\n\n            dump_qdict(func_fprintf, f, comp_indent, value);\n\n            break;\n\n        }\n\n        case QTYPE_QLIST: {\n\n            QList *value = qobject_to_qlist(obj);\n\n            dump_qlist(func_fprintf, f, comp_indent, value);\n\n            break;\n\n        }\n\n        case QTYPE_QFLOAT: {\n\n            QFloat *value = qobject_to_qfloat(obj);\n\n            func_fprintf(f, \"%g\", qfloat_get_double(value));\n\n            break;\n\n        }\n\n        case QTYPE_QBOOL: {\n\n            QBool *value = qobject_to_qbool(obj);\n\n            func_fprintf(f, \"%s\", qbool_get_int(value) ? \"true\" : \"false\");\n\n            break;\n\n        }\n\n        case QTYPE_QERROR: {\n\n            QString *value = qerror_human((QError *)obj);\n\n            func_fprintf(f, \"%s\", qstring_get_str(value));\n\n            QDECREF(value);\n\n            break;\n\n        }\n\n        case QTYPE_NONE:\n\n            break;\n\n        case QTYPE_MAX:\n\n        default:\n\n            abort();\n\n    }\n\n}\n", "idx": 21319}
{"project": "qemu", "commit_id": "5c6c0e513600ba57c3e73b7151d3c0664438f7b5", "target": 1, "func": "static void esp_command_complete(SCSIBus *bus, int reason, uint32_t tag,\n\n                                 uint32_t arg)\n\n{\n\n    ESPState *s = DO_UPCAST(ESPState, busdev.qdev, bus->qbus.parent);\n\n\n\n    if (reason == SCSI_REASON_DONE) {\n\n        DPRINTF(\"SCSI Command complete\\n\");\n\n        if (s->ti_size != 0)\n\n            DPRINTF(\"SCSI command completed unexpectedly\\n\");\n\n        s->ti_size = 0;\n\n        s->dma_left = 0;\n\n        s->async_len = 0;\n\n        if (arg)\n\n            DPRINTF(\"Command failed\\n\");\n\n        s->sense = arg;\n\n        s->rregs[ESP_RSTAT] = STAT_ST;\n\n        esp_dma_done(s);\n\n        s->current_dev = NULL;\n\n    } else {\n\n        DPRINTF(\"transfer %d/%d\\n\", s->dma_left, s->ti_size);\n\n        s->async_len = arg;\n\n        s->async_buf = s->current_dev->info->get_buf(s->current_dev, 0);\n\n        if (s->dma_left) {\n\n            esp_do_dma(s);\n\n        } else if (s->dma_counter != 0 && s->ti_size <= 0) {\n\n            /* If this was the last part of a DMA transfer then the\n\n               completion interrupt is deferred to here.  */\n\n            esp_dma_done(s);\n\n        }\n\n    }\n\n}\n", "idx": 21389}
{"project": "FFmpeg", "commit_id": "0c22311b56e66115675c4a96e4c78547886a4171", "target": 0, "func": "static void opt_pad_color(const char *arg) {\n\n    /* Input is expected to be six hex digits similar to\n\n       how colors are expressed in html tags (but without the #) */\n\n    int rgb = strtol(arg, NULL, 16);\n\n    int r,g,b;\n\n\n\n    r = (rgb >> 16);\n\n    g = ((rgb >> 8) & 255);\n\n    b = (rgb & 255);\n\n\n\n    padcolor[0] = RGB_TO_Y(r,g,b);\n\n    padcolor[1] = RGB_TO_U(r,g,b,0);\n\n    padcolor[2] = RGB_TO_V(r,g,b,0);\n\n}\n", "idx": 21586}
{"project": "FFmpeg", "commit_id": "ca16618b01abfde44b4eaf92dc89b01aa1b4a91e", "target": 0, "func": "static int xan_decode_end(AVCodecContext *avctx)\n\n{\n\n    XanContext *s = avctx->priv_data;\n\n\n\n    /* release the last frame */\n\n    avctx->release_buffer(avctx, &s->last_frame);\n\n\n\n    av_free(s->buffer1);\n\n    av_free(s->buffer2);\n\n\n\n    return 0;\n\n}\n", "idx": 21607}
{"project": "qemu", "commit_id": "1bd075f29ea6d11853475c7c42734595720c3ac6", "target": 1, "func": "iscsi_aio_write16_cb(struct iscsi_context *iscsi, int status,\n\n                     void *command_data, void *opaque)\n\n{\n\n    IscsiAIOCB *acb = opaque;\n\n\n\n    trace_iscsi_aio_write16_cb(iscsi, status, acb, acb->canceled);\n\n\n\n    g_free(acb->buf);\n\n\n\n    if (acb->canceled != 0) {\n\n        qemu_aio_release(acb);\n\n        scsi_free_scsi_task(acb->task);\n\n        acb->task = NULL;\n\n        return;\n\n    }\n\n\n\n    acb->status = 0;\n\n    if (status < 0) {\n\n        error_report(\"Failed to write16 data to iSCSI lun. %s\",\n\n                     iscsi_get_error(iscsi));\n\n        acb->status = -EIO;\n\n    }\n\n\n\n    iscsi_schedule_bh(acb);\n\n    scsi_free_scsi_task(acb->task);\n\n    acb->task = NULL;\n\n}\n", "idx": 21633}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int apc_probe(AVProbeData *p)\n\n{\n\n    if (p->buf_size < 8)\n\n        return 0;\n\n\n\n    if (!strncmp(p->buf, \"CRYO_APC\", 8))\n\n        return AVPROBE_SCORE_MAX;\n\n\n\n    return 0;\n\n}\n", "idx": 21664}
{"project": "qemu", "commit_id": "7ea2d269cb84ca7a2f4b7c3735634176f7c1dc35", "target": 1, "func": "NBDExport *nbd_export_new(BlockDriverState *bs, off_t dev_offset,\n\n                          off_t size, uint32_t nbdflags,\n\n                          void (*close)(NBDExport *))\n\n{\n\n    NBDExport *exp = g_malloc0(sizeof(NBDExport));\n\n    exp->refcount = 1;\n\n    QTAILQ_INIT(&exp->clients);\n\n    exp->bs = bs;\n\n    exp->dev_offset = dev_offset;\n\n    exp->nbdflags = nbdflags;\n\n    exp->size = size == -1 ? bdrv_getlength(bs) : size;\n\n    exp->close = close;\n\n    exp->ctx = bdrv_get_aio_context(bs);\n\n    bdrv_ref(bs);\n\n    bdrv_add_aio_context_notifier(bs, bs_aio_attached, bs_aio_detach, exp);\n\n\n\n\n\n\n\n    return exp;\n\n}", "idx": 21691}
{"project": "FFmpeg", "commit_id": "5f01beb54846de8764c15206aa63086238dde493", "target": 1, "func": "int ff_lzw_decode_init(LZWState *p, int csize, uint8_t *buf, int buf_size, int mode)\n\n{\n\n    struct LZWState *s = (struct LZWState *)p;\n\n\n\n    if(csize < 1 || csize > LZW_MAXBITS)\n\n        return -1;\n\n    /* read buffer */\n\n    s->eob_reached = 0;\n\n    s->pbuf = buf;\n\n    s->ebuf = s->pbuf + buf_size;\n\n    s->bbuf = 0;\n\n    s->bbits = 0;\n\n    s->bs = 0;\n\n\n\n    /* decoder */\n\n    s->codesize = csize;\n\n    s->cursize = s->codesize + 1;\n\n    s->curmask = mask[s->cursize];\n\n    s->top_slot = 1 << s->cursize;\n\n    s->clear_code = 1 << s->codesize;\n\n    s->end_code = s->clear_code + 1;\n\n    s->slot = s->newcodes = s->clear_code + 2;\n\n    s->oc = s->fc = 0;\n\n    s->sp = s->stack;\n\n\n\n    s->mode = mode;\n\n    switch(s->mode){\n\n    case FF_LZW_GIF:\n\n        s->extra_slot= 0;\n\n        break;\n\n    case FF_LZW_TIFF:\n\n        s->extra_slot= 1;\n\n        break;\n\n    default:\n\n        return -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 21815}
{"project": "qemu", "commit_id": "09b9418c6d085a0728372aa760ebd10128a020b1", "target": 1, "func": "static target_long monitor_get_tbl (const struct MonitorDef *md, int val)\n\n{\n\n    CPUState *env = mon_get_cpu();\n\n    if (!env)\n\n        return 0;\n\n    return cpu_ppc_load_tbl(env);\n\n}\n", "idx": 21823}
{"project": "FFmpeg", "commit_id": "7dd44cde2abb156710f26a08b6cd6c8dd9a9793d", "target": 0, "func": "static void sub2video_update(InputStream *ist, AVSubtitle *sub)\n\n{\n\n    AVFrame *frame = ist->sub2video.frame;\n\n    int8_t *dst;\n\n    int     dst_linesize;\n\n    int num_rects, i;\n\n    int64_t pts, end_pts;\n\n\n\n    if (!frame)\n\n        return;\n\n    if (sub) {\n\n        pts       = av_rescale_q(sub->pts + sub->start_display_time * 1000LL,\n\n                                 AV_TIME_BASE_Q, ist->st->time_base);\n\n        end_pts   = av_rescale_q(sub->pts + sub->end_display_time   * 1000LL,\n\n                                 AV_TIME_BASE_Q, ist->st->time_base);\n\n        num_rects = sub->num_rects;\n\n    } else {\n\n        pts       = ist->sub2video.end_pts;\n\n        end_pts   = INT64_MAX;\n\n        num_rects = 0;\n\n    }\n\n    if (sub2video_get_blank_frame(ist) < 0) {\n\n        av_log(ist->dec_ctx, AV_LOG_ERROR,\n\n               \"Impossible to get a blank canvas.\\n\");\n\n        return;\n\n    }\n\n    dst          = frame->data    [0];\n\n    dst_linesize = frame->linesize[0];\n\n    for (i = 0; i < num_rects; i++)\n\n        sub2video_copy_rect(dst, dst_linesize, frame->width, frame->height, sub->rects[i]);\n\n    sub2video_push_ref(ist, pts);\n\n    ist->sub2video.end_pts = end_pts;\n\n}\n", "idx": 21843}
{"project": "qemu", "commit_id": "90e56fb46d0a7add88ed463efa4e723a6238f692", "target": 0, "func": "void migrate_compress_threads_create(void)\n\n{\n\n    int i, thread_count;\n\n\n\n    if (!migrate_use_compression()) {\n\n        return;\n\n    }\n\n    quit_comp_thread = false;\n\n    compression_switch = true;\n\n    thread_count = migrate_compress_threads();\n\n    compress_threads = g_new0(QemuThread, thread_count);\n\n    comp_param = g_new0(CompressParam, thread_count);\n\n    comp_done_cond = g_new0(QemuCond, 1);\n\n    comp_done_lock = g_new0(QemuMutex, 1);\n\n    qemu_cond_init(comp_done_cond);\n\n    qemu_mutex_init(comp_done_lock);\n\n    for (i = 0; i < thread_count; i++) {\n\n        /* com_param[i].file is just used as a dummy buffer to save data, set\n\n         * it's ops to empty.\n\n         */\n\n        comp_param[i].file = qemu_fopen_ops(NULL, &empty_ops);\n\n        comp_param[i].done = true;\n\n        qemu_mutex_init(&comp_param[i].mutex);\n\n        qemu_cond_init(&comp_param[i].cond);\n\n        qemu_thread_create(compress_threads + i, \"compress\",\n\n                           do_data_compress, comp_param + i,\n\n                           QEMU_THREAD_JOINABLE);\n\n    }\n\n}\n", "idx": 21875}
{"project": "qemu", "commit_id": "cfb2d02be9413d45b30ed6d8e38800250b6b4b48", "target": 0, "func": "static inline void cpu_loop_exec_tb(CPUState *cpu, TranslationBlock *tb,\n\n                                    TranslationBlock **last_tb, int *tb_exit,\n\n                                    SyncClocks *sc)\n\n{\n\n    uintptr_t ret;\n\n    int32_t insns_left;\n\n\n\n    if (unlikely(atomic_read(&cpu->exit_request))) {\n\n        return;\n\n    }\n\n\n\n    trace_exec_tb(tb, tb->pc);\n\n    ret = cpu_tb_exec(cpu, tb);\n\n    tb = (TranslationBlock *)(ret & ~TB_EXIT_MASK);\n\n    *tb_exit = ret & TB_EXIT_MASK;\n\n    if (*tb_exit != TB_EXIT_REQUESTED) {\n\n        *last_tb = tb;\n\n        return;\n\n    }\n\n\n\n    *last_tb = NULL;\n\n    insns_left = atomic_read(&cpu->icount_decr.u32);\n\n    atomic_set(&cpu->icount_decr.u16.high, 0);\n\n    if (insns_left < 0) {\n\n        /* Something asked us to stop executing\n\n         * chained TBs; just continue round the main\n\n         * loop. Whatever requested the exit will also\n\n         * have set something else (eg exit_request or\n\n         * interrupt_request) which we will handle\n\n         * next time around the loop.  But we need to\n\n         * ensure the zeroing of tcg_exit_req (see cpu_tb_exec)\n\n         * comes before the next read of cpu->exit_request\n\n         * or cpu->interrupt_request.\n\n         */\n\n        smp_mb();\n\n        return;\n\n    }\n\n\n\n    /* Instruction counter expired.  */\n\n    assert(use_icount);\n\n#ifndef CONFIG_USER_ONLY\n\n    if (cpu->icount_extra) {\n\n        /* Refill decrementer and continue execution.  */\n\n        cpu->icount_extra += insns_left;\n\n        insns_left = MIN(0xffff, cpu->icount_extra);\n\n        cpu->icount_extra -= insns_left;\n\n        cpu->icount_decr.u16.low = insns_left;\n\n    } else {\n\n        /* Execute any remaining instructions, then let the main loop\n\n         * handle the next event.\n\n         */\n\n        if (insns_left > 0) {\n\n            cpu_exec_nocache(cpu, insns_left, tb, false);\n\n            align_clocks(sc, cpu);\n\n        }\n\n        cpu->exception_index = EXCP_INTERRUPT;\n\n        cpu_loop_exit(cpu);\n\n    }\n\n#endif\n\n}\n", "idx": 21880}
{"project": "qemu", "commit_id": "45bbbb466cf4a6280076ea5a51f67ef5bedee345", "target": 1, "func": "void helper_divq_EAX_T0(void)\n\n{\n\n    uint64_t r0, r1;\n\n    if (T0 == 0) {\n\n        raise_exception(EXCP00_DIVZ);\n\n    }\n\n    r0 = EAX;\n\n    r1 = EDX;\n\n    div64(&r0, &r1, T0);\n\n    EAX = r0;\n\n    EDX = r1;\n\n}\n", "idx": 21921}
{"project": "qemu", "commit_id": "1108b2f8a939fb5778d384149e2f1b99062a72da", "target": 1, "func": "static int ioh3420_initfn(PCIDevice *d)\n\n{\n\n    PCIEPort *p = PCIE_PORT(d);\n\n    PCIESlot *s = PCIE_SLOT(d);\n\n    int rc;\n\n\n\n    pci_bridge_initfn(d, TYPE_PCIE_BUS);\n\n    pcie_port_init_reg(d);\n\n\n\n    rc = pci_bridge_ssvid_init(d, IOH_EP_SSVID_OFFSET,\n\n                               IOH_EP_SSVID_SVID, IOH_EP_SSVID_SSID);\n\n    if (rc < 0) {\n\n        goto err_bridge;\n\n    }\n\n\n\n    rc = msi_init(d, IOH_EP_MSI_OFFSET, IOH_EP_MSI_NR_VECTOR,\n\n                  IOH_EP_MSI_SUPPORTED_FLAGS & PCI_MSI_FLAGS_64BIT,\n\n                  IOH_EP_MSI_SUPPORTED_FLAGS & PCI_MSI_FLAGS_MASKBIT);\n\n    if (rc < 0) {\n\n        goto err_bridge;\n\n    }\n\n\n\n    rc = pcie_cap_init(d, IOH_EP_EXP_OFFSET, PCI_EXP_TYPE_ROOT_PORT, p->port);\n\n    if (rc < 0) {\n\n        goto err_msi;\n\n    }\n\n\n\n    pcie_cap_arifwd_init(d);\n\n    pcie_cap_deverr_init(d);\n\n    pcie_cap_slot_init(d, s->slot);\n\n    pcie_cap_root_init(d);\n\n\n\n    pcie_chassis_create(s->chassis);\n\n    rc = pcie_chassis_add_slot(s);\n\n    if (rc < 0) {\n\n        goto err_pcie_cap;\n\n    }\n\n\n\n    rc = pcie_aer_init(d, IOH_EP_AER_OFFSET, PCI_ERR_SIZEOF);\n\n    if (rc < 0) {\n\n        goto err;\n\n    }\n\n    pcie_aer_root_init(d);\n\n    ioh3420_aer_vector_update(d);\n\n\n\n    return 0;\n\n\n\nerr:\n\n    pcie_chassis_del_slot(s);\n\nerr_pcie_cap:\n\n    pcie_cap_exit(d);\n\nerr_msi:\n\n    msi_uninit(d);\n\nerr_bridge:\n\n    pci_bridge_exitfn(d);\n\n    return rc;\n\n}\n", "idx": 22002}
{"project": "FFmpeg", "commit_id": "6ea7dd25c773145b50eed55c2059647bb086aaca", "target": 1, "func": "static int swf_write_header(AVFormatContext *s)\n\n{\n\n    SWFContext *swf = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    PutBitContext p;\n\n    uint8_t buf1[256];\n\n    int i, width, height, rate, rate_base;\n\n    int version;\n\n\n\n    swf->sound_samples = 0;\n\n    swf->swf_frame_number = 0;\n\n    swf->video_frame_number = 0;\n\n\n\n    for(i=0;i<s->nb_streams;i++) {\n\n        AVCodecContext *enc = s->streams[i]->codec;\n\n        if (enc->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n            if (swf->audio_enc) {\n\n                av_log(s, AV_LOG_ERROR, \"SWF muxer only supports 1 audio stream\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n\n            if (enc->codec_id == AV_CODEC_ID_MP3) {\n\n                if (!enc->frame_size) {\n\n                    av_log(s, AV_LOG_ERROR, \"audio frame size not set\\n\");\n\n                    return -1;\n\n\n                swf->audio_enc = enc;\n\n                swf->audio_fifo= av_fifo_alloc(AUDIO_FIFO_SIZE);\n\n                if (!swf->audio_fifo)\n\n                    return AVERROR(ENOMEM);\n\n            } else {\n\n                av_log(s, AV_LOG_ERROR, \"SWF muxer only supports MP3\\n\");\n\n                return -1;\n\n\n        } else {\n\n            if (swf->video_enc) {\n\n                av_log(s, AV_LOG_ERROR, \"SWF muxer only supports 1 video stream\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n\n            if (enc->codec_id == AV_CODEC_ID_VP6F ||\n\n                enc->codec_id == AV_CODEC_ID_FLV1 ||\n\n                enc->codec_id == AV_CODEC_ID_MJPEG) {\n\n                swf->video_st  = s->streams[i];\n\n                swf->video_enc = enc;\n\n            } else {\n\n                av_log(s, AV_LOG_ERROR, \"SWF muxer only supports VP6, FLV1 and MJPEG\\n\");\n\n                return -1;\n\n\n\n\n\n\n    if (!swf->video_enc) {\n\n        /* currently, cannot work correctly if audio only */\n\n        width = 320;\n\n        height = 200;\n\n        rate = 10;\n\n        rate_base= 1;\n\n    } else {\n\n        width = swf->video_enc->width;\n\n        height = swf->video_enc->height;\n\n        // TODO: should be avg_frame_rate\n\n        rate = swf->video_st->time_base.den;\n\n        rate_base = swf->video_st->time_base.num;\n\n\n\n\n    if (!swf->audio_enc)\n\n        swf->samples_per_frame = (44100LL * rate_base) / rate;\n\n    else\n\n        swf->samples_per_frame = (swf->audio_enc->sample_rate * rate_base) / rate;\n\n\n\n    avio_write(pb, \"FWS\", 3);\n\n\n\n    if (!strcmp(\"avm2\", s->oformat->name))\n\n        version = 9;\n\n    else if (swf->video_enc && swf->video_enc->codec_id == AV_CODEC_ID_VP6F)\n\n        version = 8; /* version 8 and above support VP6 codec */\n\n    else if (swf->video_enc && swf->video_enc->codec_id == AV_CODEC_ID_FLV1)\n\n        version = 6; /* version 6 and above support FLV1 codec */\n\n    else\n\n        version = 4; /* version 4 for mpeg audio support */\n\n    avio_w8(pb, version);\n\n\n\n    avio_wl32(pb, DUMMY_FILE_SIZE); /* dummy size\n\n                                      (will be patched if not streamed) */\n\n\n\n    put_swf_rect(pb, 0, width * 20, 0, height * 20);\n\n\n\n\n\n    avio_wl16(pb, (rate * 256) / rate_base); /* frame rate */\n\n    swf->duration_pos = avio_tell(pb);\n\n    avio_wl16(pb, (uint16_t)(DUMMY_DURATION * (int64_t)rate / rate_base)); /* frame count */\n\n\n\n    /* avm2/swf v9 (also v8?) files require a file attribute tag */\n\n    if (version == 9) {\n\n        put_swf_tag(s, TAG_FILEATTRIBUTES);\n\n        avio_wl32(pb, 1<<3); /* set ActionScript v3/AVM2 flag */\n\n        put_swf_end_tag(s);\n\n\n\n\n    /* define a shape with the jpeg inside */\n\n    if (swf->video_enc && swf->video_enc->codec_id == AV_CODEC_ID_MJPEG) {\n\n        put_swf_tag(s, TAG_DEFINESHAPE);\n\n\n\n        avio_wl16(pb, SHAPE_ID); /* ID of shape */\n\n        /* bounding rectangle */\n\n        put_swf_rect(pb, 0, width, 0, height);\n\n        /* style info */\n\n        avio_w8(pb, 1); /* one fill style */\n\n        avio_w8(pb, 0x41); /* clipped bitmap fill */\n\n        avio_wl16(pb, BITMAP_ID); /* bitmap ID */\n\n        /* position of the bitmap */\n\n        put_swf_matrix(pb, 1 << FRAC_BITS, 0,\n\n                       0,  1 << FRAC_BITS, 0, 0);\n\n        avio_w8(pb, 0); /* no line style */\n\n\n\n        /* shape drawing */\n\n        init_put_bits(&p, buf1, sizeof(buf1));\n\n        put_bits(&p, 4, 1); /* one fill bit */\n\n        put_bits(&p, 4, 0); /* zero line bit */\n\n\n\n        put_bits(&p, 1, 0); /* not an edge */\n\n        put_bits(&p, 5, FLAG_MOVETO | FLAG_SETFILL0);\n\n        put_bits(&p, 5, 1); /* nbits */\n\n        put_bits(&p, 1, 0); /* X */\n\n        put_bits(&p, 1, 0); /* Y */\n\n        put_bits(&p, 1, 1); /* set fill style 1 */\n\n\n\n        /* draw the rectangle ! */\n\n        put_swf_line_edge(&p, width, 0);\n\n        put_swf_line_edge(&p, 0, height);\n\n        put_swf_line_edge(&p, -width, 0);\n\n        put_swf_line_edge(&p, 0, -height);\n\n\n\n        /* end of shape */\n\n        put_bits(&p, 1, 0); /* not an edge */\n\n        put_bits(&p, 5, 0);\n\n\n\n        flush_put_bits(&p);\n\n        avio_write(pb, buf1, put_bits_ptr(&p) - p.buf);\n\n\n\n        put_swf_end_tag(s);\n\n\n\n\n    if (swf->audio_enc && swf->audio_enc->codec_id == AV_CODEC_ID_MP3) {\n\n        int v = 0;\n\n\n\n        /* start sound */\n\n        put_swf_tag(s, TAG_STREAMHEAD2);\n\n        switch(swf->audio_enc->sample_rate) {\n\n        case 11025: v |= 1 << 2; break;\n\n        case 22050: v |= 2 << 2; break;\n\n        case 44100: v |= 3 << 2; break;\n\n        default:\n\n            /* not supported */\n\n            av_log(s, AV_LOG_ERROR, \"swf does not support that sample rate, choose from (44100, 22050, 11025).\\n\");\n\n            return -1;\n\n\n        v |= 0x02; /* 16 bit playback */\n\n        if (swf->audio_enc->channels == 2)\n\n            v |= 0x01; /* stereo playback */\n\n        avio_w8(s->pb, v);\n\n        v |= 0x20; /* mp3 compressed */\n\n        avio_w8(s->pb, v);\n\n        avio_wl16(s->pb, swf->samples_per_frame);  /* avg samples per frame */\n\n        avio_wl16(s->pb, 0);\n\n\n\n        put_swf_end_tag(s);\n\n\n\n\n    avio_flush(s->pb);\n\n    return 0;\n", "idx": 22031}
{"project": "qemu", "commit_id": "0b368a10c71af96f6cf93b0ba5c2ee3bdbd50e96", "target": 1, "func": "static int kvm_put_msrs(X86CPU *cpu, int level)\n\n{\n\n    CPUX86State *env = &cpu->env;\n\n    int i;\n\n    int ret;\n\n\n\n    kvm_msr_buf_reset(cpu);\n\n\n\n    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_CS, env->sysenter_cs);\n\n    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_ESP, env->sysenter_esp);\n\n    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_EIP, env->sysenter_eip);\n\n    kvm_msr_entry_add(cpu, MSR_PAT, env->pat);\n\n    if (has_msr_star) {\n\n        kvm_msr_entry_add(cpu, MSR_STAR, env->star);\n\n    }\n\n    if (has_msr_hsave_pa) {\n\n        kvm_msr_entry_add(cpu, MSR_VM_HSAVE_PA, env->vm_hsave);\n\n    }\n\n    if (has_msr_tsc_aux) {\n\n        kvm_msr_entry_add(cpu, MSR_TSC_AUX, env->tsc_aux);\n\n    }\n\n    if (has_msr_tsc_adjust) {\n\n        kvm_msr_entry_add(cpu, MSR_TSC_ADJUST, env->tsc_adjust);\n\n    }\n\n    if (has_msr_misc_enable) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_MISC_ENABLE,\n\n                          env->msr_ia32_misc_enable);\n\n    }\n\n    if (has_msr_smbase) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_SMBASE, env->smbase);\n\n    }\n\n    if (has_msr_bndcfgs) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_BNDCFGS, env->msr_bndcfgs);\n\n    }\n\n    if (has_msr_xss) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_XSS, env->xss);\n\n    }\n\n#ifdef TARGET_X86_64\n\n    if (lm_capable_kernel) {\n\n        kvm_msr_entry_add(cpu, MSR_CSTAR, env->cstar);\n\n        kvm_msr_entry_add(cpu, MSR_KERNELGSBASE, env->kernelgsbase);\n\n        kvm_msr_entry_add(cpu, MSR_FMASK, env->fmask);\n\n        kvm_msr_entry_add(cpu, MSR_LSTAR, env->lstar);\n\n    }\n\n#endif\n\n    /*\n\n     * The following MSRs have side effects on the guest or are too heavy\n\n     * for normal writeback. Limit them to reset or full state updates.\n\n     */\n\n    if (level >= KVM_PUT_RESET_STATE) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_TSC, env->tsc);\n\n        kvm_msr_entry_add(cpu, MSR_KVM_SYSTEM_TIME, env->system_time_msr);\n\n        kvm_msr_entry_add(cpu, MSR_KVM_WALL_CLOCK, env->wall_clock_msr);\n\n        if (env->features[FEAT_KVM] & (1 << KVM_FEATURE_ASYNC_PF)) {\n\n            kvm_msr_entry_add(cpu, MSR_KVM_ASYNC_PF_EN, env->async_pf_en_msr);\n\n        }\n\n        if (env->features[FEAT_KVM] & (1 << KVM_FEATURE_PV_EOI)) {\n\n            kvm_msr_entry_add(cpu, MSR_KVM_PV_EOI_EN, env->pv_eoi_en_msr);\n\n        }\n\n        if (env->features[FEAT_KVM] & (1 << KVM_FEATURE_STEAL_TIME)) {\n\n            kvm_msr_entry_add(cpu, MSR_KVM_STEAL_TIME, env->steal_time_msr);\n\n        }\n\n        if (has_msr_architectural_pmu) {\n\n            /* Stop the counter.  */\n\n            kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, 0);\n\n            kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL, 0);\n\n\n\n            /* Set the counter values.  */\n\n            for (i = 0; i < MAX_FIXED_COUNTERS; i++) {\n\n                kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR0 + i,\n\n                                  env->msr_fixed_counters[i]);\n\n            }\n\n            for (i = 0; i < num_architectural_pmu_counters; i++) {\n\n                kvm_msr_entry_add(cpu, MSR_P6_PERFCTR0 + i,\n\n                                  env->msr_gp_counters[i]);\n\n                kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i,\n\n                                  env->msr_gp_evtsel[i]);\n\n            }\n\n            kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_STATUS,\n\n                              env->msr_global_status);\n\n            kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_OVF_CTRL,\n\n                              env->msr_global_ovf_ctrl);\n\n\n\n            /* Now start the PMU.  */\n\n            kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL,\n\n                              env->msr_fixed_ctr_ctrl);\n\n            kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL,\n\n                              env->msr_global_ctrl);\n\n        }\n\n        /*\n\n         * Hyper-V partition-wide MSRs: to avoid clearing them on cpu hot-add,\n\n         * only sync them to KVM on the first cpu\n\n         */\n\n        if (current_cpu == first_cpu) {\n\n            if (has_msr_hv_hypercall) {\n\n                kvm_msr_entry_add(cpu, HV_X64_MSR_GUEST_OS_ID,\n\n                                  env->msr_hv_guest_os_id);\n\n                kvm_msr_entry_add(cpu, HV_X64_MSR_HYPERCALL,\n\n                                  env->msr_hv_hypercall);\n\n            }\n\n            if (cpu->hyperv_time) {\n\n                kvm_msr_entry_add(cpu, HV_X64_MSR_REFERENCE_TSC,\n\n                                  env->msr_hv_tsc);\n\n            }\n\n        }\n\n        if (cpu->hyperv_vapic) {\n\n            kvm_msr_entry_add(cpu, HV_X64_MSR_APIC_ASSIST_PAGE,\n\n                              env->msr_hv_vapic);\n\n        }\n\n        if (has_msr_hv_crash) {\n\n            int j;\n\n\n\n            for (j = 0; j < HV_CRASH_PARAMS; j++)\n\n                kvm_msr_entry_add(cpu, HV_X64_MSR_CRASH_P0 + j,\n\n                                  env->msr_hv_crash_params[j]);\n\n\n\n            kvm_msr_entry_add(cpu, HV_X64_MSR_CRASH_CTL, HV_CRASH_CTL_NOTIFY);\n\n        }\n\n        if (has_msr_hv_runtime) {\n\n            kvm_msr_entry_add(cpu, HV_X64_MSR_VP_RUNTIME, env->msr_hv_runtime);\n\n        }\n\n        if (cpu->hyperv_synic) {\n\n            int j;\n\n\n\n            kvm_msr_entry_add(cpu, HV_X64_MSR_SVERSION, HV_SYNIC_VERSION);\n\n\n\n            kvm_msr_entry_add(cpu, HV_X64_MSR_SCONTROL,\n\n                              env->msr_hv_synic_control);\n\n            kvm_msr_entry_add(cpu, HV_X64_MSR_SIEFP,\n\n                              env->msr_hv_synic_evt_page);\n\n            kvm_msr_entry_add(cpu, HV_X64_MSR_SIMP,\n\n                              env->msr_hv_synic_msg_page);\n\n\n\n            for (j = 0; j < ARRAY_SIZE(env->msr_hv_synic_sint); j++) {\n\n                kvm_msr_entry_add(cpu, HV_X64_MSR_SINT0 + j,\n\n                                  env->msr_hv_synic_sint[j]);\n\n            }\n\n        }\n\n        if (has_msr_hv_stimer) {\n\n            int j;\n\n\n\n            for (j = 0; j < ARRAY_SIZE(env->msr_hv_stimer_config); j++) {\n\n                kvm_msr_entry_add(cpu, HV_X64_MSR_STIMER0_CONFIG + j * 2,\n\n                                env->msr_hv_stimer_config[j]);\n\n            }\n\n\n\n            for (j = 0; j < ARRAY_SIZE(env->msr_hv_stimer_count); j++) {\n\n                kvm_msr_entry_add(cpu, HV_X64_MSR_STIMER0_COUNT + j * 2,\n\n                                env->msr_hv_stimer_count[j]);\n\n            }\n\n        }\n\n        if (env->features[FEAT_1_EDX] & CPUID_MTRR) {\n\n            uint64_t phys_mask = MAKE_64BIT_MASK(0, cpu->phys_bits);\n\n\n\n            kvm_msr_entry_add(cpu, MSR_MTRRdefType, env->mtrr_deftype);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix64K_00000, env->mtrr_fixed[0]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix16K_80000, env->mtrr_fixed[1]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix16K_A0000, env->mtrr_fixed[2]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C0000, env->mtrr_fixed[3]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C8000, env->mtrr_fixed[4]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D0000, env->mtrr_fixed[5]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D8000, env->mtrr_fixed[6]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E0000, env->mtrr_fixed[7]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E8000, env->mtrr_fixed[8]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F0000, env->mtrr_fixed[9]);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F8000, env->mtrr_fixed[10]);\n\n            for (i = 0; i < MSR_MTRRcap_VCNT; i++) {\n\n                /* The CPU GPs if we write to a bit above the physical limit of\n\n                 * the host CPU (and KVM emulates that)\n\n                 */\n\n                uint64_t mask = env->mtrr_var[i].mask;\n\n                mask &= phys_mask;\n\n\n\n                kvm_msr_entry_add(cpu, MSR_MTRRphysBase(i),\n\n                                  env->mtrr_var[i].base);\n\n                kvm_msr_entry_add(cpu, MSR_MTRRphysMask(i), mask);\n\n            }\n\n        }\n\n\n\n        /* Note: MSR_IA32_FEATURE_CONTROL is written separately, see\n\n         *       kvm_put_msr_feature_control. */\n\n    }\n\n    if (env->mcg_cap) {\n\n        int i;\n\n\n\n        kvm_msr_entry_add(cpu, MSR_MCG_STATUS, env->mcg_status);\n\n        kvm_msr_entry_add(cpu, MSR_MCG_CTL, env->mcg_ctl);\n\n        if (has_msr_mcg_ext_ctl) {\n\n            kvm_msr_entry_add(cpu, MSR_MCG_EXT_CTL, env->mcg_ext_ctl);\n\n        }\n\n        for (i = 0; i < (env->mcg_cap & 0xff) * 4; i++) {\n\n            kvm_msr_entry_add(cpu, MSR_MC0_CTL + i, env->mce_banks[i]);\n\n        }\n\n    }\n\n\n\n    ret = kvm_vcpu_ioctl(CPU(cpu), KVM_SET_MSRS, cpu->kvm_msr_buf);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    if (ret < cpu->kvm_msr_buf->nmsrs) {\n\n        struct kvm_msr_entry *e = &cpu->kvm_msr_buf->entries[ret];\n\n        error_report(\"error: failed to set MSR 0x%\" PRIx32 \" to 0x%\" PRIx64,\n\n                     (uint32_t)e->index, (uint64_t)e->data);\n\n    }\n\n\n\n    assert(ret == cpu->kvm_msr_buf->nmsrs);\n\n    return 0;\n\n}\n", "idx": 22060}
{"project": "FFmpeg", "commit_id": "d1cacdb8dda4eb2a5532267b0aeb1d2afdf95f05", "target": 0, "func": "static av_cold int a64multi_init_encoder(AVCodecContext *avctx)\n\n{\n\n    A64Context *c = avctx->priv_data;\n\n    int a;\n\n    av_lfg_init(&c->randctx, 1);\n\n\n\n    if (avctx->global_quality < 1) {\n\n        c->mc_lifetime = 4;\n\n    } else {\n\n        c->mc_lifetime = avctx->global_quality /= FF_QP2LAMBDA;\n\n    }\n\n\n\n    av_log(avctx, AV_LOG_INFO, \"charset lifetime set to %d frame(s)\\n\", c->mc_lifetime);\n\n\n\n    /* precalc luma values for later use */\n\n    for (a = 0; a < 5; a++) {\n\n        c->mc_luma_vals[a]=a64_palette[mc_colors[a]][0] * 0.30 +\n\n                           a64_palette[mc_colors[a]][1] * 0.59 +\n\n                           a64_palette[mc_colors[a]][2] * 0.11;\n\n    }\n\n\n\n    c->mc_frame_counter = 0;\n\n    c->mc_use_5col      = avctx->codec->id == CODEC_ID_A64_MULTI5;\n\n    c->mc_meta_charset  = av_malloc (32000 * c->mc_lifetime * sizeof(int));\n\n    c->mc_best_cb       = av_malloc (CHARSET_CHARS * 32 * sizeof(int));\n\n    c->mc_charmap       = av_mallocz(1000 * c->mc_lifetime * sizeof(int));\n\n    c->mc_colram        = av_mallocz(CHARSET_CHARS * sizeof(uint8_t));\n\n    c->mc_charset       = av_malloc (0x800 * (INTERLACED+1) * sizeof(uint8_t));\n\n\n\n    /* set up extradata */\n\n    avctx->extradata      = av_mallocz(8 * 4 + FF_INPUT_BUFFER_PADDING_SIZE);\n\n    avctx->extradata_size = 8 * 4;\n\n    AV_WB32(avctx->extradata, c->mc_lifetime);\n\n    AV_WB32(avctx->extradata+16, INTERLACED);\n\n\n\n    avcodec_get_frame_defaults(&c->picture);\n\n    avctx->coded_frame            = &c->picture;\n\n    avctx->coded_frame->pict_type = FF_I_TYPE;\n\n    avctx->coded_frame->key_frame = 1;\n\n    if (!avctx->codec_tag)\n\n         avctx->codec_tag = AV_RL32(\"a64m\");\n\n\n\n    return 0;\n\n}\n", "idx": 22091}
{"project": "qemu", "commit_id": "5b8d7289e9e92a0d7bcecb93cd189e245fef10cd", "target": 0, "func": "static bool insn_crosses_page(CPUARMState *env, DisasContext *s)\n\n{\n\n    /* Return true if the insn at dc->pc might cross a page boundary.\n\n     * (False positives are OK, false negatives are not.)\n\n     */\n\n    uint16_t insn;\n\n\n\n    if ((s->pc & 3) == 0) {\n\n        /* At a 4-aligned address we can't be crossing a page */\n\n        return false;\n\n    }\n\n\n\n    /* This must be a Thumb insn */\n\n    insn = arm_lduw_code(env, s->pc, s->sctlr_b);\n\n\n\n    if ((insn >> 11) >= 0x1d) {\n\n        /* Top five bits 0b11101 / 0b11110 / 0b11111 : this is the\n\n         * First half of a 32-bit Thumb insn. Thumb-1 cores might\n\n         * end up actually treating this as two 16-bit insns (see the\n\n         * code at the start of disas_thumb2_insn()) but we don't bother\n\n         * to check for that as it is unlikely, and false positives here\n\n         * are harmless.\n\n         */\n\n        return true;\n\n    }\n\n    /* Definitely a 16-bit insn, can't be crossing a page. */\n\n    return false;\n\n}\n", "idx": 22097}
{"project": "qemu", "commit_id": "a702b35388c307ce2364691e2edc14094701c81e", "target": 0, "func": "static uint32_t slavio_timer_mem_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n    SLAVIO_TIMERState *s = opaque;\n\n    uint32_t saddr, ret;\n\n\n\n    saddr = (addr & TIMER_MAXADDR) >> 2;\n\n    switch (saddr) {\n\n    case 0:\n\n        // read limit (system counter mode) or read most signifying\n\n        // part of counter (user mode)\n\n        if (slavio_timer_is_user(s)) {\n\n            // read user timer MSW\n\n            slavio_timer_get_out(s);\n\n            ret = s->counthigh;\n\n        } else {\n\n            // read limit\n\n            // clear irq\n\n            qemu_irq_lower(s->irq);\n\n            s->reached = 0;\n\n            ret = s->limit & 0x7fffffff;\n\n        }\n\n        break;\n\n    case 1:\n\n        // read counter and reached bit (system mode) or read lsbits\n\n        // of counter (user mode)\n\n        slavio_timer_get_out(s);\n\n        if (slavio_timer_is_user(s)) // read user timer LSW\n\n            ret = s->count & 0xffffffe00;\n\n        else // read limit\n\n            ret = (s->count & 0x7ffffe00) | s->reached;\n\n        break;\n\n    case 3:\n\n        // only available in processor counter/timer\n\n        // read start/stop status\n\n        ret = s->running;\n\n        break;\n\n    case 4:\n\n        // only available in system counter\n\n        // read user/system mode\n\n        ret = s->slave_mode;\n\n        break;\n\n    default:\n\n        DPRINTF(\"invalid read address \" TARGET_FMT_plx \"\\n\", addr);\n\n        ret = 0;\n\n        break;\n\n    }\n\n    DPRINTF(\"read \" TARGET_FMT_plx \" = %08x\\n\", addr, ret);\n\n\n\n    return ret;\n\n}\n", "idx": 22105}
{"project": "FFmpeg", "commit_id": "1c37848f9029985d1271da9a0d161c2ebf0aca81", "target": 1, "func": "static int webm_dash_manifest_write_header(AVFormatContext *s)\n\n{\n\n    int i;\n\n    double start = 0.0;\n\n    WebMDashMuxContext *w = s->priv_data;\n\n    parse_adaptation_sets(s);\n\n    write_header(s);\n\n    avio_printf(s->pb, \"<Period id=\\\"0\\\"\");\n\n    avio_printf(s->pb, \" start=\\\"PT%gS\\\"\", start);\n\n    if (!w->is_live) {\n\n        avio_printf(s->pb, \" duration=\\\"PT%gS\\\"\", get_duration(s));\n\n    }\n\n    avio_printf(s->pb, \" >\\n\");\n\n\n\n    for (i = 0; i < w->nb_as; i++) {\n\n        if (write_adaptation_set(s, i) < 0) return -1;\n\n    }\n\n\n\n    avio_printf(s->pb, \"</Period>\\n\");\n\n    write_footer(s);\n\n    return 0;\n\n}\n", "idx": 22124}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void gic_dist_writeb(void *opaque, target_phys_addr_t offset,\n\n                            uint32_t value)\n\n{\n\n    GICState *s = (GICState *)opaque;\n\n    int irq;\n\n    int i;\n\n    int cpu;\n\n\n\n    cpu = gic_get_current_cpu(s);\n\n    if (offset < 0x100) {\n\n        if (offset == 0) {\n\n            s->enabled = (value & 1);\n\n            DPRINTF(\"Distribution %sabled\\n\", s->enabled ? \"En\" : \"Dis\");\n\n        } else if (offset < 4) {\n\n            /* ignored.  */\n\n        } else if (offset >= 0x80) {\n\n            /* Interrupt Security Registers, RAZ/WI */\n\n        } else {\n\n            goto bad_reg;\n\n        }\n\n    } else if (offset < 0x180) {\n\n        /* Interrupt Set Enable.  */\n\n        irq = (offset - 0x100) * 8 + GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        if (irq < 16)\n\n          value = 0xff;\n\n        for (i = 0; i < 8; i++) {\n\n            if (value & (1 << i)) {\n\n                int mask = (irq < GIC_INTERNAL) ? (1 << cpu) : GIC_TARGET(irq);\n\n                int cm = (irq < GIC_INTERNAL) ? (1 << cpu) : ALL_CPU_MASK;\n\n\n\n                if (!GIC_TEST_ENABLED(irq + i, cm)) {\n\n                    DPRINTF(\"Enabled IRQ %d\\n\", irq + i);\n\n                }\n\n                GIC_SET_ENABLED(irq + i, cm);\n\n                /* If a raised level triggered IRQ enabled then mark\n\n                   is as pending.  */\n\n                if (GIC_TEST_LEVEL(irq + i, mask)\n\n                        && !GIC_TEST_TRIGGER(irq + i)) {\n\n                    DPRINTF(\"Set %d pending mask %x\\n\", irq + i, mask);\n\n                    GIC_SET_PENDING(irq + i, mask);\n\n                }\n\n            }\n\n        }\n\n    } else if (offset < 0x200) {\n\n        /* Interrupt Clear Enable.  */\n\n        irq = (offset - 0x180) * 8 + GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        if (irq < 16)\n\n          value = 0;\n\n        for (i = 0; i < 8; i++) {\n\n            if (value & (1 << i)) {\n\n                int cm = (irq < GIC_INTERNAL) ? (1 << cpu) : ALL_CPU_MASK;\n\n\n\n                if (GIC_TEST_ENABLED(irq + i, cm)) {\n\n                    DPRINTF(\"Disabled IRQ %d\\n\", irq + i);\n\n                }\n\n                GIC_CLEAR_ENABLED(irq + i, cm);\n\n            }\n\n        }\n\n    } else if (offset < 0x280) {\n\n        /* Interrupt Set Pending.  */\n\n        irq = (offset - 0x200) * 8 + GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        if (irq < 16)\n\n          irq = 0;\n\n\n\n        for (i = 0; i < 8; i++) {\n\n            if (value & (1 << i)) {\n\n                GIC_SET_PENDING(irq + i, GIC_TARGET(irq));\n\n            }\n\n        }\n\n    } else if (offset < 0x300) {\n\n        /* Interrupt Clear Pending.  */\n\n        irq = (offset - 0x280) * 8 + GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        for (i = 0; i < 8; i++) {\n\n            /* ??? This currently clears the pending bit for all CPUs, even\n\n               for per-CPU interrupts.  It's unclear whether this is the\n\n               corect behavior.  */\n\n            if (value & (1 << i)) {\n\n                GIC_CLEAR_PENDING(irq + i, ALL_CPU_MASK);\n\n            }\n\n        }\n\n    } else if (offset < 0x400) {\n\n        /* Interrupt Active.  */\n\n        goto bad_reg;\n\n    } else if (offset < 0x800) {\n\n        /* Interrupt Priority.  */\n\n        irq = (offset - 0x400) + GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        if (irq < GIC_INTERNAL) {\n\n            s->priority1[irq][cpu] = value;\n\n        } else {\n\n            s->priority2[irq - GIC_INTERNAL] = value;\n\n        }\n\n    } else if (offset < 0xc00) {\n\n        /* Interrupt CPU Target. RAZ/WI on uniprocessor GICs, with the\n\n         * annoying exception of the 11MPCore's GIC.\n\n         */\n\n        if (s->num_cpu != 1 || s->revision == REV_11MPCORE) {\n\n            irq = (offset - 0x800) + GIC_BASE_IRQ;\n\n            if (irq >= s->num_irq) {\n\n                goto bad_reg;\n\n            }\n\n            if (irq < 29) {\n\n                value = 0;\n\n            } else if (irq < GIC_INTERNAL) {\n\n                value = ALL_CPU_MASK;\n\n            }\n\n            s->irq_target[irq] = value & ALL_CPU_MASK;\n\n        }\n\n    } else if (offset < 0xf00) {\n\n        /* Interrupt Configuration.  */\n\n        irq = (offset - 0xc00) * 4 + GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        if (irq < GIC_INTERNAL)\n\n            value |= 0xaa;\n\n        for (i = 0; i < 4; i++) {\n\n            if (value & (1 << (i * 2))) {\n\n                GIC_SET_MODEL(irq + i);\n\n            } else {\n\n                GIC_CLEAR_MODEL(irq + i);\n\n            }\n\n            if (value & (2 << (i * 2))) {\n\n                GIC_SET_TRIGGER(irq + i);\n\n            } else {\n\n                GIC_CLEAR_TRIGGER(irq + i);\n\n            }\n\n        }\n\n    } else {\n\n        /* 0xf00 is only handled for 32-bit writes.  */\n\n        goto bad_reg;\n\n    }\n\n    gic_update(s);\n\n    return;\n\nbad_reg:\n\n    hw_error(\"gic_dist_writeb: Bad offset %x\\n\", (int)offset);\n\n}\n", "idx": 22190}
{"project": "qemu", "commit_id": "aa4a3dce1c88ed51b616806b8214b7c8428b7470", "target": 1, "func": "static void vmxnet3_handle_command(VMXNET3State *s, uint64_t cmd)\n\n{\n\n    s->last_command = cmd;\n\n\n\n    switch (cmd) {\n\n    case VMXNET3_CMD_GET_PERM_MAC_HI:\n\n        VMW_CBPRN(\"Set: Get upper part of permanent MAC\");\n\n        break;\n\n\n\n    case VMXNET3_CMD_GET_PERM_MAC_LO:\n\n        VMW_CBPRN(\"Set: Get lower part of permanent MAC\");\n\n        break;\n\n\n\n    case VMXNET3_CMD_GET_STATS:\n\n        VMW_CBPRN(\"Set: Get device statistics\");\n\n        vmxnet3_fill_stats(s);\n\n        break;\n\n\n\n    case VMXNET3_CMD_ACTIVATE_DEV:\n\n        VMW_CBPRN(\"Set: Activating vmxnet3 device\");\n\n        vmxnet3_activate_device(s);\n\n        break;\n\n\n\n    case VMXNET3_CMD_UPDATE_RX_MODE:\n\n        VMW_CBPRN(\"Set: Update rx mode\");\n\n        vmxnet3_update_rx_mode(s);\n\n        break;\n\n\n\n    case VMXNET3_CMD_UPDATE_VLAN_FILTERS:\n\n        VMW_CBPRN(\"Set: Update VLAN filters\");\n\n        vmxnet3_update_vlan_filters(s);\n\n        break;\n\n\n\n    case VMXNET3_CMD_UPDATE_MAC_FILTERS:\n\n        VMW_CBPRN(\"Set: Update MAC filters\");\n\n        vmxnet3_update_mcast_filters(s);\n\n        break;\n\n\n\n    case VMXNET3_CMD_UPDATE_FEATURE:\n\n        VMW_CBPRN(\"Set: Update features\");\n\n        vmxnet3_update_features(s);\n\n        break;\n\n\n\n    case VMXNET3_CMD_UPDATE_PMCFG:\n\n        VMW_CBPRN(\"Set: Update power management config\");\n\n        vmxnet3_update_pm_state(s);\n\n        break;\n\n\n\n    case VMXNET3_CMD_GET_LINK:\n\n        VMW_CBPRN(\"Set: Get link\");\n\n        break;\n\n\n\n    case VMXNET3_CMD_RESET_DEV:\n\n        VMW_CBPRN(\"Set: Reset device\");\n\n        vmxnet3_reset(s);\n\n        break;\n\n\n\n    case VMXNET3_CMD_QUIESCE_DEV:\n\n        VMW_CBPRN(\"Set: VMXNET3_CMD_QUIESCE_DEV - pause the device\");\n\n        vmxnet3_deactivate_device(s);\n\n        break;\n\n\n\n    case VMXNET3_CMD_GET_CONF_INTR:\n\n        VMW_CBPRN(\"Set: VMXNET3_CMD_GET_CONF_INTR - interrupt configuration\");\n\n        break;\n\n\n\n    case VMXNET3_CMD_GET_ADAPTIVE_RING_INFO:\n\n        VMW_CBPRN(\"Set: VMXNET3_CMD_GET_ADAPTIVE_RING_INFO - \"\n\n                  \"adaptive ring info flags\");\n\n        break;\n\n\n\n    default:\n\n        VMW_CBPRN(\"Received unknown command: %\" PRIx64, cmd);\n\n        break;\n\n    }\n\n}\n", "idx": 22226}
{"project": "FFmpeg", "commit_id": "fbdb2059684ff27be61cfe40446e68cb2f9a12f8", "target": 0, "func": "static int encode_init(AVCodecContext * avctx){\n\n    WMACodecContext *s = avctx->priv_data;\n\n    int i, flags1, flags2;\n\n    uint8_t *extradata;\n\n\n\n    s->avctx = avctx;\n\n\n\n    if(avctx->channels > MAX_CHANNELS) {\n\n        av_log(avctx, AV_LOG_ERROR, \"too many channels: got %i, need %i or fewer\",\n\n               avctx->channels, MAX_CHANNELS);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if (avctx->sample_rate > 48000) {\n\n        av_log(avctx, AV_LOG_ERROR, \"sample rate is too high: %d > 48kHz\",\n\n               avctx->sample_rate);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if(avctx->bit_rate < 24*1000) {\n\n        av_log(avctx, AV_LOG_ERROR, \"bitrate too low: got %i, need 24000 or higher\\n\",\n\n               avctx->bit_rate);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    /* extract flag infos */\n\n    flags1 = 0;\n\n    flags2 = 1;\n\n    if (avctx->codec->id == CODEC_ID_WMAV1) {\n\n        extradata= av_malloc(4);\n\n        avctx->extradata_size= 4;\n\n        AV_WL16(extradata, flags1);\n\n        AV_WL16(extradata+2, flags2);\n\n    } else if (avctx->codec->id == CODEC_ID_WMAV2) {\n\n        extradata= av_mallocz(10);\n\n        avctx->extradata_size= 10;\n\n        AV_WL32(extradata, flags1);\n\n        AV_WL16(extradata+4, flags2);\n\n    }else\n\n        av_assert0(0);\n\n    avctx->extradata= extradata;\n\n    s->use_exp_vlc = flags2 & 0x0001;\n\n    s->use_bit_reservoir = flags2 & 0x0002;\n\n    s->use_variable_block_len = flags2 & 0x0004;\n\n    if (avctx->channels == 2)\n\n        s->ms_stereo = 1;\n\n\n\n    ff_wma_init(avctx, flags2);\n\n\n\n    /* init MDCT */\n\n    for(i = 0; i < s->nb_block_sizes; i++)\n\n        ff_mdct_init(&s->mdct_ctx[i], s->frame_len_bits - i + 1, 0, 1.0);\n\n\n\n    s->block_align     = avctx->bit_rate * (int64_t)s->frame_len /\n\n                         (avctx->sample_rate * 8);\n\n    s->block_align     = FFMIN(s->block_align, MAX_CODED_SUPERFRAME_SIZE);\n\n    avctx->block_align = s->block_align;\n\n    avctx->bit_rate    = avctx->block_align * 8LL * avctx->sample_rate /\n\n                         s->frame_len;\n\n//av_log(NULL, AV_LOG_ERROR, \"%d %d %d %d\\n\", s->block_align, avctx->bit_rate, s->frame_len, avctx->sample_rate);\n\n    avctx->frame_size = avctx->delay = s->frame_len;\n\n\n\n#if FF_API_OLD_ENCODE_AUDIO\n\n    avctx->coded_frame = &s->frame;\n\n    avcodec_get_frame_defaults(avctx->coded_frame);\n\n#endif\n\n\n\n    return 0;\n\n}\n", "idx": 22333}
{"project": "qemu", "commit_id": "488d65772ce94aa439f26d7136db384aec460bcb", "target": 1, "func": "static void check_watchpoint(int offset, int len_mask, int flags)\n\n{\n\n    CPUState *env = cpu_single_env;\n\n    target_ulong pc, cs_base;\n\n    TranslationBlock *tb;\n\n    target_ulong vaddr;\n\n    CPUWatchpoint *wp;\n\n    int cpu_flags;\n\n\n\n    if (env->watchpoint_hit) {\n\n        /* We re-entered the check after replacing the TB. Now raise\n\n         * the debug interrupt so that is will trigger after the\n\n         * current instruction. */\n\n        cpu_interrupt(env, CPU_INTERRUPT_DEBUG);\n\n        return;\n\n    }\n\n    vaddr = (env->mem_io_vaddr & TARGET_PAGE_MASK) + offset;\n\n    QTAILQ_FOREACH(wp, &env->watchpoints, entry) {\n\n        if ((vaddr == (wp->vaddr & len_mask) ||\n\n             (vaddr & wp->len_mask) == wp->vaddr) && (wp->flags & flags)) {\n\n            wp->flags |= BP_WATCHPOINT_HIT;\n\n            if (!env->watchpoint_hit) {\n\n                env->watchpoint_hit = wp;\n\n                tb = tb_find_pc(env->mem_io_pc);\n\n                if (!tb) {\n\n                    cpu_abort(env, \"check_watchpoint: could not find TB for \"\n\n                              \"pc=%p\", (void *)env->mem_io_pc);\n\n                }\n\n                cpu_restore_state(tb, env, env->mem_io_pc);\n\n                tb_phys_invalidate(tb, -1);\n\n                if (wp->flags & BP_STOP_BEFORE_ACCESS) {\n\n                    env->exception_index = EXCP_DEBUG;\n\n                } else {\n\n                    cpu_get_tb_cpu_state(env, &pc, &cs_base, &cpu_flags);\n\n                    tb_gen_code(env, pc, cs_base, cpu_flags, 1);\n\n                }\n\n                cpu_resume_from_signal(env, NULL);\n\n            }\n\n        } else {\n\n            wp->flags &= ~BP_WATCHPOINT_HIT;\n\n        }\n\n    }\n\n}\n", "idx": 22350}
{"project": "qemu", "commit_id": "5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b", "target": 0, "func": "static void vnc_write_s32(VncState *vs, int32_t value)\n\n{\n\n    vnc_write_u32(vs, *(uint32_t *)&value);\n\n}\n", "idx": 22415}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "static int vnc_zlib_stop(VncState *vs)\n\n{\n\n    z_streamp zstream = &vs->zlib_stream;\n\n    int previous_out;\n\n\n\n    // switch back to normal output/zlib buffers\n\n    vs->zlib = vs->output;\n\n    vs->output = vs->zlib_tmp;\n\n\n\n    // compress the zlib buffer\n\n\n\n    // initialize the stream\n\n    // XXX need one stream per session\n\n    if (zstream->opaque != vs) {\n\n        int err;\n\n\n\n        VNC_DEBUG(\"VNC: initializing zlib stream\\n\");\n\n        VNC_DEBUG(\"VNC: opaque = %p | vs = %p\\n\", zstream->opaque, vs);\n\n        zstream->zalloc = vnc_zlib_zalloc;\n\n        zstream->zfree = vnc_zlib_zfree;\n\n\n\n        err = deflateInit2(zstream, vs->tight_compression, Z_DEFLATED, MAX_WBITS,\n\n                           MAX_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n\n\n\n        if (err != Z_OK) {\n\n            fprintf(stderr, \"VNC: error initializing zlib\\n\");\n\n            return -1;\n\n        }\n\n\n\n        vs->zlib_level = vs->tight_compression;\n\n        zstream->opaque = vs;\n\n    }\n\n\n\n    if (vs->tight_compression != vs->zlib_level) {\n\n        if (deflateParams(zstream, vs->tight_compression,\n\n                          Z_DEFAULT_STRATEGY) != Z_OK) {\n\n            return -1;\n\n        }\n\n        vs->zlib_level = vs->tight_compression;\n\n    }\n\n\n\n    // reserve memory in output buffer\n\n    buffer_reserve(&vs->output, vs->zlib.offset + 64);\n\n\n\n    // set pointers\n\n    zstream->next_in = vs->zlib.buffer;\n\n    zstream->avail_in = vs->zlib.offset;\n\n    zstream->next_out = vs->output.buffer + vs->output.offset;\n\n    zstream->avail_out = vs->output.capacity - vs->output.offset;\n\n    zstream->data_type = Z_BINARY;\n\n    previous_out = zstream->total_out;\n\n\n\n    // start encoding\n\n    if (deflate(zstream, Z_SYNC_FLUSH) != Z_OK) {\n\n        fprintf(stderr, \"VNC: error during zlib compression\\n\");\n\n        return -1;\n\n    }\n\n\n\n    vs->output.offset = vs->output.capacity - zstream->avail_out;\n\n    return zstream->total_out - previous_out;\n\n}\n", "idx": 22423}
{"project": "FFmpeg", "commit_id": "4d59d075a96c7bc9fc7a118f96015fbf5156708a", "target": 0, "func": "static void check_rgb2yuv(void)\n\n{\n\n    declare_func(void, uint8_t *dst[3], ptrdiff_t dst_stride[3],\n\n                 int16_t *src[3], ptrdiff_t src_stride,\n\n                 int w, int h, const int16_t coeff[3][3][8],\n\n                 const int16_t off[8]);\n\n    ColorSpaceDSPContext dsp;\n\n    int odepth, fmt, n;\n\n    LOCAL_ALIGNED_32(int16_t, src_y, [W * H * 2]);\n\n    LOCAL_ALIGNED_32(int16_t, src_u, [W * H * 2]);\n\n    LOCAL_ALIGNED_32(int16_t, src_v, [W * H * 2]);\n\n    int16_t *src[3] = { src_y, src_u, src_v };\n\n    LOCAL_ALIGNED_32(uint8_t, dst0_y, [W * H]);\n\n    LOCAL_ALIGNED_32(uint8_t, dst0_u, [W * H]);\n\n    LOCAL_ALIGNED_32(uint8_t, dst0_v, [W * H]);\n\n    LOCAL_ALIGNED_32(uint8_t, dst1_y, [W * H]);\n\n    LOCAL_ALIGNED_32(uint8_t, dst1_u, [W * H]);\n\n    LOCAL_ALIGNED_32(uint8_t, dst1_v, [W * H]);\n\n    uint8_t *dst0[3] = { dst0_y, dst0_u, dst0_v }, *dst1[3] = { dst1_y, dst1_u, dst1_v };\n\n    LOCAL_ALIGNED_32(int16_t, offset, [8]);\n\n    LOCAL_ALIGNED_32(int16_t, coeff_buf, [3 * 3 * 8]);\n\n    int16_t (*coeff)[3][8] = (int16_t(*)[3][8]) coeff_buf;\n\n\n\n    ff_colorspacedsp_init(&dsp);\n\n    for (n = 0; n < 8; n++) {\n\n        offset[n] = 16;\n\n\n\n        // these somewhat resemble bt601/smpte170m coefficients\n\n        coeff[0][0][n] = lrint(0.3 * (1 << 14));\n\n        coeff[0][1][n] = lrint(0.6 * (1 << 14));\n\n        coeff[0][2][n] = lrint(0.1 * (1 << 14));\n\n        coeff[1][0][n] = lrint(-0.15 * (1 << 14));\n\n        coeff[1][1][n] = lrint(-0.35 * (1 << 14));\n\n        coeff[1][2][n] = lrint(0.5 * (1 << 14));\n\n        coeff[2][0][n] = lrint(0.5 * (1 << 14));\n\n        coeff[2][1][n] = lrint(-0.42 * (1 << 14));\n\n        coeff[2][2][n] = lrint(-0.08 * (1 << 14));\n\n    }\n\n    for (odepth = 0; odepth < 3; odepth++) {\n\n        for (fmt = 0; fmt < 3; fmt++) {\n\n            if (check_func(dsp.rgb2yuv[odepth][fmt],\n\n                           \"ff_colorspacedsp_rgb2yuv_%sp%d\",\n\n                           format_string[fmt], odepth * 2 + 8)) {\n\n                int ss_w = !!fmt, ss_h = fmt == 2;\n\n                int y_dst_stride = W << !!odepth;\n\n                int uv_dst_stride = y_dst_stride >> ss_w;\n\n\n\n                randomize_buffers();\n\n                call_ref(dst0, (ptrdiff_t[3]) { y_dst_stride, uv_dst_stride, uv_dst_stride },\n\n                         src, W, W, H, coeff, offset);\n\n                call_new(dst1, (ptrdiff_t[3]) { y_dst_stride, uv_dst_stride, uv_dst_stride },\n\n                         src, W, W, H, coeff, offset);\n\n                if (memcmp(dst0[0], dst1[0], H * y_dst_stride) ||\n\n                    memcmp(dst0[1], dst1[1], H * uv_dst_stride >> ss_h) ||\n\n                    memcmp(dst0[2], dst1[2], H * uv_dst_stride >> ss_h)) {\n\n                    fail();\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    report(\"rgb2yuv\");\n\n}\n", "idx": 22456}
{"project": "FFmpeg", "commit_id": "0491a2a07a44f6e5e6f34081835e402c07025fd2", "target": 0, "func": "static char *time_value_string(char *buf, int buf_size, int64_t val, const AVRational *time_base)\n\n{\n\n    if (val == AV_NOPTS_VALUE) {\n\n        snprintf(buf, buf_size, \"N/A\");\n\n    } else {\n\n        double d = val * av_q2d(*time_base);\n\n        value_string(buf, buf_size, (struct unit_value){.val.d=d, .unit=unit_second_str});\n\n    }\n\n\n\n    return buf;\n\n}\n", "idx": 22511}
{"project": "qemu", "commit_id": "7e84c2498f0ff3999937d18d1e9abaa030400000", "target": 0, "func": "void helper_ljmp_protected_T0_T1(void)\n\n{\n\n    int new_cs, new_eip;\n\n    uint32_t e1, e2, cpl, dpl, rpl, limit;\n\n\n\n    new_cs = T0;\n\n    new_eip = T1;\n\n    if ((new_cs & 0xfffc) == 0)\n\n        raise_exception_err(EXCP0D_GPF, 0);\n\n    if (load_segment(&e1, &e2, new_cs) != 0)\n\n        raise_exception_err(EXCP0D_GPF, new_cs & 0xfffc);\n\n    cpl = env->hflags & HF_CPL_MASK;\n\n    if (e2 & DESC_S_MASK) {\n\n        if (!(e2 & DESC_CS_MASK))\n\n            raise_exception_err(EXCP0D_GPF, new_cs & 0xfffc);\n\n        dpl = (e2 >> DESC_DPL_SHIFT) & 3;\n\n        if (e2 & DESC_CS_MASK) {\n\n            /* conforming code segment */\n\n            if (dpl > cpl)\n\n                raise_exception_err(EXCP0D_GPF, new_cs & 0xfffc);\n\n        } else {\n\n            /* non conforming code segment */\n\n            rpl = new_cs & 3;\n\n            if (rpl > cpl)\n\n                raise_exception_err(EXCP0D_GPF, new_cs & 0xfffc);\n\n            if (dpl != cpl)\n\n                raise_exception_err(EXCP0D_GPF, new_cs & 0xfffc);\n\n        }\n\n        if (!(e2 & DESC_P_MASK))\n\n            raise_exception_err(EXCP0B_NOSEG, new_cs & 0xfffc);\n\n        limit = get_seg_limit(e1, e2);\n\n        if (new_eip > limit)\n\n            raise_exception_err(EXCP0D_GPF, new_cs & 0xfffc);\n\n        cpu_x86_load_seg_cache(env, R_CS, (new_cs & 0xfffc) | cpl,\n\n                       get_seg_base(e1, e2), limit, e2);\n\n        EIP = new_eip;\n\n    } else {\n\n        cpu_abort(env, \"jmp to call/task gate not supported 0x%04x:0x%08x\", \n\n                  new_cs, new_eip);\n\n    }\n\n}\n", "idx": 22553}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int socket_get_fd(void *opaque)\n\n{\n\n    QEMUFileSocket *s = opaque;\n\n\n\n    return s->fd;\n\n}\n", "idx": 22666}
{"project": "qemu", "commit_id": "3a5c76baf312d83cb77c8faa72c5f7a477effed0", "target": 0, "func": "static void sun4uv_init(MemoryRegion *address_space_mem,\n\n                        MachineState *machine,\n\n                        const struct hwdef *hwdef)\n\n{\n\n    SPARCCPU *cpu;\n\n    Nvram *nvram;\n\n    unsigned int i;\n\n    uint64_t initrd_addr, initrd_size, kernel_addr, kernel_size, kernel_entry;\n\n    PCIBus *pci_bus, *pci_bus2, *pci_bus3;\n\n    ISABus *isa_bus;\n\n    SysBusDevice *s;\n\n    qemu_irq *ivec_irqs, *pbm_irqs;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    DriveInfo *fd[MAX_FD];\n\n    FWCfgState *fw_cfg;\n\n\n\n    /* init CPUs */\n\n    cpu = cpu_devinit(machine->cpu_model, hwdef);\n\n\n\n    /* set up devices */\n\n    ram_init(0, machine->ram_size);\n\n\n\n    prom_init(hwdef->prom_addr, bios_name);\n\n\n\n    ivec_irqs = qemu_allocate_irqs(cpu_set_ivec_irq, cpu, IVEC_MAX);\n\n    pci_bus = pci_apb_init(APB_SPECIAL_BASE, APB_MEM_BASE, ivec_irqs, &pci_bus2,\n\n                           &pci_bus3, &pbm_irqs);\n\n    pci_vga_init(pci_bus);\n\n\n\n    // XXX Should be pci_bus3\n\n    isa_bus = pci_ebus_init(pci_bus, -1, pbm_irqs);\n\n\n\n    i = 0;\n\n    if (hwdef->console_serial_base) {\n\n        serial_mm_init(address_space_mem, hwdef->console_serial_base, 0,\n\n                       NULL, 115200, serial_hds[i], DEVICE_BIG_ENDIAN);\n\n        i++;\n\n    }\n\n\n\n    serial_hds_isa_init(isa_bus, MAX_SERIAL_PORTS);\n\n    parallel_hds_isa_init(isa_bus, MAX_PARALLEL_PORTS);\n\n\n\n    for(i = 0; i < nb_nics; i++)\n\n        pci_nic_init_nofail(&nd_table[i], pci_bus, \"ne2k_pci\", NULL);\n\n\n\n    ide_drive_get(hd, ARRAY_SIZE(hd));\n\n\n\n    pci_cmd646_ide_init(pci_bus, hd, 1);\n\n\n\n    isa_create_simple(isa_bus, \"i8042\");\n\n    for(i = 0; i < MAX_FD; i++) {\n\n        fd[i] = drive_get(IF_FLOPPY, 0, i);\n\n    }\n\n    fdctrl_init_isa(isa_bus, fd);\n\n\n\n    /* Map NVRAM into I/O (ebus) space */\n\n    nvram = m48t59_init(NULL, 0, 0, NVRAM_SIZE, 1968, 59);\n\n    s = SYS_BUS_DEVICE(nvram);\n\n    memory_region_add_subregion(get_system_io(), 0x2000,\n\n                                sysbus_mmio_get_region(s, 0));\n\n \n\n    initrd_size = 0;\n\n    initrd_addr = 0;\n\n    kernel_size = sun4u_load_kernel(machine->kernel_filename,\n\n                                    machine->initrd_filename,\n\n                                    ram_size, &initrd_size, &initrd_addr,\n\n                                    &kernel_addr, &kernel_entry);\n\n\n\n    sun4u_NVRAM_set_params(nvram, NVRAM_SIZE, \"Sun4u\", machine->ram_size,\n\n                           machine->boot_order,\n\n                           kernel_addr, kernel_size,\n\n                           machine->kernel_cmdline,\n\n                           initrd_addr, initrd_size,\n\n                           /* XXX: need an option to load a NVRAM image */\n\n                           0,\n\n                           graphic_width, graphic_height, graphic_depth,\n\n                           (uint8_t *)&nd_table[0].macaddr);\n\n\n\n    fw_cfg = fw_cfg_init_io(BIOS_CFG_IOPORT);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_MAX_CPUS, (uint16_t)max_cpus);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_KERNEL_ADDR, kernel_entry);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);\n\n    if (machine->kernel_cmdline) {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_CMDLINE_SIZE,\n\n                       strlen(machine->kernel_cmdline) + 1);\n\n        fw_cfg_add_string(fw_cfg, FW_CFG_CMDLINE_DATA, machine->kernel_cmdline);\n\n    } else {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_CMDLINE_SIZE, 0);\n\n    }\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_INITRD_ADDR, initrd_addr);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, machine->boot_order[0]);\n\n\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_SPARC64_WIDTH, graphic_width);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_SPARC64_HEIGHT, graphic_height);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_SPARC64_DEPTH, graphic_depth);\n\n\n\n    qemu_register_boot_set(fw_cfg_boot_set, fw_cfg);\n\n}\n", "idx": 22775}
{"project": "FFmpeg", "commit_id": "da2e774fd6841da7cede8c8ef30337449329727c", "target": 1, "func": "static int kmvc_decode_inter_8x8(KmvcContext * ctx, const uint8_t * src, int src_size, int w, int h)\n\n{\n\n    BitBuf bb;\n\n    int res, val;\n\n    int i, j;\n\n    int bx, by;\n\n    int l0x, l1x, l0y, l1y;\n\n    int mx, my;\n\n    const uint8_t *src_end = src + src_size;\n\n\n\n    kmvc_init_getbits(bb, src);\n\n\n\n    for (by = 0; by < h; by += 8)\n\n        for (bx = 0; bx < w; bx += 8) {\n\n            kmvc_getbit(bb, src, src_end, res);\n\n            if (!res) {\n\n                kmvc_getbit(bb, src, src_end, res);\n\n                if (!res) {     // fill whole 8x8 block\n\n                    if (src >= src_end) {\n\n                        av_log(ctx->avctx, AV_LOG_ERROR, \"Data overrun\\n\");\n\n                        return AVERROR_INVALIDDATA;\n\n                    }\n\n                    val = *src++;\n\n                    for (i = 0; i < 64; i++)\n\n                        BLK(ctx->cur, bx + (i & 0x7), by + (i >> 3)) = val;\n\n                } else {        // copy block from previous frame\n\n                    for (i = 0; i < 64; i++)\n\n                        BLK(ctx->cur, bx + (i & 0x7), by + (i >> 3)) =\n\n                            BLK(ctx->prev, bx + (i & 0x7), by + (i >> 3));\n\n                }\n\n            } else {            // handle four 4x4 subblocks\n\n                for (i = 0; i < 4; i++) {\n\n                    l0x = bx + (i & 1) * 4;\n\n                    l0y = by + (i & 2) * 2;\n\n                    kmvc_getbit(bb, src, src_end, res);\n\n                    if (!res) {\n\n                        kmvc_getbit(bb, src, src_end, res);\n\n                        if (!res) {     // fill whole 4x4 block\n\n                            if (src >= src_end) {\n\n                                av_log(ctx->avctx, AV_LOG_ERROR, \"Data overrun\\n\");\n\n                                return AVERROR_INVALIDDATA;\n\n                            }\n\n                            val = *src++;\n\n                            for (j = 0; j < 16; j++)\n\n                                BLK(ctx->cur, l0x + (j & 3), l0y + (j >> 2)) = val;\n\n                        } else {        // copy block\n\n                            if (src >= src_end) {\n\n                                av_log(ctx->avctx, AV_LOG_ERROR, \"Data overrun\\n\");\n\n                                return AVERROR_INVALIDDATA;\n\n                            }\n\n                            val = *src++;\n\n                            mx = (val & 0xF) - 8;\n\n                            my = (val >> 4) - 8;\n\n                            for (j = 0; j < 16; j++)\n\n                                BLK(ctx->cur, l0x + (j & 3), l0y + (j >> 2)) =\n\n                                    BLK(ctx->prev, l0x + (j & 3) + mx, l0y + (j >> 2) + my);\n\n                        }\n\n                    } else {    // descend to 2x2 sub-sub-blocks\n\n                        for (j = 0; j < 4; j++) {\n\n                            l1x = l0x + (j & 1) * 2;\n\n                            l1y = l0y + (j & 2);\n\n                            kmvc_getbit(bb, src, src_end, res);\n\n                            if (!res) {\n\n                                kmvc_getbit(bb, src, src_end, res);\n\n                                if (!res) {     // fill whole 2x2 block\n\n                                    if (src >= src_end) {\n\n                                        av_log(ctx->avctx, AV_LOG_ERROR, \"Data overrun\\n\");\n\n                                        return AVERROR_INVALIDDATA;\n\n                                    }\n\n                                    val = *src++;\n\n                                    BLK(ctx->cur, l1x, l1y) = val;\n\n                                    BLK(ctx->cur, l1x + 1, l1y) = val;\n\n                                    BLK(ctx->cur, l1x, l1y + 1) = val;\n\n                                    BLK(ctx->cur, l1x + 1, l1y + 1) = val;\n\n                                } else {        // copy block\n\n                                    if (src >= src_end) {\n\n                                        av_log(ctx->avctx, AV_LOG_ERROR, \"Data overrun\\n\");\n\n                                        return AVERROR_INVALIDDATA;\n\n                                    }\n\n                                    val = *src++;\n\n                                    mx = (val & 0xF) - 8;\n\n                                    my = (val >> 4) - 8;\n\n                                    BLK(ctx->cur, l1x, l1y) = BLK(ctx->prev, l1x + mx, l1y + my);\n\n                                    BLK(ctx->cur, l1x + 1, l1y) =\n\n                                        BLK(ctx->prev, l1x + 1 + mx, l1y + my);\n\n                                    BLK(ctx->cur, l1x, l1y + 1) =\n\n                                        BLK(ctx->prev, l1x + mx, l1y + 1 + my);\n\n                                    BLK(ctx->cur, l1x + 1, l1y + 1) =\n\n                                        BLK(ctx->prev, l1x + 1 + mx, l1y + 1 + my);\n\n                                }\n\n                            } else {    // read values for block\n\n                                BLK(ctx->cur, l1x, l1y) = *src++;\n\n                                BLK(ctx->cur, l1x + 1, l1y) = *src++;\n\n                                BLK(ctx->cur, l1x, l1y + 1) = *src++;\n\n                                BLK(ctx->cur, l1x + 1, l1y + 1) = *src++;\n\n                            }\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n        }\n\n\n\n    return 0;\n\n}\n", "idx": 22818}
{"project": "qemu", "commit_id": "cb5ef3fa1871522a0886627033459e94bd537fb7", "target": 1, "func": "static int tmp105_tx(I2CSlave *i2c, uint8_t data)\n\n{\n\n    TMP105State *s = (TMP105State *) i2c;\n\n\n\n    if (!s->len ++)\n\n        s->pointer = data;\n\n    else {\n\n        if (s->len <= 2)\n\n            s->buf[s->len - 1] = data;\n\n        tmp105_write(s);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 22837}
{"project": "qemu", "commit_id": "215e79c01c4e6f766eb9add56c56453e9ea1d948", "target": 0, "func": "static bool cpu_thread_is_idle(CPUState *cpu)\n\n{\n\n    if (cpu->stop || cpu->queued_work_first) {\n\n        return false;\n\n    }\n\n    if (cpu->stopped || !runstate_is_running()) {\n\n        return true;\n\n    }\n\n    if (!cpu->halted || qemu_cpu_has_work(cpu) ||\n\n        kvm_async_interrupts_enabled()) {\n\n        return false;\n\n    }\n\n    return true;\n\n}\n", "idx": 22855}
{"project": "FFmpeg", "commit_id": "9d0b45ade864f3d2ccd8610149fe1fff53c4e937", "target": 1, "func": "static int rprobe(AVFormatContext *s, uint8_t *enc_header, const uint8_t *r_val)\n\n{\n\n    OMAContext *oc = s->priv_data;\n\n    unsigned int pos;\n\n    struct AVDES av_des;\n\n\n\n    if (!enc_header || !r_val)\n\n        return -1;\n\n\n\n    /* m_val */\n\n    av_des_init(&av_des, r_val, 192, 1);\n\n    av_des_crypt(&av_des, oc->m_val, &enc_header[48], 1, NULL, 1);\n\n\n\n    /* s_val */\n\n    av_des_init(&av_des, oc->m_val, 64, 0);\n\n    av_des_crypt(&av_des, oc->s_val, NULL, 1, NULL, 0);\n\n\n\n    /* sm_val */\n\n    pos = OMA_ENC_HEADER_SIZE + oc->k_size + oc->e_size;\n\n    av_des_init(&av_des, oc->s_val, 64, 0);\n\n    av_des_mac(&av_des, oc->sm_val, &enc_header[pos], (oc->i_size >> 3));\n\n\n\n    pos += oc->i_size;\n\n\n\n    return memcmp(&enc_header[pos], oc->sm_val, 8) ? -1 : 0;\n\n}\n", "idx": 22895}
{"project": "FFmpeg", "commit_id": "dcbe15813ed09cf491e75a21cce0e751f5bc2b34", "target": 0, "func": "static int check_opcodes(MMCO *mmco1, MMCO *mmco2, int n_mmcos)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < n_mmcos; i++) {\n\n        if (mmco1[i].opcode != mmco2[i].opcode)\n\n            return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 22902}
{"project": "qemu", "commit_id": "fedf0d35aafc4f1f1e5f6dbc80cb23ae1ae49f0b", "target": 1, "func": "static VncJobQueue *vnc_queue_init(void)\n\n{\n\n    VncJobQueue *queue = g_malloc0(sizeof(VncJobQueue));\n\n\n\n    qemu_cond_init(&queue->cond);\n\n    qemu_mutex_init(&queue->mutex);\n\n    QTAILQ_INIT(&queue->jobs);\n\n    return queue;\n\n}\n", "idx": 22954}
{"project": "FFmpeg", "commit_id": "ef4c71e8f83a46fb31a11f0a066efb90821c579f", "target": 0, "func": "static int config_props(AVFilterLink *link)\n\n{\n\n    UnsharpContext *unsharp = link->dst->priv;\n\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(link->format);\n\n\n\n    unsharp->hsub = desc->log2_chroma_w;\n\n    unsharp->vsub = desc->log2_chroma_h;\n\n\n\n    init_filter_param(link->dst, &unsharp->luma,   \"luma\",   link->w);\n\n    init_filter_param(link->dst, &unsharp->chroma, \"chroma\", SHIFTUP(link->w, unsharp->hsub));\n\n\n\n    return 0;\n\n}\n", "idx": 23022}
{"project": "FFmpeg", "commit_id": "dc2e4c2e532b80565f5fbacd3a24a6db7567c257", "target": 0, "func": "static int64_t wav_seek_tag(AVIOContext *s, int64_t offset, int whence)\n\n{\n\n    offset += offset < INT64_MAX && offset & 1;\n\n\n\n    return avio_seek(s, offset, whence);\n\n}\n", "idx": 23027}
{"project": "qemu", "commit_id": "25cec2b896a977565ca04e5c649aab8c6e48bda8", "target": 1, "func": "void os_setup_post(void)\n\n{\n\n    int fd = 0;\n\n\n\n    if (daemonize) {\n\n        uint8_t status = 0;\n\n        ssize_t len;\n\n\n\n        do {        \n\n            len = write(daemon_pipe, &status, 1);\n\n        } while (len < 0 && errno == EINTR);\n\n        if (len != 1) {\n\n            exit(1);\n\n        }\n\n        if (chdir(\"/\")) {\n\n            perror(\"not able to chdir to /\");\n\n            exit(1);\n\n        }\n\n        TFR(fd = qemu_open(\"/dev/null\", O_RDWR));\n\n        if (fd == -1) {\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    change_root();\n\n    change_process_uid();\n\n\n\n    if (daemonize) {\n\n        dup2(fd, 0);\n\n        dup2(fd, 1);\n\n        dup2(fd, 2);\n\n\n\n        close(fd);\n\n    }\n\n}\n", "idx": 23093}
{"project": "FFmpeg", "commit_id": "91abb473fb8432226918da4fe03365ebaf688978", "target": 0, "func": "static void put_pixels_y2_mmx(UINT8 *block, const UINT8 *pixels, int line_size, int h)\n\n{\n\n#if 0\n\n  UINT8 *p;\n\n  const UINT8 *pix;\n\n  p = block;\n\n  pix = pixels;\n\n  MOVQ_ZERO(mm7);\n\n  MOVQ_WONE(mm4);\n\n  JUMPALIGN();\n\n  do {\n\n    __asm __volatile(\n\n\t\"movq\t%1, %%mm0\\n\\t\"\n\n\t\"movq\t%2, %%mm1\\n\\t\"\n\n\t\"movq\t%%mm0, %%mm2\\n\\t\"\n\n\t\"movq\t%%mm1, %%mm3\\n\\t\"\n\n\t\"punpcklbw %%mm7, %%mm0\\n\\t\"\n\n\t\"punpcklbw %%mm7, %%mm1\\n\\t\"\n\n\t\"punpckhbw %%mm7, %%mm2\\n\\t\"\n\n\t\"punpckhbw %%mm7, %%mm3\\n\\t\"\n\n\t\"paddusw %%mm1, %%mm0\\n\\t\"\n\n\t\"paddusw %%mm3, %%mm2\\n\\t\"\n\n\t\"paddusw %%mm4, %%mm0\\n\\t\"\n\n\t\"paddusw %%mm4, %%mm2\\n\\t\"\n\n\t\"psrlw\t$1, %%mm0\\n\\t\"\n\n\t\"psrlw\t$1, %%mm2\\n\\t\"\n\n\t\"packuswb  %%mm2, %%mm0\\n\\t\"\n\n\t\"movq\t%%mm0, %0\\n\\t\"\n\n\t:\"=m\"(*p)\n\n\t:\"m\"(*pix),\n\n\t \"m\"(*(pix+line_size))\n\n\t:\"memory\");\n\n   pix += line_size;\n\n   p += line_size;\n\n  } while (--h);\n\n#else\n\n  __asm __volatile(\n\n  \tMOVQ_BFE(%%mm7)\n\n\t\"lea (%3, %3), %%eax\t\\n\\t\"\n\n\t\"movq (%1), %%mm0\t\\n\\t\"\n\n\t\".balign 8     \t\t\\n\\t\"\n\n\t\"1:\t\t\t\\n\\t\"\n\n\t\"movq (%1, %3), %%mm1\t\\n\\t\"\n\n\t\"movq (%1, %%eax),%%mm2\t\\n\\t\"\n\n\tPAVG_MMX(%%mm1, %%mm0)\n\n\t\"movq %%mm6, (%2)\t\\n\\t\"\n\n\tPAVG_MMX(%%mm2, %%mm1)\n\n\t\"movq %%mm6, (%2, %3)\t\\n\\t\"\n\n\t\"addl %%eax, %1\t\t\\n\\t\"\n\n\t\"addl %%eax, %2\t\t\\n\\t\"\n\n#ifdef LONG_UNROLL\n\n\t\"movq (%1, %3), %%mm1\t\\n\\t\"\n\n\t\"movq (%1, %%eax),%%mm0\t\\n\\t\"\n\n\tPAVG_MMX(%%mm1, %%mm2)\n\n\t\"movq %%mm6, (%2)\t\\n\\t\"\n\n\tPAVG_MMX(%%mm0, %%mm1)\n\n\t\"movq %%mm6, (%2, %3)\t\\n\\t\"\n\n\t\"addl %%eax, %1\t\t\\n\\t\"\n\n\t\"addl %%eax, %2\t\t\\n\\t\"\n\n\t\"subl $4, %0\t\t\\n\\t\"\n\n#else\n\n\t\"subl $2, %0\t\t\\n\\t\"\n\n#endif\n\n\t\"jnz 1b\t\t\t\\n\\t\"\n\n\t:\"+g\"(h), \"+S\"(pixels), \"+D\"(block)\n\n\t:\"r\"(line_size)\n\n\t:\"eax\", \"memory\");\n\n#endif\n\n\n\n\n\n}\n", "idx": 23112}
{"project": "FFmpeg", "commit_id": "fd34dbea58e097609ff09cf7dcc59f74930195d3", "target": 1, "func": "static int mxf_read_index_table_segment(void *arg, AVIOContext *pb, int tag, int size, UID uid)\n\n{\n\n    MXFIndexTableSegment *segment = arg;\n\n    switch(tag) {\n\n    case 0x3F05:\n\n        segment->edit_unit_byte_count = avio_rb32(pb);\n\n        av_dlog(NULL, \"EditUnitByteCount %d\\n\", segment->edit_unit_byte_count);\n\n        break;\n\n    case 0x3F06:\n\n        segment->index_sid = avio_rb32(pb);\n\n        av_dlog(NULL, \"IndexSID %d\\n\", segment->index_sid);\n\n        break;\n\n    case 0x3F07:\n\n        segment->body_sid = avio_rb32(pb);\n\n        av_dlog(NULL, \"BodySID %d\\n\", segment->body_sid);\n\n        break;\n\n    case 0x3F08:\n\n        segment->slice_count = avio_r8(pb);\n\n        av_dlog(NULL, \"SliceCount %d\\n\", segment->slice_count);\n\n        break;\n\n    case 0x3F09:\n\n        av_dlog(NULL, \"DeltaEntryArray found\\n\");\n\n        return mxf_read_delta_entry_array(pb, segment);\n\n    case 0x3F0A:\n\n        av_dlog(NULL, \"IndexEntryArray found\\n\");\n\n        return mxf_read_index_entry_array(pb, segment);\n\n    case 0x3F0B:\n\n        segment->index_edit_rate.num = avio_rb32(pb);\n\n        segment->index_edit_rate.den = avio_rb32(pb);\n\n        av_dlog(NULL, \"IndexEditRate %d/%d\\n\", segment->index_edit_rate.num,\n\n                segment->index_edit_rate.den);\n\n        break;\n\n    case 0x3F0C:\n\n        segment->index_start_position = avio_rb64(pb);\n\n        av_dlog(NULL, \"IndexStartPosition %\"PRId64\"\\n\", segment->index_start_position);\n\n        break;\n\n    case 0x3F0D:\n\n        segment->index_duration = avio_rb64(pb);\n\n        av_dlog(NULL, \"IndexDuration %\"PRId64\"\\n\", segment->index_duration);\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 23160}
{"project": "qemu", "commit_id": "ed4f86e8b6eff8e600c69adee68c7cd34dd2cccb", "target": 1, "func": "int load_multiboot(FWCfgState *fw_cfg,\n                   FILE *f,\n                   const char *kernel_filename,\n                   const char *initrd_filename,\n                   const char *kernel_cmdline,\n                   int kernel_file_size,\n                   uint8_t *header)\n{\n    int i, is_multiboot = 0;\n    uint32_t flags = 0;\n    uint32_t mh_entry_addr;\n    uint32_t mh_load_addr;\n    uint32_t mb_kernel_size;\n    MultibootState mbs;\n    uint8_t bootinfo[MBI_SIZE];\n    uint8_t *mb_bootinfo_data;\n    uint32_t cmdline_len;\n    /* Ok, let's see if it is a multiboot image.\n       The header is 12x32bit long, so the latest entry may be 8192 - 48. */\n    for (i = 0; i < (8192 - 48); i += 4) {\n        if (ldl_p(header+i) == 0x1BADB002) {\n            uint32_t checksum = ldl_p(header+i+8);\n            flags = ldl_p(header+i+4);\n            checksum += flags;\n            checksum += (uint32_t)0x1BADB002;\n            if (!checksum) {\n                is_multiboot = 1;\n                break;\n    if (!is_multiboot)\n        return 0; /* no multiboot */\n    mb_debug(\"qemu: I believe we found a multiboot image!\\n\");\n    memset(bootinfo, 0, sizeof(bootinfo));\n    memset(&mbs, 0, sizeof(mbs));\n    if (flags & 0x00000004) { /* MULTIBOOT_HEADER_HAS_VBE */\n        fprintf(stderr, \"qemu: multiboot knows VBE. we don't.\\n\");\n    if (!(flags & 0x00010000)) { /* MULTIBOOT_HEADER_HAS_ADDR */\n        uint64_t elf_entry;\n        uint64_t elf_low, elf_high;\n        int kernel_size;\n        fclose(f);\n        if (((struct elf64_hdr*)header)->e_machine == EM_X86_64) {\n            fprintf(stderr, \"Cannot load x86-64 image, give a 32bit one.\\n\");\n        kernel_size = load_elf(kernel_filename, NULL, NULL, &elf_entry,\n                               &elf_low, &elf_high, 0, I386_ELF_MACHINE,\n                               0, 0);\n        if (kernel_size < 0) {\n            fprintf(stderr, \"Error while loading elf kernel\\n\");\n        mh_load_addr = elf_low;\n        mb_kernel_size = elf_high - elf_low;\n        mh_entry_addr = elf_entry;\n        mbs.mb_buf = g_malloc(mb_kernel_size);\n        if (rom_copy(mbs.mb_buf, mh_load_addr, mb_kernel_size) != mb_kernel_size) {\n            fprintf(stderr, \"Error while fetching elf kernel from rom\\n\");\n        mb_debug(\"qemu: loading multiboot-elf kernel (%#x bytes) with entry %#zx\\n\",\n                  mb_kernel_size, (size_t)mh_entry_addr);\n    } else {\n        /* Valid if mh_flags sets MULTIBOOT_HEADER_HAS_ADDR. */\n        uint32_t mh_header_addr = ldl_p(header+i+12);\n        uint32_t mh_load_end_addr = ldl_p(header+i+20);\n        uint32_t mh_bss_end_addr = ldl_p(header+i+24);\n        mh_load_addr = ldl_p(header+i+16);\n        uint32_t mb_kernel_text_offset = i - (mh_header_addr - mh_load_addr);\n        uint32_t mb_load_size = 0;\n        mh_entry_addr = ldl_p(header+i+28);\n        if (mh_load_end_addr) {\n            mb_kernel_size = mh_bss_end_addr - mh_load_addr;\n            mb_load_size = mh_load_end_addr - mh_load_addr;\n        } else {\n            mb_kernel_size = kernel_file_size - mb_kernel_text_offset;\n            mb_load_size = mb_kernel_size;\n        /* Valid if mh_flags sets MULTIBOOT_HEADER_HAS_VBE.\n        uint32_t mh_mode_type = ldl_p(header+i+32);\n        uint32_t mh_width = ldl_p(header+i+36);\n        uint32_t mh_height = ldl_p(header+i+40);\n        uint32_t mh_depth = ldl_p(header+i+44); */\n        mb_debug(\"multiboot: mh_header_addr = %#x\\n\", mh_header_addr);\n        mb_debug(\"multiboot: mh_load_addr = %#x\\n\", mh_load_addr);\n        mb_debug(\"multiboot: mh_load_end_addr = %#x\\n\", mh_load_end_addr);\n        mb_debug(\"multiboot: mh_bss_end_addr = %#x\\n\", mh_bss_end_addr);\n        mb_debug(\"qemu: loading multiboot kernel (%#x bytes) at %#x\\n\",\n                 mb_load_size, mh_load_addr);\n        mbs.mb_buf = g_malloc(mb_kernel_size);\n        fseek(f, mb_kernel_text_offset, SEEK_SET);\n        if (fread(mbs.mb_buf, 1, mb_load_size, f) != mb_load_size) {\n            fprintf(stderr, \"fread() failed\\n\");\n        memset(mbs.mb_buf + mb_load_size, 0, mb_kernel_size - mb_load_size);\n        fclose(f);\n    mbs.mb_buf_phys = mh_load_addr;\n    mbs.mb_buf_size = TARGET_PAGE_ALIGN(mb_kernel_size);\n    mbs.offset_mbinfo = mbs.mb_buf_size;\n    /* Calculate space for cmdlines, bootloader name, and mb_mods */\n    cmdline_len = strlen(kernel_filename) + 1;\n    cmdline_len += strlen(kernel_cmdline) + 1;\n    if (initrd_filename) {\n        const char *r = initrd_filename;\n        cmdline_len += strlen(r) + 1;\n        mbs.mb_mods_avail = 1;\n        while (*(r = get_opt_value(NULL, 0, r))) {\n           mbs.mb_mods_avail++;\n           r++;\n    mbs.mb_buf_size += cmdline_len;\n    mbs.mb_buf_size += MB_MOD_SIZE * mbs.mb_mods_avail;\n    mbs.mb_buf_size += strlen(bootloader_name) + 1;\n    mbs.mb_buf_size = TARGET_PAGE_ALIGN(mbs.mb_buf_size);\n    /* enlarge mb_buf to hold cmdlines, bootloader, mb-info structs */\n    mbs.mb_buf            = g_realloc(mbs.mb_buf, mbs.mb_buf_size);\n    mbs.offset_cmdlines   = mbs.offset_mbinfo + mbs.mb_mods_avail * MB_MOD_SIZE;\n    mbs.offset_bootloader = mbs.offset_cmdlines + cmdline_len;\n    if (initrd_filename) {\n        const char *next_initrd;\n        char not_last, tmpbuf[strlen(initrd_filename) + 1];\n        mbs.offset_mods = mbs.mb_buf_size;\n        do {\n            char *next_space;\n            int mb_mod_length;\n            uint32_t offs = mbs.mb_buf_size;\n            next_initrd = get_opt_value(tmpbuf, sizeof(tmpbuf), initrd_filename);\n            not_last = *next_initrd;\n            /* if a space comes after the module filename, treat everything\n               after that as parameters */\n            hwaddr c = mb_add_cmdline(&mbs, tmpbuf);\n            if ((next_space = strchr(tmpbuf, ' ')))\n                *next_space = '\\0';\n            mb_debug(\"multiboot loading module: %s\\n\", tmpbuf);\n            mb_mod_length = get_image_size(tmpbuf);\n            if (mb_mod_length < 0) {\n                fprintf(stderr, \"Failed to open file '%s'\\n\", tmpbuf);\n            mbs.mb_buf_size = TARGET_PAGE_ALIGN(mb_mod_length + mbs.mb_buf_size);\n            mbs.mb_buf = g_realloc(mbs.mb_buf, mbs.mb_buf_size);\n            load_image(tmpbuf, (unsigned char *)mbs.mb_buf + offs);\n            mb_add_mod(&mbs, mbs.mb_buf_phys + offs,\n                       mbs.mb_buf_phys + offs + mb_mod_length, c);\n            mb_debug(\"mod_start: %p\\nmod_end:   %p\\n  cmdline: \"TARGET_FMT_plx\"\\n\",\n                     (char *)mbs.mb_buf + offs,\n                     (char *)mbs.mb_buf + offs + mb_mod_length, c);\n            initrd_filename = next_initrd+1;\n        } while (not_last);\n    /* Commandline support */\n    char kcmdline[strlen(kernel_filename) + strlen(kernel_cmdline) + 2];\n    snprintf(kcmdline, sizeof(kcmdline), \"%s %s\",\n             kernel_filename, kernel_cmdline);\n    stl_p(bootinfo + MBI_CMDLINE, mb_add_cmdline(&mbs, kcmdline));\n    stl_p(bootinfo + MBI_BOOTLOADER, mb_add_bootloader(&mbs, bootloader_name));\n    stl_p(bootinfo + MBI_MODS_ADDR,  mbs.mb_buf_phys + mbs.offset_mbinfo);\n    stl_p(bootinfo + MBI_MODS_COUNT, mbs.mb_mods_count); /* mods_count */\n    /* the kernel is where we want it to be now */\n    stl_p(bootinfo + MBI_FLAGS, MULTIBOOT_FLAGS_MEMORY\n                                | MULTIBOOT_FLAGS_BOOT_DEVICE\n                                | MULTIBOOT_FLAGS_CMDLINE\n                                | MULTIBOOT_FLAGS_MODULES\n                                | MULTIBOOT_FLAGS_MMAP\n                                | MULTIBOOT_FLAGS_BOOTLOADER);\n    stl_p(bootinfo + MBI_BOOT_DEVICE, 0x8000ffff); /* XXX: use the -boot switch? */\n    stl_p(bootinfo + MBI_MMAP_ADDR,   ADDR_E820_MAP);\n    mb_debug(\"multiboot: mh_entry_addr = %#x\\n\", mh_entry_addr);\n    mb_debug(\"           mb_buf_phys   = \"TARGET_FMT_plx\"\\n\", mbs.mb_buf_phys);\n    mb_debug(\"           mod_start     = \"TARGET_FMT_plx\"\\n\", mbs.mb_buf_phys + mbs.offset_mods);\n    mb_debug(\"           mb_mods_count = %d\\n\", mbs.mb_mods_count);\n    /* save bootinfo off the stack */\n    mb_bootinfo_data = g_memdup(bootinfo, sizeof(bootinfo));\n    /* Pass variables to option rom */\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ENTRY, mh_entry_addr);\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, mh_load_addr);\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, mbs.mb_buf_size);\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_KERNEL_DATA,\n                     mbs.mb_buf, mbs.mb_buf_size);\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, ADDR_MBI);\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, sizeof(bootinfo));\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_INITRD_DATA, mb_bootinfo_data,\n                     sizeof(bootinfo));\n    option_rom[nb_option_roms].name = \"multiboot.bin\";\n    option_rom[nb_option_roms].bootindex = 0;\n    nb_option_roms++;\n    return 1; /* yes, we are multiboot */", "idx": 23204}
{"project": "qemu", "commit_id": "77cb0f5aafc8e6d0c6d3c339f381c9b7921648e0", "target": 1, "func": "static int adb_kbd_poll(ADBDevice *d, uint8_t *obuf)\n\n{\n\n    KBDState *s = ADB_KEYBOARD(d);\n\n    int keycode;\n\n    int olen;\n\n\n\n    olen = 0;\n\n    if (s->count == 0) {\n\n        return 0;\n\n    }\n\n    keycode = s->data[s->rptr];\n\n    s->rptr++;\n\n    if (s->rptr == sizeof(s->data)) {\n\n        s->rptr = 0;\n\n    }\n\n    s->count--;\n\n    /*\n\n     * The power key is the only two byte value key, so it is a special case.\n\n     * Since 0x7f is not a used keycode for ADB we overload it to indicate the\n\n     * power button when we're storing keycodes in our internal buffer, and\n\n     * expand it out to two bytes when we send to the guest.\n\n     */\n\n    if (keycode == 0x7f) {\n\n        obuf[0] = 0x7f;\n\n        obuf[1] = 0x7f;\n\n        olen = 2;\n\n    } else {\n\n        obuf[0] = keycode;\n\n        /* NOTE: the power key key-up is the two byte sequence 0xff 0xff;\n\n         * otherwise we could in theory send a second keycode in the second\n\n         * byte, but choose not to bother.\n\n         */\n\n        obuf[1] = 0xff;\n\n        olen = 2;\n\n    }\n\n\n\n    return olen;\n\n}\n", "idx": 23298}
{"project": "FFmpeg", "commit_id": "83e34ae3c2b36e7b20169a8866e3f49294db1f5a", "target": 1, "func": "static inline int wv_unpack_stereo(WavpackFrameContext *s, GetBitContext *gb,\n\n                                   void *dst_l, void *dst_r, const int type)\n\n{\n\n    int i, j, count = 0;\n\n    int last, t;\n\n    int A, B, L, L2, R, R2;\n\n    int pos                 = s->pos;\n\n    uint32_t crc            = s->sc.crc;\n\n    uint32_t crc_extra_bits = s->extra_sc.crc;\n\n    int16_t *dst16_l        = dst_l;\n\n    int16_t *dst16_r        = dst_r;\n\n    int32_t *dst32_l        = dst_l;\n\n    int32_t *dst32_r        = dst_r;\n\n    float *dstfl_l          = dst_l;\n\n    float *dstfl_r          = dst_r;\n\n\n\n    s->one = s->zero = s->zeroes = 0;\n\n    do {\n\n        L = wv_get_value(s, gb, 0, &last);\n\n        if (last)\n\n            break;\n\n        R = wv_get_value(s, gb, 1, &last);\n\n        if (last)\n\n            break;\n\n        for (i = 0; i < s->terms; i++) {\n\n            t = s->decorr[i].value;\n\n            if (t > 0) {\n\n                if (t > 8) {\n\n                    if (t & 1) {\n\n                        A = 2U * s->decorr[i].samplesA[0] - s->decorr[i].samplesA[1];\n\n                        B = 2U * s->decorr[i].samplesB[0] - s->decorr[i].samplesB[1];\n\n                    } else {\n\n                        A = (int)(3U * s->decorr[i].samplesA[0] - s->decorr[i].samplesA[1]) >> 1;\n\n                        B = (int)(3U * s->decorr[i].samplesB[0] - s->decorr[i].samplesB[1]) >> 1;\n\n                    }\n\n                    s->decorr[i].samplesA[1] = s->decorr[i].samplesA[0];\n\n                    s->decorr[i].samplesB[1] = s->decorr[i].samplesB[0];\n\n                    j                        = 0;\n\n                } else {\n\n                    A = s->decorr[i].samplesA[pos];\n\n                    B = s->decorr[i].samplesB[pos];\n\n                    j = (pos + t) & 7;\n\n                }\n\n                if (type != AV_SAMPLE_FMT_S16P) {\n\n                    L2 = L + ((s->decorr[i].weightA * (int64_t)A + 512) >> 10);\n\n                    R2 = R + ((s->decorr[i].weightB * (int64_t)B + 512) >> 10);\n\n                } else {\n\n                    L2 = L + ((int)(s->decorr[i].weightA * (unsigned)A + 512) >> 10);\n\n                    R2 = R + ((int)(s->decorr[i].weightB * (unsigned)B + 512) >> 10);\n\n                }\n\n                if (A && L)\n\n                    s->decorr[i].weightA -= ((((L ^ A) >> 30) & 2) - 1) * s->decorr[i].delta;\n\n                if (B && R)\n\n                    s->decorr[i].weightB -= ((((R ^ B) >> 30) & 2) - 1) * s->decorr[i].delta;\n\n                s->decorr[i].samplesA[j] = L = L2;\n\n                s->decorr[i].samplesB[j] = R = R2;\n\n            } else if (t == -1) {\n\n                if (type != AV_SAMPLE_FMT_S16P)\n\n                    L2 = L + ((s->decorr[i].weightA * (int64_t)s->decorr[i].samplesA[0] + 512) >> 10);\n\n                else\n\n                    L2 = L + ((int)(s->decorr[i].weightA * (unsigned)s->decorr[i].samplesA[0] + 512) >> 10);\n\n                UPDATE_WEIGHT_CLIP(s->decorr[i].weightA, s->decorr[i].delta, s->decorr[i].samplesA[0], L);\n\n                L = L2;\n\n                if (type != AV_SAMPLE_FMT_S16P)\n\n                    R2 = R + ((s->decorr[i].weightB * (int64_t)L2 + 512) >> 10);\n\n                else\n\n                    R2 = R + ((int)(s->decorr[i].weightB * (unsigned)L2 + 512) >> 10);\n\n                UPDATE_WEIGHT_CLIP(s->decorr[i].weightB, s->decorr[i].delta, L2, R);\n\n                R                        = R2;\n\n                s->decorr[i].samplesA[0] = R;\n\n            } else {\n\n                if (type != AV_SAMPLE_FMT_S16P)\n\n                    R2 = R + ((s->decorr[i].weightB * (int64_t)s->decorr[i].samplesB[0] + 512) >> 10);\n\n                else\n\n                    R2 = R + ((int)(s->decorr[i].weightB * (unsigned)s->decorr[i].samplesB[0] + 512) >> 10);\n\n                UPDATE_WEIGHT_CLIP(s->decorr[i].weightB, s->decorr[i].delta, s->decorr[i].samplesB[0], R);\n\n                R = R2;\n\n\n\n                if (t == -3) {\n\n                    R2                       = s->decorr[i].samplesA[0];\n\n                    s->decorr[i].samplesA[0] = R;\n\n                }\n\n\n\n                if (type != AV_SAMPLE_FMT_S16P)\n\n                    L2 = L + ((s->decorr[i].weightA * (int64_t)R2 + 512) >> 10);\n\n                else\n\n                    L2 = L + ((int)(s->decorr[i].weightA * (unsigned)R2 + 512) >> 10);\n\n                UPDATE_WEIGHT_CLIP(s->decorr[i].weightA, s->decorr[i].delta, R2, L);\n\n                L                        = L2;\n\n                s->decorr[i].samplesB[0] = L;\n\n            }\n\n        }\n\n\n\n        if (type == AV_SAMPLE_FMT_S16P) {\n\n            if (FFABS(L) + (unsigned)FFABS(R) > (1<<19)) {\n\n                av_log(s->avctx, AV_LOG_ERROR, \"sample %d %d too large\\n\", L, R);\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n\n\n        pos = (pos + 1) & 7;\n\n        if (s->joint)\n\n            L += (unsigned)(R -= (unsigned)(L >> 1));\n\n        crc = (crc * 3 + L) * 3 + R;\n\n\n\n        if (type == AV_SAMPLE_FMT_FLTP) {\n\n            *dstfl_l++ = wv_get_value_float(s, &crc_extra_bits, L);\n\n            *dstfl_r++ = wv_get_value_float(s, &crc_extra_bits, R);\n\n        } else if (type == AV_SAMPLE_FMT_S32P) {\n\n            *dst32_l++ = wv_get_value_integer(s, &crc_extra_bits, L);\n\n            *dst32_r++ = wv_get_value_integer(s, &crc_extra_bits, R);\n\n        } else {\n\n            *dst16_l++ = wv_get_value_integer(s, &crc_extra_bits, L);\n\n            *dst16_r++ = wv_get_value_integer(s, &crc_extra_bits, R);\n\n        }\n\n        count++;\n\n    } while (!last && count < s->samples);\n\n\n\n    wv_reset_saved_context(s);\n\n\n\n    if (last && count < s->samples) {\n\n        int size = av_get_bytes_per_sample(type);\n\n        memset((uint8_t*)dst_l + count*size, 0, (s->samples-count)*size);\n\n        memset((uint8_t*)dst_r + count*size, 0, (s->samples-count)*size);\n\n    }\n\n\n\n    if ((s->avctx->err_recognition & AV_EF_CRCCHECK) &&\n\n        wv_check_crc(s, crc, crc_extra_bits))\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    return 0;\n\n}\n", "idx": 23308}
{"project": "qemu", "commit_id": "3761abb167847e9d848588bf15c5d7476845f7e8", "target": 1, "func": "static void qxl_create_guest_primary(PCIQXLDevice *qxl, int loadvm,\n\n                                     qxl_async_io async)\n\n{\n\n    QXLDevSurfaceCreate surface;\n\n    QXLSurfaceCreate *sc = &qxl->guest_primary.surface;\n\n    int size;\n\n    int requested_height = le32_to_cpu(sc->height);\n\n    int requested_stride = le32_to_cpu(sc->stride);\n\n\n\n    size = abs(requested_stride) * requested_height;\n\n    if (size > qxl->vgamem_size) {\n\n        qxl_set_guest_bug(qxl, \"%s: requested primary larger then framebuffer\"\n\n                               \" size\", __func__);\n\n        return;\n\n    }\n\n\n\n    if (qxl->mode == QXL_MODE_NATIVE) {\n\n        qxl_set_guest_bug(qxl, \"%s: nop since already in QXL_MODE_NATIVE\",\n\n                      __func__);\n\n    }\n\n    qxl_exit_vga_mode(qxl);\n\n\n\n    surface.format     = le32_to_cpu(sc->format);\n\n    surface.height     = le32_to_cpu(sc->height);\n\n    surface.mem        = le64_to_cpu(sc->mem);\n\n    surface.position   = le32_to_cpu(sc->position);\n\n    surface.stride     = le32_to_cpu(sc->stride);\n\n    surface.width      = le32_to_cpu(sc->width);\n\n    surface.type       = le32_to_cpu(sc->type);\n\n    surface.flags      = le32_to_cpu(sc->flags);\n\n    trace_qxl_create_guest_primary(qxl->id, sc->width, sc->height, sc->mem,\n\n                                   sc->format, sc->position);\n\n    trace_qxl_create_guest_primary_rest(qxl->id, sc->stride, sc->type,\n\n                                        sc->flags);\n\n\n\n    if ((surface.stride & 0x3) != 0) {\n\n        qxl_set_guest_bug(qxl, \"primary surface stride = %d %% 4 != 0\",\n\n                          surface.stride);\n\n        return;\n\n    }\n\n\n\n    surface.mouse_mode = true;\n\n    surface.group_id   = MEMSLOT_GROUP_GUEST;\n\n    if (loadvm) {\n\n        surface.flags |= QXL_SURF_FLAG_KEEP_DATA;\n\n    }\n\n\n\n    qxl->mode = QXL_MODE_NATIVE;\n\n    qxl->cmdflags = 0;\n\n    qemu_spice_create_primary_surface(&qxl->ssd, 0, &surface, async);\n\n\n\n    if (async == QXL_SYNC) {\n\n        qxl_create_guest_primary_complete(qxl);\n\n    }\n\n}\n", "idx": 23314}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t mpc8544_guts_read(void *opaque, target_phys_addr_t addr,\n\n                                  unsigned size)\n\n{\n\n    uint32_t value = 0;\n\n    CPUPPCState *env = cpu_single_env;\n\n\n\n    addr &= MPC8544_GUTS_MMIO_SIZE - 1;\n\n    switch (addr) {\n\n    case MPC8544_GUTS_ADDR_PVR:\n\n        value = env->spr[SPR_PVR];\n\n        break;\n\n    case MPC8544_GUTS_ADDR_SVR:\n\n        value = env->spr[SPR_E500_SVR];\n\n        break;\n\n    default:\n\n        fprintf(stderr, \"guts: Unknown register read: %x\\n\", (int)addr);\n\n        break;\n\n    }\n\n\n\n    return value;\n\n}\n", "idx": 23394}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_conditional_jump(DisasContext * ctx,\n\n\t\t\t\t target_ulong ift, target_ulong ifnott)\n\n{\n\n    int l1;\n\n    TCGv sr;\n\n\n\n    l1 = gen_new_label();\n\n    sr = tcg_temp_new();\n\n    tcg_gen_andi_i32(sr, cpu_sr, SR_T);\n\n    tcg_gen_brcondi_i32(TCG_COND_NE, sr, 0, l1);\n\n    gen_goto_tb(ctx, 0, ifnott);\n\n    gen_set_label(l1);\n\n    gen_goto_tb(ctx, 1, ift);\n\n}\n", "idx": 23409}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "void rgb16tobgr32(const uint8_t *src, uint8_t *dst, unsigned int src_size)\n\n{\n\n\tconst uint16_t *end;\n\n\tuint8_t *d = (uint8_t *)dst;\n\n\tconst uint16_t *s = (uint16_t *)src;\n\n\tend = s + src_size/2;\n\n\twhile(s < end)\n\n\t{\n\n\t\tregister uint16_t bgr;\n\n\t\tbgr = *s++;\n\n\t\t*d++ = (bgr&0xF800)>>8;\n\n\t\t*d++ = (bgr&0x7E0)>>3;\n\n\t\t*d++ = (bgr&0x1F)<<3;\n\n\t\t*d++ = 0;\n\n\t}\n\n}\n", "idx": 23431}
{"project": "qemu", "commit_id": "2d0d2837dcf786da415cf4165d37f4ddd684ff57", "target": 0, "func": "DriveInfo *add_init_drive(const char *optstr)\n\n{\n\n    DriveInfo *dinfo;\n\n    QemuOpts *opts;\n\n\n\n    opts = drive_def(optstr);\n\n    if (!opts)\n\n        return NULL;\n\n\n\n    dinfo = drive_init(opts, current_machine->use_scsi);\n\n    if (!dinfo) {\n\n        qemu_opts_del(opts);\n\n        return NULL;\n\n    }\n\n\n\n    return dinfo;\n\n}\n", "idx": 23520}
{"project": "FFmpeg", "commit_id": "3b199d29cd597a3518136d78860e172060b9e83d", "target": 0, "func": "static av_cold int smc_decode_init(AVCodecContext *avctx)\n\n{\n\n    SmcContext *s = avctx->priv_data;\n\n\n\n    s->avctx = avctx;\n\n    avctx->pix_fmt = AV_PIX_FMT_PAL8;\n\n\n\n    s->frame.data[0] = NULL;\n\n\n\n    return 0;\n\n}\n", "idx": 23653}
{"project": "qemu", "commit_id": "9ea63c05d90ba85d819f9b2472ce6dfba7a403b4", "target": 0, "func": "int do_subchannel_work_virtual(SubchDev *sch)\n\n{\n\n\n\n    SCSW *s = &sch->curr_status.scsw;\n\n\n\n    if (s->ctrl & SCSW_FCTL_CLEAR_FUNC) {\n\n        sch_handle_clear_func(sch);\n\n    } else if (s->ctrl & SCSW_FCTL_HALT_FUNC) {\n\n        sch_handle_halt_func(sch);\n\n    } else if (s->ctrl & SCSW_FCTL_START_FUNC) {\n\n        /* Triggered by both ssch and rsch. */\n\n        sch_handle_start_func_virtual(sch);\n\n    } else {\n\n        /* Cannot happen. */\n\n        return 0;\n\n    }\n\n    css_inject_io_interrupt(sch);\n\n    return 0;\n\n}\n", "idx": 23682}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static inline uint64_t ldq_phys_internal(target_phys_addr_t addr,\n\n                                         enum device_endian endian)\n\n{\n\n    uint8_t *ptr;\n\n    uint64_t val;\n\n    MemoryRegionSection *section;\n\n\n\n    section = phys_page_find(address_space_memory.dispatch, addr >> TARGET_PAGE_BITS);\n\n\n\n    if (!(memory_region_is_ram(section->mr) ||\n\n          memory_region_is_romd(section->mr))) {\n\n        /* I/O case */\n\n        addr = memory_region_section_addr(section, addr);\n\n\n\n        /* XXX This is broken when device endian != cpu endian.\n\n               Fix and add \"endian\" variable check */\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n        val = io_mem_read(section->mr, addr, 4) << 32;\n\n        val |= io_mem_read(section->mr, addr + 4, 4);\n\n#else\n\n        val = io_mem_read(section->mr, addr, 4);\n\n        val |= io_mem_read(section->mr, addr + 4, 4) << 32;\n\n#endif\n\n    } else {\n\n        /* RAM case */\n\n        ptr = qemu_get_ram_ptr((memory_region_get_ram_addr(section->mr)\n\n                                & TARGET_PAGE_MASK)\n\n                               + memory_region_section_addr(section, addr));\n\n        switch (endian) {\n\n        case DEVICE_LITTLE_ENDIAN:\n\n            val = ldq_le_p(ptr);\n\n            break;\n\n        case DEVICE_BIG_ENDIAN:\n\n            val = ldq_be_p(ptr);\n\n            break;\n\n        default:\n\n            val = ldq_p(ptr);\n\n            break;\n\n        }\n\n    }\n\n    return val;\n\n}\n", "idx": 23686}
{"project": "qemu", "commit_id": "59800ec8e52bcfa271fa61fb0aae19205ef1b7f1", "target": 0, "func": "uint64_t helper_fnmsub(CPUPPCState *env, uint64_t arg1, uint64_t arg2,\n\n                       uint64_t arg3)\n\n{\n\n    CPU_DoubleU farg1, farg2, farg3;\n\n\n\n    farg1.ll = arg1;\n\n    farg2.ll = arg2;\n\n    farg3.ll = arg3;\n\n\n\n    if (unlikely((float64_is_infinity(farg1.d) && float64_is_zero(farg2.d)) ||\n\n                 (float64_is_zero(farg1.d) &&\n\n                  float64_is_infinity(farg2.d)))) {\n\n        /* Multiplication of zero by infinity */\n\n        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXIMZ);\n\n    } else {\n\n        if (unlikely(float64_is_signaling_nan(farg1.d) ||\n\n                     float64_is_signaling_nan(farg2.d) ||\n\n                     float64_is_signaling_nan(farg3.d))) {\n\n            /* sNaN operation */\n\n            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);\n\n        }\n\n        /* This is the way the PowerPC specification defines it */\n\n        float128 ft0_128, ft1_128;\n\n\n\n        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);\n\n        ft1_128 = float64_to_float128(farg2.d, &env->fp_status);\n\n        ft0_128 = float128_mul(ft0_128, ft1_128, &env->fp_status);\n\n        if (unlikely(float128_is_infinity(ft0_128) &&\n\n                     float64_is_infinity(farg3.d) &&\n\n                     float128_is_neg(ft0_128) == float64_is_neg(farg3.d))) {\n\n            /* Magnitude subtraction of infinities */\n\n            farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXISI);\n\n        } else {\n\n            ft1_128 = float64_to_float128(farg3.d, &env->fp_status);\n\n            ft0_128 = float128_sub(ft0_128, ft1_128, &env->fp_status);\n\n            farg1.d = float128_to_float64(ft0_128, &env->fp_status);\n\n        }\n\n        if (likely(!float64_is_any_nan(farg1.d))) {\n\n            farg1.d = float64_chs(farg1.d);\n\n        }\n\n    }\n\n    return farg1.ll;\n\n}\n", "idx": 23733}
{"project": "qemu", "commit_id": "4b9b7092b4cbef084138a446b8247ba89fd474f4", "target": 1, "func": "static void cdrom_change_cb(void *opaque, int reason)\n\n{\n\n    IDEState *s = opaque;\n\n    uint64_t nb_sectors;\n\n\n\n    if (!(reason & CHANGE_MEDIA)) {\n\n        return;\n\n    }\n\n\n\n    bdrv_get_geometry(s->bs, &nb_sectors);\n\n    s->nb_sectors = nb_sectors;\n\n\n\n    s->sense_key = SENSE_UNIT_ATTENTION;\n\n    s->asc = ASC_MEDIUM_MAY_HAVE_CHANGED;\n\n    s->cdrom_changed = 1;\n\n    s->events.new_media = true;\n\n    ide_set_irq(s->bus);\n\n}\n", "idx": 23772}
{"project": "FFmpeg", "commit_id": "8fa18e042ad2c078f759692f1db5629d16d70595", "target": 0, "func": "static int http_connect(URLContext *h, const char *path, const char *local_path,\n\n                        const char *hoststr, const char *auth,\n\n                        const char *proxyauth, int *new_location)\n\n{\n\n    HTTPContext *s = h->priv_data;\n\n    int post, err;\n\n    char headers[HTTP_HEADERS_SIZE] = \"\";\n\n    char *authstr = NULL, *proxyauthstr = NULL;\n\n    uint64_t off = s->off;\n\n    int len = 0;\n\n    const char *method;\n\n    int send_expect_100 = 0;\n\n\n\n    /* send http header */\n\n    post = h->flags & AVIO_FLAG_WRITE;\n\n\n\n    if (s->post_data) {\n\n        /* force POST method and disable chunked encoding when\n\n         * custom HTTP post data is set */\n\n        post            = 1;\n\n        s->chunked_post = 0;\n\n    }\n\n\n\n    if (s->method)\n\n        method = s->method;\n\n    else\n\n        method = post ? \"POST\" : \"GET\";\n\n\n\n    authstr      = ff_http_auth_create_response(&s->auth_state, auth,\n\n                                                local_path, method);\n\n    proxyauthstr = ff_http_auth_create_response(&s->proxy_auth_state, proxyauth,\n\n                                                local_path, method);\n\n    if (post && !s->post_data) {\n\n        send_expect_100 = s->send_expect_100;\n\n        /* The user has supplied authentication but we don't know the auth type,\n\n         * send Expect: 100-continue to get the 401 response including the\n\n         * WWW-Authenticate header, or an 100 continue if no auth actually\n\n         * is needed. */\n\n        if (auth && *auth &&\n\n            s->auth_state.auth_type == HTTP_AUTH_NONE &&\n\n            s->http_code != 401)\n\n            send_expect_100 = 1;\n\n    }\n\n\n\n#if FF_API_HTTP_USER_AGENT\n\n    if (strcmp(s->user_agent_deprecated, DEFAULT_USER_AGENT)) {\n\n        av_log(s, AV_LOG_WARNING, \"the user-agent option is deprecated, please use user_agent option\\n\");\n\n        s->user_agent = av_strdup(s->user_agent_deprecated);\n\n    }\n\n#endif\n\n    /* set default headers if needed */\n\n    if (!has_header(s->headers, \"\\r\\nUser-Agent: \"))\n\n        len += av_strlcatf(headers + len, sizeof(headers) - len,\n\n                           \"User-Agent: %s\\r\\n\", s->user_agent);\n\n    if (!has_header(s->headers, \"\\r\\nAccept: \"))\n\n        len += av_strlcpy(headers + len, \"Accept: */*\\r\\n\",\n\n                          sizeof(headers) - len);\n\n    // Note: we send this on purpose even when s->off is 0 when we're probing,\n\n    // since it allows us to detect more reliably if a (non-conforming)\n\n    // server supports seeking by analysing the reply headers.\n\n    if (!has_header(s->headers, \"\\r\\nRange: \") && !post && (s->off > 0 || s->end_off || s->seekable == -1)) {\n\n        len += av_strlcatf(headers + len, sizeof(headers) - len,\n\n                           \"Range: bytes=%\"PRIu64\"-\", s->off);\n\n        if (s->end_off)\n\n            len += av_strlcatf(headers + len, sizeof(headers) - len,\n\n                               \"%\"PRId64, s->end_off - 1);\n\n        len += av_strlcpy(headers + len, \"\\r\\n\",\n\n                          sizeof(headers) - len);\n\n    }\n\n    if (send_expect_100 && !has_header(s->headers, \"\\r\\nExpect: \"))\n\n        len += av_strlcatf(headers + len, sizeof(headers) - len,\n\n                           \"Expect: 100-continue\\r\\n\");\n\n\n\n    if (!has_header(s->headers, \"\\r\\nConnection: \")) {\n\n        if (s->multiple_requests)\n\n            len += av_strlcpy(headers + len, \"Connection: keep-alive\\r\\n\",\n\n                              sizeof(headers) - len);\n\n        else\n\n            len += av_strlcpy(headers + len, \"Connection: close\\r\\n\",\n\n                              sizeof(headers) - len);\n\n    }\n\n\n\n    if (!has_header(s->headers, \"\\r\\nHost: \"))\n\n        len += av_strlcatf(headers + len, sizeof(headers) - len,\n\n                           \"Host: %s\\r\\n\", hoststr);\n\n    if (!has_header(s->headers, \"\\r\\nContent-Length: \") && s->post_data)\n\n        len += av_strlcatf(headers + len, sizeof(headers) - len,\n\n                           \"Content-Length: %d\\r\\n\", s->post_datalen);\n\n\n\n    if (!has_header(s->headers, \"\\r\\nContent-Type: \") && s->content_type)\n\n        len += av_strlcatf(headers + len, sizeof(headers) - len,\n\n                           \"Content-Type: %s\\r\\n\", s->content_type);\n\n    if (!has_header(s->headers, \"\\r\\nCookie: \") && s->cookies) {\n\n        char *cookies = NULL;\n\n        if (!get_cookies(s, &cookies, path, hoststr) && cookies) {\n\n            len += av_strlcatf(headers + len, sizeof(headers) - len,\n\n                               \"Cookie: %s\\r\\n\", cookies);\n\n            av_free(cookies);\n\n        }\n\n    }\n\n    if (!has_header(s->headers, \"\\r\\nIcy-MetaData: \") && s->icy)\n\n        len += av_strlcatf(headers + len, sizeof(headers) - len,\n\n                           \"Icy-MetaData: %d\\r\\n\", 1);\n\n\n\n    /* now add in custom headers */\n\n    if (s->headers)\n\n        av_strlcpy(headers + len, s->headers, sizeof(headers) - len);\n\n\n\n    snprintf(s->buffer, sizeof(s->buffer),\n\n             \"%s %s HTTP/1.1\\r\\n\"\n\n             \"%s\"\n\n             \"%s\"\n\n             \"%s\"\n\n             \"%s%s\"\n\n             \"\\r\\n\",\n\n             method,\n\n             path,\n\n             post && s->chunked_post ? \"Transfer-Encoding: chunked\\r\\n\" : \"\",\n\n             headers,\n\n             authstr ? authstr : \"\",\n\n             proxyauthstr ? \"Proxy-\" : \"\", proxyauthstr ? proxyauthstr : \"\");\n\n\n\n    av_log(h, AV_LOG_DEBUG, \"request: %s\\n\", s->buffer);\n\n\n\n    if ((err = ffurl_write(s->hd, s->buffer, strlen(s->buffer))) < 0)\n\n        goto done;\n\n\n\n    if (s->post_data)\n\n        if ((err = ffurl_write(s->hd, s->post_data, s->post_datalen)) < 0)\n\n            goto done;\n\n\n\n    /* init input buffer */\n\n    s->buf_ptr          = s->buffer;\n\n    s->buf_end          = s->buffer;\n\n    s->line_count       = 0;\n\n    s->off              = 0;\n\n    s->icy_data_read    = 0;\n\n    s->filesize         = UINT64_MAX;\n\n    s->willclose        = 0;\n\n    s->end_chunked_post = 0;\n\n    s->end_header       = 0;\n\n    if (post && !s->post_data && !send_expect_100) {\n\n        /* Pretend that it did work. We didn't read any header yet, since\n\n         * we've still to send the POST data, but the code calling this\n\n         * function will check http_code after we return. */\n\n        s->http_code = 200;\n\n        err = 0;\n\n        goto done;\n\n    }\n\n\n\n    /* wait for header */\n\n    err = http_read_header(h, new_location);\n\n    if (err < 0)\n\n        goto done;\n\n\n\n    if (*new_location)\n\n        s->off = off;\n\n\n\n    err = (off == s->off) ? 0 : -1;\n\ndone:\n\n    av_freep(&authstr);\n\n    av_freep(&proxyauthstr);\n\n    return err;\n\n}\n", "idx": 23797}
{"project": "qemu", "commit_id": "599d0c45615b7d099d256738a586d0f63bc707e6", "target": 1, "func": "static int xen_host_pci_sysfs_path(const XenHostPCIDevice *d,\n\n                                   const char *name, char *buf, ssize_t size)\n\n{\n\n    int rc;\n\n\n\n    rc = snprintf(buf, size, \"/sys/bus/pci/devices/%04x:%02x:%02x.%d/%s\",\n\n                  d->domain, d->bus, d->dev, d->func, name);\n\n\n\n    if (rc >= size || rc < 0) {\n\n        /* The output is truncated, or some other error was encountered */\n\n        return -ENODEV;\n\n    }\n\n    return 0;\n\n}\n", "idx": 23806}
{"project": "qemu", "commit_id": "b3f7f0c5e6449be7275f1762bccbfa2177395a3b", "target": 1, "func": "static int colo_do_checkpoint_transaction(MigrationState *s,\n\n                                          QIOChannelBuffer *bioc,\n\n                                          QEMUFile *fb)\n\n{\n\n    Error *local_err = NULL;\n\n    int ret = -1;\n\n\n\n    colo_send_message(s->to_dst_file, COLO_MESSAGE_CHECKPOINT_REQUEST,\n\n                      &local_err);\n\n    if (local_err) {\n\n\n\n\n\n    colo_receive_check_message(s->rp_state.from_dst_file,\n\n                    COLO_MESSAGE_CHECKPOINT_REPLY, &local_err);\n\n    if (local_err) {\n\n\n\n    /* Reset channel-buffer directly */\n\n    qio_channel_io_seek(QIO_CHANNEL(bioc), 0, 0, NULL);\n\n    bioc->usage = 0;\n\n\n\n    qemu_mutex_lock_iothread();\n\n\n\n\n\n    vm_stop_force_state(RUN_STATE_COLO);\n\n\n    trace_colo_vm_state_change(\"run\", \"stop\");\n\n\n\n\n\n\n\n\n\n\n    /* Disable block migration */\n\n    s->params.blk = 0;\n\n    s->params.shared = 0;\n\n    qemu_savevm_state_header(fb);\n\n    qemu_savevm_state_begin(fb, &s->params);\n\n    qemu_mutex_lock_iothread();\n\n    qemu_savevm_state_complete_precopy(fb, false);\n\n\n\n\n    qemu_fflush(fb);\n\n\n\n    colo_send_message(s->to_dst_file, COLO_MESSAGE_VMSTATE_SEND, &local_err);\n\n    if (local_err) {\n\n\n\n\n     * We need the size of the VMstate data in Secondary side,\n\n     * With which we can decide how much data should be read.\n\n\n    colo_send_message_value(s->to_dst_file, COLO_MESSAGE_VMSTATE_SIZE,\n\n                            bioc->usage, &local_err);\n\n    if (local_err) {\n\n\n\n\n\n    qemu_put_buffer(s->to_dst_file, bioc->data, bioc->usage);\n\n    qemu_fflush(s->to_dst_file);\n\n    ret = qemu_file_get_error(s->to_dst_file);\n\n    if (ret < 0) {\n\n\n\n\n\n    colo_receive_check_message(s->rp_state.from_dst_file,\n\n                       COLO_MESSAGE_VMSTATE_RECEIVED, &local_err);\n\n    if (local_err) {\n\n\n\n\n\n    colo_receive_check_message(s->rp_state.from_dst_file,\n\n                       COLO_MESSAGE_VMSTATE_LOADED, &local_err);\n\n    if (local_err) {\n\n\n\n\n\n    ret = 0;\n\n\n\n    qemu_mutex_lock_iothread();\n\n    vm_start();\n\n\n    trace_colo_vm_state_change(\"stop\", \"run\");\n\n\n\nout:\n\n    if (local_err) {\n\n        error_report_err(local_err);\n\n\n    return ret;\n", "idx": 23840}
{"project": "FFmpeg", "commit_id": "3176217c60ca7828712985092d9102d331ea4f3d", "target": 0, "func": "int ff_h264_decode_mb_cabac(const H264Context *h, H264SliceContext *sl)\n\n{\n\n    int mb_xy;\n\n    int mb_type, partition_count, cbp = 0;\n\n    int dct8x8_allowed= h->pps.transform_8x8_mode;\n\n    int decode_chroma = h->sps.chroma_format_idc == 1 || h->sps.chroma_format_idc == 2;\n\n    const int pixel_shift = h->pixel_shift;\n\n\n\n    mb_xy = sl->mb_xy = sl->mb_x + sl->mb_y*h->mb_stride;\n\n\n\n    ff_tlog(h->avctx, \"pic:%d mb:%d/%d\\n\", h->frame_num, sl->mb_x, sl->mb_y);\n\n    if (sl->slice_type_nos != AV_PICTURE_TYPE_I) {\n\n        int skip;\n\n        /* a skipped mb needs the aff flag from the following mb */\n\n        if (FRAME_MBAFF(h) && (sl->mb_y & 1) == 1 && sl->prev_mb_skipped)\n\n            skip = sl->next_mb_skipped;\n\n        else\n\n            skip = decode_cabac_mb_skip(h, sl, sl->mb_x, sl->mb_y );\n\n        /* read skip flags */\n\n        if( skip ) {\n\n            if (FRAME_MBAFF(h) && (sl->mb_y & 1) == 0) {\n\n                h->cur_pic.mb_type[mb_xy] = MB_TYPE_SKIP;\n\n                sl->next_mb_skipped = decode_cabac_mb_skip(h, sl, sl->mb_x, sl->mb_y+1 );\n\n                if(!sl->next_mb_skipped)\n\n                    sl->mb_mbaff = sl->mb_field_decoding_flag = decode_cabac_field_decoding_flag(h, sl);\n\n            }\n\n\n\n            decode_mb_skip(h, sl);\n\n\n\n            h->cbp_table[mb_xy] = 0;\n\n            h->chroma_pred_mode_table[mb_xy] = 0;\n\n            sl->last_qscale_diff = 0;\n\n\n\n            return 0;\n\n\n\n        }\n\n    }\n\n    if (FRAME_MBAFF(h)) {\n\n        if ((sl->mb_y & 1) == 0)\n\n            sl->mb_mbaff =\n\n            sl->mb_field_decoding_flag = decode_cabac_field_decoding_flag(h, sl);\n\n    }\n\n\n\n    sl->prev_mb_skipped = 0;\n\n\n\n    fill_decode_neighbors(h, sl, -(MB_FIELD(sl)));\n\n\n\n    if (sl->slice_type_nos == AV_PICTURE_TYPE_B) {\n\n        int ctx = 0;\n\n        assert(sl->slice_type_nos == AV_PICTURE_TYPE_B);\n\n\n\n        if (!IS_DIRECT(sl->left_type[LTOP] - 1))\n\n            ctx++;\n\n        if (!IS_DIRECT(sl->top_type - 1))\n\n            ctx++;\n\n\n\n        if( !get_cabac_noinline( &sl->cabac, &sl->cabac_state[27+ctx] ) ){\n\n            mb_type= 0; /* B_Direct_16x16 */\n\n        }else if( !get_cabac_noinline( &sl->cabac, &sl->cabac_state[27+3] ) ) {\n\n            mb_type= 1 + get_cabac_noinline( &sl->cabac, &sl->cabac_state[27+5] ); /* B_L[01]_16x16 */\n\n        }else{\n\n            int bits;\n\n            bits = get_cabac_noinline( &sl->cabac, &sl->cabac_state[27+4] ) << 3;\n\n            bits+= get_cabac_noinline( &sl->cabac, &sl->cabac_state[27+5] ) << 2;\n\n            bits+= get_cabac_noinline( &sl->cabac, &sl->cabac_state[27+5] ) << 1;\n\n            bits+= get_cabac_noinline( &sl->cabac, &sl->cabac_state[27+5] );\n\n            if( bits < 8 ){\n\n                mb_type= bits + 3; /* B_Bi_16x16 through B_L1_L0_16x8 */\n\n            }else if( bits == 13 ){\n\n                mb_type = decode_cabac_intra_mb_type(sl, 32, 0);\n\n                goto decode_intra_mb;\n\n            }else if( bits == 14 ){\n\n                mb_type= 11; /* B_L1_L0_8x16 */\n\n            }else if( bits == 15 ){\n\n                mb_type= 22; /* B_8x8 */\n\n            }else{\n\n                bits= ( bits<<1 ) + get_cabac_noinline( &sl->cabac, &sl->cabac_state[27+5] );\n\n                mb_type= bits - 4; /* B_L0_Bi_* through B_Bi_Bi_* */\n\n            }\n\n        }\n\n            partition_count = ff_h264_b_mb_type_info[mb_type].partition_count;\n\n            mb_type         = ff_h264_b_mb_type_info[mb_type].type;\n\n    } else if (sl->slice_type_nos == AV_PICTURE_TYPE_P) {\n\n        if( get_cabac_noinline( &sl->cabac, &sl->cabac_state[14] ) == 0 ) {\n\n            /* P-type */\n\n            if( get_cabac_noinline( &sl->cabac, &sl->cabac_state[15] ) == 0 ) {\n\n                /* P_L0_D16x16, P_8x8 */\n\n                mb_type= 3 * get_cabac_noinline( &sl->cabac, &sl->cabac_state[16] );\n\n            } else {\n\n                /* P_L0_D8x16, P_L0_D16x8 */\n\n                mb_type= 2 - get_cabac_noinline( &sl->cabac, &sl->cabac_state[17] );\n\n            }\n\n            partition_count = ff_h264_p_mb_type_info[mb_type].partition_count;\n\n            mb_type         = ff_h264_p_mb_type_info[mb_type].type;\n\n        } else {\n\n            mb_type = decode_cabac_intra_mb_type(sl, 17, 0);\n\n            goto decode_intra_mb;\n\n        }\n\n    } else {\n\n        mb_type = decode_cabac_intra_mb_type(sl, 3, 1);\n\n        if (sl->slice_type == AV_PICTURE_TYPE_SI && mb_type)\n\n            mb_type--;\n\n        assert(sl->slice_type_nos == AV_PICTURE_TYPE_I);\n\ndecode_intra_mb:\n\n        partition_count = 0;\n\n        cbp                      = ff_h264_i_mb_type_info[mb_type].cbp;\n\n        sl->intra16x16_pred_mode = ff_h264_i_mb_type_info[mb_type].pred_mode;\n\n        mb_type                  = ff_h264_i_mb_type_info[mb_type].type;\n\n    }\n\n    if (MB_FIELD(sl))\n\n        mb_type |= MB_TYPE_INTERLACED;\n\n\n\n    h->slice_table[mb_xy] = sl->slice_num;\n\n\n\n    if(IS_INTRA_PCM(mb_type)) {\n\n        const int mb_size = ff_h264_mb_sizes[h->sps.chroma_format_idc] *\n\n                            h->sps.bit_depth_luma >> 3;\n\n        const uint8_t *ptr;\n\n\n\n        // We assume these blocks are very rare so we do not optimize it.\n\n        // FIXME The two following lines get the bitstream position in the cabac\n\n        // decode, I think it should be done by a function in cabac.h (or cabac.c).\n\n        ptr= sl->cabac.bytestream;\n\n        if(sl->cabac.low&0x1) ptr--;\n\n        if(CABAC_BITS==16){\n\n            if(sl->cabac.low&0x1FF) ptr--;\n\n        }\n\n\n\n        // The pixels are stored in the same order as levels in h->mb array.\n\n        if ((int) (sl->cabac.bytestream_end - ptr) < mb_size)\n\n            return -1;\n\n        sl->intra_pcm_ptr = ptr;\n\n        ptr += mb_size;\n\n\n\n        ff_init_cabac_decoder(&sl->cabac, ptr, sl->cabac.bytestream_end - ptr);\n\n\n\n        // All blocks are present\n\n        h->cbp_table[mb_xy] = 0xf7ef;\n\n        h->chroma_pred_mode_table[mb_xy] = 0;\n\n        // In deblocking, the quantizer is 0\n\n        h->cur_pic.qscale_table[mb_xy] = 0;\n\n        // All coeffs are present\n\n        memset(h->non_zero_count[mb_xy], 16, 48);\n\n        h->cur_pic.mb_type[mb_xy] = mb_type;\n\n        sl->last_qscale_diff = 0;\n\n        return 0;\n\n    }\n\n\n\n    fill_decode_caches(h, sl, mb_type);\n\n\n\n    if( IS_INTRA( mb_type ) ) {\n\n        int i, pred_mode;\n\n        if( IS_INTRA4x4( mb_type ) ) {\n\n            if (dct8x8_allowed && get_cabac_noinline(&sl->cabac, &sl->cabac_state[399 + sl->neighbor_transform_size])) {\n\n                mb_type |= MB_TYPE_8x8DCT;\n\n                for( i = 0; i < 16; i+=4 ) {\n\n                    int pred = pred_intra_mode(h, sl, i);\n\n                    int mode = decode_cabac_mb_intra4x4_pred_mode(sl, pred);\n\n                    fill_rectangle(&sl->intra4x4_pred_mode_cache[scan8[i]], 2, 2, 8, mode, 1);\n\n                }\n\n            } else {\n\n                for( i = 0; i < 16; i++ ) {\n\n                    int pred = pred_intra_mode(h, sl, i);\n\n                    sl->intra4x4_pred_mode_cache[scan8[i]] = decode_cabac_mb_intra4x4_pred_mode(sl, pred);\n\n\n\n                    ff_dlog(h->avctx, \"i4x4 pred=%d mode=%d\\n\", pred,\n\n                            sl->intra4x4_pred_mode_cache[scan8[i]]);\n\n                }\n\n            }\n\n            write_back_intra_pred_mode(h, sl);\n\n            if (ff_h264_check_intra4x4_pred_mode(sl->intra4x4_pred_mode_cache, h->avctx,\n\n                                                 sl->top_samples_available, sl->left_samples_available) < 0 )\n\n                return -1;\n\n        } else {\n\n            sl->intra16x16_pred_mode = ff_h264_check_intra_pred_mode(h->avctx, sl->top_samples_available,\n\n                                                                     sl->left_samples_available, sl->intra16x16_pred_mode, 0);\n\n            if (sl->intra16x16_pred_mode < 0) return -1;\n\n        }\n\n        if(decode_chroma){\n\n            h->chroma_pred_mode_table[mb_xy] =\n\n            pred_mode                        = decode_cabac_mb_chroma_pre_mode(h, sl);\n\n\n\n            pred_mode= ff_h264_check_intra_pred_mode(h->avctx, sl->top_samples_available,\n\n                                                     sl->left_samples_available, pred_mode, 1 );\n\n            if( pred_mode < 0 ) return -1;\n\n            sl->chroma_pred_mode = pred_mode;\n\n        } else {\n\n            sl->chroma_pred_mode = DC_128_PRED8x8;\n\n        }\n\n    } else if( partition_count == 4 ) {\n\n        int i, j, sub_partition_count[4], list, ref[2][4];\n\n\n\n        if (sl->slice_type_nos == AV_PICTURE_TYPE_B ) {\n\n            for( i = 0; i < 4; i++ ) {\n\n                sl->sub_mb_type[i] = decode_cabac_b_mb_sub_type(sl);\n\n                sub_partition_count[i] = ff_h264_b_sub_mb_type_info[sl->sub_mb_type[i]].partition_count;\n\n                sl->sub_mb_type[i]     = ff_h264_b_sub_mb_type_info[sl->sub_mb_type[i]].type;\n\n            }\n\n            if (IS_DIRECT(sl->sub_mb_type[0] | sl->sub_mb_type[1] |\n\n                          sl->sub_mb_type[2] | sl->sub_mb_type[3])) {\n\n                ff_h264_pred_direct_motion(h, sl, &mb_type);\n\n                sl->ref_cache[0][scan8[4]] =\n\n                sl->ref_cache[1][scan8[4]] =\n\n                sl->ref_cache[0][scan8[12]] =\n\n                sl->ref_cache[1][scan8[12]] = PART_NOT_AVAILABLE;\n\n                    for( i = 0; i < 4; i++ )\n\n                        fill_rectangle(&sl->direct_cache[scan8[4*i]], 2, 2, 8, (sl->sub_mb_type[i] >> 1) & 0xFF, 1);\n\n            }\n\n        } else {\n\n            for( i = 0; i < 4; i++ ) {\n\n                sl->sub_mb_type[i] = decode_cabac_p_mb_sub_type(sl);\n\n                sub_partition_count[i] = ff_h264_p_sub_mb_type_info[sl->sub_mb_type[i]].partition_count;\n\n                sl->sub_mb_type[i]     = ff_h264_p_sub_mb_type_info[sl->sub_mb_type[i]].type;\n\n            }\n\n        }\n\n\n\n        for( list = 0; list < sl->list_count; list++ ) {\n\n                for( i = 0; i < 4; i++ ) {\n\n                    if(IS_DIRECT(sl->sub_mb_type[i])) continue;\n\n                    if(IS_DIR(sl->sub_mb_type[i], 0, list)){\n\n                        int rc = sl->ref_count[list] << MB_MBAFF(sl);\n\n                        if (rc > 1) {\n\n                            ref[list][i] = decode_cabac_mb_ref(sl, list, 4 * i);\n\n                            if (ref[list][i] >= (unsigned) rc) {\n\n                                av_log(h->avctx, AV_LOG_ERROR, \"Reference %d >= %d\\n\", ref[list][i], rc);\n\n                                return -1;\n\n                            }\n\n                        }else\n\n                            ref[list][i] = 0;\n\n                    } else {\n\n                        ref[list][i] = -1;\n\n                    }\n\n                    sl->ref_cache[list][scan8[4 * i] + 1] =\n\n                    sl->ref_cache[list][scan8[4 * i] + 8] = sl->ref_cache[list][scan8[4 * i] + 9] = ref[list][i];\n\n                }\n\n        }\n\n\n\n        if(dct8x8_allowed)\n\n            dct8x8_allowed = get_dct8x8_allowed(h, sl);\n\n\n\n        for (list = 0; list < sl->list_count; list++) {\n\n            for(i=0; i<4; i++){\n\n                sl->ref_cache[list][scan8[4 * i]] = sl->ref_cache[list][scan8[4 * i] + 1];\n\n                if(IS_DIRECT(sl->sub_mb_type[i])){\n\n                    fill_rectangle(sl->mvd_cache[list][scan8[4*i]], 2, 2, 8, 0, 2);\n\n                    continue;\n\n                }\n\n\n\n                if(IS_DIR(sl->sub_mb_type[i], 0, list) && !IS_DIRECT(sl->sub_mb_type[i])){\n\n                    const int sub_mb_type= sl->sub_mb_type[i];\n\n                    const int block_width= (sub_mb_type & (MB_TYPE_16x16|MB_TYPE_16x8)) ? 2 : 1;\n\n                    for(j=0; j<sub_partition_count[i]; j++){\n\n                        int mpx, mpy;\n\n                        int mx, my;\n\n                        const int index= 4*i + block_width*j;\n\n                        int16_t (* mv_cache)[2] = &sl->mv_cache[list][ scan8[index] ];\n\n                        uint8_t (* mvd_cache)[2]= &sl->mvd_cache[list][ scan8[index] ];\n\n                        pred_motion(h, sl, index, block_width, list, sl->ref_cache[list][ scan8[index] ], &mx, &my);\n\n                        DECODE_CABAC_MB_MVD(sl, list, index)\n\n                        ff_tlog(h->avctx, \"final mv:%d %d\\n\", mx, my);\n\n\n\n                        if(IS_SUB_8X8(sub_mb_type)){\n\n                            mv_cache[ 1 ][0]=\n\n                            mv_cache[ 8 ][0]= mv_cache[ 9 ][0]= mx;\n\n                            mv_cache[ 1 ][1]=\n\n                            mv_cache[ 8 ][1]= mv_cache[ 9 ][1]= my;\n\n\n\n                            mvd_cache[ 1 ][0]=\n\n                            mvd_cache[ 8 ][0]= mvd_cache[ 9 ][0]= mpx;\n\n                            mvd_cache[ 1 ][1]=\n\n                            mvd_cache[ 8 ][1]= mvd_cache[ 9 ][1]= mpy;\n\n                        }else if(IS_SUB_8X4(sub_mb_type)){\n\n                            mv_cache[ 1 ][0]= mx;\n\n                            mv_cache[ 1 ][1]= my;\n\n\n\n                            mvd_cache[ 1 ][0]=  mpx;\n\n                            mvd_cache[ 1 ][1]= mpy;\n\n                        }else if(IS_SUB_4X8(sub_mb_type)){\n\n                            mv_cache[ 8 ][0]= mx;\n\n                            mv_cache[ 8 ][1]= my;\n\n\n\n                            mvd_cache[ 8 ][0]= mpx;\n\n                            mvd_cache[ 8 ][1]= mpy;\n\n                        }\n\n                        mv_cache[ 0 ][0]= mx;\n\n                        mv_cache[ 0 ][1]= my;\n\n\n\n                        mvd_cache[ 0 ][0]= mpx;\n\n                        mvd_cache[ 0 ][1]= mpy;\n\n                    }\n\n                }else{\n\n                    fill_rectangle(sl->mv_cache [list][ scan8[4*i] ], 2, 2, 8, 0, 4);\n\n                    fill_rectangle(sl->mvd_cache[list][ scan8[4*i] ], 2, 2, 8, 0, 2);\n\n                }\n\n            }\n\n        }\n\n    } else if( IS_DIRECT(mb_type) ) {\n\n        ff_h264_pred_direct_motion(h, sl, &mb_type);\n\n        fill_rectangle(sl->mvd_cache[0][scan8[0]], 4, 4, 8, 0, 2);\n\n        fill_rectangle(sl->mvd_cache[1][scan8[0]], 4, 4, 8, 0, 2);\n\n        dct8x8_allowed &= h->sps.direct_8x8_inference_flag;\n\n    } else {\n\n        int list, i;\n\n        if(IS_16X16(mb_type)){\n\n            for (list = 0; list < sl->list_count; list++) {\n\n                if(IS_DIR(mb_type, 0, list)){\n\n                    int ref, rc = sl->ref_count[list] << MB_MBAFF(sl);\n\n                    if (rc > 1) {\n\n                        ref= decode_cabac_mb_ref(sl, list, 0);\n\n                        if (ref >= (unsigned) rc) {\n\n                            av_log(h->avctx, AV_LOG_ERROR, \"Reference %d >= %d\\n\", ref, rc);\n\n                            return -1;\n\n                        }\n\n                    }else\n\n                        ref=0;\n\n                    fill_rectangle(&sl->ref_cache[list][ scan8[0] ], 4, 4, 8, ref, 1);\n\n                }\n\n            }\n\n            for (list = 0; list < sl->list_count; list++) {\n\n                if(IS_DIR(mb_type, 0, list)){\n\n                    int mx,my,mpx,mpy;\n\n                    pred_motion(h, sl, 0, 4, list, sl->ref_cache[list][ scan8[0] ], &mx, &my);\n\n                    DECODE_CABAC_MB_MVD(sl, list, 0)\n\n                    ff_tlog(h->avctx, \"final mv:%d %d\\n\", mx, my);\n\n\n\n                    fill_rectangle(sl->mvd_cache[list][ scan8[0] ], 4, 4, 8, pack8to16(mpx,mpy), 2);\n\n                    fill_rectangle(sl->mv_cache[list][ scan8[0] ], 4, 4, 8, pack16to32(mx,my), 4);\n\n                }\n\n            }\n\n        }\n\n        else if(IS_16X8(mb_type)){\n\n            for (list = 0; list < sl->list_count; list++) {\n\n                    for(i=0; i<2; i++){\n\n                        if(IS_DIR(mb_type, i, list)){\n\n                            int ref, rc = sl->ref_count[list] << MB_MBAFF(sl);\n\n                            if (rc > 1) {\n\n                                ref= decode_cabac_mb_ref(sl, list, 8 * i);\n\n                                if (ref >= (unsigned) rc) {\n\n                                    av_log(h->avctx, AV_LOG_ERROR, \"Reference %d >= %d\\n\", ref, rc);\n\n                                    return -1;\n\n                                }\n\n                            }else\n\n                                ref=0;\n\n                            fill_rectangle(&sl->ref_cache[list][ scan8[0] + 16*i ], 4, 2, 8, ref, 1);\n\n                        }else\n\n                            fill_rectangle(&sl->ref_cache[list][ scan8[0] + 16*i ], 4, 2, 8, (LIST_NOT_USED&0xFF), 1);\n\n                    }\n\n            }\n\n            for (list = 0; list < sl->list_count; list++) {\n\n                for(i=0; i<2; i++){\n\n                    if(IS_DIR(mb_type, i, list)){\n\n                        int mx,my,mpx,mpy;\n\n                        pred_16x8_motion(h, sl, 8*i, list, sl->ref_cache[list][scan8[0] + 16*i], &mx, &my);\n\n                        DECODE_CABAC_MB_MVD(sl, list, 8*i)\n\n                        ff_tlog(h->avctx, \"final mv:%d %d\\n\", mx, my);\n\n\n\n                        fill_rectangle(sl->mvd_cache[list][ scan8[0] + 16*i ], 4, 2, 8, pack8to16(mpx,mpy), 2);\n\n                        fill_rectangle(sl->mv_cache[list][ scan8[0] + 16*i ], 4, 2, 8, pack16to32(mx,my), 4);\n\n                    }else{\n\n                        fill_rectangle(sl->mvd_cache[list][ scan8[0] + 16*i ], 4, 2, 8, 0, 2);\n\n                        fill_rectangle(sl->mv_cache[list][ scan8[0] + 16*i ], 4, 2, 8, 0, 4);\n\n                    }\n\n                }\n\n            }\n\n        }else{\n\n            assert(IS_8X16(mb_type));\n\n            for (list = 0; list < sl->list_count; list++) {\n\n                    for(i=0; i<2; i++){\n\n                        if(IS_DIR(mb_type, i, list)){ //FIXME optimize\n\n                            int ref, rc = sl->ref_count[list] << MB_MBAFF(sl);\n\n                            if (rc > 1) {\n\n                                ref = decode_cabac_mb_ref(sl, list, 4 * i);\n\n                                if (ref >= (unsigned) rc) {\n\n                                    av_log(h->avctx, AV_LOG_ERROR, \"Reference %d >= %d\\n\", ref, rc);\n\n                                    return -1;\n\n                                }\n\n                            }else\n\n                                ref=0;\n\n                            fill_rectangle(&sl->ref_cache[list][ scan8[0] + 2*i ], 2, 4, 8, ref, 1);\n\n                        }else\n\n                            fill_rectangle(&sl->ref_cache[list][ scan8[0] + 2*i ], 2, 4, 8, (LIST_NOT_USED&0xFF), 1);\n\n                    }\n\n            }\n\n            for (list = 0; list < sl->list_count; list++) {\n\n                for(i=0; i<2; i++){\n\n                    if(IS_DIR(mb_type, i, list)){\n\n                        int mx,my,mpx,mpy;\n\n                        pred_8x16_motion(h, sl, i*4, list, sl->ref_cache[list][ scan8[0] + 2*i ], &mx, &my);\n\n                        DECODE_CABAC_MB_MVD(sl, list, 4*i)\n\n\n\n                        ff_tlog(h->avctx, \"final mv:%d %d\\n\", mx, my);\n\n                        fill_rectangle(sl->mvd_cache[list][ scan8[0] + 2*i ], 2, 4, 8, pack8to16(mpx,mpy), 2);\n\n                        fill_rectangle(sl->mv_cache[list][ scan8[0] + 2*i ], 2, 4, 8, pack16to32(mx,my), 4);\n\n                    }else{\n\n                        fill_rectangle(sl->mvd_cache[list][ scan8[0] + 2*i ], 2, 4, 8, 0, 2);\n\n                        fill_rectangle(sl->mv_cache[list][ scan8[0] + 2*i ], 2, 4, 8, 0, 4);\n\n                    }\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n   if( IS_INTER( mb_type ) ) {\n\n        h->chroma_pred_mode_table[mb_xy] = 0;\n\n        write_back_motion(h, sl, mb_type);\n\n   }\n\n\n\n    if( !IS_INTRA16x16( mb_type ) ) {\n\n        cbp  = decode_cabac_mb_cbp_luma(sl);\n\n        if(decode_chroma)\n\n            cbp |= decode_cabac_mb_cbp_chroma(sl) << 4;\n\n    }\n\n\n\n    h->cbp_table[mb_xy] = sl->cbp = cbp;\n\n\n\n    if( dct8x8_allowed && (cbp&15) && !IS_INTRA( mb_type ) ) {\n\n        mb_type |= MB_TYPE_8x8DCT * get_cabac_noinline(&sl->cabac, &sl->cabac_state[399 + sl->neighbor_transform_size]);\n\n    }\n\n\n\n    /* It would be better to do this in fill_decode_caches, but we don't know\n\n     * the transform mode of the current macroblock there. */\n\n    if (CHROMA444(h) && IS_8x8DCT(mb_type)){\n\n        int i;\n\n        uint8_t *nnz_cache = sl->non_zero_count_cache;\n\n        for (i = 0; i < 2; i++){\n\n            if (sl->left_type[LEFT(i)] && !IS_8x8DCT(sl->left_type[LEFT(i)])) {\n\n                nnz_cache[3+8* 1 + 2*8*i]=\n\n                nnz_cache[3+8* 2 + 2*8*i]=\n\n                nnz_cache[3+8* 6 + 2*8*i]=\n\n                nnz_cache[3+8* 7 + 2*8*i]=\n\n                nnz_cache[3+8*11 + 2*8*i]=\n\n                nnz_cache[3+8*12 + 2*8*i]= IS_INTRA(mb_type) ? 64 : 0;\n\n            }\n\n        }\n\n        if (sl->top_type && !IS_8x8DCT(sl->top_type)){\n\n            uint32_t top_empty = CABAC(h) && !IS_INTRA(mb_type) ? 0 : 0x40404040;\n\n            AV_WN32A(&nnz_cache[4+8* 0], top_empty);\n\n            AV_WN32A(&nnz_cache[4+8* 5], top_empty);\n\n            AV_WN32A(&nnz_cache[4+8*10], top_empty);\n\n        }\n\n    }\n\n    h->cur_pic.mb_type[mb_xy] = mb_type;\n\n\n\n    if( cbp || IS_INTRA16x16( mb_type ) ) {\n\n        const uint8_t *scan, *scan8x8;\n\n        const uint32_t *qmul;\n\n\n\n        if(IS_INTERLACED(mb_type)){\n\n            scan8x8 = sl->qscale ? h->field_scan8x8 : h->field_scan8x8_q0;\n\n            scan    = sl->qscale ? h->field_scan : h->field_scan_q0;\n\n        }else{\n\n            scan8x8 = sl->qscale ? h->zigzag_scan8x8 : h->zigzag_scan8x8_q0;\n\n            scan    = sl->qscale ? h->zigzag_scan : h->zigzag_scan_q0;\n\n        }\n\n\n\n        // decode_cabac_mb_dqp\n\n        if(get_cabac_noinline( &sl->cabac, &sl->cabac_state[60 + (sl->last_qscale_diff != 0)])){\n\n            int val = 1;\n\n            int ctx= 2;\n\n            const int max_qp = 51 + 6*(h->sps.bit_depth_luma-8);\n\n\n\n            while( get_cabac_noinline( &sl->cabac, &sl->cabac_state[60 + ctx] ) ) {\n\n                ctx= 3;\n\n                val++;\n\n                if(val > 2*max_qp){ //prevent infinite loop\n\n                    av_log(h->avctx, AV_LOG_ERROR, \"cabac decode of qscale diff failed at %d %d\\n\", sl->mb_x, sl->mb_y);\n\n                    return -1;\n\n                }\n\n            }\n\n\n\n            if( val&0x01 )\n\n                val=   (val + 1)>>1 ;\n\n            else\n\n                val= -((val + 1)>>1);\n\n            sl->last_qscale_diff = val;\n\n            sl->qscale += val;\n\n            if (((unsigned)sl->qscale) > max_qp){\n\n                if (sl->qscale < 0) sl->qscale += max_qp + 1;\n\n                else                sl->qscale -= max_qp + 1;\n\n            }\n\n            sl->chroma_qp[0] = get_chroma_qp(h, 0, sl->qscale);\n\n            sl->chroma_qp[1] = get_chroma_qp(h, 1, sl->qscale);\n\n        }else\n\n            sl->last_qscale_diff=0;\n\n\n\n        decode_cabac_luma_residual(h, sl, scan, scan8x8, pixel_shift, mb_type, cbp, 0);\n\n        if (CHROMA444(h)) {\n\n            decode_cabac_luma_residual(h, sl, scan, scan8x8, pixel_shift, mb_type, cbp, 1);\n\n            decode_cabac_luma_residual(h, sl, scan, scan8x8, pixel_shift, mb_type, cbp, 2);\n\n        } else if (CHROMA422(h)) {\n\n            if( cbp&0x30 ){\n\n                int c;\n\n                for (c = 0; c < 2; c++)\n\n                    decode_cabac_residual_dc_422(h, sl, sl->mb + ((256 + 16*16*c) << pixel_shift), 3,\n\n                                                 CHROMA_DC_BLOCK_INDEX + c,\n\n                                                 ff_h264_chroma422_dc_scan, 8);\n\n            }\n\n\n\n            if( cbp&0x20 ) {\n\n                int c, i, i8x8;\n\n                for( c = 0; c < 2; c++ ) {\n\n                    int16_t *mb = sl->mb + (16*(16 + 16*c) << pixel_shift);\n\n                    qmul = h->dequant4_coeff[c+1+(IS_INTRA( mb_type ) ? 0:3)][sl->chroma_qp[c]];\n\n                    for (i8x8 = 0; i8x8 < 2; i8x8++) {\n\n                        for (i = 0; i < 4; i++) {\n\n                            const int index = 16 + 16 * c + 8*i8x8 + i;\n\n                            decode_cabac_residual_nondc(h, sl, mb, 4, index, scan + 1, qmul, 15);\n\n                            mb += 16<<pixel_shift;\n\n                        }\n\n                    }\n\n                }\n\n            } else {\n\n                fill_rectangle(&sl->non_zero_count_cache[scan8[16]], 4, 4, 8, 0, 1);\n\n                fill_rectangle(&sl->non_zero_count_cache[scan8[32]], 4, 4, 8, 0, 1);\n\n            }\n\n        } else /* yuv420 */ {\n\n            if( cbp&0x30 ){\n\n                int c;\n\n                for (c = 0; c < 2; c++)\n\n                    decode_cabac_residual_dc(h, sl, sl->mb + ((256 + 16 * 16 * c) << pixel_shift),\n\n                                             3, CHROMA_DC_BLOCK_INDEX + c, ff_h264_chroma_dc_scan, 4);\n\n            }\n\n\n\n            if( cbp&0x20 ) {\n\n                int c, i;\n\n                for( c = 0; c < 2; c++ ) {\n\n                    qmul = h->dequant4_coeff[c+1+(IS_INTRA( mb_type ) ? 0:3)][sl->chroma_qp[c]];\n\n                    for( i = 0; i < 4; i++ ) {\n\n                        const int index = 16 + 16 * c + i;\n\n                        decode_cabac_residual_nondc(h, sl, sl->mb + (16*index << pixel_shift), 4, index, scan + 1, qmul, 15);\n\n                    }\n\n                }\n\n            } else {\n\n                fill_rectangle(&sl->non_zero_count_cache[scan8[16]], 4, 4, 8, 0, 1);\n\n                fill_rectangle(&sl->non_zero_count_cache[scan8[32]], 4, 4, 8, 0, 1);\n\n            }\n\n        }\n\n    } else {\n\n        fill_rectangle(&sl->non_zero_count_cache[scan8[ 0]], 4, 4, 8, 0, 1);\n\n        fill_rectangle(&sl->non_zero_count_cache[scan8[16]], 4, 4, 8, 0, 1);\n\n        fill_rectangle(&sl->non_zero_count_cache[scan8[32]], 4, 4, 8, 0, 1);\n\n        sl->last_qscale_diff = 0;\n\n    }\n\n\n\n    h->cur_pic.qscale_table[mb_xy] = sl->qscale;\n\n    write_back_non_zero_count(h, sl);\n\n\n\n    return 0;\n\n}\n", "idx": 23871}
{"project": "qemu", "commit_id": "30656b097e9dd7978d3fe9416cb9f5a421a9e63e", "target": 0, "func": "static ssize_t colo_rewriter_receive_iov(NetFilterState *nf,\n\n                                         NetClientState *sender,\n\n                                         unsigned flags,\n\n                                         const struct iovec *iov,\n\n                                         int iovcnt,\n\n                                         NetPacketSent *sent_cb)\n\n{\n\n    RewriterState *s = FILTER_COLO_REWRITER(nf);\n\n    Connection *conn;\n\n    ConnectionKey key;\n\n    Packet *pkt;\n\n    ssize_t size = iov_size(iov, iovcnt);\n\n    char *buf = g_malloc0(size);\n\n\n\n    iov_to_buf(iov, iovcnt, 0, buf, size);\n\n    pkt = packet_new(buf, size);\n\n\n\n    /*\n\n     * if we get tcp packet\n\n     * we will rewrite it to make secondary guest's\n\n     * connection established successfully\n\n     */\n\n    if (pkt && is_tcp_packet(pkt)) {\n\n\n\n        fill_connection_key(pkt, &key);\n\n\n\n        if (sender == nf->netdev) {\n\n            /*\n\n             * We need make tcp TX and RX packet\n\n             * into one connection.\n\n             */\n\n            reverse_connection_key(&key);\n\n        }\n\n        conn = connection_get(s->connection_track_table,\n\n                              &key,\n\n                              NULL);\n\n\n\n        if (sender == nf->netdev) {\n\n            /* NET_FILTER_DIRECTION_TX */\n\n            /* handle_primary_tcp_pkt */\n\n        } else {\n\n            /* NET_FILTER_DIRECTION_RX */\n\n            /* handle_secondary_tcp_pkt */\n\n        }\n\n    }\n\n\n\n    packet_destroy(pkt, NULL);\n\n    pkt = NULL;\n\n    return 0;\n\n}\n", "idx": 24046}
{"project": "qemu", "commit_id": "698feb5e13a2d763369909ce33f2bd7a7c1c11c0", "target": 0, "func": "static void vhost_iommu_region_del(MemoryListener *listener,\n\n                                   MemoryRegionSection *section)\n\n{\n\n    struct vhost_dev *dev = container_of(listener, struct vhost_dev,\n\n                                         iommu_listener);\n\n    struct vhost_iommu *iommu;\n\n\n\n    if (!memory_region_is_iommu(section->mr)) {\n\n        return;\n\n    }\n\n\n\n    QLIST_FOREACH(iommu, &dev->iommu_list, iommu_next) {\n\n        if (iommu->mr == section->mr) {\n\n            memory_region_unregister_iommu_notifier(iommu->mr,\n\n                                                    &iommu->n);\n\n            QLIST_REMOVE(iommu, iommu_next);\n\n            g_free(iommu);\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 24160}
{"project": "FFmpeg", "commit_id": "d31e3f7ccc5d1e198b3a582f4413ce7342928d8c", "target": 0, "func": "static int gif_write_header(AVFormatContext *s)\n\n{\n\n    GIFContext *gif = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    AVCodecContext *enc, *video_enc;\n\n    int i, width, height, loop_count /*, rate*/;\n\n\n\n/* XXX: do we reject audio streams or just ignore them ?\n\n    if(s->nb_streams > 1)\n\n        return -1;\n\n*/\n\n    gif->time = 0;\n\n    gif->file_time = 0;\n\n\n\n    video_enc = NULL;\n\n    for(i=0;i<s->nb_streams;i++) {\n\n        enc = s->streams[i]->codec;\n\n        if (enc->codec_type != AVMEDIA_TYPE_AUDIO)\n\n            video_enc = enc;\n\n    }\n\n\n\n    if (!video_enc) {\n\n        av_free(gif);\n\n        return -1;\n\n    } else {\n\n        width = video_enc->width;\n\n        height = video_enc->height;\n\n        loop_count = s->loop_output;\n\n//        rate = video_enc->time_base.den;\n\n    }\n\n\n\n    if (video_enc->pix_fmt != PIX_FMT_RGB24) {\n\n        av_log(s, AV_LOG_ERROR, \"ERROR: gif only handles the rgb24 pixel format. Use -pix_fmt rgb24.\\n\");\n\n        return AVERROR(EIO);\n\n    }\n\n\n\n    gif_image_write_header(pb, width, height, loop_count, NULL);\n\n\n\n    avio_flush(s->pb);\n\n    return 0;\n\n}\n", "idx": 24227}
{"project": "FFmpeg", "commit_id": "033f1644b59abd755bb529afa5db394d18d9c30b", "target": 1, "func": "fixup_vorbis_headers(AVFormatContext * as, struct oggvorbis_private *priv,\n\n                     uint8_t **buf)\n\n{\n\n    int i,offset, len, buf_len;\n\n    unsigned char *ptr;\n\n\n\n    len = priv->len[0] + priv->len[1] + priv->len[2];\n\n    buf_len = len + len/255 + 64;\n\n    ptr = *buf = av_realloc(NULL, buf_len);\n\n\n\n    memset(*buf, '\\0', buf_len);\n\n\n\n    ptr[0] = 2;\n\n    offset = 1;\n\n    offset += av_xiphlacing(&ptr[offset], priv->len[0]);\n\n    offset += av_xiphlacing(&ptr[offset], priv->len[1]);\n\n    for (i = 0; i < 3; i++) {\n\n        memcpy(&ptr[offset], priv->packet[i], priv->len[i]);\n\n        offset += priv->len[i];\n\n        av_freep(&priv->packet[i]);\n\n    }\n\n    *buf = av_realloc(*buf, offset + FF_INPUT_BUFFER_PADDING_SIZE);\n\n    return offset;\n\n}", "idx": 24235}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static void load_tco(const TestData *d)\n\n{\n\n    qpci_io_writew(d->dev, d->tco_io_base + TCO_RLD, 4);\n\n}\n", "idx": 24334}
{"project": "FFmpeg", "commit_id": "bacc4b6e8173fa944c24f297435dc507a60efb10", "target": 1, "func": "static void revert_acfilter(WmallDecodeCtx *s, int tile_size)\n\n{\n\n    int ich, pred, i, j;\n\n    int16_t *filter_coeffs = s->acfilter_coeffs;\n\n    int scaling            = s->acfilter_scaling;\n\n    int order              = s->acfilter_order;\n\n\n\n    for (ich = 0; ich < s->num_channels; ich++) {\n\n        int *prevvalues = s->acfilter_prevvalues[ich];\n\n        for (i = 0; i < order; i++) {\n\n            pred = 0;\n\n            for (j = 0; j < order; j++) {\n\n                if (i <= j)\n\n                    pred += filter_coeffs[j] * prevvalues[j - i];\n\n                else\n\n                    pred += s->channel_residues[ich][i - j - 1] * filter_coeffs[j];\n\n            }\n\n            pred >>= scaling;\n\n            s->channel_residues[ich][i] += pred;\n\n        }\n\n        for (i = order; i < tile_size; i++) {\n\n            pred = 0;\n\n            for (j = 0; j < order; j++)\n\n                pred += s->channel_residues[ich][i - j - 1] * filter_coeffs[j];\n\n            pred >>= scaling;\n\n            s->channel_residues[ich][i] += pred;\n\n        }\n\n        for (j = 0; j < order; j++)\n\n            prevvalues[j] = s->channel_residues[ich][tile_size - j - 1];\n\n    }\n\n}\n", "idx": 24471}
{"project": "FFmpeg", "commit_id": "2272ab0e84de6ef29548e0c89bb041a5c2e55a18", "target": 0, "func": "static int mp3_write_xing(AVFormatContext *s)\n\n{\n\n    MP3Context       *mp3 = s->priv_data;\n\n    AVCodecContext *codec = s->streams[mp3->audio_stream_idx]->codec;\n\n    AVDictionaryEntry *enc = av_dict_get(s->streams[mp3->audio_stream_idx]->metadata, \"encoder\", NULL, 0);\n\n    AVIOContext *dyn_ctx;\n\n    int32_t        header;\n\n    MPADecodeHeader  mpah;\n\n    int srate_idx, i, channels;\n\n    int bitrate_idx;\n\n    int best_bitrate_idx = -1;\n\n    int best_bitrate_error = INT_MAX;\n\n    int ret;\n\n    int ver = 0;\n\n    int bytes_needed;\n\n\n\n    if (!s->pb->seekable || !mp3->write_xing)\n\n        return 0;\n\n\n\n    for (i = 0; i < FF_ARRAY_ELEMS(avpriv_mpa_freq_tab); i++) {\n\n        const uint16_t base_freq = avpriv_mpa_freq_tab[i];\n\n\n\n        if      (codec->sample_rate == base_freq)     ver = 0x3; // MPEG 1\n\n        else if (codec->sample_rate == base_freq / 2) ver = 0x2; // MPEG 2\n\n        else if (codec->sample_rate == base_freq / 4) ver = 0x0; // MPEG 2.5\n\n        else continue;\n\n\n\n        srate_idx = i;\n\n        break;\n\n    }\n\n    if (i == FF_ARRAY_ELEMS(avpriv_mpa_freq_tab)) {\n\n        av_log(s, AV_LOG_WARNING, \"Unsupported sample rate, not writing Xing header.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    switch (codec->channels) {\n\n    case 1:  channels = MPA_MONO;                                          break;\n\n    case 2:  channels = MPA_STEREO;                                        break;\n\n    default: av_log(s, AV_LOG_WARNING, \"Unsupported number of channels, \"\n\n                    \"not writing Xing header.\\n\");\n\n             return -1;\n\n    }\n\n\n\n    /* dummy MPEG audio header */\n\n    header  =  0xffU                                 << 24; // sync\n\n    header |= (0x7 << 5 | ver << 3 | 0x1 << 1 | 0x1) << 16; // sync/audio-version/layer 3/no crc*/\n\n    header |= (srate_idx << 2) << 8;\n\n    header |= channels << 6;\n\n\n\n    for (bitrate_idx = 1; bitrate_idx < 15; bitrate_idx++) {\n\n        int bit_rate = 1000 * avpriv_mpa_bitrate_tab[ver != 3][3 - 1][bitrate_idx];\n\n        int error    = FFABS(bit_rate - codec->bit_rate);\n\n\n\n        if (error < best_bitrate_error) {\n\n            best_bitrate_error = error;\n\n            best_bitrate_idx   = bitrate_idx;\n\n        }\n\n    }\n\n    av_assert0(best_bitrate_idx >= 0);\n\n\n\n    for (bitrate_idx = best_bitrate_idx; ; bitrate_idx++) {\n\n        int32_t mask = bitrate_idx << (4 + 8);\n\n        if (15 == bitrate_idx)\n\n            return -1;\n\n        header |= mask;\n\n\n\n        avpriv_mpegaudio_decode_header(&mpah, header);\n\n        mp3->xing_offset = xing_offtbl[mpah.lsf == 1][mpah.nb_channels == 1] + 4;\n\n        bytes_needed     = mp3->xing_offset + XING_SIZE;\n\n\n\n        if (bytes_needed <= mpah.frame_size)\n\n            break;\n\n\n\n        header &= ~mask;\n\n    }\n\n\n\n    ret = avio_open_dyn_buf(&dyn_ctx);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    avio_wb32(dyn_ctx, header);\n\n\n\n    ffio_fill(dyn_ctx, 0, mp3->xing_offset - 4);\n\n    ffio_wfourcc(dyn_ctx, \"Xing\");\n\n    avio_wb32(dyn_ctx, 0x01 | 0x02 | 0x04 | 0x08);  // frames / size / TOC / vbr scale\n\n\n\n    mp3->size = mpah.frame_size;\n\n    mp3->want=1;\n\n    mp3->seen=0;\n\n    mp3->pos=0;\n\n\n\n    avio_wb32(dyn_ctx, 0);  // frames\n\n    avio_wb32(dyn_ctx, 0);  // size\n\n\n\n    // TOC\n\n    for (i = 0; i < XING_TOC_SIZE; i++)\n\n        avio_w8(dyn_ctx, (uint8_t)(255 * i / XING_TOC_SIZE));\n\n\n\n    // vbr quality\n\n    // we write it, because some (broken) tools always expect it to be present\n\n    avio_wb32(dyn_ctx, 0);\n\n\n\n    // encoder short version string\n\n    if (enc) {\n\n        uint8_t encoder_str[9] = { 0 };\n\n        if (   strlen(enc->value) > sizeof(encoder_str)\n\n            && !strcmp(\"Lavc libmp3lame\", enc->value)) {\n\n            memcpy(encoder_str, \"Lavf lame\", 9);\n\n        } else\n\n            memcpy(encoder_str, enc->value, FFMIN(strlen(enc->value), sizeof(encoder_str)));\n\n\n\n        avio_write(dyn_ctx, encoder_str, sizeof(encoder_str));\n\n    } else\n\n        avio_write(dyn_ctx, \"Lavf\\0\\0\\0\\0\\0\", 9);\n\n\n\n    avio_w8(dyn_ctx, 0);      // tag revision 0 / unknown vbr method\n\n    avio_w8(dyn_ctx, 0);      // unknown lowpass filter value\n\n    ffio_fill(dyn_ctx, 0, 8); // empty replaygain fields\n\n    avio_w8(dyn_ctx, 0);      // unknown encoding flags\n\n    avio_w8(dyn_ctx, 0);      // unknown abr/minimal bitrate\n\n\n\n    // encoder delay\n\n    if (codec->initial_padding - 528 - 1 >= 1 << 12) {\n\n        av_log(s, AV_LOG_WARNING, \"Too many samples of initial padding.\\n\");\n\n    }\n\n    avio_wb24(dyn_ctx, FFMAX(codec->initial_padding - 528 - 1, 0)<<12);\n\n\n\n    avio_w8(dyn_ctx,   0); // misc\n\n    avio_w8(dyn_ctx,   0); // mp3gain\n\n    avio_wb16(dyn_ctx, 0); // preset\n\n\n\n    // audio length and CRCs (will be updated later)\n\n    avio_wb32(dyn_ctx, 0); // music length\n\n    avio_wb16(dyn_ctx, 0); // music crc\n\n    avio_wb16(dyn_ctx, 0); // tag crc\n\n\n\n    ffio_fill(dyn_ctx, 0, mpah.frame_size - bytes_needed);\n\n\n\n    mp3->xing_frame_size   = avio_close_dyn_buf(dyn_ctx, &mp3->xing_frame);\n\n    mp3->xing_frame_offset = avio_tell(s->pb);\n\n    avio_write(s->pb, mp3->xing_frame, mp3->xing_frame_size);\n\n\n\n    mp3->audio_size = mp3->xing_frame_size;\n\n\n\n    return 0;\n\n}\n", "idx": 24506}
{"project": "qemu", "commit_id": "97f90cbfe810bb153fc44bde732d9639610783bb", "target": 0, "func": "static void dec_store(DisasContext *dc)\n\n{\n\n    TCGv t, *addr;\n\n    unsigned int size;\n\n\n\n    size = 1 << (dc->opcode & 3);\n\n\n\n    if (size > 4 && (dc->tb_flags & MSR_EE_FLAG)\n\n          && !(dc->env->pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)) {\n\n        tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_ILLEGAL_OP);\n\n        t_gen_raise_exception(dc, EXCP_HW_EXCP);\n\n        return;\n\n    }\n\n\n\n    LOG_DIS(\"s%d%s\\n\", size, dc->type_b ? \"i\" : \"\");\n\n    t_sync_flags(dc);\n\n    /* If we get a fault on a dslot, the jmpstate better be in sync.  */\n\n    sync_jmpstate(dc);\n\n    addr = compute_ldst_addr(dc, &t);\n\n\n\n    /* Verify alignment if needed.  */\n\n    if ((dc->env->pvr.regs[2] & PVR2_UNALIGNED_EXC_MASK) && size > 1) {\n\n        gen_helper_memalign(*addr, tcg_const_tl(dc->rd),\n\n                            tcg_const_tl(1), tcg_const_tl(size - 1));\n\n    }\n\n\n\n    gen_store(dc, *addr, cpu_R[dc->rd], size);\n\n    if (addr == &t)\n\n        tcg_temp_free(t);\n\n}\n", "idx": 24511}
{"project": "qemu", "commit_id": "8360544a6d3a54df1fce80f55ba4ad075a8ded54", "target": 0, "func": "static void qpci_spapr_io_writew(QPCIBus *bus, void *addr, uint16_t value)\n\n{\n\n    QPCIBusSPAPR *s = container_of(bus, QPCIBusSPAPR, bus);\n\n    uint64_t port = (uintptr_t)addr;\n\n    value = bswap16(value);\n\n    if (port < s->pio.size) {\n\n        writew(s->pio_cpu_base + port, value);\n\n    } else {\n\n        writew(s->mmio_cpu_base + port, value);\n\n    }\n\n}\n", "idx": 24514}
{"project": "FFmpeg", "commit_id": "add41decd94b2d3581a3715ba10f27168b8cdb1b", "target": 0, "func": "static int get_http_header_data(MMSHContext *mmsh)\n\n{\n\n    MMSContext *mms = &mmsh->mms;\n\n    int res, len;\n\n    ChunkType chunk_type;\n\n\n\n    for (;;) {\n\n        len = 0;\n\n        res = chunk_type = get_chunk_header(mmsh, &len);\n\n        if (res < 0) {\n\n            return res;\n\n        } else if (chunk_type == CHUNK_TYPE_ASF_HEADER){\n\n            // get asf header and stored it\n\n            if (!mms->header_parsed) {\n\n                if (mms->asf_header) {\n\n                    if (len != mms->asf_header_size) {\n\n                        mms->asf_header_size = len;\n\n                        av_dlog(NULL, \"Header len changed from %d to %d\\n\",\n\n                                mms->asf_header_size, len);\n\n                        av_freep(&mms->asf_header);\n\n                    }\n\n                }\n\n                mms->asf_header = av_mallocz(len);\n\n                if (!mms->asf_header) {\n\n                    return AVERROR(ENOMEM);\n\n                }\n\n                mms->asf_header_size = len;\n\n            }\n\n            if (len > mms->asf_header_size) {\n\n                av_log(NULL, AV_LOG_ERROR,\n\n                       \"Asf header packet len = %d exceed the asf header buf size %d\\n\",\n\n                       len, mms->asf_header_size);\n\n                return AVERROR(EIO);\n\n            }\n\n            res = ffurl_read_complete(mms->mms_hd, mms->asf_header, len);\n\n            if (res != len) {\n\n                av_log(NULL, AV_LOG_ERROR,\n\n                       \"Recv asf header data len %d != expected len %d\\n\", res, len);\n\n                return AVERROR(EIO);\n\n            }\n\n            mms->asf_header_size = len;\n\n            if (!mms->header_parsed) {\n\n                res = ff_mms_asf_header_parser(mms);\n\n                mms->header_parsed = 1;\n\n                return res;\n\n            }\n\n        } else if (chunk_type == CHUNK_TYPE_DATA) {\n\n            // read data packet and do padding\n\n            return read_data_packet(mmsh, len);\n\n        } else {\n\n            if (len) {\n\n                if (len > sizeof(mms->in_buffer)) {\n\n                    av_log(NULL, AV_LOG_ERROR,\n\n                           \"Other packet len = %d exceed the in_buffer size %zu\\n\",\n\n                           len, sizeof(mms->in_buffer));\n\n                    return AVERROR(EIO);\n\n                }\n\n                res = ffurl_read_complete(mms->mms_hd, mms->in_buffer, len);\n\n                if (res != len) {\n\n                    av_log(NULL, AV_LOG_ERROR, \"Read other chunk type data failed!\\n\");\n\n                    return AVERROR(EIO);\n\n                } else {\n\n                    av_dlog(NULL, \"Skip chunk type %d \\n\", chunk_type);\n\n                    continue;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 24545}
{"project": "qemu", "commit_id": "1b57bd4f2f4993104a5cb48912435396faa10d58", "target": 1, "func": "static inline bool rom_order_compare(Rom *rom, Rom *item)\n\n{\n\n    return (rom->as > item->as) ||\n\n           (rom->as == item->as && rom->addr >= item->addr);\n\n}\n", "idx": 24635}
{"project": "FFmpeg", "commit_id": "6a69a175e7b5c5393528ed0f5753e41573fa0df2", "target": 1, "func": "static void clear_context(MpegEncContext *s)\n\n{\n\n    int i, j, k;\n\n\n\n    memset(&s->next_picture, 0, sizeof(s->next_picture));\n\n    memset(&s->last_picture, 0, sizeof(s->last_picture));\n\n    memset(&s->current_picture, 0, sizeof(s->current_picture));\n\n    memset(&s->new_picture, 0, sizeof(s->new_picture));\n\n\n\n    memset(s->thread_context, 0, sizeof(s->thread_context));\n\n\n\n    s->me.map = NULL;\n\n    s->me.score_map = NULL;\n\n    s->dct_error_sum = NULL;\n\n    s->block = NULL;\n\n    s->blocks = NULL;\n\n    memset(s->pblocks, 0, sizeof(s->pblocks));\n\n    s->ac_val_base = NULL;\n\n    s->ac_val[0] =\n\n    s->ac_val[1] =\n\n    s->ac_val[2] =NULL;\n\n    s->sc.edge_emu_buffer = NULL;\n\n    s->me.scratchpad = NULL;\n\n    s->me.temp =\n\n    s->sc.rd_scratchpad =\n\n    s->sc.b_scratchpad =\n\n    s->sc.obmc_scratchpad = NULL;\n\n\n\n    s->parse_context.buffer = NULL;\n\n    s->parse_context.buffer_size = 0;\n\n\n    s->bitstream_buffer = NULL;\n\n    s->allocated_bitstream_buffer_size = 0;\n\n    s->picture          = NULL;\n\n    s->mb_type          = NULL;\n\n    s->p_mv_table_base  = NULL;\n\n    s->b_forw_mv_table_base = NULL;\n\n    s->b_back_mv_table_base = NULL;\n\n    s->b_bidir_forw_mv_table_base = NULL;\n\n    s->b_bidir_back_mv_table_base = NULL;\n\n    s->b_direct_mv_table_base = NULL;\n\n    s->p_mv_table            = NULL;\n\n    s->b_forw_mv_table       = NULL;\n\n    s->b_back_mv_table       = NULL;\n\n    s->b_bidir_forw_mv_table = NULL;\n\n    s->b_bidir_back_mv_table = NULL;\n\n    s->b_direct_mv_table     = NULL;\n\n    for (i = 0; i < 2; i++) {\n\n        for (j = 0; j < 2; j++) {\n\n            for (k = 0; k < 2; k++) {\n\n                s->b_field_mv_table_base[i][j][k] = NULL;\n\n                s->b_field_mv_table[i][j][k] = NULL;\n\n            }\n\n            s->b_field_select_table[i][j] = NULL;\n\n            s->p_field_mv_table_base[i][j] = NULL;\n\n            s->p_field_mv_table[i][j] = NULL;\n\n        }\n\n        s->p_field_select_table[i] = NULL;\n\n    }\n\n\n\n    s->dc_val_base = NULL;\n\n    s->coded_block_base = NULL;\n\n    s->mbintra_table = NULL;\n\n    s->cbp_table = NULL;\n\n    s->pred_dir_table = NULL;\n\n\n\n    s->mbskip_table = NULL;\n\n\n\n    s->er.error_status_table = NULL;\n\n    s->er.er_temp_buffer = NULL;\n\n    s->mb_index2xy = NULL;\n\n    s->lambda_table = NULL;\n\n\n\n    s->cplx_tab = NULL;\n\n    s->bits_tab = NULL;\n\n}", "idx": 24651}
{"project": "qemu", "commit_id": "f186d64d8fda4bb22c15beb8e45b7814fbd8b51e", "target": 0, "func": "bool replay_checkpoint(ReplayCheckpoint checkpoint)\n\n{\n\n    bool res = false;\n\n    assert(EVENT_CHECKPOINT + checkpoint <= EVENT_CHECKPOINT_LAST);\n\n    replay_save_instructions();\n\n\n\n    if (!replay_file) {\n\n        return true;\n\n    }\n\n\n\n    replay_mutex_lock();\n\n\n\n    if (replay_mode == REPLAY_MODE_PLAY) {\n\n        if (replay_next_event_is(EVENT_CHECKPOINT + checkpoint)) {\n\n            replay_finish_event();\n\n        } else if (replay_data_kind != EVENT_ASYNC) {\n\n            res = false;\n\n            goto out;\n\n        }\n\n        replay_read_events(checkpoint);\n\n        /* replay_read_events may leave some unread events.\n\n           Return false if not all of the events associated with\n\n           checkpoint were processed */\n\n        res = replay_data_kind != EVENT_ASYNC;\n\n    } else if (replay_mode == REPLAY_MODE_RECORD) {\n\n        replay_put_event(EVENT_CHECKPOINT + checkpoint);\n\n        replay_save_events(checkpoint);\n\n        res = true;\n\n    }\n\nout:\n\n    replay_mutex_unlock();\n\n    return res;\n\n}\n", "idx": 24711}
{"project": "qemu", "commit_id": "faadf50e2962dd54175647a80bd6fc4319c91973", "target": 1, "func": "static void init_proc_601 (CPUPPCState *env)\n\n{\n\n    gen_spr_ne_601(env);\n\n    gen_spr_601(env);\n\n    /* Hardware implementation registers */\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID0, \"HID0\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID1, \"HID1\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_601_HID2, \"HID2\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_601_HID5, \"HID5\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_601_HID15, \"HID15\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* Memory management */\n\n#if !defined(CONFIG_USER_ONLY)\n\n    env->nb_tlb = 64;\n\n    env->nb_ways = 2;\n\n    env->id_tlbs = 0;\n\n#endif\n\n    init_excp_601(env);\n\n    env->dcache_line_size = 64;\n\n    env->icache_line_size = 64;\n\n    /* XXX: TODO: allocate internal IRQ controller */\n\n}\n", "idx": 24918}
{"project": "qemu", "commit_id": "bb639f829f139ddc83325b3b6825f93096ee44f1", "target": 1, "func": "static void ahci_irq_raise(AHCIState *s, AHCIDevice *dev)\n\n{\n\n    AHCIPCIState *d = container_of(s, AHCIPCIState, ahci);\n\n    PCIDevice *pci_dev =\n\n        (PCIDevice *)object_dynamic_cast(OBJECT(d), TYPE_PCI_DEVICE);\n\n\n\n    DPRINTF(0, \"raise irq\\n\");\n\n\n\n    if (pci_dev && msi_enabled(pci_dev)) {\n\n        msi_notify(pci_dev, 0);\n\n    } else {\n\n        qemu_irq_raise(s->irq);\n\n    }\n\n}\n", "idx": 24965}
{"project": "FFmpeg", "commit_id": "47775cb8de880dfd2f82029d109229ae65aae767", "target": 0, "func": "static av_always_inline void decode_cabac_residual_internal( H264Context *h, DCTELEM *block, int cat, int n, const uint8_t *scantable, const uint32_t *qmul, int max_coeff, int is_dc ) {\n\n    static const int significant_coeff_flag_offset[2][6] = {\n\n      { 105+0, 105+15, 105+29, 105+44, 105+47, 402 },\n\n      { 277+0, 277+15, 277+29, 277+44, 277+47, 436 }\n\n    };\n\n    static const int last_coeff_flag_offset[2][6] = {\n\n      { 166+0, 166+15, 166+29, 166+44, 166+47, 417 },\n\n      { 338+0, 338+15, 338+29, 338+44, 338+47, 451 }\n\n    };\n\n    static const int coeff_abs_level_m1_offset[6] = {\n\n        227+0, 227+10, 227+20, 227+30, 227+39, 426\n\n    };\n\n    static const uint8_t significant_coeff_flag_offset_8x8[2][63] = {\n\n      { 0, 1, 2, 3, 4, 5, 5, 4, 4, 3, 3, 4, 4, 4, 5, 5,\n\n        4, 4, 4, 4, 3, 3, 6, 7, 7, 7, 8, 9,10, 9, 8, 7,\n\n        7, 6,11,12,13,11, 6, 7, 8, 9,14,10, 9, 8, 6,11,\n\n       12,13,11, 6, 9,14,10, 9,11,12,13,11,14,10,12 },\n\n      { 0, 1, 1, 2, 2, 3, 3, 4, 5, 6, 7, 7, 7, 8, 4, 5,\n\n        6, 9,10,10, 8,11,12,11, 9, 9,10,10, 8,11,12,11,\n\n        9, 9,10,10, 8,11,12,11, 9, 9,10,10, 8,13,13, 9,\n\n        9,10,10, 8,13,13, 9, 9,10,10,14,14,14,14,14 }\n\n    };\n\n    /* node ctx: 0..3: abslevel1 (with abslevelgt1 == 0).\n\n     * 4..7: abslevelgt1 + 3 (and abslevel1 doesn't matter).\n\n     * map node ctx => cabac ctx for level=1 */\n\n    static const uint8_t coeff_abs_level1_ctx[8] = { 1, 2, 3, 4, 0, 0, 0, 0 };\n\n    /* map node ctx => cabac ctx for level>1 */\n\n    static const uint8_t coeff_abs_levelgt1_ctx[8] = { 5, 5, 5, 5, 6, 7, 8, 9 };\n\n    static const uint8_t coeff_abs_level_transition[2][8] = {\n\n    /* update node ctx after decoding a level=1 */\n\n        { 1, 2, 3, 3, 4, 5, 6, 7 },\n\n    /* update node ctx after decoding a level>1 */\n\n        { 4, 4, 4, 4, 5, 6, 7, 7 }\n\n    };\n\n\n\n    int index[64];\n\n\n\n    int av_unused last;\n\n    int coeff_count = 0;\n\n    int node_ctx = 0;\n\n\n\n    uint8_t *significant_coeff_ctx_base;\n\n    uint8_t *last_coeff_ctx_base;\n\n    uint8_t *abs_level_m1_ctx_base;\n\n\n\n#ifndef ARCH_X86\n\n#define CABAC_ON_STACK\n\n#endif\n\n#ifdef CABAC_ON_STACK\n\n#define CC &cc\n\n    CABACContext cc;\n\n    cc.range     = h->cabac.range;\n\n    cc.low       = h->cabac.low;\n\n    cc.bytestream= h->cabac.bytestream;\n\n#else\n\n#define CC &h->cabac\n\n#endif\n\n\n\n\n\n    /* cat: 0-> DC 16x16  n = 0\n\n     *      1-> AC 16x16  n = luma4x4idx\n\n     *      2-> Luma4x4   n = luma4x4idx\n\n     *      3-> DC Chroma n = iCbCr\n\n     *      4-> AC Chroma n = 4 * iCbCr + chroma4x4idx\n\n     *      5-> Luma8x8   n = 4 * luma8x8idx\n\n     */\n\n\n\n    /* read coded block flag */\n\n    if( is_dc || cat != 5 ) {\n\n        if( get_cabac( CC, &h->cabac_state[85 + get_cabac_cbf_ctx( h, cat, n, is_dc ) ] ) == 0 ) {\n\n            if( !is_dc ) {\n\n                if( cat == 1 || cat == 2 )\n\n                    h->non_zero_count_cache[scan8[n]] = 0;\n\n                else\n\n                    h->non_zero_count_cache[scan8[16+n]] = 0;\n\n            }\n\n\n\n#ifdef CABAC_ON_STACK\n\n            h->cabac.range     = cc.range     ;\n\n            h->cabac.low       = cc.low       ;\n\n            h->cabac.bytestream= cc.bytestream;\n\n#endif\n\n            return;\n\n        }\n\n    }\n\n\n\n    significant_coeff_ctx_base = h->cabac_state\n\n        + significant_coeff_flag_offset[MB_FIELD][cat];\n\n    last_coeff_ctx_base = h->cabac_state\n\n        + last_coeff_flag_offset[MB_FIELD][cat];\n\n    abs_level_m1_ctx_base = h->cabac_state\n\n        + coeff_abs_level_m1_offset[cat];\n\n\n\n    if( !is_dc && cat == 5 ) {\n\n#define DECODE_SIGNIFICANCE( coefs, sig_off, last_off ) \\\n\n        for(last= 0; last < coefs; last++) { \\\n\n            uint8_t *sig_ctx = significant_coeff_ctx_base + sig_off; \\\n\n            if( get_cabac( CC, sig_ctx )) { \\\n\n                uint8_t *last_ctx = last_coeff_ctx_base + last_off; \\\n\n                index[coeff_count++] = last; \\\n\n                if( get_cabac( CC, last_ctx ) ) { \\\n\n                    last= max_coeff; \\\n\n                    break; \\\n\n                } \\\n\n            } \\\n\n        }\\\n\n        if( last == max_coeff -1 ) {\\\n\n            index[coeff_count++] = last;\\\n\n        }\n\n        const uint8_t *sig_off = significant_coeff_flag_offset_8x8[MB_FIELD];\n\n#if defined(ARCH_X86) && defined(HAVE_7REGS) && defined(HAVE_EBX_AVAILABLE) && !defined(BROKEN_RELOCATIONS)\n\n        coeff_count= decode_significance_8x8_x86(CC, significant_coeff_ctx_base, index, sig_off);\n\n    } else {\n\n        coeff_count= decode_significance_x86(CC, max_coeff, significant_coeff_ctx_base, index);\n\n#else\n\n        DECODE_SIGNIFICANCE( 63, sig_off[last], last_coeff_flag_offset_8x8[last] );\n\n    } else {\n\n        DECODE_SIGNIFICANCE( max_coeff - 1, last, last );\n\n#endif\n\n    }\n\n    assert(coeff_count > 0);\n\n\n\n    if( is_dc ) {\n\n        if( cat == 0 )\n\n            h->cbp_table[h->mb_xy] |= 0x100;\n\n        else\n\n            h->cbp_table[h->mb_xy] |= 0x40 << n;\n\n    } else {\n\n        if( cat == 1 || cat == 2 )\n\n            h->non_zero_count_cache[scan8[n]] = coeff_count;\n\n        else if( cat == 4 )\n\n            h->non_zero_count_cache[scan8[16+n]] = coeff_count;\n\n        else {\n\n            assert( cat == 5 );\n\n            fill_rectangle(&h->non_zero_count_cache[scan8[n]], 2, 2, 8, coeff_count, 1);\n\n        }\n\n    }\n\n\n\n    for( coeff_count--; coeff_count >= 0; coeff_count-- ) {\n\n        uint8_t *ctx = coeff_abs_level1_ctx[node_ctx] + abs_level_m1_ctx_base;\n\n\n\n        int j= scantable[index[coeff_count]];\n\n\n\n        if( get_cabac( CC, ctx ) == 0 ) {\n\n            node_ctx = coeff_abs_level_transition[0][node_ctx];\n\n            if( is_dc ) {\n\n                block[j] = get_cabac_bypass_sign( CC, -1);\n\n            }else{\n\n                block[j] = (get_cabac_bypass_sign( CC, -qmul[j]) + 32) >> 6;\n\n            }\n\n        } else {\n\n            int coeff_abs = 2;\n\n            ctx = coeff_abs_levelgt1_ctx[node_ctx] + abs_level_m1_ctx_base;\n\n            node_ctx = coeff_abs_level_transition[1][node_ctx];\n\n\n\n            while( coeff_abs < 15 && get_cabac( CC, ctx ) ) {\n\n                coeff_abs++;\n\n            }\n\n\n\n            if( coeff_abs >= 15 ) {\n\n                int j = 0;\n\n                while( get_cabac_bypass( CC ) ) {\n\n                    j++;\n\n                }\n\n\n\n                coeff_abs=1;\n\n                while( j-- ) {\n\n                    coeff_abs += coeff_abs + get_cabac_bypass( CC );\n\n                }\n\n                coeff_abs+= 14;\n\n            }\n\n\n\n            if( is_dc ) {\n\n                if( get_cabac_bypass( CC ) ) block[j] = -coeff_abs;\n\n                else                                block[j] =  coeff_abs;\n\n            }else{\n\n                if( get_cabac_bypass( CC ) ) block[j] = (-coeff_abs * qmul[j] + 32) >> 6;\n\n                else                                block[j] = ( coeff_abs * qmul[j] + 32) >> 6;\n\n            }\n\n        }\n\n    }\n\n#ifdef CABAC_ON_STACK\n\n            h->cabac.range     = cc.range     ;\n\n            h->cabac.low       = cc.low       ;\n\n            h->cabac.bytestream= cc.bytestream;\n\n#endif\n\n\n\n}\n", "idx": 24976}
{"project": "FFmpeg", "commit_id": "9c097f1cfc1825882353dc73e24a0d707d2495f2", "target": 0, "func": "static int ffserver_apply_stream_config(AVCodecContext *enc, const AVDictionary *conf, AVDictionary **opts)\n\n{\n\n    AVDictionaryEntry *e;\n\n    int ret = 0;\n\n\n\n    /* Return values from ffserver_set_*_param are ignored.\n\n       Values are initially parsed and checked before inserting to AVDictionary. */\n\n\n\n    //video params\n\n    if ((e = av_dict_get(conf, \"VideoBitRateRangeMin\", NULL, 0)))\n\n        ffserver_set_int_param(&enc->rc_min_rate, e->value, 1000, INT_MIN, INT_MAX, NULL, 0, NULL);\n\n    if ((e = av_dict_get(conf, \"VideoBitRateRangeMax\", NULL, 0)))\n\n        ffserver_set_int_param(&enc->rc_max_rate, e->value, 1000, INT_MIN, INT_MAX, NULL, 0, NULL);\n\n    if ((e = av_dict_get(conf, \"Debug\", NULL, 0)))\n\n        ffserver_set_int_param(&enc->debug, e->value, 0, INT_MIN, INT_MAX, NULL, 0, NULL);\n\n    if ((e = av_dict_get(conf, \"Strict\", NULL, 0)))\n\n        ffserver_set_int_param(&enc->strict_std_compliance, e->value, 0, INT_MIN, INT_MAX, NULL, 0, NULL);\n\n    if ((e = av_dict_get(conf, \"VideoBufferSize\", NULL, 0)))\n\n        ffserver_set_int_param(&enc->rc_buffer_size, e->value, 8*1024, INT_MIN, INT_MAX, NULL, 0, NULL);\n\n    if ((e = av_dict_get(conf, \"VideoBitRateTolerance\", NULL, 0)))\n\n        ffserver_set_int_param(&enc->bit_rate_tolerance, e->value, 1000, INT_MIN, INT_MAX, NULL, 0, NULL);\n\n    if ((e = av_dict_get(conf, \"VideoBitRate\", NULL, 0)))\n\n        ffserver_set_int_param(&enc->bit_rate, e->value, 1000, INT_MIN, INT_MAX, NULL, 0, NULL);\n\n    if ((e = av_dict_get(conf, \"VideoSizeWidth\", NULL, 0)))\n\n        ffserver_set_int_param(&enc->width, e->value, 0, INT_MIN, INT_MAX, NULL, 0, NULL);\n\n    if ((e = av_dict_get(conf, \"VideoSizeHeight\", NULL, 0)))\n\n        ffserver_set_int_param(&enc->height, e->value, 0, INT_MIN, INT_MAX, NULL, 0, NULL);\n\n    if ((e = av_dict_get(conf, \"PixelFormat\", NULL, 0))) {\n\n        int val;\n\n        ffserver_set_int_param(&val, e->value, 0, INT_MIN, INT_MAX, NULL, 0, NULL);\n\n        enc->pix_fmt = val;\n\n    }\n\n    if ((e = av_dict_get(conf, \"VideoGopSize\", NULL, 0)))\n\n        ffserver_set_int_param(&enc->gop_size, e->value, 0, INT_MIN, INT_MAX, NULL, 0, NULL);\n\n    if ((e = av_dict_get(conf, \"VideoFrameRateNum\", NULL, 0)))\n\n        ffserver_set_int_param(&enc->time_base.num, e->value, 0, INT_MIN, INT_MAX, NULL, 0, NULL);\n\n    if ((e = av_dict_get(conf, \"VideoFrameRateDen\", NULL, 0)))\n\n        ffserver_set_int_param(&enc->time_base.den, e->value, 0, INT_MIN, INT_MAX, NULL, 0, NULL);\n\n    if ((e = av_dict_get(conf, \"VideoQDiff\", NULL, 0)))\n\n        ffserver_set_int_param(&enc->max_qdiff, e->value, 0, INT_MIN, INT_MAX, NULL, 0, NULL);\n\n    if ((e = av_dict_get(conf, \"VideoQMax\", NULL, 0)))\n\n        ffserver_set_int_param(&enc->qmax, e->value, 0, INT_MIN, INT_MAX, NULL, 0, NULL);\n\n    if ((e = av_dict_get(conf, \"VideoQMin\", NULL, 0)))\n\n        ffserver_set_int_param(&enc->qmin, e->value, 0, INT_MIN, INT_MAX, NULL, 0, NULL);\n\n    if ((e = av_dict_get(conf, \"LumiMask\", NULL, 0)))\n\n        ffserver_set_float_param(&enc->lumi_masking, e->value, 0, -FLT_MAX, FLT_MAX, NULL, 0, NULL);\n\n    if ((e = av_dict_get(conf, \"DarkMask\", NULL, 0)))\n\n        ffserver_set_float_param(&enc->dark_masking, e->value, 0, -FLT_MAX, FLT_MAX, NULL, 0, NULL);\n\n    if (av_dict_get(conf, \"BitExact\", NULL, 0))\n\n        enc->flags |= CODEC_FLAG_BITEXACT;\n\n    if (av_dict_get(conf, \"DctFastint\", NULL, 0))\n\n        enc->dct_algo  = FF_DCT_FASTINT;\n\n    if (av_dict_get(conf, \"IdctSimple\", NULL, 0))\n\n        enc->idct_algo = FF_IDCT_SIMPLE;\n\n    if (av_dict_get(conf, \"VideoHighQuality\", NULL, 0))\n\n        enc->mb_decision = FF_MB_DECISION_BITS;\n\n    if ((e = av_dict_get(conf, \"VideoTag\", NULL, 0)))\n\n        enc->codec_tag = MKTAG(e->value[0], e->value[1], e->value[2], e->value[3]);\n\n    if (av_dict_get(conf, \"Qscale\", NULL, 0)) {\n\n        enc->flags |= CODEC_FLAG_QSCALE;\n\n        ffserver_set_int_param(&enc->global_quality, e->value, FF_QP2LAMBDA, INT_MIN, INT_MAX, NULL, 0, NULL);\n\n    }\n\n    if (av_dict_get(conf, \"Video4MotionVector\", NULL, 0)) {\n\n        enc->mb_decision = FF_MB_DECISION_BITS; //FIXME remove\n\n        enc->flags |= CODEC_FLAG_4MV;\n\n    }\n\n    //audio params\n\n    if ((e = av_dict_get(conf, \"AudioChannels\", NULL, 0)))\n\n        ffserver_set_int_param(&enc->channels, e->value, 0, INT_MIN, INT_MAX, NULL, 0, NULL);\n\n    if ((e = av_dict_get(conf, \"AudioSampleRate\", NULL, 0)))\n\n        ffserver_set_int_param(&enc->sample_rate, e->value, 0, INT_MIN, INT_MAX, NULL, 0, NULL);\n\n    if ((e = av_dict_get(conf, \"AudioBitRate\", NULL, 0)))\n\n        ffserver_set_int_param(&enc->bit_rate, e->value, 0, INT_MIN, INT_MAX, NULL, 0, NULL);\n\n\n\n    av_opt_set_dict2(enc, opts, AV_OPT_SEARCH_CHILDREN);\n\n    e = NULL;\n\n    while (e = av_dict_get(*opts, \"\", e, AV_DICT_IGNORE_SUFFIX)) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Provided AVOption '%s' doesn't match any existing option.\\n\", e->key);\n\n        ret = AVERROR(EINVAL);\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 25011}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "static inline void RENAME(yuvPlanartoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,\n\n\tunsigned int width, unsigned int height,\n\n\tint lumStride, int chromStride, int dstStride, int vertLumPerChroma)\n\n{\n\n\tunsigned y;\n\n\tconst unsigned chromWidth= width>>1;\n\n\tfor(y=0; y<height; y++)\n\n\t{\n\n#ifdef HAVE_MMX\n\n//FIXME handle 2 lines a once (fewer prefetch, reuse some chrom, but very likely limited by mem anyway)\n\n\t\tasm volatile(\n\n\t\t\t\"xor %%\"REG_a\", %%\"REG_a\"\t\\n\\t\"\n\n\t\t\t\".balign 16\t\t\t\\n\\t\"\n\n\t\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\tPREFETCH\" 32(%1, %%\"REG_a\", 2)\t\\n\\t\"\n\n\t\t\tPREFETCH\" 32(%2, %%\"REG_a\")\t\\n\\t\"\n\n\t\t\tPREFETCH\" 32(%3, %%\"REG_a\")\t\\n\\t\"\n\n\t\t\t\"movq (%2, %%\"REG_a\"), %%mm0\t\\n\\t\" // U(0)\n\n\t\t\t\"movq %%mm0, %%mm2\t\t\\n\\t\" // U(0)\n\n\t\t\t\"movq (%3, %%\"REG_a\"), %%mm1\t\\n\\t\" // V(0)\n\n\t\t\t\"punpcklbw %%mm1, %%mm0\t\t\\n\\t\" // UVUV UVUV(0)\n\n\t\t\t\"punpckhbw %%mm1, %%mm2\t\t\\n\\t\" // UVUV UVUV(8)\n\n\n\n\t\t\t\"movq (%1, %%\"REG_a\",2), %%mm3\t\\n\\t\" // Y(0)\n\n\t\t\t\"movq 8(%1, %%\"REG_a\",2), %%mm5\t\\n\\t\" // Y(8)\n\n\t\t\t\"movq %%mm3, %%mm4\t\t\\n\\t\" // Y(0)\n\n\t\t\t\"movq %%mm5, %%mm6\t\t\\n\\t\" // Y(8)\n\n\t\t\t\"punpcklbw %%mm0, %%mm3\t\t\\n\\t\" // YUYV YUYV(0)\n\n\t\t\t\"punpckhbw %%mm0, %%mm4\t\t\\n\\t\" // YUYV YUYV(4)\n\n\t\t\t\"punpcklbw %%mm2, %%mm5\t\t\\n\\t\" // YUYV YUYV(8)\n\n\t\t\t\"punpckhbw %%mm2, %%mm6\t\t\\n\\t\" // YUYV YUYV(12)\n\n\n\n\t\t\tMOVNTQ\" %%mm3, (%0, %%\"REG_a\", 4)\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm4, 8(%0, %%\"REG_a\", 4)\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm5, 16(%0, %%\"REG_a\", 4)\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm6, 24(%0, %%\"REG_a\", 4)\\n\\t\"\n\n\n\n\t\t\t\"add $8, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\"cmp %4, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\" jb 1b\t\t\t\t\\n\\t\"\n\n\t\t\t::\"r\"(dst), \"r\"(ysrc), \"r\"(usrc), \"r\"(vsrc), \"g\" ((long)chromWidth)\n\n\t\t\t: \"%\"REG_a\n\n\t\t);\n\n#else\n\n\n\n#if defined ARCH_ALPHA && defined HAVE_MVI\n\n#define pl2yuy2(n)\t\t\t\t\t\\\n\n\ty1 = yc[n];\t\t\t\t\t\\\n\n\ty2 = yc2[n];\t\t\t\t\t\\\n\n\tu = uc[n];\t\t\t\t\t\\\n\n\tv = vc[n];\t\t\t\t\t\\\n\n\tasm(\"unpkbw %1, %0\" : \"=r\"(y1) : \"r\"(y1));\t\\\n\n\tasm(\"unpkbw %1, %0\" : \"=r\"(y2) : \"r\"(y2));\t\\\n\n\tasm(\"unpkbl %1, %0\" : \"=r\"(u) : \"r\"(u));\t\\\n\n\tasm(\"unpkbl %1, %0\" : \"=r\"(v) : \"r\"(v));\t\\\n\n\tyuv1 = (u << 8) + (v << 24);\t\t\t\\\n\n\tyuv2 = yuv1 + y2;\t\t\t\t\\\n\n\tyuv1 += y1;\t\t\t\t\t\\\n\n\tqdst[n] = yuv1;\t\t\t\t\t\\\n\n\tqdst2[n] = yuv2;\n\n\n\n\t\tint i;\n\n\t\tuint64_t *qdst = (uint64_t *) dst;\n\n\t\tuint64_t *qdst2 = (uint64_t *) (dst + dstStride);\n\n\t\tconst uint32_t *yc = (uint32_t *) ysrc;\n\n\t\tconst uint32_t *yc2 = (uint32_t *) (ysrc + lumStride);\n\n\t\tconst uint16_t *uc = (uint16_t*) usrc, *vc = (uint16_t*) vsrc;\n\n\t\tfor(i = 0; i < chromWidth; i += 8){\n\n\t\t\tuint64_t y1, y2, yuv1, yuv2;\n\n\t\t\tuint64_t u, v;\n\n\t\t\t/* Prefetch */\n\n\t\t\tasm(\"ldq $31,64(%0)\" :: \"r\"(yc));\n\n\t\t\tasm(\"ldq $31,64(%0)\" :: \"r\"(yc2));\n\n\t\t\tasm(\"ldq $31,64(%0)\" :: \"r\"(uc));\n\n\t\t\tasm(\"ldq $31,64(%0)\" :: \"r\"(vc));\n\n\n\n\t\t\tpl2yuy2(0);\n\n\t\t\tpl2yuy2(1);\n\n\t\t\tpl2yuy2(2);\n\n\t\t\tpl2yuy2(3);\n\n\n\n\t\t\tyc += 4;\n\n\t\t\tyc2 += 4;\n\n\t\t\tuc += 4;\n\n\t\t\tvc += 4;\n\n\t\t\tqdst += 4;\n\n\t\t\tqdst2 += 4;\n\n\t\t}\n\n\t\ty++;\n\n\t\tysrc += lumStride;\n\n\t\tdst += dstStride;\n\n\n\n#elif __WORDSIZE >= 64\n\n\t\tint i;\n\n\t\tuint64_t *ldst = (uint64_t *) dst;\n\n\t\tconst uint8_t *yc = ysrc, *uc = usrc, *vc = vsrc;\n\n\t\tfor(i = 0; i < chromWidth; i += 2){\n\n\t\t\tuint64_t k, l;\n\n\t\t\tk = yc[0] + (uc[0] << 8) +\n\n\t\t\t    (yc[1] << 16) + (vc[0] << 24);\n\n\t\t\tl = yc[2] + (uc[1] << 8) +\n\n\t\t\t    (yc[3] << 16) + (vc[1] << 24);\n\n\t\t\t*ldst++ = k + (l << 32);\n\n\t\t\tyc += 4;\n\n\t\t\tuc += 2;\n\n\t\t\tvc += 2;\n\n\t\t}\n\n\n\n#else\n\n\t\tint i, *idst = (int32_t *) dst;\n\n\t\tconst uint8_t *yc = ysrc, *uc = usrc, *vc = vsrc;\n\n\t\tfor(i = 0; i < chromWidth; i++){\n\n#ifdef WORDS_BIGENDIAN\n\n\t\t\t*idst++ = (yc[0] << 24)+ (uc[0] << 16) +\n\n\t\t\t    (yc[1] << 8) + (vc[0] << 0);\n\n#else\n\n\t\t\t*idst++ = yc[0] + (uc[0] << 8) +\n\n\t\t\t    (yc[1] << 16) + (vc[0] << 24);\n\n#endif\n\n\t\t\tyc += 2;\n\n\t\t\tuc++;\n\n\t\t\tvc++;\n\n\t\t}\n\n#endif\n\n#endif\n\n\t\tif((y&(vertLumPerChroma-1))==(vertLumPerChroma-1) )\n\n\t\t{\n\n\t\t\tusrc += chromStride;\n\n\t\t\tvsrc += chromStride;\n\n\t\t}\n\n\t\tysrc += lumStride;\n\n\t\tdst += dstStride;\n\n\t}\n\n#ifdef HAVE_MMX\n\nasm(    EMMS\" \\n\\t\"\n\n        SFENCE\" \\n\\t\"\n\n        :::\"memory\");\n\n#endif\n\n}\n", "idx": 25184}
{"project": "qemu", "commit_id": "bec93d7283b635aabaf0bbff67b6da7fc99e020a", "target": 0, "func": "static void gen_compute_eflags_c(DisasContext *s, TCGv reg, bool inv)\n\n{\n\n    TCGv t0, t1;\n\n    int size;\n\n\n\n    switch (s->cc_op) {\n\n    case CC_OP_SUBB ... CC_OP_SUBQ:\n\n        /* (DATA_TYPE)(CC_DST + CC_SRC) < (DATA_TYPE)CC_SRC */\n\n        size = s->cc_op - CC_OP_SUBB;\n\n        t1 = gen_ext_tl(cpu_tmp0, cpu_cc_src, size, false);\n\n        /* If no temporary was used, be careful not to alias t1 and t0.  */\n\n        t0 = TCGV_EQUAL(t1, cpu_cc_src) ? cpu_tmp0 : reg;\n\n        tcg_gen_add_tl(t0, cpu_cc_dst, cpu_cc_src);\n\n        gen_extu(size, t0);\n\n        goto add_sub;\n\n\n\n    case CC_OP_ADDB ... CC_OP_ADDQ:\n\n        /* (DATA_TYPE)CC_DST < (DATA_TYPE)CC_SRC */\n\n        size = s->cc_op - CC_OP_ADDB;\n\n        t1 = gen_ext_tl(cpu_tmp0, cpu_cc_src, size, false);\n\n        t0 = gen_ext_tl(reg, cpu_cc_dst, size, false);\n\n    add_sub:\n\n        tcg_gen_setcond_tl(inv ? TCG_COND_GEU : TCG_COND_LTU, reg, t0, t1);\n\n        inv = false;\n\n        break;\n\n\n\n    case CC_OP_SBBB ... CC_OP_SBBQ:\n\n        /* (DATA_TYPE)(CC_DST + CC_SRC + 1) <= (DATA_TYPE)CC_SRC */\n\n        size = s->cc_op - CC_OP_SBBB;\n\n        t1 = gen_ext_tl(cpu_tmp0, cpu_cc_src, size, false);\n\n        if (TCGV_EQUAL(t1, reg) && TCGV_EQUAL(reg, cpu_cc_src)) {\n\n            tcg_gen_mov_tl(cpu_tmp0, cpu_cc_src);\n\n            t1 = cpu_tmp0;\n\n        }\n\n\n\n        tcg_gen_add_tl(reg, cpu_cc_dst, cpu_cc_src);\n\n        tcg_gen_addi_tl(reg, reg, 1);\n\n        gen_extu(size, reg);\n\n        t0 = reg;\n\n        goto adc_sbb;\n\n\n\n    case CC_OP_ADCB ... CC_OP_ADCQ:\n\n        /* (DATA_TYPE)CC_DST <= (DATA_TYPE)CC_SRC */\n\n        size = s->cc_op - CC_OP_ADCB;\n\n        t1 = gen_ext_tl(cpu_tmp0, cpu_cc_src, size, false);\n\n        t0 = gen_ext_tl(reg, cpu_cc_dst, size, false);\n\n    adc_sbb:\n\n        tcg_gen_setcond_tl(inv ? TCG_COND_GTU : TCG_COND_LEU, reg, t0, t1);\n\n        inv = false;\n\n        break;\n\n\n\n    case CC_OP_LOGICB ... CC_OP_LOGICQ:\n\n        tcg_gen_movi_tl(reg, 0);\n\n        break;\n\n\n\n    case CC_OP_INCB ... CC_OP_INCQ:\n\n    case CC_OP_DECB ... CC_OP_DECQ:\n\n        if (inv) {\n\n            tcg_gen_xori_tl(reg, cpu_cc_src, 1);\n\n        } else {\n\n            tcg_gen_mov_tl(reg, cpu_cc_src);\n\n        }\n\n        inv = false;\n\n        break;\n\n\n\n    case CC_OP_SHLB ... CC_OP_SHLQ:\n\n        /* (CC_SRC >> (DATA_BITS - 1)) & 1 */\n\n        size = s->cc_op - CC_OP_SHLB;\n\n        tcg_gen_shri_tl(reg, cpu_cc_src, (8 << size) - 1);\n\n        tcg_gen_andi_tl(reg, reg, 1);\n\n        break;\n\n\n\n    case CC_OP_MULB ... CC_OP_MULQ:\n\n        tcg_gen_setcondi_tl(inv ? TCG_COND_EQ : TCG_COND_NE,\n\n                            reg, cpu_cc_src, 0);\n\n        inv = false;\n\n        break;\n\n\n\n    case CC_OP_EFLAGS:\n\n    case CC_OP_SARB ... CC_OP_SARQ:\n\n        /* CC_SRC & 1 */\n\n        tcg_gen_andi_tl(reg, cpu_cc_src, 1);\n\n        break;\n\n\n\n    default:\n\n       /* The need to compute only C from CC_OP_DYNAMIC is important\n\n          in efficiently implementing e.g. INC at the start of a TB.  */\n\n       gen_update_cc_op(s);\n\n       gen_helper_cc_compute_c(cpu_tmp2_i32, cpu_env, cpu_cc_op);\n\n       tcg_gen_extu_i32_tl(reg, cpu_tmp2_i32);\n\n       break;\n\n    }\n\n    if (inv) {\n\n        tcg_gen_xori_tl(reg, reg, 1);\n\n    }\n\n}\n", "idx": 25324}
{"project": "qemu", "commit_id": "2fb50a33401a2415b71ddc291e8a77bcd2f9e547", "target": 0, "func": "static void set_irq_level(void *opaque, int n, int level)\n\n{\n\n    NVICState *s = opaque;\n\n    VecInfo *vec;\n\n\n\n    n += NVIC_FIRST_IRQ;\n\n\n\n    assert(n >= NVIC_FIRST_IRQ && n < s->num_irq);\n\n\n\n    trace_nvic_set_irq_level(n, level);\n\n\n\n    /* The pending status of an external interrupt is\n\n     * latched on rising edge and exception handler return.\n\n     *\n\n     * Pulsing the IRQ will always run the handler\n\n     * once, and the handler will re-run until the\n\n     * level is low when the handler completes.\n\n     */\n\n    vec = &s->vectors[n];\n\n    if (level != vec->level) {\n\n        vec->level = level;\n\n        if (level) {\n\n            armv7m_nvic_set_pending(s, n);\n\n        }\n\n    }\n\n}\n", "idx": 25363}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "static inline void RENAME(uyvytoyv12)(const uint8_t *src, uint8_t *ydst, uint8_t *udst, uint8_t *vdst,\n\n\tlong width, long height,\n\n\tlong lumStride, long chromStride, long srcStride)\n\n{\n\n\tlong y;\n\n\tconst long chromWidth= width>>1;\n\n\tfor(y=0; y<height; y+=2)\n\n\t{\n\n#ifdef HAVE_MMX\n\n\t\tasm volatile(\n\n\t\t\t\"xorl %%eax, %%eax\t\t\\n\\t\"\n\n\t\t\t\"pcmpeqw %%mm7, %%mm7\t\t\\n\\t\"\n\n\t\t\t\"psrlw $8, %%mm7\t\t\\n\\t\" // FF,00,FF,00...\n\n\t\t\tASMALIGN(4)\n\n\t\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\tPREFETCH\" 64(%0, %%eax, 4)\t\\n\\t\"\n\n\t\t\t\"movq (%0, %%eax, 4), %%mm0\t\\n\\t\" // UYVY UYVY(0)\n\n\t\t\t\"movq 8(%0, %%eax, 4), %%mm1\t\\n\\t\" // UYVY UYVY(4)\n\n\t\t\t\"movq %%mm0, %%mm2\t\t\\n\\t\" // UYVY UYVY(0)\n\n\t\t\t\"movq %%mm1, %%mm3\t\t\\n\\t\" // UYVY UYVY(4)\n\n\t\t\t\"pand %%mm7, %%mm0\t\t\\n\\t\" // U0V0 U0V0(0)\n\n\t\t\t\"pand %%mm7, %%mm1\t\t\\n\\t\" // U0V0 U0V0(4)\n\n\t\t\t\"psrlw $8, %%mm2\t\t\\n\\t\" // Y0Y0 Y0Y0(0)\n\n\t\t\t\"psrlw $8, %%mm3\t\t\\n\\t\" // Y0Y0 Y0Y0(4)\n\n\t\t\t\"packuswb %%mm1, %%mm0\t\t\\n\\t\" // UVUV UVUV(0)\n\n\t\t\t\"packuswb %%mm3, %%mm2\t\t\\n\\t\" // YYYY YYYY(0)\n\n\n\n\t\t\tMOVNTQ\" %%mm2, (%1, %%eax, 2)\t\\n\\t\"\n\n\n\n\t\t\t\"movq 16(%0, %%eax, 4), %%mm1\t\\n\\t\" // UYVY UYVY(8)\n\n\t\t\t\"movq 24(%0, %%eax, 4), %%mm2\t\\n\\t\" // UYVY UYVY(12)\n\n\t\t\t\"movq %%mm1, %%mm3\t\t\\n\\t\" // UYVY UYVY(8)\n\n\t\t\t\"movq %%mm2, %%mm4\t\t\\n\\t\" // UYVY UYVY(12)\n\n\t\t\t\"pand %%mm7, %%mm1\t\t\\n\\t\" // U0V0 U0V0(8)\n\n\t\t\t\"pand %%mm7, %%mm2\t\t\\n\\t\" // U0V0 U0V0(12)\n\n\t\t\t\"psrlw $8, %%mm3\t\t\\n\\t\" // Y0Y0 Y0Y0(8)\n\n\t\t\t\"psrlw $8, %%mm4\t\t\\n\\t\" // Y0Y0 Y0Y0(12)\n\n\t\t\t\"packuswb %%mm2, %%mm1\t\t\\n\\t\" // UVUV UVUV(8)\n\n\t\t\t\"packuswb %%mm4, %%mm3\t\t\\n\\t\" // YYYY YYYY(8)\n\n\n\n\t\t\tMOVNTQ\" %%mm3, 8(%1, %%eax, 2)\t\\n\\t\"\n\n\n\n\t\t\t\"movq %%mm0, %%mm2\t\t\\n\\t\" // UVUV UVUV(0)\n\n\t\t\t\"movq %%mm1, %%mm3\t\t\\n\\t\" // UVUV UVUV(8)\n\n\t\t\t\"psrlw $8, %%mm0\t\t\\n\\t\" // V0V0 V0V0(0)\n\n\t\t\t\"psrlw $8, %%mm1\t\t\\n\\t\" // V0V0 V0V0(8)\n\n\t\t\t\"pand %%mm7, %%mm2\t\t\\n\\t\" // U0U0 U0U0(0)\n\n\t\t\t\"pand %%mm7, %%mm3\t\t\\n\\t\" // U0U0 U0U0(8)\n\n\t\t\t\"packuswb %%mm1, %%mm0\t\t\\n\\t\" // VVVV VVVV(0)\n\n\t\t\t\"packuswb %%mm3, %%mm2\t\t\\n\\t\" // UUUU UUUU(0)\n\n\n\n\t\t\tMOVNTQ\" %%mm0, (%3, %%eax)\t\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm2, (%2, %%eax)\t\\n\\t\"\n\n\n\n\t\t\t\"addl $8, %%eax\t\t\t\\n\\t\"\n\n\t\t\t\"cmpl %4, %%eax\t\t\t\\n\\t\"\n\n\t\t\t\" jb 1b\t\t\t\t\\n\\t\"\n\n\t\t\t::\"r\"(src), \"r\"(ydst), \"r\"(udst), \"r\"(vdst), \"g\" (chromWidth)\n\n\t\t\t: \"memory\", \"%eax\"\n\n\t\t);\n\n\n\n\t\tydst += lumStride;\n\n\t\tsrc  += srcStride;\n\n\n\n\t\tasm volatile(\n\n\t\t\t\"xorl %%eax, %%eax\t\t\\n\\t\"\n\n\t\t\tASMALIGN(4)\n\n\t\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\tPREFETCH\" 64(%0, %%eax, 4)\t\\n\\t\"\n\n\t\t\t\"movq (%0, %%eax, 4), %%mm0\t\\n\\t\" // YUYV YUYV(0)\n\n\t\t\t\"movq 8(%0, %%eax, 4), %%mm1\t\\n\\t\" // YUYV YUYV(4)\n\n\t\t\t\"movq 16(%0, %%eax, 4), %%mm2\t\\n\\t\" // YUYV YUYV(8)\n\n\t\t\t\"movq 24(%0, %%eax, 4), %%mm3\t\\n\\t\" // YUYV YUYV(12)\n\n\t\t\t\"psrlw $8, %%mm0\t\t\\n\\t\" // Y0Y0 Y0Y0(0)\n\n\t\t\t\"psrlw $8, %%mm1\t\t\\n\\t\" // Y0Y0 Y0Y0(4)\n\n\t\t\t\"psrlw $8, %%mm2\t\t\\n\\t\" // Y0Y0 Y0Y0(8)\n\n\t\t\t\"psrlw $8, %%mm3\t\t\\n\\t\" // Y0Y0 Y0Y0(12)\n\n\t\t\t\"packuswb %%mm1, %%mm0\t\t\\n\\t\" // YYYY YYYY(0)\n\n\t\t\t\"packuswb %%mm3, %%mm2\t\t\\n\\t\" // YYYY YYYY(8)\n\n\n\n\t\t\tMOVNTQ\" %%mm0, (%1, %%eax, 2)\t\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm2, 8(%1, %%eax, 2)\t\\n\\t\"\n\n\n\n\t\t\t\"addl $8, %%eax\t\t\t\\n\\t\"\n\n\t\t\t\"cmpl %4, %%eax\t\t\t\\n\\t\"\n\n\t\t\t\" jb 1b\t\t\t\t\\n\\t\"\n\n\n\n\t\t\t::\"r\"(src), \"r\"(ydst), \"r\"(udst), \"r\"(vdst), \"g\" (chromWidth)\n\n\t\t\t: \"memory\", \"%eax\"\n\n\t\t);\n\n#else\n\n\t\tlong i;\n\n\t\tfor(i=0; i<chromWidth; i++)\n\n\t\t{\n\n\t\t\tudst[i] \t= src[4*i+0];\n\n\t\t\tydst[2*i+0] \t= src[4*i+1];\n\n\t\t\tvdst[i] \t= src[4*i+2];\n\n\t\t\tydst[2*i+1] \t= src[4*i+3];\n\n\t\t}\n\n\t\tydst += lumStride;\n\n\t\tsrc  += srcStride;\n\n\n\n\t\tfor(i=0; i<chromWidth; i++)\n\n\t\t{\n\n\t\t\tydst[2*i+0] \t= src[4*i+1];\n\n\t\t\tydst[2*i+1] \t= src[4*i+3];\n\n\t\t}\n\n#endif\n\n\t\tudst += chromStride;\n\n\t\tvdst += chromStride;\n\n\t\tydst += lumStride;\n\n\t\tsrc  += srcStride;\n\n\t}\n\n#ifdef HAVE_MMX\n\nasm volatile(   EMMS\" \\n\\t\"\n\n        \tSFENCE\" \\n\\t\"\n\n        \t:::\"memory\");\n\n#endif\n\n}\n", "idx": 25375}
{"project": "FFmpeg", "commit_id": "1a3598aae768465a8efc8475b6df5a8261bc62fc", "target": 1, "func": "static int jpeg2000_decode_packets(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile)\n\n{\n\n    int layno, reslevelno, compno, precno, ok_reslevel, ret;\n\n    uint8_t prog_order = tile->codsty[0].prog_order;\n\n    uint16_t x;\n\n    uint16_t y;\n\n\n\n    s->bit_index = 8;\n\n    switch (prog_order) {\n\n    case JPEG2000_PGOD_LRCP:\n\n        for (layno = 0; layno < tile->codsty[0].nlayers; layno++) {\n\n            ok_reslevel = 1;\n\n            for (reslevelno = 0; ok_reslevel; reslevelno++) {\n\n                ok_reslevel = 0;\n\n                for (compno = 0; compno < s->ncomponents; compno++) {\n\n                    Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n\n                    Jpeg2000QuantStyle *qntsty  = tile->qntsty + compno;\n\n                    if (reslevelno < codsty->nreslevels) {\n\n                        Jpeg2000ResLevel *rlevel = tile->comp[compno].reslevel +\n\n                                                   reslevelno;\n\n                        ok_reslevel = 1;\n\n                        for (precno = 0; precno < rlevel->num_precincts_x * rlevel->num_precincts_y; precno++)\n\n                            if ((ret = jpeg2000_decode_packet(s,\n\n                                                              codsty, rlevel,\n\n                                                              precno, layno,\n\n                                                              qntsty->expn + (reslevelno ? 3 * (reslevelno - 1) + 1 : 0),\n\n                                                              qntsty->nguardbits)) < 0)\n\n                                return ret;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        break;\n\n\n\n    case JPEG2000_PGOD_CPRL:\n\n        for (compno = 0; compno < s->ncomponents; compno++) {\n\n            Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n\n            Jpeg2000QuantStyle *qntsty  = tile->qntsty + compno;\n\n\n\n            /* Set bit stream buffer address according to tile-part.\n\n             * For DCinema one tile-part per component, so can be\n\n             * indexed by component. */\n\n            s->buf = tile->tile_part[compno].tp_start_bstrm;\n\n\n\n            /* Position loop (y axis)\n\n             * TODO: Automate computing of step 256.\n\n             * Fixed here, but to be computed before entering here. */\n\n            for (y = 0; y < s->height; y += 256) {\n\n                /* Position loop (y axis)\n\n                 * TODO: automate computing of step 256.\n\n                 * Fixed here, but to be computed before entering here. */\n\n                for (x = 0; x < s->width; x += 256) {\n\n                    for (reslevelno = 0; reslevelno < codsty->nreslevels; reslevelno++) {\n\n                        uint16_t prcx, prcy;\n\n                        uint8_t reducedresno = codsty->nreslevels - 1 -reslevelno; //  ==> N_L - r\n\n                        Jpeg2000ResLevel *rlevel = tile->comp[compno].reslevel + reslevelno;\n\n\n\n                        if (!((y % (1 << (rlevel->log2_prec_height + reducedresno)) == 0) ||\n\n                              (y == 0))) // TODO: 2nd condition simplified as try0 always =0 for dcinema\n\n                            continue;\n\n\n\n                        if (!((x % (1 << (rlevel->log2_prec_width + reducedresno)) == 0) ||\n\n                              (x == 0))) // TODO: 2nd condition simplified as try0 always =0 for dcinema\n\n                            continue;\n\n\n\n                        // check if a precinct exists\n\n                        prcx   = ff_jpeg2000_ceildivpow2(x, reducedresno) >> rlevel->log2_prec_width;\n\n                        prcy   = ff_jpeg2000_ceildivpow2(y, reducedresno) >> rlevel->log2_prec_height;\n\n                        precno = prcx + rlevel->num_precincts_x * prcy;\n\n                        for (layno = 0; layno < tile->codsty[0].nlayers; layno++) {\n\n                            if ((ret = jpeg2000_decode_packet(s, codsty, rlevel,\n\n                                                              precno, layno,\n\n                                                              qntsty->expn + (reslevelno ? 3 * (reslevelno - 1) + 1 : 0),\n\n                                                              qntsty->nguardbits)) < 0)\n\n                                return ret;\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        break;\n\n\n\n    default:\n\n        break;\n\n    }\n\n\n\n    /* EOC marker reached */\n\n    s->buf += 2;\n\n\n\n    return 0;\n\n}\n", "idx": 25460}
{"project": "FFmpeg", "commit_id": "f4ae3cce64bd46b1d539bdeac39753f83015f114", "target": 1, "func": "static void rstrip_spaces_buf(AVBPrint *buf)\n\n{\n\n    while (buf->len > 0 && buf->str[buf->len - 1] == ' ')\n\n        buf->str[--buf->len] = 0;\n\n}\n", "idx": 25477}
{"project": "qemu", "commit_id": "967b75230b9720ea2b3ae49f38f8287026125f9f", "target": 1, "func": "static void pnv_chip_power9_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PnvChipClass *k = PNV_CHIP_CLASS(klass);\n\n\n\n    k->cpu_model = \"POWER9\";\n\n    k->chip_type = PNV_CHIP_POWER9;\n\n    k->chip_cfam_id = 0x100d104980000000ull; /* P9 Nimbus DD1.0 */\n\n    k->cores_mask = POWER9_CORE_MASK;\n\n    k->core_pir = pnv_chip_core_pir_p9;\n\n\n    dc->desc = \"PowerNV Chip POWER9\";\n\n}", "idx": 25498}
{"project": "qemu", "commit_id": "7466bc49107fbd84336ba680f860d5eadd6def13", "target": 0, "func": "void qemu_spice_display_init(DisplayState *ds)\n\n{\n\n    assert(sdpy.ds == NULL);\n\n    sdpy.ds = ds;\n\n    sdpy.bufsize = (16 * 1024 * 1024);\n\n    sdpy.buf = qemu_malloc(sdpy.bufsize);\n\n    pthread_mutex_init(&sdpy.lock, NULL);\n\n    register_displaychangelistener(ds, &display_listener);\n\n\n\n    sdpy.qxl.base.sif = &dpy_interface.base;\n\n    qemu_spice_add_interface(&sdpy.qxl.base);\n\n    assert(sdpy.worker);\n\n\n\n    qemu_add_vm_change_state_handler(qemu_spice_vm_change_state_handler, &sdpy);\n\n    qemu_spice_create_host_memslot(&sdpy);\n\n    qemu_spice_create_host_primary(&sdpy);\n\n}\n", "idx": 25576}
{"project": "qemu", "commit_id": "b7bad50ae81efeb180609eeecdb086ebc7536ed7", "target": 0, "func": "static void cryptodev_builtin_cleanup(\n\n             CryptoDevBackend *backend,\n\n             Error **errp)\n\n{\n\n    CryptoDevBackendBuiltin *builtin =\n\n                      CRYPTODEV_BACKEND_BUILTIN(backend);\n\n    size_t i;\n\n    int queues = backend->conf.peers.queues;\n\n    CryptoDevBackendClient *cc;\n\n\n\n    for (i = 0; i < MAX_NUM_SESSIONS; i++) {\n\n        if (builtin->sessions[i] != NULL) {\n\n            cryptodev_builtin_sym_close_session(\n\n                    backend, i, 0, errp);\n\n        }\n\n    }\n\n\n\n    assert(queues == 1);\n\n\n\n    for (i = 0; i < queues; i++) {\n\n        cc = backend->conf.peers.ccs[i];\n\n        if (cc) {\n\n            cryptodev_backend_free_client(cc);\n\n            backend->conf.peers.ccs[i] = NULL;\n\n        }\n\n    }\n\n\n\n    cryptodev_backend_set_ready(backend, false);\n\n}\n", "idx": 25585}
{"project": "qemu", "commit_id": "ce137829e7e58fcdc5ba63b5e256f972e80be438", "target": 1, "func": "static void clear_commits(BDRVVVFATState* s)\n\n{\n\n    int i;\n\nDLOG(fprintf(stderr, \"clear_commits (%d commits)\\n\", s->commits.next));\n\n    for (i = 0; i < s->commits.next; i++) {\n\n\tcommit_t* commit = array_get(&(s->commits), i);\n\n\tassert(commit->path || commit->action == ACTION_WRITEOUT);\n\n\tif (commit->action != ACTION_WRITEOUT) {\n\n\t    assert(commit->path);\n\n\t    free(commit->path);\n\n\t} else\n\n\t    assert(commit->path == NULL);\n\n    }\n\n    s->commits.next = 0;\n\n}\n", "idx": 25586}
{"project": "qemu", "commit_id": "c527e0afcd7d719abc3a5ca5e4c8ac2fe48b999f", "target": 1, "func": "vmxnet3_dump_rx_descr(struct Vmxnet3_RxDesc *descr)\n\n{\n\n    VMW_PKPRN(\"RX DESCR: addr %\" PRIx64 \", len: %d, gen: %d, rsvd: %d, \"\n\n              \"dtype: %d, ext1: %d, btype: %d\",\n\n              le64_to_cpu(descr->addr), descr->len, descr->gen,\n\n              descr->rsvd, descr->dtype, descr->ext1, descr->btype);\n\n}\n", "idx": 25600}
{"project": "qemu", "commit_id": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc", "target": 0, "func": "static void qmp_chardev_open_socket(Chardev *chr,\n\n                                    ChardevBackend *backend,\n\n                                    bool *be_opened,\n\n                                    Error **errp)\n\n{\n\n    SocketChardev *s = SOCKET_CHARDEV(chr);\n\n    ChardevSocket *sock = backend->u.socket.data;\n\n    SocketAddress *addr = sock->addr;\n\n    bool do_nodelay     = sock->has_nodelay ? sock->nodelay : false;\n\n    bool is_listen      = sock->has_server  ? sock->server  : true;\n\n    bool is_telnet      = sock->has_telnet  ? sock->telnet  : false;\n\n    bool is_tn3270      = sock->has_tn3270  ? sock->tn3270  : false;\n\n    bool is_waitconnect = sock->has_wait    ? sock->wait    : false;\n\n    int64_t reconnect   = sock->has_reconnect ? sock->reconnect : 0;\n\n    QIOChannelSocket *sioc = NULL;\n\n\n\n    s->is_listen = is_listen;\n\n    s->is_telnet = is_telnet;\n\n    s->is_tn3270 = is_tn3270;\n\n    s->do_nodelay = do_nodelay;\n\n    if (sock->tls_creds) {\n\n        Object *creds;\n\n        creds = object_resolve_path_component(\n\n            object_get_objects_root(), sock->tls_creds);\n\n        if (!creds) {\n\n            error_setg(errp, \"No TLS credentials with id '%s'\",\n\n                       sock->tls_creds);\n\n            goto error;\n\n        }\n\n        s->tls_creds = (QCryptoTLSCreds *)\n\n            object_dynamic_cast(creds,\n\n                                TYPE_QCRYPTO_TLS_CREDS);\n\n        if (!s->tls_creds) {\n\n            error_setg(errp, \"Object with id '%s' is not TLS credentials\",\n\n                       sock->tls_creds);\n\n            goto error;\n\n        }\n\n        object_ref(OBJECT(s->tls_creds));\n\n        if (is_listen) {\n\n            if (s->tls_creds->endpoint != QCRYPTO_TLS_CREDS_ENDPOINT_SERVER) {\n\n                error_setg(errp, \"%s\",\n\n                           \"Expected TLS credentials for server endpoint\");\n\n                goto error;\n\n            }\n\n        } else {\n\n            if (s->tls_creds->endpoint != QCRYPTO_TLS_CREDS_ENDPOINT_CLIENT) {\n\n                error_setg(errp, \"%s\",\n\n                           \"Expected TLS credentials for client endpoint\");\n\n                goto error;\n\n            }\n\n        }\n\n    }\n\n\n\n    s->addr = QAPI_CLONE(SocketAddress, sock->addr);\n\n\n\n    qemu_chr_set_feature(chr, QEMU_CHAR_FEATURE_RECONNECTABLE);\n\n    /* TODO SOCKET_ADDRESS_FD where fd has AF_UNIX */\n\n    if (addr->type == SOCKET_ADDRESS_KIND_UNIX) {\n\n        qemu_chr_set_feature(chr, QEMU_CHAR_FEATURE_FD_PASS);\n\n    }\n\n\n\n    /* be isn't opened until we get a connection */\n\n    *be_opened = false;\n\n\n\n    update_disconnected_filename(s);\n\n\n\n    if (is_listen) {\n\n        if (is_telnet || is_tn3270) {\n\n            s->do_telnetopt = 1;\n\n        }\n\n    } else if (reconnect > 0) {\n\n        s->reconnect_time = reconnect;\n\n    }\n\n\n\n    if (s->reconnect_time) {\n\n        sioc = qio_channel_socket_new();\n\n        tcp_chr_set_client_ioc_name(chr, sioc);\n\n        qio_channel_socket_connect_async(sioc, s->addr,\n\n                                         qemu_chr_socket_connected,\n\n                                         chr, NULL);\n\n    } else {\n\n        if (s->is_listen) {\n\n            char *name;\n\n            sioc = qio_channel_socket_new();\n\n\n\n            name = g_strdup_printf(\"chardev-tcp-listener-%s\", chr->label);\n\n            qio_channel_set_name(QIO_CHANNEL(sioc), name);\n\n            g_free(name);\n\n\n\n            if (qio_channel_socket_listen_sync(sioc, s->addr, errp) < 0) {\n\n                goto error;\n\n            }\n\n\n\n            qapi_free_SocketAddress(s->addr);\n\n            s->addr = socket_local_address(sioc->fd, errp);\n\n            update_disconnected_filename(s);\n\n\n\n            s->listen_ioc = sioc;\n\n            if (is_waitconnect &&\n\n                qemu_chr_wait_connected(chr, errp) < 0) {\n\n                return;\n\n            }\n\n            if (!s->ioc) {\n\n                s->listen_tag = qio_channel_add_watch(\n\n                    QIO_CHANNEL(s->listen_ioc), G_IO_IN,\n\n                    tcp_chr_accept, chr, NULL);\n\n            }\n\n        } else if (qemu_chr_wait_connected(chr, errp) < 0) {\n\n            goto error;\n\n        }\n\n    }\n\n\n\n    return;\n\n\n\nerror:\n\n    if (sioc) {\n\n        object_unref(OBJECT(sioc));\n\n    }\n\n}\n", "idx": 25625}
{"project": "qemu", "commit_id": "456d60692310e7ac25cf822cc1e98192ad636ece", "target": 1, "func": "static CharDriverState* create_eventfd_chr_device(void * opaque, EventNotifier *n,\n\n                                                  int vector)\n\n{\n\n    /* create a event character device based on the passed eventfd */\n\n    IVShmemState *s = opaque;\n\n    CharDriverState * chr;\n\n    int eventfd = event_notifier_get_fd(n);\n\n\n\n    chr = qemu_chr_open_eventfd(eventfd);\n\n\n\n    if (chr == NULL) {\n\n        fprintf(stderr, \"creating eventfd for eventfd %d failed\\n\", eventfd);\n\n        exit(-1);\n\n    }\n\n\n\n\n    /* if MSI is supported we need multiple interrupts */\n\n    if (ivshmem_has_feature(s, IVSHMEM_MSI)) {\n\n        s->eventfd_table[vector].pdev = &s->dev;\n\n        s->eventfd_table[vector].vector = vector;\n\n\n\n        qemu_chr_add_handlers(chr, ivshmem_can_receive, fake_irqfd,\n\n                      ivshmem_event, &s->eventfd_table[vector]);\n\n    } else {\n\n        qemu_chr_add_handlers(chr, ivshmem_can_receive, ivshmem_receive,\n\n                      ivshmem_event, s);\n\n    }\n\n\n\n    return chr;\n\n\n\n}", "idx": 25682}
{"project": "qemu", "commit_id": "9359a58b122187964d7465d48165680eadbf69d3", "target": 0, "func": "static void ehci_opreg_write(void *ptr, hwaddr addr,\n\n                             uint64_t val, unsigned size)\n\n{\n\n    EHCIState *s = ptr;\n\n    uint32_t *mmio = s->opreg + (addr >> 2);\n\n    uint32_t old = *mmio;\n\n    int i;\n\n\n\n    trace_usb_ehci_opreg_write(addr + s->opregbase, addr2str(addr), val);\n\n\n\n    switch (addr) {\n\n    case USBCMD:\n\n        if (val & USBCMD_HCRESET) {\n\n            ehci_reset(s);\n\n            val = s->usbcmd;\n\n            break;\n\n        }\n\n\n\n        /* not supporting dynamic frame list size at the moment */\n\n        if ((val & USBCMD_FLS) && !(s->usbcmd & USBCMD_FLS)) {\n\n            fprintf(stderr, \"attempt to set frame list size -- value %d\\n\",\n\n                    (int)val & USBCMD_FLS);\n\n            val &= ~USBCMD_FLS;\n\n        }\n\n\n\n        if (val & USBCMD_IAAD) {\n\n            /*\n\n             * Process IAAD immediately, otherwise the Linux IAAD watchdog may\n\n             * trigger and re-use a qh without us seeing the unlink.\n\n             */\n\n            s->async_stepdown = 0;\n\n            qemu_bh_schedule(s->async_bh);\n\n            trace_usb_ehci_doorbell_ring();\n\n        }\n\n\n\n        if (((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & val) !=\n\n            ((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & s->usbcmd)) {\n\n            if (s->pstate == EST_INACTIVE) {\n\n                SET_LAST_RUN_CLOCK(s);\n\n            }\n\n            s->usbcmd = val; /* Set usbcmd for ehci_update_halt() */\n\n            ehci_update_halt(s);\n\n            s->async_stepdown = 0;\n\n            qemu_bh_schedule(s->async_bh);\n\n        }\n\n        break;\n\n\n\n    case USBSTS:\n\n        val &= USBSTS_RO_MASK;              // bits 6 through 31 are RO\n\n        ehci_clear_usbsts(s, val);          // bits 0 through 5 are R/WC\n\n        val = s->usbsts;\n\n        ehci_update_irq(s);\n\n        break;\n\n\n\n    case USBINTR:\n\n        val &= USBINTR_MASK;\n\n        if (ehci_enabled(s) && (USBSTS_FLR & val)) {\n\n            qemu_bh_schedule(s->async_bh);\n\n        }\n\n        break;\n\n\n\n    case FRINDEX:\n\n        val &= 0x00003ff8; /* frindex is 14bits and always a multiple of 8 */\n\n        break;\n\n\n\n    case CONFIGFLAG:\n\n        val &= 0x1;\n\n        if (val) {\n\n            for(i = 0; i < NB_PORTS; i++)\n\n                handle_port_owner_write(s, i, 0);\n\n        }\n\n        break;\n\n\n\n    case PERIODICLISTBASE:\n\n        if (ehci_periodic_enabled(s)) {\n\n            fprintf(stderr,\n\n              \"ehci: PERIODIC list base register set while periodic schedule\\n\"\n\n              \"      is enabled and HC is enabled\\n\");\n\n        }\n\n        break;\n\n\n\n    case ASYNCLISTADDR:\n\n        if (ehci_async_enabled(s)) {\n\n            fprintf(stderr,\n\n              \"ehci: ASYNC list address register set while async schedule\\n\"\n\n              \"      is enabled and HC is enabled\\n\");\n\n        }\n\n        break;\n\n    }\n\n\n\n    *mmio = val;\n\n    trace_usb_ehci_opreg_change(addr + s->opregbase, addr2str(addr),\n\n                                *mmio, old);\n\n}\n", "idx": 25710}
{"project": "qemu", "commit_id": "baf35cb90204d75404892aa4e52628ae7a00669b", "target": 1, "func": "void qemu_aio_init(void)\n\n{\n\n    struct sigaction act;\n\n\n\n    aio_initialized = 1;\n\n\n\n    sigfillset(&act.sa_mask);\n\n    act.sa_flags = 0; /* do not restart syscalls to interrupt select() */\n\n    act.sa_handler = aio_signal_handler;\n\n    sigaction(aio_sig_num, &act, NULL);\n\n\n\n#if defined(__GLIBC__) && defined(__linux__)\n\n    {\n\n        /* XXX: aio thread exit seems to hang on RedHat 9 and this init\n\n           seems to fix the problem. */\n\n        struct aioinit ai;\n\n        memset(&ai, 0, sizeof(ai));\n\n        ai.aio_threads = 1;\n\n        ai.aio_num = 1;\n\n        ai.aio_idle_time = 365 * 100000;\n\n        aio_init(&ai);\n\n    }\n\n#endif\n\n}\n", "idx": 25717}
{"project": "qemu", "commit_id": "17eb587aeb492fe68f8130b027154ff0921fc0b4", "target": 1, "func": "static int tftp_session_allocate(Slirp *slirp, struct sockaddr_storage *srcsas,\n\n                                 struct tftp_t *tp)\n\n{\n\n  struct tftp_session *spt;\n\n  int k;\n\n\n\n  for (k = 0; k < TFTP_SESSIONS_MAX; k++) {\n\n    spt = &slirp->tftp_sessions[k];\n\n\n\n    if (!tftp_session_in_use(spt))\n\n        goto found;\n\n\n\n    /* sessions time out after 5 inactive seconds */\n\n    if ((int)(curtime - spt->timestamp) > 5000) {\n\n        tftp_session_terminate(spt);\n\n        goto found;\n\n    }\n\n  }\n\n\n\n  return -1;\n\n\n\n found:\n\n  memset(spt, 0, sizeof(*spt));\n\n  spt->client_addr = *srcsas;\n\n  spt->fd = -1;\n\n  spt->block_size = 512;\n\n  spt->client_port = tp->udp.uh_sport;\n\n  spt->slirp = slirp;\n\n\n\n  tftp_session_update(spt);\n\n\n\n  return k;\n\n}\n", "idx": 25785}
{"project": "qemu", "commit_id": "e53f27b9d9df73461308618151fa6e6392aebd85", "target": 1, "func": "static int tcp_get_msgfd(CharDriverState *chr)\n\n{\n\n    TCPCharDriver *s = chr->opaque;\n\n\n\n    return s->msgfd;\n\n}\n", "idx": 25839}
{"project": "qemu", "commit_id": "4c8d0d27676778febad3802a95218d5ceaca171e", "target": 0, "func": "void qemu_fd_register(int fd)\n\n{\n\n    WSAEventSelect(fd, qemu_event_handle, FD_READ | FD_ACCEPT | FD_CLOSE |\n\n                   FD_CONNECT | FD_WRITE | FD_OOB);\n\n}\n", "idx": 25975}
{"project": "qemu", "commit_id": "187337f8b0ec0813dd3876d1efe37d415fb81c2e", "target": 1, "func": "static struct pxa2xx_i2s_s *pxa2xx_i2s_init(target_phys_addr_t base,\n\n                qemu_irq irq, struct pxa2xx_dma_state_s *dma)\n\n{\n\n    int iomemtype;\n\n    struct pxa2xx_i2s_s *s = (struct pxa2xx_i2s_s *)\n\n            qemu_mallocz(sizeof(struct pxa2xx_i2s_s));\n\n\n\n    s->base = base;\n\n    s->irq = irq;\n\n    s->dma = dma;\n\n    s->data_req = pxa2xx_i2s_data_req;\n\n\n\n    pxa2xx_i2s_reset(s);\n\n\n\n    iomemtype = cpu_register_io_memory(0, pxa2xx_i2s_readfn,\n\n                    pxa2xx_i2s_writefn, s);\n\n    cpu_register_physical_memory(s->base & 0xfff00000, 0xfffff, iomemtype);\n\n\n\n    register_savevm(\"pxa2xx_i2s\", base, 0,\n\n                    pxa2xx_i2s_save, pxa2xx_i2s_load, s);\n\n\n\n    return s;\n\n}\n", "idx": 25980}
{"project": "FFmpeg", "commit_id": "ac9919b9662f28816cf79c1d5c36719160009588", "target": 0, "func": "static void mxf_write_cdci_common(AVFormatContext *s, AVStream *st, const UID key, unsigned size)\n\n{\n\n    MXFStreamContext *sc = st->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    int stored_height = (st->codec->height+15)/16*16;\n\n    int display_height;\n\n    int f1, f2;\n\n    unsigned desc_size = size+8+8+8+8+8+8+5+16+sc->interlaced*4+12+20;\n\n    if (sc->interlaced && sc->field_dominance)\n\n        desc_size += 5;\n\n\n\n    mxf_write_generic_desc(s, st, key, desc_size);\n\n\n\n    mxf_write_local_tag(pb, 4, 0x3203);\n\n    avio_wb32(pb, st->codec->width);\n\n\n\n    mxf_write_local_tag(pb, 4, 0x3202);\n\n    avio_wb32(pb, stored_height>>sc->interlaced);\n\n\n\n    mxf_write_local_tag(pb, 4, 0x3209);\n\n    avio_wb32(pb, st->codec->width);\n\n\n\n    if (st->codec->height == 608) // PAL + VBI\n\n        display_height = 576;\n\n    else if (st->codec->height == 512)  // NTSC + VBI\n\n        display_height = 486;\n\n    else\n\n        display_height = st->codec->height;\n\n\n\n    mxf_write_local_tag(pb, 4, 0x3208);\n\n    avio_wb32(pb, display_height>>sc->interlaced);\n\n\n\n    // component depth\n\n    mxf_write_local_tag(pb, 4, 0x3301);\n\n    avio_wb32(pb, sc->component_depth);\n\n\n\n    // horizontal subsampling\n\n    mxf_write_local_tag(pb, 4, 0x3302);\n\n    avio_wb32(pb, 2);\n\n\n\n    // frame layout\n\n    mxf_write_local_tag(pb, 1, 0x320C);\n\n    avio_w8(pb, sc->interlaced);\n\n\n\n    // video line map\n\n    switch (st->codec->height) {\n\n    case  576: f1 = 23; f2 = st->codec->codec_id == AV_CODEC_ID_DVVIDEO ? 335 : 336; break;\n\n    case  608: f1 =  7; f2 = 320; break;\n\n    case  480: f1 = 20; f2 = st->codec->codec_id == AV_CODEC_ID_DVVIDEO ? 285 : 283; break;\n\n    case  512: f1 =  7; f2 = 270; break;\n\n    case  720: f1 = 26; f2 =   0; break; // progressive\n\n    case 1080: f1 = 21; f2 = 584; break;\n\n    default:   f1 =  0; f2 =   0; break;\n\n    }\n\n\n\n    if (!sc->interlaced) {\n\n        f2  = 0;\n\n        f1 *= 2;\n\n    }\n\n\n\n    mxf_write_local_tag(pb, 12+sc->interlaced*4, 0x320D);\n\n    avio_wb32(pb, sc->interlaced ? 2 : 1);\n\n    avio_wb32(pb, 4);\n\n    avio_wb32(pb, f1);\n\n    if (sc->interlaced)\n\n        avio_wb32(pb, f2);\n\n\n\n    mxf_write_local_tag(pb, 8, 0x320E);\n\n    avio_wb32(pb, sc->aspect_ratio.num);\n\n    avio_wb32(pb, sc->aspect_ratio.den);\n\n\n\n    mxf_write_local_tag(pb, 16, 0x3201);\n\n    avio_write(pb, *sc->codec_ul, 16);\n\n\n\n    if (sc->interlaced && sc->field_dominance) {\n\n        mxf_write_local_tag(pb, 1, 0x3212);\n\n        avio_w8(pb, sc->field_dominance);\n\n    }\n\n\n\n}\n", "idx": 26114}
{"project": "qemu", "commit_id": "7bb5d6ade6d8afbcad72a871f712370ffae457c6", "target": 0, "func": "static void pc_dimm_init(Object *obj)\n\n{\n\n    PCDIMMDevice *dimm = PC_DIMM(obj);\n\n\n\n    object_property_add(obj, PC_DIMM_SIZE_PROP, \"int\", pc_dimm_get_size,\n\n                        NULL, NULL, NULL, &error_abort);\n\n    object_property_add_link(obj, PC_DIMM_MEMDEV_PROP, TYPE_MEMORY_BACKEND,\n\n                             (Object **)&dimm->hostmem,\n\n                             qdev_prop_allow_set_link_before_realize,\n\n                             OBJ_PROP_LINK_UNREF_ON_RELEASE,\n\n                             &error_abort);\n\n}\n", "idx": 26118}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_visitor_out_native_list_int8(TestOutputVisitorData *data,\n\n                                              const void *unused)\n\n{\n\n    test_native_list(data, unused, USER_DEF_NATIVE_LIST_UNION_KIND_S8);\n\n}\n", "idx": 26149}
{"project": "qemu", "commit_id": "b25b387fa5928e516cb2c9e7fde68e958bd7e50a", "target": 0, "func": "static int64_t coroutine_fn qcow2_co_get_block_status(BlockDriverState *bs,\n\n        int64_t sector_num, int nb_sectors, int *pnum, BlockDriverState **file)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    uint64_t cluster_offset;\n\n    int index_in_cluster, ret;\n\n    unsigned int bytes;\n\n    int64_t status = 0;\n\n\n\n    bytes = MIN(INT_MAX, nb_sectors * BDRV_SECTOR_SIZE);\n\n    qemu_co_mutex_lock(&s->lock);\n\n    ret = qcow2_get_cluster_offset(bs, sector_num << 9, &bytes,\n\n                                   &cluster_offset);\n\n    qemu_co_mutex_unlock(&s->lock);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    *pnum = bytes >> BDRV_SECTOR_BITS;\n\n\n\n    if (cluster_offset != 0 && ret != QCOW2_CLUSTER_COMPRESSED &&\n\n        !s->cipher) {\n\n        index_in_cluster = sector_num & (s->cluster_sectors - 1);\n\n        cluster_offset |= (index_in_cluster << BDRV_SECTOR_BITS);\n\n        *file = bs->file->bs;\n\n        status |= BDRV_BLOCK_OFFSET_VALID | cluster_offset;\n\n    }\n\n    if (ret == QCOW2_CLUSTER_ZERO_PLAIN || ret == QCOW2_CLUSTER_ZERO_ALLOC) {\n\n        status |= BDRV_BLOCK_ZERO;\n\n    } else if (ret != QCOW2_CLUSTER_UNALLOCATED) {\n\n        status |= BDRV_BLOCK_DATA;\n\n    }\n\n    return status;\n\n}\n", "idx": 26202}
{"project": "qemu", "commit_id": "cdb3081269347fd9271fd1b7a9df312e2953bdd9", "target": 0, "func": "static void vfio_iommu_map_notify(Notifier *n, void *data)\n\n{\n\n    VFIOGuestIOMMU *giommu = container_of(n, VFIOGuestIOMMU, n);\n\n    VFIOContainer *container = giommu->container;\n\n    IOMMUTLBEntry *iotlb = data;\n\n    hwaddr iova = iotlb->iova + giommu->iommu_offset;\n\n    MemoryRegion *mr;\n\n    hwaddr xlat;\n\n    hwaddr len = iotlb->addr_mask + 1;\n\n    void *vaddr;\n\n    int ret;\n\n\n\n    trace_vfio_iommu_map_notify(iova, iova + iotlb->addr_mask);\n\n\n\n    if (iotlb->target_as != &address_space_memory) {\n\n        error_report(\"Wrong target AS \\\"%s\\\", only system memory is allowed\",\n\n                     iotlb->target_as->name ? iotlb->target_as->name : \"none\");\n\n        return;\n\n    }\n\n\n\n    /*\n\n     * The IOMMU TLB entry we have just covers translation through\n\n     * this IOMMU to its immediate target.  We need to translate\n\n     * it the rest of the way through to memory.\n\n     */\n\n    rcu_read_lock();\n\n    mr = address_space_translate(&address_space_memory,\n\n                                 iotlb->translated_addr,\n\n                                 &xlat, &len, iotlb->perm & IOMMU_WO);\n\n    if (!memory_region_is_ram(mr)) {\n\n        error_report(\"iommu map to non memory area %\"HWADDR_PRIx\"\",\n\n                     xlat);\n\n        goto out;\n\n    }\n\n    /*\n\n     * Translation truncates length to the IOMMU page size,\n\n     * check that it did not truncate too much.\n\n     */\n\n    if (len & iotlb->addr_mask) {\n\n        error_report(\"iommu has granularity incompatible with target AS\");\n\n        goto out;\n\n    }\n\n\n\n    if ((iotlb->perm & IOMMU_RW) != IOMMU_NONE) {\n\n        vaddr = memory_region_get_ram_ptr(mr) + xlat;\n\n        ret = vfio_dma_map(container, iova,\n\n                           iotlb->addr_mask + 1, vaddr,\n\n                           !(iotlb->perm & IOMMU_WO) || mr->readonly);\n\n        if (ret) {\n\n            error_report(\"vfio_dma_map(%p, 0x%\"HWADDR_PRIx\", \"\n\n                         \"0x%\"HWADDR_PRIx\", %p) = %d (%m)\",\n\n                         container, iova,\n\n                         iotlb->addr_mask + 1, vaddr, ret);\n\n        }\n\n    } else {\n\n        ret = vfio_dma_unmap(container, iova, iotlb->addr_mask + 1);\n\n        if (ret) {\n\n            error_report(\"vfio_dma_unmap(%p, 0x%\"HWADDR_PRIx\", \"\n\n                         \"0x%\"HWADDR_PRIx\") = %d (%m)\",\n\n                         container, iova,\n\n                         iotlb->addr_mask + 1, ret);\n\n        }\n\n    }\n\nout:\n\n    rcu_read_unlock();\n\n}\n", "idx": 26203}
{"project": "qemu", "commit_id": "4fa4ce7107c6ec432f185307158c5df91ce54308", "target": 0, "func": "static int local_truncate(FsContext *ctx, V9fsPath *fs_path, off_t size)\n\n{\n\n    char buffer[PATH_MAX];\n\n    char *path = fs_path->data;\n\n\n\n    return truncate(rpath(ctx, path, buffer), size);\n\n}\n", "idx": 26223}
{"project": "qemu", "commit_id": "298a1665a2800f7264e483c2dd1f551574243a2f", "target": 0, "func": "static bool is_zero_sectors(BlockDriverState *bs, int64_t start,\n\n                            uint32_t count)\n\n{\n\n    int nr;\n\n    BlockDriverState *file;\n\n    int64_t res;\n\n\n\n    if (start + count > bs->total_sectors) {\n\n        count = bs->total_sectors - start;\n\n    }\n\n\n\n    if (!count) {\n\n        return true;\n\n    }\n\n    res = bdrv_get_block_status_above(bs, NULL, start, count,\n\n                                      &nr, &file);\n\n    return res >= 0 && (res & BDRV_BLOCK_ZERO) && nr == count;\n\n}\n", "idx": 26227}
{"project": "qemu", "commit_id": "1a28cac3161f8a85ee0256776068eaed2da025e5", "target": 0, "func": "void qemu_mutex_lock_iothread(void)\n\n{\n\n    if (kvm_enabled()) {\n\n        qemu_mutex_lock(&qemu_fair_mutex);\n\n        qemu_mutex_lock(&qemu_global_mutex);\n\n        qemu_mutex_unlock(&qemu_fair_mutex);\n\n    } else\n\n        qemu_signal_lock(100);\n\n}\n", "idx": 26275}
{"project": "qemu", "commit_id": "83f7f32901c630f4fc01acd0d9082da466b17102", "target": 1, "func": "static bool is_special_wait_psw(CPUState *cs)\n\n{\n\n    /* signal quiesce */\n\n    return cs->kvm_run->psw_addr == 0xfffUL;\n\n}\n", "idx": 26296}
{"project": "FFmpeg", "commit_id": "7cc01c25727a96eaaa0c177234b626e47c8ea491", "target": 1, "func": "static void implicit_weight_table(const H264Context *h, H264SliceContext *sl, int field)\n\n{\n\n    int ref0, ref1, i, cur_poc, ref_start, ref_count0, ref_count1;\n\n\n\n    for (i = 0; i < 2; i++) {\n\n        sl->luma_weight_flag[i]   = 0;\n\n        sl->chroma_weight_flag[i] = 0;\n\n    }\n\n\n\n    if (field < 0) {\n\n        if (h->picture_structure == PICT_FRAME) {\n\n            cur_poc = h->cur_pic_ptr->poc;\n\n        } else {\n\n            cur_poc = h->cur_pic_ptr->field_poc[h->picture_structure - 1];\n\n        }\n\n        if (sl->ref_count[0] == 1 && sl->ref_count[1] == 1 && !FRAME_MBAFF(h) &&\n\n            sl->ref_list[0][0].poc + sl->ref_list[1][0].poc == 2 * cur_poc) {\n\n            sl->use_weight        = 0;\n\n            sl->use_weight_chroma = 0;\n\n            return;\n\n        }\n\n        ref_start  = 0;\n\n        ref_count0 = sl->ref_count[0];\n\n        ref_count1 = sl->ref_count[1];\n\n    } else {\n\n        cur_poc    = h->cur_pic_ptr->field_poc[field];\n\n        ref_start  = 16;\n\n        ref_count0 = 16 + 2 * sl->ref_count[0];\n\n        ref_count1 = 16 + 2 * sl->ref_count[1];\n\n    }\n\n\n\n    sl->use_weight               = 2;\n\n    sl->use_weight_chroma        = 2;\n\n    sl->luma_log2_weight_denom   = 5;\n\n    sl->chroma_log2_weight_denom = 5;\n\n\n\n    for (ref0 = ref_start; ref0 < ref_count0; ref0++) {\n\n        int poc0 = sl->ref_list[0][ref0].poc;\n\n        for (ref1 = ref_start; ref1 < ref_count1; ref1++) {\n\n            int w = 32;\n\n            if (!sl->ref_list[0][ref0].parent->long_ref && !sl->ref_list[1][ref1].parent->long_ref) {\n\n                int poc1 = sl->ref_list[1][ref1].poc;\n\n                int td   = av_clip_int8(poc1 - poc0);\n\n                if (td) {\n\n                    int tb = av_clip_int8(cur_poc - poc0);\n\n                    int tx = (16384 + (FFABS(td) >> 1)) / td;\n\n                    int dist_scale_factor = (tb * tx + 32) >> 8;\n\n                    if (dist_scale_factor >= -64 && dist_scale_factor <= 128)\n\n                        w = 64 - dist_scale_factor;\n\n                }\n\n            }\n\n            if (field < 0) {\n\n                sl->implicit_weight[ref0][ref1][0] =\n\n                sl->implicit_weight[ref0][ref1][1] = w;\n\n            } else {\n\n                sl->implicit_weight[ref0][ref1][field] = w;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 26300}
{"project": "qemu", "commit_id": "49cffbc6079c27432b4635d5d03ce14a249d86e2", "target": 1, "func": "void virtio_blk_submit_multireq(BlockBackend *blk, MultiReqBuffer *mrb)\n\n{\n\n    int i = 0, start = 0, num_reqs = 0, niov = 0, nb_sectors = 0;\n\n    int max_xfer_len = 0;\n\n    int64_t sector_num = 0;\n\n\n\n    if (mrb->num_reqs == 1) {\n\n        submit_requests(blk, mrb, 0, 1, -1);\n\n        mrb->num_reqs = 0;\n\n        return;\n\n    }\n\n\n\n    max_xfer_len = blk_get_max_transfer_length(mrb->reqs[0]->dev->blk);\n\n    max_xfer_len = MIN_NON_ZERO(max_xfer_len, BDRV_REQUEST_MAX_SECTORS);\n\n\n\n    qsort(mrb->reqs, mrb->num_reqs, sizeof(*mrb->reqs),\n\n          &multireq_compare);\n\n\n\n    for (i = 0; i < mrb->num_reqs; i++) {\n\n        VirtIOBlockReq *req = mrb->reqs[i];\n\n        if (num_reqs > 0) {\n\n            bool merge = true;\n\n\n\n            /* merge would exceed maximum number of IOVs */\n\n            if (niov + req->qiov.niov > IOV_MAX) {\n\n                merge = false;\n\n            }\n\n\n\n            /* merge would exceed maximum transfer length of backend device */\n\n            if (req->qiov.size / BDRV_SECTOR_SIZE + nb_sectors > max_xfer_len) {\n\n                merge = false;\n\n            }\n\n\n\n            /* requests are not sequential */\n\n            if (sector_num + nb_sectors != req->sector_num) {\n\n                merge = false;\n\n            }\n\n\n\n            if (!merge) {\n\n                submit_requests(blk, mrb, start, num_reqs, niov);\n\n                num_reqs = 0;\n\n            }\n\n        }\n\n\n\n        if (num_reqs == 0) {\n\n            sector_num = req->sector_num;\n\n            nb_sectors = niov = 0;\n\n            start = i;\n\n        }\n\n\n\n        nb_sectors += req->qiov.size / BDRV_SECTOR_SIZE;\n\n        niov += req->qiov.niov;\n\n        num_reqs++;\n\n    }\n\n\n\n    submit_requests(blk, mrb, start, num_reqs, niov);\n\n    mrb->num_reqs = 0;\n\n}\n", "idx": 26368}
{"project": "qemu", "commit_id": "14cec170ea4724e6881ba2febb20e88a942e52d3", "target": 1, "func": "static int xen_pt_bar_reg_read(XenPCIPassthroughState *s, XenPTReg *cfg_entry,\n\n                               uint32_t *value, uint32_t valid_mask)\n\n{\n\n    XenPTRegInfo *reg = cfg_entry->reg;\n\n    uint32_t valid_emu_mask = 0;\n\n    uint32_t bar_emu_mask = 0;\n\n    int index;\n\n\n\n    /* get BAR index */\n\n    index = xen_pt_bar_offset_to_index(reg->offset);\n\n    if (index < 0 || index >= PCI_NUM_REGIONS) {\n\n        XEN_PT_ERR(&s->dev, \"Internal error: Invalid BAR index [%d].\\n\", index);\n\n        return -1;\n\n    }\n\n\n\n    /* use fixed-up value from kernel sysfs */\n\n    *value = base_address_with_flags(&s->real_device.io_regions[index]);\n\n\n\n    /* set emulate mask depend on BAR flag */\n\n    switch (s->bases[index].bar_flag) {\n\n    case XEN_PT_BAR_FLAG_MEM:\n\n        bar_emu_mask = XEN_PT_BAR_MEM_EMU_MASK;\n\n        break;\n\n    case XEN_PT_BAR_FLAG_IO:\n\n        bar_emu_mask = XEN_PT_BAR_IO_EMU_MASK;\n\n        break;\n\n    case XEN_PT_BAR_FLAG_UPPER:\n\n        bar_emu_mask = XEN_PT_BAR_ALLF;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    /* emulate BAR */\n\n    valid_emu_mask = bar_emu_mask & valid_mask;\n\n    *value = XEN_PT_MERGE_VALUE(*value, cfg_entry->data, ~valid_emu_mask);\n\n\n\n    return 0;\n\n}\n", "idx": 26372}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static inline void gen_movcf_d (DisasContext *ctx, int fs, int fd, int cc, int tf)\n\n{\n\n    int cond;\n\n    TCGv_i32 t0 = tcg_temp_new_i32();\n\n    TCGv_i64 fp0;\n\n    int l1 = gen_new_label();\n\n\n\n    if (tf)\n\n        cond = TCG_COND_EQ;\n\n    else\n\n        cond = TCG_COND_NE;\n\n\n\n    tcg_gen_andi_i32(t0, fpu_fcr31, 1 << get_fp_bit(cc));\n\n    tcg_gen_brcondi_i32(cond, t0, 0, l1);\n\n    tcg_temp_free_i32(t0);\n\n    fp0 = tcg_temp_new_i64();\n\n    gen_load_fpr64(ctx, fp0, fs);\n\n    gen_store_fpr64(ctx, fp0, fd);\n\n    tcg_temp_free_i64(fp0);\n\n    gen_set_label(l1);\n\n}\n", "idx": 26463}
{"project": "qemu", "commit_id": "06b1297017415ae6a07a0e97ad7d8e90b2d95823", "target": 1, "func": "static int virtio_net_has_buffers(VirtIONet *n, int bufsize)\n\n{\n\n    if (virtio_queue_empty(n->rx_vq) ||\n\n        (n->mergeable_rx_bufs &&\n\n         !virtqueue_avail_bytes(n->rx_vq, bufsize, 0))) {\n\n        virtio_queue_set_notification(n->rx_vq, 1);\n\n        return 0;\n\n    }\n\n\n\n    virtio_queue_set_notification(n->rx_vq, 0);\n\n    return 1;\n\n}\n", "idx": 26516}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "int bdrv_writev_vmstate(BlockDriverState *bs, QEMUIOVector *qiov, int64_t pos)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n\n\n    if (!drv) {\n\n        return -ENOMEDIUM;\n\n    } else if (drv->bdrv_save_vmstate) {\n\n        return drv->bdrv_save_vmstate(bs, qiov, pos);\n\n    } else if (bs->file) {\n\n        return bdrv_writev_vmstate(bs->file, qiov, pos);\n\n    }\n\n\n\n    return -ENOTSUP;\n\n}\n", "idx": 26573}
{"project": "qemu", "commit_id": "4fa4ce7107c6ec432f185307158c5df91ce54308", "target": 0, "func": "static int local_statfs(FsContext *s, V9fsPath *fs_path, struct statfs *stbuf)\n\n{\n\n    char buffer[PATH_MAX];\n\n    char *path = fs_path->data;\n\n\n\n    return statfs(rpath(s, path, buffer), stbuf);\n\n}\n", "idx": 26576}
{"project": "qemu", "commit_id": "c34d440a728fd3b5099d11dec122d440ef092c23", "target": 0, "func": "static int kvm_get_msr(CPUState *env, struct kvm_msr_entry *msrs, int n)\n\n{\n\n    struct kvm_msrs *kmsrs = qemu_malloc(sizeof *kmsrs + n * sizeof *msrs);\n\n    int r;\n\n\n\n    kmsrs->nmsrs = n;\n\n    memcpy(kmsrs->entries, msrs, n * sizeof *msrs);\n\n    r = kvm_vcpu_ioctl(env, KVM_GET_MSRS, kmsrs);\n\n    memcpy(msrs, kmsrs->entries, n * sizeof *msrs);\n\n    free(kmsrs);\n\n    return r;\n\n}\n", "idx": 26600}
{"project": "FFmpeg", "commit_id": "9bff052b51f27f6cce04e8d7d8b405c710d7ad67", "target": 0, "func": "static void blur(uint8_t       *dst, const int dst_linesize,\n\n                 const uint8_t *src, const int src_linesize,\n\n                 const int w, const int h, FilterParam *fp)\n\n{\n\n    int x, y;\n\n    FilterParam f = *fp;\n\n    const int radius = f.dist_width/2;\n\n\n\n    const uint8_t * const src2[NB_PLANES] = { src };\n\n    int          src2_linesize[NB_PLANES] = { src_linesize };\n\n    uint8_t     *dst2[NB_PLANES] = { f.pre_filter_buf };\n\n    int dst2_linesize[NB_PLANES] = { f.pre_filter_linesize };\n\n\n\n    sws_scale(f.pre_filter_context, src2, src2_linesize, 0, h, dst2, dst2_linesize);\n\n\n\n#define UPDATE_FACTOR do {                                              \\\n\n        int factor;                                                     \\\n\n        factor = f.color_diff_coeff[COLOR_DIFF_COEFF_SIZE/2 + pre_val - \\\n\n                 f.pre_filter_buf[ix + iy*f.pre_filter_linesize]] * f.dist_coeff[dx + dy*f.dist_linesize]; \\\n\n        sum += src[ix + iy*src_linesize] * factor;                      \\\n\n        div += factor;                                                  \\\n\n    } while (0)\n\n\n\n    for (y = 0; y < h; y++) {\n\n        for (x = 0; x < w; x++) {\n\n            int sum = 0;\n\n            int div = 0;\n\n            int dy;\n\n            const int pre_val = f.pre_filter_buf[x + y*f.pre_filter_linesize];\n\n            if (x >= radius && x < w - radius) {\n\n                for (dy = 0; dy < radius*2 + 1; dy++) {\n\n                    int dx;\n\n                    int iy = y+dy - radius;\n\n                    if      (iy < 0)  iy = -iy;\n\n                    else if (iy >= h) iy = h+h-iy-1;\n\n\n\n                    for (dx = 0; dx < radius*2 + 1; dx++) {\n\n                        const int ix = x+dx - radius;\n\n                        UPDATE_FACTOR;\n\n                    }\n\n                }\n\n            } else {\n\n                for (dy = 0; dy < radius*2+1; dy++) {\n\n                    int dx;\n\n                    int iy = y+dy - radius;\n\n                    if      (iy <  0) iy = -iy;\n\n                    else if (iy >= h) iy = h+h-iy-1;\n\n\n\n                    for (dx = 0; dx < radius*2 + 1; dx++) {\n\n                        int ix = x+dx - radius;\n\n                        if      (ix < 0)  ix = -ix;\n\n                        else if (ix >= w) ix = w+w-ix-1;\n\n                        UPDATE_FACTOR;\n\n                    }\n\n                }\n\n            }\n\n            dst[x + y*dst_linesize] = (sum + div/2) / div;\n\n        }\n\n    }\n\n}\n", "idx": 26614}
{"project": "FFmpeg", "commit_id": "488a0fa68973d48e264d54f1722f7afb18afbea7", "target": 0, "func": "static int configure_input_audio_filter(FilterGraph *fg, InputFilter *ifilter,\n\n                                        AVFilterInOut *in)\n\n{\n\n    AVFilterContext *last_filter;\n\n    const AVFilter *abuffer_filt = avfilter_get_by_name(\"abuffer\");\n\n    InputStream *ist = ifilter->ist;\n\n    InputFile     *f = input_files[ist->file_index];\n\n    char args[255], name[255];\n\n    int ret, pad_idx = 0;\n\n\n\n    snprintf(args, sizeof(args), \"time_base=%d/%d:sample_rate=%d:sample_fmt=%s\"\n\n             \":channel_layout=0x%\"PRIx64,\n\n             1, ist->st->codec->sample_rate,\n\n             ist->st->codec->sample_rate,\n\n             av_get_sample_fmt_name(ist->st->codec->sample_fmt),\n\n             ist->st->codec->channel_layout);\n\n    snprintf(name, sizeof(name), \"graph %d input from stream %d:%d\", fg->index,\n\n             ist->file_index, ist->st->index);\n\n\n\n    if ((ret = avfilter_graph_create_filter(&ifilter->filter, abuffer_filt,\n\n                                            name, args, NULL,\n\n                                            fg->graph)) < 0)\n\n        return ret;\n\n    last_filter = ifilter->filter;\n\n\n\n    if (audio_sync_method > 0) {\n\n        AVFilterContext *async;\n\n        int  len = 0;\n\n\n\n        av_log(NULL, AV_LOG_WARNING, \"-async has been deprecated. Used the \"\n\n               \"asyncts audio filter instead.\\n\");\n\n\n\n        if (audio_sync_method > 1)\n\n            len += snprintf(args + len, sizeof(args) - len, \"compensate=1:\"\n\n                            \"max_comp=%d:\", audio_sync_method);\n\n        snprintf(args + len, sizeof(args) - len, \"min_delta=%f\",\n\n                 audio_drift_threshold);\n\n\n\n        snprintf(name, sizeof(name), \"graph %d audio sync for input stream %d:%d\",\n\n                 fg->index, ist->file_index, ist->st->index);\n\n        ret = avfilter_graph_create_filter(&async,\n\n                                           avfilter_get_by_name(\"asyncts\"),\n\n                                           name, args, NULL, fg->graph);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        ret = avfilter_link(last_filter, 0, async, 0);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        last_filter = async;\n\n    }\n\n    if (audio_volume != 256) {\n\n        AVFilterContext *volume;\n\n\n\n        av_log(NULL, AV_LOG_WARNING, \"-vol has been deprecated. Use the volume \"\n\n               \"audio filter instead.\\n\");\n\n\n\n        snprintf(args, sizeof(args), \"volume=%f\", audio_volume / 256.0);\n\n\n\n        snprintf(name, sizeof(name), \"graph %d volume for input stream %d:%d\",\n\n                 fg->index, ist->file_index, ist->st->index);\n\n        ret = avfilter_graph_create_filter(&volume,\n\n                                           avfilter_get_by_name(\"volume\"),\n\n                                           name, args, NULL, fg->graph);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        ret = avfilter_link(last_filter, 0, volume, 0);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        last_filter = volume;\n\n    }\n\n\n\n    snprintf(name, sizeof(name), \"trim for input stream %d:%d\",\n\n             ist->file_index, ist->st->index);\n\n    ret = insert_trim(((f->start_time == AV_NOPTS_VALUE) || !f->accurate_seek) ?\n\n                      AV_NOPTS_VALUE : 0, INT64_MAX, &last_filter, &pad_idx, name);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if ((ret = avfilter_link(last_filter, 0, in->filter_ctx, in->pad_idx)) < 0)\n\n        return ret;\n\n\n\n    return 0;\n\n}\n", "idx": 26664}
{"project": "FFmpeg", "commit_id": "8dca0877e3e1457e9ec79ffa1ead1135aabb791c", "target": 0, "func": "static int mpegts_write_packet_internal(AVFormatContext *s, AVPacket *pkt)\n\n{\n\n    AVStream *st = s->streams[pkt->stream_index];\n\n    int size = pkt->size;\n\n    uint8_t *buf = pkt->data;\n\n    uint8_t *data = NULL;\n\n    MpegTSWrite *ts = s->priv_data;\n\n    MpegTSWriteStream *ts_st = st->priv_data;\n\n    const uint64_t delay = av_rescale(s->max_delay, 90000, AV_TIME_BASE) * 2;\n\n    int64_t dts = AV_NOPTS_VALUE, pts = AV_NOPTS_VALUE;\n\n\n\n    if (ts->reemit_pat_pmt) {\n\n        av_log(s, AV_LOG_WARNING,\n\n               \"resend_headers option is deprecated, use -mpegts_flags resend_headers\\n\");\n\n        ts->reemit_pat_pmt = 0;\n\n        ts->flags         |= MPEGTS_FLAG_REEMIT_PAT_PMT;\n\n    }\n\n\n\n    if (ts->flags & MPEGTS_FLAG_REEMIT_PAT_PMT) {\n\n        ts->pat_packet_count = ts->pat_packet_period - 1;\n\n        ts->sdt_packet_count = ts->sdt_packet_period - 1;\n\n        ts->flags           &= ~MPEGTS_FLAG_REEMIT_PAT_PMT;\n\n    }\n\n\n\n    if (pkt->pts != AV_NOPTS_VALUE)\n\n        pts = pkt->pts + delay;\n\n    if (pkt->dts != AV_NOPTS_VALUE)\n\n        dts = pkt->dts + delay;\n\n\n\n    if (ts_st->first_pts_check && pts == AV_NOPTS_VALUE) {\n\n        av_log(s, AV_LOG_ERROR, \"first pts value must set\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n    ts_st->first_pts_check = 0;\n\n\n\n    if (st->codec->codec_id == AV_CODEC_ID_H264) {\n\n        const uint8_t *p = buf, *buf_end = p + size;\n\n        uint32_t state = -1;\n\n\n\n        if (pkt->size < 5 || AV_RB32(pkt->data) != 0x0000001) {\n\n            av_log(s, AV_LOG_ERROR, \"H.264 bitstream malformed, \"\n\n                   \"no startcode found, use -bsf h264_mp4toannexb\\n\");\n\n            return AVERROR(EINVAL);\n\n        }\n\n\n\n        do {\n\n            p = avpriv_find_start_code(p, buf_end, &state);\n\n            av_dlog(s, \"nal %d\\n\", state & 0x1f);\n\n        } while (p < buf_end && (state & 0x1f) != 9 &&\n\n                 (state & 0x1f) != 5 && (state & 0x1f) != 1);\n\n\n\n        if ((state & 0x1f) != 9) { // AUD NAL\n\n            data = av_malloc(pkt->size + 6);\n\n            if (!data)\n\n                return AVERROR(ENOMEM);\n\n            memcpy(data + 6, pkt->data, pkt->size);\n\n            AV_WB32(data, 0x00000001);\n\n            data[4] = 0x09;\n\n            data[5] = 0xf0; // any slice type (0xe) + rbsp stop one bit\n\n            buf     = data;\n\n            size    = pkt->size + 6;\n\n        }\n\n    } else if (st->codec->codec_id == AV_CODEC_ID_AAC) {\n\n        if (pkt->size < 2) {\n\n            av_log(s, AV_LOG_ERROR, \"AAC packet too short\\n\");\n\n            return AVERROR(EINVAL);\n\n        }\n\n        if ((AV_RB16(pkt->data) & 0xfff0) != 0xfff0) {\n\n            int ret;\n\n            AVPacket pkt2;\n\n\n\n            if (!ts_st->amux) {\n\n                av_log(s, AV_LOG_ERROR, \"AAC bitstream not in ADTS format \"\n\n                                        \"and extradata missing\\n\");\n\n                return AVERROR(EINVAL);\n\n            }\n\n\n\n            av_init_packet(&pkt2);\n\n            pkt2.data = pkt->data;\n\n            pkt2.size = pkt->size;\n\n\n\n            ret = avio_open_dyn_buf(&ts_st->amux->pb);\n\n            if (ret < 0)\n\n                return AVERROR(ENOMEM);\n\n\n\n            ret = av_write_frame(ts_st->amux, &pkt2);\n\n            if (ret < 0) {\n\n                avio_close_dyn_buf(ts_st->amux->pb, &data);\n\n                ts_st->amux->pb = NULL;\n\n                av_free(data);\n\n                return ret;\n\n            }\n\n            size            = avio_close_dyn_buf(ts_st->amux->pb, &data);\n\n            ts_st->amux->pb = NULL;\n\n            buf             = data;\n\n        }\n\n    }\n\n\n\n    if (st->codec->codec_type != AVMEDIA_TYPE_AUDIO) {\n\n        // for video and subtitle, write a single pes packet\n\n        mpegts_write_pes(s, st, buf, size, pts, dts,\n\n                         pkt->flags & AV_PKT_FLAG_KEY);\n\n        av_free(data);\n\n        return 0;\n\n    }\n\n\n\n    if (ts_st->payload_size + size > ts->pes_payload_size) {\n\n        if (ts_st->payload_size) {\n\n            mpegts_write_pes(s, st, ts_st->payload, ts_st->payload_size,\n\n                             ts_st->payload_pts, ts_st->payload_dts,\n\n                             ts_st->payload_flags & AV_PKT_FLAG_KEY);\n\n            ts_st->payload_size = 0;\n\n        }\n\n        if (size > ts->pes_payload_size) {\n\n            mpegts_write_pes(s, st, buf, size, pts, dts,\n\n                             pkt->flags & AV_PKT_FLAG_KEY);\n\n            av_free(data);\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    if (!ts_st->payload_size) {\n\n        ts_st->payload_pts   = pts;\n\n        ts_st->payload_dts   = dts;\n\n        ts_st->payload_flags = pkt->flags;\n\n    }\n\n\n\n    memcpy(ts_st->payload + ts_st->payload_size, buf, size);\n\n    ts_st->payload_size += size;\n\n\n\n    av_free(data);\n\n\n\n    return 0;\n\n}\n", "idx": 26665}
{"project": "FFmpeg", "commit_id": "f6b7f72461673e4d398b1edf9ed2a7fe70d99c47", "target": 0, "func": "static void av_always_inline filter_mb_edgech( uint8_t *pix, int stride, const int16_t bS[4], unsigned int qp, H264Context *h, int intra ) {\n\n    const int qp_bd_offset = 6 * (h->sps.bit_depth_luma - 8);\n\n    const unsigned int index_a = qp - qp_bd_offset + h->slice_alpha_c0_offset;\n\n    const int alpha = alpha_table[index_a];\n\n    const int beta  = beta_table[qp - qp_bd_offset + h->slice_beta_offset];\n\n    if (alpha ==0 || beta == 0) return;\n\n\n\n    if( bS[0] < 4 || !intra ) {\n\n        int8_t tc[4];\n\n        tc[0] = tc0_table[index_a][bS[0]]+1;\n\n        tc[1] = tc0_table[index_a][bS[1]]+1;\n\n        tc[2] = tc0_table[index_a][bS[2]]+1;\n\n        tc[3] = tc0_table[index_a][bS[3]]+1;\n\n        h->h264dsp.h264_v_loop_filter_chroma(pix, stride, alpha, beta, tc);\n\n    } else {\n\n        h->h264dsp.h264_v_loop_filter_chroma_intra(pix, stride, alpha, beta);\n\n    }\n\n}\n", "idx": 26870}
{"project": "qemu", "commit_id": "6658ffb81ee56a510d7d77025872a508a9adce3a", "target": 1, "func": "static inline int gen_intermediate_code_internal(CPUState *env, \n\n                                                 TranslationBlock *tb, \n\n                                                 int search_pc)\n\n{\n\n    DisasContext dc1, *dc = &dc1;\n\n    uint16_t *gen_opc_end;\n\n    int j, lj;\n\n    target_ulong pc_start;\n\n    uint32_t next_page_start;\n\n    \n\n    /* generate intermediate code */\n\n    pc_start = tb->pc;\n\n       \n\n    dc->tb = tb;\n\n\n\n    gen_opc_ptr = gen_opc_buf;\n\n    gen_opc_end = gen_opc_buf + OPC_MAX_SIZE;\n\n    gen_opparam_ptr = gen_opparam_buf;\n\n\n\n    dc->is_jmp = DISAS_NEXT;\n\n    dc->pc = pc_start;\n\n    dc->singlestep_enabled = env->singlestep_enabled;\n\n    dc->condjmp = 0;\n\n    dc->thumb = env->thumb;\n\n\n#if !defined(CONFIG_USER_ONLY)\n\n    dc->user = (env->uncached_cpsr & 0x1f) == ARM_CPU_MODE_USR;\n\n#endif\n\n    next_page_start = (pc_start & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE;\n\n    nb_gen_labels = 0;\n\n    lj = -1;\n\n    do {\n\n        if (env->nb_breakpoints > 0) {\n\n            for(j = 0; j < env->nb_breakpoints; j++) {\n\n                if (env->breakpoints[j] == dc->pc) {\n\n                    gen_op_movl_T0_im((long)dc->pc);\n\n                    gen_op_movl_reg_TN[0][15]();\n\n                    gen_op_debug();\n\n                    dc->is_jmp = DISAS_JUMP;\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n        if (search_pc) {\n\n            j = gen_opc_ptr - gen_opc_buf;\n\n            if (lj < j) {\n\n                lj++;\n\n                while (lj < j)\n\n                    gen_opc_instr_start[lj++] = 0;\n\n            }\n\n            gen_opc_pc[lj] = dc->pc;\n\n            gen_opc_instr_start[lj] = 1;\n\n        }\n\n\n\n        if (env->thumb)\n\n          disas_thumb_insn(dc);\n\n        else\n\n          disas_arm_insn(env, dc);\n\n\n\n        if (dc->condjmp && !dc->is_jmp) {\n\n            gen_set_label(dc->condlabel);\n\n            dc->condjmp = 0;\n\n        }\n\n        /* Terminate the TB on memory ops if watchpoints are present.  */\n\n        /* FIXME: This should be replacd by the deterministic execution\n\n         * IRQ raising bits.  */\n\n        if (dc->is_mem && env->nb_watchpoints)\n\n            break;\n\n\n\n        /* Translation stops when a conditional branch is enoutered.\n\n         * Otherwise the subsequent code could get translated several times.\n\n         * Also stop translation when a page boundary is reached.  This\n\n         * ensures prefech aborts occur at the right place.  */\n\n    } while (!dc->is_jmp && gen_opc_ptr < gen_opc_end &&\n\n             !env->singlestep_enabled &&\n\n             dc->pc < next_page_start);\n\n    /* At this stage dc->condjmp will only be set when the skipped\n\n     * instruction was a conditional branch, and the PC has already been\n\n     * written.  */\n\n    if (__builtin_expect(env->singlestep_enabled, 0)) {\n\n        /* Make sure the pc is updated, and raise a debug exception.  */\n\n        if (dc->condjmp) {\n\n            gen_op_debug();\n\n            gen_set_label(dc->condlabel);\n\n        }\n\n        if (dc->condjmp || !dc->is_jmp) {\n\n            gen_op_movl_T0_im((long)dc->pc);\n\n            gen_op_movl_reg_TN[0][15]();\n\n            dc->condjmp = 0;\n\n        }\n\n        gen_op_debug();\n\n    } else {\n\n        switch(dc->is_jmp) {\n\n        case DISAS_NEXT:\n\n            gen_goto_tb(dc, 1, dc->pc);\n\n            break;\n\n        default:\n\n        case DISAS_JUMP:\n\n        case DISAS_UPDATE:\n\n            /* indicate that the hash table must be used to find the next TB */\n\n            gen_op_movl_T0_0();\n\n            gen_op_exit_tb();\n\n            break;\n\n        case DISAS_TB_JUMP:\n\n            /* nothing more to generate */\n\n            break;\n\n        }\n\n        if (dc->condjmp) {\n\n            gen_set_label(dc->condlabel);\n\n            gen_goto_tb(dc, 1, dc->pc);\n\n            dc->condjmp = 0;\n\n        }\n\n    }\n\n    *gen_opc_ptr = INDEX_op_end;\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (loglevel & CPU_LOG_TB_IN_ASM) {\n\n        fprintf(logfile, \"----------------\\n\");\n\n        fprintf(logfile, \"IN: %s\\n\", lookup_symbol(pc_start));\n\n        target_disas(logfile, pc_start, dc->pc - pc_start, env->thumb);\n\n        fprintf(logfile, \"\\n\");\n\n        if (loglevel & (CPU_LOG_TB_OP)) {\n\n            fprintf(logfile, \"OP:\\n\");\n\n            dump_ops(gen_opc_buf, gen_opparam_buf);\n\n            fprintf(logfile, \"\\n\");\n\n        }\n\n    }\n\n#endif\n\n    if (search_pc) {\n\n        j = gen_opc_ptr - gen_opc_buf;\n\n        lj++;\n\n        while (lj <= j)\n\n            gen_opc_instr_start[lj++] = 0;\n\n        tb->size = 0;\n\n    } else {\n\n        tb->size = dc->pc - pc_start;\n\n    }\n\n    return 0;\n\n}", "idx": 26934}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "static CaptureVoiceOut *audio_pcm_capture_find_specific (\n\n    AudioState *s,\n\n    audsettings_t *as\n\n    )\n\n{\n\n    CaptureVoiceOut *cap;\n\n\n\n    for (cap = s->cap_head.lh_first; cap; cap = cap->entries.le_next) {\n\n        if (audio_pcm_info_eq (&cap->hw.info, as)) {\n\n            return cap;\n\n        }\n\n    }\n\n    return NULL;\n\n}\n", "idx": 26969}
{"project": "FFmpeg", "commit_id": "20035fa24103da9199de3515ca75ba1f6bb275aa", "target": 1, "func": "static int scale_vector(int16_t *dst, const int16_t *vector, int length)\n\n{\n\n    int bits, max = 0;\n\n    int i;\n\n\n\n    for (i = 0; i < length; i++)\n\n        max |= FFABS(vector[i]);\n\n\n\n    bits  = normalize_bits(max, 15);\n\n\n\n    if (bits == 15)\n\n        for (i = 0; i < length; i++)\n\n            dst[i] = vector[i] * 0x7fff >> 3;\n\n    else\n\n        for (i = 0; i < length; i++)\n\n            dst[i] = vector[i] << bits >> 3;\n\n\n\n    return bits - 3;\n\n}\n", "idx": 26997}
{"project": "FFmpeg", "commit_id": "9156a5ad72e989e0fa2735741edf894fffad33b9", "target": 0, "func": "static void ipvideo_decode_opcodes(IpvideoContext *s)\n\n{\n\n    int x, y;\n\n    unsigned char opcode;\n\n    int ret;\n\n    static int frame = 0;\n\n    GetBitContext gb;\n\n\n\n    debug_interplay(\"------------------ frame %d\\n\", frame);\n\n    frame++;\n\n\n\n    /* this is PAL8, so make the palette available */\n\n    memcpy(s->current_frame.data[1], s->avctx->palctrl->palette, PALETTE_COUNT * 4);\n\n\n\n    s->stride = s->current_frame.linesize[0];\n\n    s->stream_ptr = s->buf + 14;  /* data starts 14 bytes in */\n\n    s->stream_end = s->buf + s->size;\n\n    s->line_inc = s->stride - 8;\n\n    s->upper_motion_limit_offset = (s->avctx->height - 8) * s->stride\n\n        + s->avctx->width - 8;\n\n\n\n    init_get_bits(&gb, s->decoding_map, s->decoding_map_size * 8);\n\n    for (y = 0; y < (s->stride * s->avctx->height); y += s->stride * 8) {\n\n        for (x = y; x < y + s->avctx->width; x += 8) {\n\n            opcode = get_bits(&gb, 4);\n\n\n\n            debug_interplay(\"  block @ (%3d, %3d): encoding 0x%X, data ptr @ %p\\n\",\n\n                            x - y, y / s->stride, opcode, s->stream_ptr);\n\n\n\n            s->pixel_ptr = s->current_frame.data[0] + x;\n\n            ret = ipvideo_decode_block[opcode](s);\n\n            if (ret != 0) {\n\n                av_log(s->avctx, AV_LOG_ERROR, \" Interplay video: decode problem on frame %d, @ block (%d, %d)\\n\",\n\n                       frame, x - y, y / s->stride);\n\n                return;\n\n            }\n\n        }\n\n    }\n\n    if (s->stream_end - s->stream_ptr > 1) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \" Interplay video: decode finished with %td bytes left over\\n\",\n\n               s->stream_end - s->stream_ptr);\n\n    }\n\n}\n", "idx": 27026}
{"project": "qemu", "commit_id": "21ce148c7ec71ee32834061355a5ecfd1a11f90f", "target": 1, "func": "static inline void cris_fidx_i(unsigned int x)\n\n{\n\n\tregister unsigned int v asm(\"$r10\") = x;\n\n\tasm (\"fidxi\\t[%0]\\n\" : : \"r\" (v) );\n\n}\n", "idx": 27036}
{"project": "FFmpeg", "commit_id": "229843aa359ae0c9519977d7fa952688db63f559", "target": 0, "func": "static void handle_char(CCaptionSubContext *ctx, char hi, char lo, int64_t pts)\n\n{\n\n    struct Screen *screen = get_writing_screen(ctx);\n\n    char *row = screen->characters[ctx->cursor_row];\n\n    int ret;\n\n\n\n    SET_FLAG(screen->row_used,ctx->cursor_row);\n\n\n\n    ret = write_char(ctx, row, ctx->cursor_column, hi);\n\n    if( ret == 0 )\n\n        ctx->cursor_column++;\n\n\n\n    if(lo) {\n\n        ret = write_char(ctx, row, ctx->cursor_column, lo);\n\n        if ( ret == 0 )\n\n            ctx->cursor_column++;\n\n    }\n\n    write_char(ctx, row, ctx->cursor_column, 0);\n\n\n\n    /* reset prev command since character can repeat */\n\n    ctx->prev_cmd[0] = 0;\n\n    ctx->prev_cmd[1] = 0;\n\n    if (lo)\n\n       av_dlog(ctx, \"(%c,%c)\\n\",hi,lo);\n\n    else\n\n       av_dlog(ctx, \"(%c)\\n\",hi);\n\n}\n", "idx": 27067}
{"project": "FFmpeg", "commit_id": "1dc42050185d63c1de5d16146fbaee92640af187", "target": 0, "func": "static int start_frame(AVFilterLink *link, AVFilterBufferRef *picref)\n\n{\n\n    AVFilterContext *ctx = link->dst;\n\n    YADIFContext *yadif = ctx->priv;\n\n\n\n    if (yadif->frame_pending)\n\n        return_frame(ctx, 1);\n\n\n\n    if (yadif->prev)\n\n        avfilter_unref_buffer(yadif->prev);\n\n    yadif->prev = yadif->cur;\n\n    yadif->cur  = yadif->next;\n\n    yadif->next = picref;\n\n\n\n    if (!yadif->cur)\n\n        return 0;\n\n\n\n    if (yadif->auto_enable && !yadif->cur->video->interlaced) {\n\n        yadif->out  = avfilter_ref_buffer(yadif->cur, AV_PERM_READ);\n\n        avfilter_unref_bufferp(&yadif->prev);\n\n        if (yadif->out->pts != AV_NOPTS_VALUE)\n\n            yadif->out->pts *= 2;\n\n        return ff_start_frame(ctx->outputs[0], yadif->out);\n\n    }\n\n\n\n    if (!yadif->prev)\n\n        yadif->prev = avfilter_ref_buffer(yadif->cur, AV_PERM_READ);\n\n\n\n    yadif->out = ff_get_video_buffer(ctx->outputs[0], AV_PERM_WRITE | AV_PERM_PRESERVE |\n\n                                     AV_PERM_REUSE, link->w, link->h);\n\n\n\n    avfilter_copy_buffer_ref_props(yadif->out, yadif->cur);\n\n    yadif->out->video->interlaced = 0;\n\n    if (yadif->out->pts != AV_NOPTS_VALUE)\n\n        yadif->out->pts *= 2;\n\n    return ff_start_frame(ctx->outputs[0], yadif->out);\n\n}\n", "idx": 27194}
